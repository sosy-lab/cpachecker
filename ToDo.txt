[AH]: Andreas Holzer <holzer@forsyte.de>
[DB]: Dirk Beyer <dirk.beyer@sfu.ca>
[MT]: Michael Tautschnig <tautschnig@forsyte.de>

* cleanup and prioritization to be done in telephone conference *
* probably group them in design/technical/conceptual *

- [MT] move getInitialElement to its own class
  * method makeInitialElement (AE, AEwLoc, must be static)
  * I'd suggest introducing CPABuilder and *Builder classes that instantiate a
    CPA, know how to create proper initial elements (with or without location
    information), and do the initialPrecision stuff
  * also pass the configuration object to the Builder instead of referring to
    CPAMain in all the classes

- [MT] Instead of the String parameters to set sep or join for merge and stop just
  create multiple CPA classes that fix the operator

- [MT] Cleanup cpa.common and move the composite stuff to compositecpa,
  CPAType.java could probably be removed rightaway

- [MT] add default implementations of stopsep/join, mergesep/join, precision stuff

- [MT] review mergeJoin for the use of joinOperator

- [MT] cleanup stop operator, rename compositestopsep, compositemergesep

- [MT] cleanup CPAMain
  * make separate function "preprocess"
  * is there any non-interprocedural analysis

- [MT] Remove isBottomElement(x) and replace by call to satisfiesPartialOrder(x,
  domain.getBottomElement())

- [DB] Maybe rename satisfiesPartialOrder to isLessOrEqual

- [MT] (well known, but not noted thus far) Using exceptions to perform
  abstraction refinement is really really cruel

- [MT] compositestop is broken
  stop(e,reachedSet,prec) calls stop(e,reachedElement), thus loses info about
  precision (and never calls stop(e,reachedSet,prec) of the underlying CPA

- [MT] The use of LocationMappedReachedSet in
  cpa.symbpredabs.explicit.ExplicitStopOperator is currently broken because of
  the disparity of reached vs. simpleReached; this results in a performance
  penalty of 10-20% according to recent regression testing
  -- this has been fixed in r318, but deserves further testing whether it is
  really fixed
  -- the fix in r318 was reverted in r319
  -- A possible solution introducing a wrapper class was added in
  r320-r322,r325, benchmarking is ongoing as of 2008-12-15
  -- Another possible idea is a general implementation of the ReachedSet as a
  multipmap of AbstractElements -> { Precisions }, with an additional option to
  specify a Comperator to obtain a "good" sorting of the keys. What is the
  crucial lessons we learnt while going back and forth so far:
  * The CPA+ algorithms requires that a projection of
    AbstractElements(WithLocation) is performed (efficiently)
  * If an interface "ReachedSet" is introduced somewhere take care that some
    CPAs only provide AbstractElement, not WithLocation, and if
    AbstractElementWithLocation becomes a defining part of the ReachedSet
    interface, ReachedSet cannot be used as part of each and every CPA

- [MT] Remove getAbstractDomain in those cases where it is now not needed anymore

- [MT] We have multiple implementations of a class Path

- [MT] Whitespace at the end of a line is undesirable for merging tools, do a cleanup

- [MT] Use iterators instead of get(i), this is CLEANER, SAFER, and FASTER in general
  (unless impossible, of course)

- [MT] in createReachedSet use a safe cast instead of reflection+cruel cast
  * code has been modified along with the LocationMappedReachedSet stuff, review
    that

- [MT] Refactor the TheoremProver (and similarly named ones) interfaces and move all
  the decision procedures related stuff to its own package

- [MT] Overriding equals (and possibly also hashCode) is a design flaw in almost
  all cases, apply proper design patterns (Singleton and Factory); I'd expect a
  speedup by several orders of magnitude

- [MT] CPAAlgorithm is unnecessarily slow because we use sets where lists could
  be used as well (we know when we insert an element that already exists in the
  collection); sets will always check for uniqueness

- [MT] DefUse satisfiesPartialOrder is broken (does not care about
  top/bottom-element); this may be true for several other CPAs as well

- [AH] stop operator in LocationCPA is very time consuming (must iterate over
  all elements of reached)

- [MT] precisionAdjustment is currently not enabled! (code commented out in
  CPAAlgorithm)

- [MT] Setting cpas.symbpredabs.mathsat.useCache to false causes a null pointer
  exception (with ExplicitCPA, at least)

- [MT] Setting cpas.symbpredabs.explicit.getUsefulBlocks to false results in a
  failing assertion in getInstance of the mathsat manager code (with
  ExplicitCPA, at least)

- [MT] Setting cpas.symbpredabs.shortestCexTrace to false causes some error I
  can't remember right now, easily reproducible with ExplicitCPA

- [MT] Skipping BlankEdge in
  src/cpa/symbpredabs/explicit/BDDMathsatExplicitAbstractManager.java is
  dangerous; however, commenting out that piece of code breaks ExplicitCPA on
  several examples, which must be due to some other bug in ExplicitCPA (other
  CPAs relying on that piece of code don't break)

- [MT] newReachedSet not used anymore, some classes still implement it

- [MT] ExplicitCPA claims that ssh/s3_srvr_2_BUG.cil.c is safe, the filename and
  other CPAs suggest that it should be UNSAFE instead

- [MT] performRefinement in ExplicitCPA is most likely broken:
  * the root must always be set to the first interpolant, otherwise we keep
    reasoning about a subtree that is infeasible anyway
  * Elements that were covered before and won't be after removing a subtree must
    get added to the waitlist (see SummaryCPA)

- [MT] The statistics classes should provide some simple support for adding
  timers, the current statistics interface is really too stupid

- [MT] setPredecessor/setSuccessor (of CFAEdge) should really not be used in
  non-private contexts, all uses (there are some) are likely just useless,
  because CFACheck did not yield errors and there use would otherwise be buggy.

- [MT] Properties of the CFA (like function entry points) should not be
  evaluated in each CPA again and again, this info must be built into the CFA

- [AH] Provide configuration to every CPA via its constructor instead of having
  a global static variable in order to improve decoupling and reusability.

