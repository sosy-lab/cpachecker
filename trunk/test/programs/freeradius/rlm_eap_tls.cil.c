/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 211 "/usr/lib/gcc/x86_64-linux-gnu/4.4.1/include/stddef.h"
typedef unsigned long size_t;
#line 32 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 50 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 90 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_TIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 107
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 114
struct buf_mem_st;
#line 114 "/usr/include/openssl/ossl_typ.h"
typedef struct buf_mem_st BUF_MEM;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 118
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 120
struct evp_pkey_st;
#line 120 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 122
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 136
struct x509_st;
#line 136 "/usr/include/openssl/ossl_typ.h"
typedef struct x509_st X509;
#line 137
struct X509_algor_st;
#line 137 "/usr/include/openssl/ossl_typ.h"
typedef struct X509_algor_st X509_ALGOR;
#line 138
struct X509_crl_st;
#line 138 "/usr/include/openssl/ossl_typ.h"
typedef struct X509_crl_st X509_CRL;
#line 139
struct X509_name_st;
#line 139 "/usr/include/openssl/ossl_typ.h"
typedef struct X509_name_st X509_NAME;
#line 140
struct x509_store_st;
#line 140 "/usr/include/openssl/ossl_typ.h"
typedef struct x509_store_st X509_STORE;
#line 141
struct x509_store_ctx_st;
#line 141 "/usr/include/openssl/ossl_typ.h"
typedef struct x509_store_ctx_st X509_STORE_CTX;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 158
struct X509_POLICY_TREE_st;
#line 158 "/usr/include/openssl/ossl_typ.h"
typedef struct X509_POLICY_TREE_st X509_POLICY_TREE;
#line 159
struct X509_POLICY_CACHE_st;
#line 159 "/usr/include/openssl/ossl_typ.h"
typedef struct X509_POLICY_CACHE_st X509_POLICY_CACHE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 281 "/usr/include/openssl/crypto.h"
struct bio_st;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 199 "/usr/include/openssl/bio.h"
typedef struct bio_st BIO;
#line 262 "/usr/include/openssl/bio.h"
typedef void bio_info_cb(struct bio_st * , int  , char const   * , int  , long  ,
                         long  );
#line 265 "/usr/include/openssl/bio.h"
struct bio_method_st {
   int type ;
   char const   *name ;
   int (*bwrite)(BIO * , char const   * , int  ) ;
   int (*bread)(BIO * , char * , int  ) ;
   int (*bputs)(BIO * , char const   * ) ;
   int (*bgets)(BIO * , char * , int  ) ;
   long (*ctrl)(BIO * , int  , long  , void * ) ;
   int (*create)(BIO * ) ;
   int (*destroy)(BIO * ) ;
   long (*callback_ctrl)(BIO * , int  , bio_info_cb * ) ;
};
#line 265 "/usr/include/openssl/bio.h"
typedef struct bio_method_st BIO_METHOD;
#line 294 "/usr/include/openssl/bio.h"
struct bio_st {
   BIO_METHOD *method ;
   long (*callback)(struct bio_st * , int  , char const   * , int  , long  , long  ) ;
   char *cb_arg ;
   int init ;
   int shutdown ;
   int flags ;
   int retry_reason ;
   int num ;
   void *ptr ;
   struct bio_st *next_bio ;
   struct bio_st *prev_bio ;
   int references ;
   unsigned long num_read ;
   unsigned long num_write ;
   CRYPTO_EX_DATA ex_data ;
};
#line 79 "/usr/include/openssl/lhash.h"
struct lhash_node_st {
   void *data ;
   struct lhash_node_st *next ;
   unsigned long hash ;
};
#line 79 "/usr/include/openssl/lhash.h"
typedef struct lhash_node_st LHASH_NODE;
#line 138 "/usr/include/openssl/lhash.h"
struct lhash_st {
   LHASH_NODE **b ;
   int (*comp)(void const   * , void const   * ) ;
   unsigned long (*hash)(void const   * ) ;
   unsigned int num_nodes ;
   unsigned int num_alloc_nodes ;
   unsigned int p ;
   unsigned int pmax ;
   unsigned long up_load ;
   unsigned long down_load ;
   unsigned long num_items ;
   unsigned long num_expands ;
   unsigned long num_expand_reallocs ;
   unsigned long num_contracts ;
   unsigned long num_contract_reallocs ;
   unsigned long num_hash_calls ;
   unsigned long num_comp_calls ;
   unsigned long num_insert ;
   unsigned long num_replace ;
   unsigned long num_delete ;
   unsigned long num_no_delete ;
   unsigned long num_retrieve ;
   unsigned long num_retrieve_miss ;
   unsigned long num_hash_comps ;
   int error ;
};
#line 288 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 299 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 323 "/usr/include/openssl/bn.h"
union __anonunion_cb_54 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 323 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_54 cb ;
};
#line 161 "/usr/include/openssl/asn1.h"
struct X509_algor_st;
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 239 "/usr/include/openssl/asn1.h"
struct ASN1_ENCODING_st {
   unsigned char *enc ;
   long len ;
   int modified ;
};
#line 239 "/usr/include/openssl/asn1.h"
typedef struct ASN1_ENCODING_st ASN1_ENCODING;
#line 499 "/usr/include/openssl/asn1.h"
union __anonunion_value_55 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 499 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_55 value ;
};
#line 499 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 97 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 115 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 108 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 108 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 114 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 141 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 297 "/usr/include/openssl/ec.h"
struct ec_key_st;
#line 297 "/usr/include/openssl/ec.h"
typedef struct ec_key_st EC_KEY;
#line 126 "/usr/include/openssl/evp.h"
union __anonunion_pkey_58 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
   struct ec_key_st *ec ;
};
#line 126 "/usr/include/openssl/evp.h"
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   union __anonunion_pkey_58 pkey ;
   int save_parameters ;
   STACK *attributes ;
};
#line 223 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 290 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 307 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 367 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 813
struct rsa_st;
#line 818
struct dsa_st;
#line 823
struct dh_st;
#line 828
struct ec_key_st;
#line 77 "/usr/include/openssl/buffer.h"
struct buf_mem_st {
   int length ;
   char *data ;
   int max ;
};
#line 143 "/usr/include/openssl/x509.h"
struct X509_algor_st {
   ASN1_OBJECT *algorithm ;
   ASN1_TYPE *parameter ;
};
#line 152 "/usr/include/openssl/x509.h"
struct X509_val_st {
   ASN1_TIME *notBefore ;
   ASN1_TIME *notAfter ;
};
#line 152 "/usr/include/openssl/x509.h"
typedef struct X509_val_st X509_VAL;
#line 158 "/usr/include/openssl/x509.h"
struct X509_pubkey_st {
   X509_ALGOR *algor ;
   ASN1_BIT_STRING *public_key ;
   EVP_PKEY *pkey ;
};
#line 158 "/usr/include/openssl/x509.h"
typedef struct X509_pubkey_st X509_PUBKEY;
#line 183 "/usr/include/openssl/x509.h"
struct X509_name_st {
   STACK *entries ;
   int modified ;
   BUF_MEM *bytes ;
   unsigned long hash ;
};
#line 243 "/usr/include/openssl/x509.h"
struct x509_cinf_st {
   ASN1_INTEGER *version ;
   ASN1_INTEGER *serialNumber ;
   X509_ALGOR *signature ;
   X509_NAME *issuer ;
   X509_VAL *validity ;
   X509_NAME *subject ;
   X509_PUBKEY *key ;
   ASN1_BIT_STRING *issuerUID ;
   ASN1_BIT_STRING *subjectUID ;
   STACK *extensions ;
};
#line 243 "/usr/include/openssl/x509.h"
typedef struct x509_cinf_st X509_CINF;
#line 263 "/usr/include/openssl/x509.h"
struct x509_cert_aux_st {
   STACK *trust ;
   STACK *reject ;
   ASN1_UTF8STRING *alias ;
   ASN1_OCTET_STRING *keyid ;
   STACK *other ;
};
#line 263 "/usr/include/openssl/x509.h"
typedef struct x509_cert_aux_st X509_CERT_AUX;
#line 272
struct AUTHORITY_KEYID_st;
#line 272 "/usr/include/openssl/x509.h"
struct x509_st {
   X509_CINF *cert_info ;
   X509_ALGOR *sig_alg ;
   ASN1_BIT_STRING *signature ;
   int valid ;
   int references ;
   char *name ;
   CRYPTO_EX_DATA ex_data ;
   long ex_pathlen ;
   long ex_pcpathlen ;
   unsigned long ex_flags ;
   unsigned long ex_kusage ;
   unsigned long ex_xkusage ;
   unsigned long ex_nscert ;
   ASN1_OCTET_STRING *skid ;
   struct AUTHORITY_KEYID_st *akid ;
   X509_POLICY_CACHE *policy_cache ;
   unsigned char sha1_hash[20] ;
   X509_CERT_AUX *aux ;
};
#line 434 "/usr/include/openssl/x509.h"
struct X509_crl_info_st {
   ASN1_INTEGER *version ;
   X509_ALGOR *sig_alg ;
   X509_NAME *issuer ;
   ASN1_TIME *lastUpdate ;
   ASN1_TIME *nextUpdate ;
   STACK *revoked ;
   STACK *extensions ;
   ASN1_ENCODING enc ;
};
#line 434 "/usr/include/openssl/x509.h"
typedef struct X509_crl_info_st X509_CRL_INFO;
#line 446 "/usr/include/openssl/x509.h"
struct X509_crl_st {
   X509_CRL_INFO *crl ;
   X509_ALGOR *sig_alg ;
   ASN1_BIT_STRING *signature ;
   int references ;
};
#line 164 "/usr/include/openssl/x509_vfy.h"
struct X509_VERIFY_PARAM_st {
   char *name ;
   time_t check_time ;
   unsigned long inh_flags ;
   unsigned long flags ;
   int purpose ;
   int trust ;
   int depth ;
   STACK *policies ;
};
#line 164 "/usr/include/openssl/x509_vfy.h"
typedef struct X509_VERIFY_PARAM_st X509_VERIFY_PARAM;
#line 181 "/usr/include/openssl/x509_vfy.h"
struct x509_store_st {
   int cache ;
   STACK *objs ;
   STACK *get_cert_methods ;
   X509_VERIFY_PARAM *param ;
   int (*verify)(X509_STORE_CTX *ctx ) ;
   int (*verify_cb)(int ok , X509_STORE_CTX *ctx ) ;
   int (*get_issuer)(X509 **issuer , X509_STORE_CTX *ctx , X509 *x ) ;
   int (*check_issued)(X509_STORE_CTX *ctx , X509 *x , X509 *issuer ) ;
   int (*check_revocation)(X509_STORE_CTX *ctx ) ;
   int (*get_crl)(X509_STORE_CTX *ctx , X509_CRL **crl , X509 *x ) ;
   int (*check_crl)(X509_STORE_CTX *ctx , X509_CRL *crl ) ;
   int (*cert_crl)(X509_STORE_CTX *ctx , X509_CRL *crl , X509 *x ) ;
   int (*cleanup)(X509_STORE_CTX *ctx ) ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
};
#line 226 "/usr/include/openssl/x509_vfy.h"
struct x509_store_ctx_st {
   X509_STORE *ctx ;
   int current_method ;
   X509 *cert ;
   STACK *untrusted ;
   STACK *crls ;
   X509_VERIFY_PARAM *param ;
   void *other_ctx ;
   int (*verify)(X509_STORE_CTX *ctx ) ;
   int (*verify_cb)(int ok , X509_STORE_CTX *ctx ) ;
   int (*get_issuer)(X509 **issuer , X509_STORE_CTX *ctx , X509 *x ) ;
   int (*check_issued)(X509_STORE_CTX *ctx , X509 *x , X509 *issuer ) ;
   int (*check_revocation)(X509_STORE_CTX *ctx ) ;
   int (*get_crl)(X509_STORE_CTX *ctx , X509_CRL **crl , X509 *x ) ;
   int (*check_crl)(X509_STORE_CTX *ctx , X509_CRL *crl ) ;
   int (*cert_crl)(X509_STORE_CTX *ctx , X509_CRL *crl , X509 *x ) ;
   int (*check_policy)(X509_STORE_CTX *ctx ) ;
   int (*cleanup)(X509_STORE_CTX *ctx ) ;
   int valid ;
   int last_untrusted ;
   STACK *chain ;
   X509_POLICY_TREE *tree ;
   int explicit_policy ;
   int error_depth ;
   int error ;
   X509 *current_cert ;
   X509 *current_issuer ;
   X509_CRL *current_crl ;
   CRYPTO_EX_DATA ex_data ;
};
#line 11 "/usr/include/openssl/comp.h"
struct comp_ctx_st;
#line 11 "/usr/include/openssl/comp.h"
typedef struct comp_ctx_st COMP_CTX;
#line 13 "/usr/include/openssl/comp.h"
struct comp_method_st {
   int type ;
   char const   *name ;
   int (*init)(COMP_CTX *ctx ) ;
   void (*finish)(COMP_CTX *ctx ) ;
   int (*compress)(COMP_CTX *ctx , unsigned char *out , unsigned int olen , unsigned char *in ,
                   unsigned int ilen ) ;
   int (*expand)(COMP_CTX *ctx , unsigned char *out , unsigned int olen , unsigned char *in ,
                 unsigned int ilen ) ;
   long (*ctrl)(void) ;
   long (*callback_ctrl)(void) ;
};
#line 13 "/usr/include/openssl/comp.h"
typedef struct comp_method_st COMP_METHOD;
#line 30 "/usr/include/openssl/comp.h"
struct comp_ctx_st {
   COMP_METHOD *meth ;
   unsigned long compress_in ;
   unsigned long compress_out ;
   unsigned long expand_in ;
   unsigned long expand_out ;
   CRYPTO_EX_DATA ex_data ;
};
#line 559 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 344 "/usr/include/openssl/ssl.h"
struct ssl_st;
#line 347 "/usr/include/openssl/ssl.h"
struct ssl_cipher_st {
   int valid ;
   char const   *name ;
   unsigned long id ;
   unsigned long algorithms ;
   unsigned long algo_strength ;
   unsigned long algorithm2 ;
   int strength_bits ;
   int alg_bits ;
   unsigned long mask ;
   unsigned long mask_strength ;
};
#line 347 "/usr/include/openssl/ssl.h"
typedef struct ssl_cipher_st SSL_CIPHER;
#line 363 "/usr/include/openssl/ssl.h"
typedef struct ssl_st SSL;
#line 364
struct ssl_ctx_st;
#line 364 "/usr/include/openssl/ssl.h"
typedef struct ssl_ctx_st SSL_CTX;
#line 367
struct ssl3_enc_method;
#line 367 "/usr/include/openssl/ssl.h"
struct ssl_method_st {
   int version ;
   int (*ssl_new)(SSL *s ) ;
   void (*ssl_clear)(SSL *s ) ;
   void (*ssl_free)(SSL *s ) ;
   int (*ssl_accept)(SSL *s ) ;
   int (*ssl_connect)(SSL *s ) ;
   int (*ssl_read)(SSL *s , void *buf , int len ) ;
   int (*ssl_peek)(SSL *s , void *buf , int len ) ;
   int (*ssl_write)(SSL *s , void const   *buf , int len ) ;
   int (*ssl_shutdown)(SSL *s ) ;
   int (*ssl_renegotiate)(SSL *s ) ;
   int (*ssl_renegotiate_check)(SSL *s ) ;
   long (*ssl_get_message)(SSL *s , int st1 , int stn , int mt , long max , int *ok ) ;
   int (*ssl_read_bytes)(SSL *s , int type , unsigned char *buf , int len , int peek ) ;
   int (*ssl_write_bytes)(SSL *s , int type , void const   *buf_ , int len ) ;
   int (*ssl_dispatch_alert)(SSL *s ) ;
   long (*ssl_ctrl)(SSL *s , int cmd , long larg , void *parg ) ;
   long (*ssl_ctx_ctrl)(SSL_CTX *ctx , int cmd , long larg , void *parg ) ;
   SSL_CIPHER *(*get_cipher_by_char)(unsigned char const   *ptr ) ;
   int (*put_cipher_by_char)(SSL_CIPHER const   *cipher , unsigned char *ptr ) ;
   int (*ssl_pending)(SSL const   *s ) ;
   int (*num_ciphers)(void) ;
   SSL_CIPHER *(*get_cipher)(unsigned int ncipher ) ;
   struct ssl_method_st *(*get_ssl_method)(int version ) ;
   long (*get_timeout)(void) ;
   struct ssl3_enc_method *ssl3_enc ;
   int (*ssl_version)(void) ;
   long (*ssl_callback_ctrl)(SSL *s , int cb_id , void (*fp)(void) ) ;
   long (*ssl_ctx_callback_ctrl)(SSL_CTX *s , int cb_id , void (*fp)(void) ) ;
};
#line 367 "/usr/include/openssl/ssl.h"
typedef struct ssl_method_st SSL_METHOD;
#line 421
struct sess_cert_st;
#line 421 "/usr/include/openssl/ssl.h"
struct ssl_session_st {
   int ssl_version ;
   unsigned int key_arg_length ;
   unsigned char key_arg[8] ;
   int master_key_length ;
   unsigned char master_key[48] ;
   unsigned int session_id_length ;
   unsigned char session_id[32] ;
   unsigned int sid_ctx_length ;
   unsigned char sid_ctx[32] ;
   int not_resumable ;
   struct sess_cert_st *sess_cert ;
   X509 *peer ;
   long verify_result ;
   int references ;
   long timeout ;
   long time ;
   int compress_meth ;
   SSL_CIPHER *cipher ;
   unsigned long cipher_id ;
   STACK *ciphers ;
   CRYPTO_EX_DATA ex_data ;
   struct ssl_session_st *prev ;
   struct ssl_session_st *next ;
   char *tlsext_hostname ;
   unsigned char *tlsext_tick ;
   size_t tlsext_ticklen ;
   long tlsext_tick_lifetime_hint ;
};
#line 421 "/usr/include/openssl/ssl.h"
typedef struct ssl_session_st SSL_SESSION;
#line 615 "/usr/include/openssl/ssl.h"
struct ssl_comp_st {
   int id ;
   char const   *name ;
   COMP_METHOD *method ;
};
#line 615 "/usr/include/openssl/ssl.h"
typedef struct ssl_comp_st SSL_COMP;
#line 628 "/usr/include/openssl/ssl.h"
struct __anonstruct_stats_67 {
   int sess_connect ;
   int sess_connect_renegotiate ;
   int sess_connect_good ;
   int sess_accept ;
   int sess_accept_renegotiate ;
   int sess_accept_good ;
   int sess_miss ;
   int sess_timeout ;
   int sess_cache_full ;
   int sess_hit ;
   int sess_cb_hit ;
};
#line 628
struct cert_st;
#line 628 "/usr/include/openssl/ssl.h"
struct ssl_ctx_st {
   SSL_METHOD *method ;
   STACK *cipher_list ;
   STACK *cipher_list_by_id ;
   struct x509_store_st *cert_store ;
   struct lhash_st *sessions ;
   unsigned long session_cache_size ;
   struct ssl_session_st *session_cache_head ;
   struct ssl_session_st *session_cache_tail ;
   int session_cache_mode ;
   long session_timeout ;
   int (*new_session_cb)(struct ssl_st *ssl , SSL_SESSION *sess ) ;
   void (*remove_session_cb)(struct ssl_ctx_st *ctx , SSL_SESSION *sess ) ;
   SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl , unsigned char *data , int len ,
                                  int *copy ) ;
   struct __anonstruct_stats_67 stats ;
   int references ;
   int (*app_verify_callback)(X509_STORE_CTX * , void * ) ;
   void *app_verify_arg ;
   pem_password_cb *default_passwd_callback ;
   void *default_passwd_callback_userdata ;
   int (*client_cert_cb)(SSL *ssl , X509 **x509 , EVP_PKEY **pkey ) ;
   int (*app_gen_cookie_cb)(SSL *ssl , unsigned char *cookie , unsigned int *cookie_len ) ;
   int (*app_verify_cookie_cb)(SSL *ssl , unsigned char *cookie , unsigned int cookie_len ) ;
   CRYPTO_EX_DATA ex_data ;
   EVP_MD const   *rsa_md5 ;
   EVP_MD const   *md5 ;
   EVP_MD const   *sha1 ;
   STACK *extra_certs ;
   STACK *comp_methods ;
   void (*info_callback)(SSL const   *ssl , int type , int val ) ;
   STACK *client_CA ;
   unsigned long options ;
   unsigned long mode ;
   long max_cert_list ;
   struct cert_st *cert ;
   int read_ahead ;
   void (*msg_callback)(int write_p , int version , int content_type , void const   *buf ,
                        size_t len , SSL *ssl , void *arg ) ;
   void *msg_callback_arg ;
   int verify_mode ;
   unsigned int sid_ctx_length ;
   unsigned char sid_ctx[32] ;
   int (*default_verify_callback)(int ok , X509_STORE_CTX *ctx ) ;
   int (*generate_session_id)(SSL const   *ssl , unsigned char *id , unsigned int *id_len ) ;
   X509_VERIFY_PARAM *param ;
   int quiet_shutdown ;
   int (*tlsext_servername_callback)(SSL * , int * , void * ) ;
   void *tlsext_servername_arg ;
   unsigned char tlsext_tick_key_name[16] ;
   unsigned char tlsext_tick_hmac_key[16] ;
   unsigned char tlsext_tick_aes_key[16] ;
};
#line 835
struct ssl2_state_st;
#line 835
struct ssl3_state_st;
#line 835
struct dtls1_state_st;
#line 835 "/usr/include/openssl/ssl.h"
struct ssl_st {
   int version ;
   int type ;
   SSL_METHOD *method ;
   BIO *rbio ;
   BIO *wbio ;
   BIO *bbio ;
   int rwstate ;
   int in_handshake ;
   int (*handshake_func)(SSL * ) ;
   int server ;
   int new_session ;
   int quiet_shutdown ;
   int shutdown ;
   int state ;
   int rstate ;
   BUF_MEM *init_buf ;
   void *init_msg ;
   int init_num ;
   int init_off ;
   unsigned char *packet ;
   unsigned int packet_length ;
   struct ssl2_state_st *s2 ;
   struct ssl3_state_st *s3 ;
   struct dtls1_state_st *d1 ;
   int read_ahead ;
   void (*msg_callback)(int write_p , int version , int content_type , void const   *buf ,
                        size_t len , SSL *ssl , void *arg ) ;
   void *msg_callback_arg ;
   int hit ;
   X509_VERIFY_PARAM *param ;
   STACK *cipher_list ;
   STACK *cipher_list_by_id ;
   EVP_CIPHER_CTX *enc_read_ctx ;
   EVP_MD const   *read_hash ;
   COMP_CTX *expand ;
   EVP_CIPHER_CTX *enc_write_ctx ;
   EVP_MD const   *write_hash ;
   COMP_CTX *compress ;
   struct cert_st *cert ;
   unsigned int sid_ctx_length ;
   unsigned char sid_ctx[32] ;
   SSL_SESSION *session ;
   int (*generate_session_id)(SSL const   *ssl , unsigned char *id , unsigned int *id_len ) ;
   int verify_mode ;
   int (*verify_callback)(int ok , X509_STORE_CTX *ctx ) ;
   void (*info_callback)(SSL const   *ssl , int type , int val ) ;
   int error ;
   int error_code ;
   SSL_CTX *ctx ;
   int debug ;
   long verify_result ;
   CRYPTO_EX_DATA ex_data ;
   STACK *client_CA ;
   int references ;
   unsigned long options ;
   unsigned long mode ;
   long max_cert_list ;
   int first_packet ;
   int client_version ;
   void (*tlsext_debug_cb)(SSL *s , int client_server , int type , unsigned char *data ,
                           int len , void *arg ) ;
   void *tlsext_debug_arg ;
   char *tlsext_hostname ;
   int servername_done ;
   int tlsext_ticket_expected ;
   SSL_CTX *initial_ctx ;
};
#line 158 "/usr/include/openssl/ssl2.h"
struct __anonstruct_tmp_68 {
   unsigned int conn_id_length ;
   unsigned int cert_type ;
   unsigned int cert_length ;
   unsigned int csl ;
   unsigned int clear ;
   unsigned int enc ;
   unsigned char ccl[32] ;
   unsigned int cipher_spec_length ;
   unsigned int session_id_length ;
   unsigned int clen ;
   unsigned int rlen ;
};
#line 158 "/usr/include/openssl/ssl2.h"
struct ssl2_state_st {
   int three_byte_header ;
   int clear_text ;
   int escape ;
   int ssl2_rollback ;
   unsigned int wnum ;
   int wpend_tot ;
   unsigned char const   *wpend_buf ;
   int wpend_off ;
   int wpend_len ;
   int wpend_ret ;
   int rbuf_left ;
   int rbuf_offs ;
   unsigned char *rbuf ;
   unsigned char *wbuf ;
   unsigned char *write_ptr ;
   unsigned int padding ;
   unsigned int rlength ;
   int ract_data_length ;
   unsigned int wlength ;
   int wact_data_length ;
   unsigned char *ract_data ;
   unsigned char *wact_data ;
   unsigned char *mac_data ;
   unsigned char *read_key ;
   unsigned char *write_key ;
   unsigned int challenge_length ;
   unsigned char challenge[32] ;
   unsigned int conn_id_length ;
   unsigned char conn_id[16] ;
   unsigned int key_material_length ;
   unsigned char key_material[48] ;
   unsigned long read_sequence ;
   unsigned long write_sequence ;
   struct __anonstruct_tmp_68 tmp ;
};
#line 294 "/usr/include/openssl/ssl3.h"
struct ssl3_record_st {
   int type ;
   unsigned int length ;
   unsigned int off ;
   unsigned char *data ;
   unsigned char *input ;
   unsigned char *comp ;
   unsigned long epoch ;
   unsigned long seq_num ;
};
#line 294 "/usr/include/openssl/ssl3.h"
typedef struct ssl3_record_st SSL3_RECORD;
#line 306 "/usr/include/openssl/ssl3.h"
struct ssl3_buffer_st {
   unsigned char *buf ;
   size_t len ;
   int offset ;
   int left ;
};
#line 306 "/usr/include/openssl/ssl3.h"
typedef struct ssl3_buffer_st SSL3_BUFFER;
#line 334 "/usr/include/openssl/ssl3.h"
struct __anonstruct_tmp_69 {
   unsigned char cert_verify_md[128] ;
   unsigned char finish_md[128] ;
   int finish_md_len ;
   unsigned char peer_finish_md[128] ;
   int peer_finish_md_len ;
   unsigned long message_size ;
   int message_type ;
   SSL_CIPHER *new_cipher ;
   DH *dh ;
   EC_KEY *ecdh ;
   int next_state ;
   int reuse_message ;
   int cert_req ;
   int ctype_num ;
   char ctype[7] ;
   STACK *ca_names ;
   int use_rsa_tmp ;
   int key_block_length ;
   unsigned char *key_block ;
   EVP_CIPHER const   *new_sym_enc ;
   EVP_MD const   *new_hash ;
   SSL_COMP const   *new_compression ;
   int cert_request ;
};
#line 334 "/usr/include/openssl/ssl3.h"
struct ssl3_state_st {
   long flags ;
   int delay_buf_pop_ret ;
   unsigned char read_sequence[8] ;
   unsigned char read_mac_secret[64] ;
   unsigned char write_sequence[8] ;
   unsigned char write_mac_secret[64] ;
   unsigned char server_random[32] ;
   unsigned char client_random[32] ;
   int need_empty_fragments ;
   int empty_fragment_done ;
   SSL3_BUFFER rbuf ;
   SSL3_BUFFER wbuf ;
   SSL3_RECORD rrec ;
   SSL3_RECORD wrec ;
   unsigned char alert_fragment[2] ;
   unsigned int alert_fragment_len ;
   unsigned char handshake_fragment[4] ;
   unsigned int handshake_fragment_len ;
   unsigned int wnum ;
   int wpend_tot ;
   int wpend_type ;
   int wpend_ret ;
   unsigned char const   *wpend_buf ;
   EVP_MD_CTX finish_dgst1 ;
   EVP_MD_CTX finish_dgst2 ;
   int change_cipher_spec ;
   int warn_alert ;
   int fatal_alert ;
   int alert_dispatch ;
   unsigned char send_alert[2] ;
   int renegotiate ;
   int total_renegotiations ;
   int num_renegotiations ;
   int in_read_app_data ;
   struct __anonstruct_tmp_69 tmp ;
};
#line 69 "/usr/include/openssl/pqueue.h"
struct _pqueue;
#line 69 "/usr/include/openssl/pqueue.h"
typedef struct _pqueue *pqueue;
#line 90 "/usr/include/openssl/dtls1.h"
struct dtls1_bitmap_st {
   unsigned long map ;
   unsigned long length ;
   unsigned long max_seq_num ;
};
#line 90 "/usr/include/openssl/dtls1.h"
typedef struct dtls1_bitmap_st DTLS1_BITMAP;
#line 97 "/usr/include/openssl/dtls1.h"
struct hm_header_st {
   unsigned char type ;
   unsigned long msg_len ;
   unsigned short seq ;
   unsigned long frag_off ;
   unsigned long frag_len ;
   unsigned int is_ccs ;
};
#line 113 "/usr/include/openssl/dtls1.h"
struct dtls1_timeout_st {
   unsigned int read_timeouts ;
   unsigned int write_timeouts ;
   unsigned int num_alerts ;
};
#line 125 "/usr/include/openssl/dtls1.h"
struct record_pqueue_st {
   unsigned short epoch ;
   pqueue q ;
};
#line 125 "/usr/include/openssl/dtls1.h"
typedef struct record_pqueue_st record_pqueue;
#line 137 "/usr/include/openssl/dtls1.h"
struct dtls1_state_st {
   unsigned int send_cookie ;
   unsigned char cookie[32] ;
   unsigned char rcvd_cookie[32] ;
   unsigned int cookie_len ;
   unsigned short r_epoch ;
   unsigned short w_epoch ;
   DTLS1_BITMAP bitmap ;
   DTLS1_BITMAP next_bitmap ;
   unsigned short handshake_write_seq ;
   unsigned short next_handshake_write_seq ;
   unsigned short handshake_read_seq ;
   record_pqueue unprocessed_rcds ;
   record_pqueue processed_rcds ;
   pqueue buffered_messages ;
   pqueue sent_messages ;
   unsigned int mtu ;
   struct hm_header_st w_msg_hdr ;
   struct hm_header_st r_msg_hdr ;
   struct dtls1_timeout_st timeout ;
   unsigned char alert_fragment[7] ;
   unsigned int alert_fragment_len ;
   unsigned char handshake_fragment[12] ;
   unsigned int handshake_fragment_len ;
   unsigned int retransmitting ;
};
#line 26 "../../../../include/token.h"
enum lrad_token_t {
    T_INVALID = 0,
    T_EOL = 1,
    T_LCBRACE = 2,
    T_RCBRACE = 3,
    T_LBRACE = 4,
    T_RBRACE = 5,
    T_COMMA = 6,
    T_SEMICOLON = 7,
    T_OP_ADD = 8,
    T_OP_SUB = 9,
    T_OP_SET = 10,
    T_OP_EQ = 11,
    T_OP_NE = 12,
    T_OP_GE = 13,
    T_OP_GT = 14,
    T_OP_LE = 15,
    T_OP_LT = 16,
    T_OP_REG_EQ = 17,
    T_OP_REG_NE = 18,
    T_OP_CMP_TRUE = 19,
    T_OP_CMP_FALSE = 20,
    T_OP_CMP_EQ = 21,
    T_HASH = 22,
    T_BARE_WORD = 23,
    T_DOUBLE_QUOTED_STRING = 24,
    T_SINGLE_QUOTED_STRING = 25,
    T_BACK_QUOTED_STRING = 26,
    T_TOKEN_LAST = 27
} ;
#line 26 "../../../../include/token.h"
typedef enum lrad_token_t LRAD_TOKEN;
#line 99 "../../../../include/libradius.h"
struct attr_flags {
   char addport ;
   char has_tag ;
   signed char len_disp ;
   char do_xlat ;
   signed char tag ;
   uint8_t encrypt ;
};
#line 99 "../../../../include/libradius.h"
typedef struct attr_flags ATTR_FLAGS;
#line 137 "../../../../include/libradius.h"
struct value_pair {
   char name[40] ;
   int attribute ;
   int type ;
   int length ;
   uint32_t lvalue ;
   LRAD_TOKEN operator ;
   uint8_t strvalue[254] ;
   ATTR_FLAGS flags ;
   struct value_pair *next ;
};
#line 137 "../../../../include/libradius.h"
typedef struct value_pair VALUE_PAIR;
#line 158 "../../../../include/libradius.h"
struct radius_packet {
   int sockfd ;
   uint32_t src_ipaddr ;
   uint32_t dst_ipaddr ;
   u_short src_port ;
   u_short dst_port ;
   int id ;
   unsigned int code ;
   uint8_t vector[16] ;
   time_t timestamp ;
   int verified ;
   uint8_t *data ;
   int data_len ;
   VALUE_PAIR *vps ;
};
#line 158 "../../../../include/libradius.h"
typedef struct radius_packet RADIUS_PACKET;
#line 19 "../../../../include/conffile.h"
struct conf_part;
#line 19 "../../../../include/conffile.h"
typedef struct conf_part CONF_SECTION;
#line 30 "../../../../include/conffile.h"
struct CONF_PARSER {
   char const   *name ;
   int type ;
   size_t offset ;
   void *data ;
   char const   *dflt ;
};
#line 30 "../../../../include/conffile.h"
typedef struct CONF_PARSER CONF_PARSER;
#line 23 "../../../../include/radiusd.h"
typedef pthread_t child_pid_t;
#line 49
struct request_data_t;
#line 49 "../../../../include/radiusd.h"
typedef struct request_data_t request_data_t;
#line 54 "../../../../include/radiusd.h"
struct auth_req {
   uint32_t magic ;
   RADIUS_PACKET *packet ;
   RADIUS_PACKET *proxy ;
   RADIUS_PACKET *reply ;
   RADIUS_PACKET *proxy_reply ;
   VALUE_PAIR *config_items ;
   VALUE_PAIR *username ;
   VALUE_PAIR *password ;
   request_data_t *data ;
   char secret[32] ;
   child_pid_t child_pid ;
   time_t timestamp ;
   int number ;
   char proxysecret[32] ;
   int proxy_try_count ;
   int proxy_outstanding ;
   time_t proxy_next_try ;
   int simul_max ;
   int simul_count ;
   int simul_mpp ;
   int finished ;
   int options ;
   void *container ;
};
#line 54 "../../../../include/radiusd.h"
typedef struct auth_req REQUEST;
#line 87 "../../../../modules/rlm_eap/libeap/eap_types.h"
struct eaptype_t {
   unsigned char type ;
   unsigned int length ;
   unsigned char *data ;
};
#line 87 "../../../../modules/rlm_eap/libeap/eap_types.h"
typedef struct eaptype_t eaptype_t;
#line 99 "../../../../modules/rlm_eap/libeap/eap_types.h"
struct eap_packet {
   unsigned char code ;
   unsigned char id ;
   unsigned int length ;
   eaptype_t type ;
   unsigned char *packet ;
};
#line 99 "../../../../modules/rlm_eap/libeap/eap_types.h"
typedef struct eap_packet EAP_PACKET;
#line 55 "../../../../modules/rlm_eap/eap.h"
struct eap_ds {
   EAP_PACKET *response ;
   EAP_PACKET *request ;
   int set_request_id ;
};
#line 55 "../../../../modules/rlm_eap/eap.h"
typedef struct eap_ds EAP_DS;
#line 102 "../../../../modules/rlm_eap/eap.h"
struct _eap_handler {
   struct _eap_handler *prev ;
   struct _eap_handler *next ;
   uint8_t state[16] ;
   uint32_t src_ipaddr ;
   unsigned int eap_id ;
   unsigned int eap_type ;
   time_t timestamp ;
   REQUEST *request ;
   char *identity ;
   EAP_DS *prev_eapds ;
   EAP_DS *eap_ds ;
   void *opaque ;
   void (*free_opaque)(void *opaque ) ;
   int status ;
   int stage ;
};
#line 102 "../../../../modules/rlm_eap/eap.h"
typedef struct _eap_handler EAP_HANDLER;
#line 129 "../../../../modules/rlm_eap/eap.h"
struct eap_type_t {
   char const   *name ;
   int (*attach)(CONF_SECTION *conf , void **type_data ) ;
   int (*initiate)(void *type_data , EAP_HANDLER *handler ) ;
   int (*authorize)(void *type_data , EAP_HANDLER *handler ) ;
   int (*authenticate)(void *type_data , EAP_HANDLER *handler ) ;
   int (*detach)(void *type_data ) ;
};
#line 129 "../../../../modules/rlm_eap/eap.h"
typedef struct eap_type_t EAP_TYPE;
#line 66 "../../../../modules/rlm_eap/libeap/eap_tls.h"
enum __anonenum_eaptls_status_t_88 {
    EAPTLS_INVALID = 0,
    EAPTLS_REQUEST = 1,
    EAPTLS_RESPONSE = 2,
    EAPTLS_SUCCESS = 3,
    EAPTLS_FAIL = 4,
    EAPTLS_NOOP = 5,
    EAPTLS_START = 6,
    EAPTLS_OK = 7,
    EAPTLS_ACK = 8,
    EAPTLS_FIRST_FRAGMENT = 9,
    EAPTLS_MORE_FRAGMENTS = 10,
    EAPTLS_LENGTH_INCLUDED = 11,
    EAPTLS_MORE_FRAGMENTS_WITH_LENGTH = 12,
    EAPTLS_HANDLED = 13
} ;
#line 66 "../../../../modules/rlm_eap/libeap/eap_tls.h"
typedef enum __anonenum_eaptls_status_t_88 eaptls_status_t;
#line 105 "../../../../modules/rlm_eap/libeap/eap_tls.h"
struct _record_t {
   unsigned char data[16384] ;
   unsigned int used ;
};
#line 105 "../../../../modules/rlm_eap/libeap/eap_tls.h"
typedef struct _record_t record_t;
#line 110 "../../../../modules/rlm_eap/libeap/eap_tls.h"
struct _tls_info_t {
   unsigned char origin ;
   unsigned char content_type ;
   unsigned char handshake_type ;
   unsigned char alert_level ;
   unsigned char alert_description ;
   char info_description[256] ;
   size_t record_len ;
   int version ;
   char initialized ;
};
#line 110 "../../../../modules/rlm_eap/libeap/eap_tls.h"
typedef struct _tls_info_t tls_info_t;
#line 137 "../../../../modules/rlm_eap/libeap/eap_tls.h"
struct _tls_session_t {
   SSL *ssl ;
   tls_info_t info ;
   BIO *into_ssl ;
   BIO *from_ssl ;
   record_t clean_in ;
   record_t clean_out ;
   record_t dirty_in ;
   record_t dirty_out ;
   void (*record_init)(record_t *buf ) ;
   void (*record_close)(record_t *buf ) ;
   unsigned int (*record_plus)(record_t *buf , void const   *ptr , unsigned int size ) ;
   unsigned int (*record_minus)(record_t *buf , void *ptr , unsigned int size ) ;
   unsigned int offset ;
   unsigned int tls_msg_len ;
   int fragment ;
   int length_flag ;
   int peap_flag ;
   void *opaque ;
   void (*free_opaque)(void *opaque ) ;
};
#line 137 "../../../../modules/rlm_eap/libeap/eap_tls.h"
typedef struct _tls_session_t tls_session_t;
#line 32 "rlm_eap_tls.h"
struct eap_tls_conf {
   char *private_key_password ;
   char *private_key_file ;
   char *certificate_file ;
   char *random_file ;
   char *ca_path ;
   char *ca_file ;
   char *dh_file ;
   char *rsa_file ;
   int rsa_key ;
   int dh_key ;
   int rsa_key_length ;
   int dh_key_length ;
   int verify_depth ;
   int file_type ;
   int include_length ;
   int fragment_size ;
   int check_crl ;
   char *check_cert_cn ;
   char *cipher_list ;
   char *check_cert_issuer ;
};
#line 32 "rlm_eap_tls.h"
typedef struct eap_tls_conf EAP_TLS_CONF;
#line 60 "rlm_eap_tls.h"
struct _eap_tls_t {
   EAP_TLS_CONF *conf ;
   SSL_CTX *ctx ;
};
#line 60 "rlm_eap_tls.h"
typedef struct _eap_tls_t eap_tls_t;
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 142
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 566 "/usr/include/openssl/bio.h"
extern BIO *BIO_new_file(char const   *filename , char const   *mode ) ;
#line 575
extern int BIO_free(BIO *a ) ;
#line 258 "/usr/include/openssl/err.h"
extern unsigned long ERR_get_error(void) ;
#line 271
extern char *ERR_error_string(unsigned long e , char *buf ) ;
#line 237 "/usr/include/openssl/rsa.h"
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 254
extern void RSA_free(RSA *r ) ;
#line 176 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 106 "/usr/include/openssl/rand.h"
extern int RAND_load_file(char const   *file , long max_bytes ) ;
#line 387 "/usr/include/openssl/x509_vfy.h"
extern int X509_STORE_set_flags(X509_STORE *ctx , unsigned long flags ) ;
#line 445
extern void *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx , int idx ) ;
#line 446
extern int X509_STORE_CTX_get_error(X509_STORE_CTX *ctx ) ;
#line 448
extern int X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx ) ;
#line 449
extern X509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx ) ;
#line 745 "/usr/include/openssl/x509.h"
extern char const   *X509_verify_cert_error_string(long n ) ;
#line 971
extern char *X509_NAME_oneline(X509_NAME *a , char *buf , int size ) ;
#line 998
extern X509_NAME *X509_get_issuer_name(X509 *a ) ;
#line 1000
extern X509_NAME *X509_get_subject_name(X509 *a ) ;
#line 1085
extern int X509_NAME_get_text_by_NID(X509_NAME *name , int nid , char *buf , int len ) ;
#line 680 "/usr/include/openssl/pem.h"
extern DH *PEM_read_bio_DHparams(BIO *bp , DH **x , pem_password_cb *cb , void *u ) ;
#line 817 "/usr/include/openssl/ssl.h"
extern void SSL_CTX_set_info_callback(SSL_CTX *ctx , void (*cb)(SSL const   *ssl ,
                                                                int type , int val ) ) ;
#line 1269
extern int SSL_CTX_set_cipher_list(SSL_CTX * , char const   *str ) ;
#line 1270
extern SSL_CTX *SSL_CTX_new(SSL_METHOD *meth ) ;
#line 1271
extern void SSL_CTX_free(SSL_CTX * ) ;
#line 1274
extern X509_STORE *SSL_CTX_get_cert_store(SSL_CTX const   * ) ;
#line 1308
extern void SSL_set_verify(SSL *s , int mode , int (*callback)(int ok , X509_STORE_CTX *ctx ) ) ;
#line 1325
extern int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx , char const   *file , int type ) ;
#line 1326
extern int SSL_CTX_use_certificate_file(SSL_CTX *ctx , char const   *file , int type ) ;
#line 1327
extern int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx , char const   *file ) ;
#line 1328
extern STACK *SSL_load_client_CA_file(char const   *file ) ;
#line 1340
extern void SSL_load_error_strings(void) ;
#line 1382
extern void SSL_CTX_set_verify(SSL_CTX *ctx , int mode , int (*callback)(int  , X509_STORE_CTX * ) ) ;
#line 1384
extern void SSL_CTX_set_verify_depth(SSL_CTX *ctx , int depth ) ;
#line 1396
extern void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx , pem_password_cb *cb ) ;
#line 1397
extern void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx , void *u ) ;
#line 1399
extern int SSL_CTX_check_private_key(SSL_CTX const   *ctx ) ;
#line 1422
extern long SSL_CTX_ctrl(SSL_CTX *ctx , int cmd , long larg , void *parg ) ;
#line 1443
extern SSL_METHOD *TLSv1_method(void) ;
#line 1466
extern void SSL_CTX_set_client_CA_list(SSL_CTX *ctx , STACK *name_list ) ;
#line 1477
extern int SSL_library_init(void) ;
#line 1495
extern int SSL_CTX_load_verify_locations(SSL_CTX *ctx , char const   *CAfile , char const   *CApath ) ;
#line 1510
extern int SSL_set_ex_data(SSL *ssl , int idx , void *data ) ;
#line 1511
extern void *SSL_get_ex_data(SSL const   *ssl , int idx ) ;
#line 1525
extern int SSL_get_ex_data_X509_STORE_CTX_idx(void) ;
#line 263 "../../../../include/libradius.h"
extern VALUE_PAIR *pairfind(VALUE_PAIR * , int  ) ;
#line 48 "../../../../include/conffile.h"
extern int cf_section_parse(CONF_SECTION *cs , void *base , CONF_PARSER const   *variables ) ;
#line 269 "../../../../include/radiusd.h"
extern int debug_flag ;
#line 352
extern int ( /* format attribute */  radlog)(int  , char const   *  , ...) ;
#line 357
extern int ( /* format attribute */  log_debug)(char const   *  , ...) ;
#line 397
extern int radius_xlat(char *out , int outlen , char const   *fmt , REQUEST *request ,
                       int (*func)(char *out , int outlen , char const   *in ) ) ;
#line 178 "../../../../modules/rlm_eap/libeap/eap_tls.h"
extern eaptls_status_t eaptls_process(EAP_HANDLER *handler ) ;
#line 180
extern int eaptls_success(EAP_DS *eap_ds , int peap_flag ) ;
#line 181
extern int eaptls_fail(EAP_DS *eap_ds , int peap_flag ) ;
#line 186
extern void eaptls_gen_mppe_keys(VALUE_PAIR **reply_vps , SSL *s , char const   *prf_label ) ;
#line 344
extern int eaptls_start(EAP_DS *eap_ds , int peap ) ;
#line 348
extern int cbtls_password(char *buf , int num , int rwflag , void *userdata ) ;
#line 349
extern void cbtls_info(SSL const   *s , int where , int ret ) ;
#line 355
extern tls_session_t *eaptls_new_session(SSL_CTX *ssl_ctx , int client_cert ) ;
#line 361
extern void session_free(void *ssn ) ;
#line 32 "rlm_eap_tls.c"
static CONF_PARSER module_config[20]  = 
#line 32 "rlm_eap_tls.c"
  {      {"rsa_key_exchange", 101, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->rsa_key)),
      (void *)0, "no"}, 
        {"dh_key_exchange", 101, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->dh_key)),
      (void *)0, "yes"}, 
        {"rsa_key_length", 1, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->rsa_key_length)),
      (void *)0, "512"}, 
        {"dh_key_length", 1, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->dh_key_length)),
      (void *)0, "512"}, 
        {"verify_depth", 1, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->verify_depth)),
      (void *)0, "0"}, 
        {"CA_path", 100, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->ca_path)),
      (void *)0, (char const   *)((void *)0)}, 
        {"pem_file_type", 101, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->file_type)),
      (void *)0, "yes"}, 
        {"private_key_file", 100, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->private_key_file)),
      (void *)0, (char const   *)((void *)0)}, 
        {"certificate_file", 100, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->certificate_file)),
      (void *)0, (char const   *)((void *)0)}, 
        {"CA_file", 100, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->ca_file)),
      (void *)0, (char const   *)((void *)0)}, 
        {"private_key_password", 100, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->private_key_password)),
      (void *)0, (char const   *)((void *)0)}, 
        {"dh_file", 100, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->dh_file)),
      (void *)0, (char const   *)((void *)0)}, 
        {"random_file", 100, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->random_file)),
      (void *)0, (char const   *)((void *)0)}, 
        {"fragment_size", 1, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->fragment_size)),
      (void *)0, "1024"}, 
        {"include_length", 101, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->include_length)),
      (void *)0, "yes"}, 
        {"check_crl", 101, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->check_crl)),
      (void *)0, "no"}, 
        {"check_cert_cn", 100, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->check_cert_cn)),
      (void *)0, (char const   *)((void *)0)}, 
        {"cipher_list", 100, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->cipher_list)),
      (void *)0, (char const   *)((void *)0)}, 
        {"check_cert_issuer", 100, (size_t )((unsigned int )(& ((EAP_TLS_CONF *)0)->check_cert_issuer)),
      (void *)0, (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), -1, (size_t )0, (void *)0, (char const   *)((void *)0)}};
#line 79 "rlm_eap_tls.c"
static int load_dh_params(SSL_CTX *ctx , char *file ) 
{ DH *dh ;
  BIO *bio ;
  long tmp ;
  void *__cil_tmp6 ;
  char const   *__cil_tmp7 ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  void *__cil_tmp11 ;
  DH **__cil_tmp12 ;
  void *__cil_tmp13 ;
  pem_password_cb *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
  {
#line 81
  __cil_tmp6 = (void *)0;
#line 81
  dh = (DH *)__cil_tmp6;
#line 84
  __cil_tmp7 = (char const   *)file;
#line 84
  bio = BIO_new_file(__cil_tmp7, "r");
  }
  {
#line 84
  __cil_tmp8 = (void *)0;
#line 84
  __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 84
  __cil_tmp10 = (unsigned long )bio;
#line 84
  if (__cil_tmp10 == __cil_tmp9) {
    {
#line 85
    radlog(4, "rlm_eap_tls: Unable to open DH file - %s", file);
    }
#line 86
    return (-1);
  } else {

  }
  }
  {
#line 89
  __cil_tmp11 = (void *)0;
#line 89
  __cil_tmp12 = (DH **)__cil_tmp11;
#line 89
  __cil_tmp13 = (void *)0;
#line 89
  __cil_tmp14 = (pem_password_cb *)__cil_tmp13;
#line 89
  __cil_tmp15 = (void *)0;
#line 89
  dh = PEM_read_bio_DHparams(bio, __cil_tmp12, __cil_tmp14, __cil_tmp15);
#line 90
  BIO_free(bio);
#line 91
  __cil_tmp16 = (char *)dh;
#line 91
  __cil_tmp17 = (void *)__cil_tmp16;
#line 91
  tmp = SSL_CTX_ctrl(ctx, 3, 0L, __cil_tmp17);
  }
#line 91
  if (tmp < 0L) {
    {
#line 92
    radlog(4, "rlm_eap_tls: Unable to set DH parameters");
#line 93
    DH_free(dh);
    }
#line 94
    return (-1);
  } else {

  }
  {
#line 97
  DH_free(dh);
  }
#line 98
  return (0);
}
}
#line 104 "rlm_eap_tls.c"
static int generate_eph_rsa_key(SSL_CTX *ctx ) 
{ RSA *rsa ;
  long tmp ;
  void *__cil_tmp4 ;
  void (*__cil_tmp5)(int  , int  , void * ) ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 108
  __cil_tmp4 = (void *)0;
#line 108
  __cil_tmp5 = (void (*)(int  , int  , void * ))__cil_tmp4;
#line 108
  __cil_tmp6 = (void *)0;
#line 108
  rsa = RSA_generate_key(512, 65537UL, __cil_tmp5, __cil_tmp6);
#line 110
  __cil_tmp7 = (char *)rsa;
#line 110
  __cil_tmp8 = (void *)__cil_tmp7;
#line 110
  tmp = SSL_CTX_ctrl(ctx, 2, 0L, __cil_tmp8);
  }
#line 110
  if (tmp) {

  } else {
    {
#line 111
    radlog(4, "rlm_eap_tls: Couldn\'t set RSA key");
    }
#line 112
    return (-1);
  }
  {
#line 115
  RSA_free(rsa);
  }
#line 116
  return (0);
}
}
#line 145 "rlm_eap_tls.c"
static int cbtls_verify(int ok , X509_STORE_CTX *ctx ) 
{ char subject[1024] ;
  char issuer[1024] ;
  char common_name[1024] ;
  char cn_str[1024] ;
  EAP_HANDLER *handler ;
  X509 *client_cert ;
  SSL *ssl ;
  int err ;
  int depth ;
  EAP_TLS_CONF *conf ;
  int my_ok ;
  char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  X509_NAME *tmp___4 ;
  X509_NAME *tmp___5 ;
  X509_NAME *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp25 ;
  long __cil_tmp26 ;
  SSL const   *__cil_tmp27 ;
  SSL const   *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  char *__cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  X509 *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  char *__cil_tmp44 ;
  int __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  char *__cil_tmp54 ;
  int __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  char *__cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  char *__cil_tmp68 ;
  char const   *__cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  char *__cil_tmp72 ;
  char const   *__cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  char *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  char *__cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  char *__cil_tmp84 ;
  int __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  char *__cil_tmp88 ;
  char const   *__cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  REQUEST *__cil_tmp92 ;
  void *__cil_tmp93 ;
  int (*__cil_tmp94)(char *out , int outlen , char const   *in ) ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  char *__cil_tmp97 ;
  unsigned long __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  char *__cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  char *__cil_tmp103 ;
  char const   *__cil_tmp104 ;
  unsigned long __cil_tmp105 ;
  unsigned long __cil_tmp106 ;
  char *__cil_tmp107 ;
  char const   *__cil_tmp108 ;
  unsigned long __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  char *__cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  char *__cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  char *__cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  char *__cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  char *__cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  char *__cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  char *__cil_tmp129 ;

  {
  {
#line 151
  __cil_tmp25 = (void *)0;
#line 151
  handler = (EAP_HANDLER *)__cil_tmp25;
#line 156
  my_ok = ok;
#line 158
  client_cert = X509_STORE_CTX_get_current_cert(ctx);
#line 159
  err = X509_STORE_CTX_get_error(ctx);
#line 160
  depth = X509_STORE_CTX_get_error_depth(ctx);
  }
#line 162
  if (! my_ok) {
    {
#line 163
    __cil_tmp26 = (long )err;
#line 163
    tmp = X509_verify_cert_error_string(__cil_tmp26);
#line 163
    radlog(4, "--> verify error:num=%d:%s\n", err, tmp);
    }
#line 165
    return (my_ok);
  } else {

  }
  {
#line 172
  tmp___0 = SSL_get_ex_data_X509_STORE_CTX_idx();
#line 172
  tmp___1 = X509_STORE_CTX_get_ex_data(ctx, tmp___0);
#line 172
  ssl = (SSL *)tmp___1;
#line 173
  __cil_tmp27 = (SSL const   *)ssl;
#line 173
  tmp___2 = SSL_get_ex_data(__cil_tmp27, 0);
#line 173
  handler = (EAP_HANDLER *)tmp___2;
#line 174
  __cil_tmp28 = (SSL const   *)ssl;
#line 174
  tmp___3 = SSL_get_ex_data(__cil_tmp28, 1);
#line 174
  conf = (EAP_TLS_CONF *)tmp___3;
#line 179
  __cil_tmp29 = 0 * 1UL;
#line 179
  __cil_tmp30 = (unsigned long )(issuer) + __cil_tmp29;
#line 179
  *((char *)__cil_tmp30) = (char )'\000';
#line 179
  __cil_tmp31 = 0 * 1UL;
#line 179
  __cil_tmp32 = (unsigned long )(subject) + __cil_tmp31;
#line 179
  __cil_tmp33 = 0 * 1UL;
#line 179
  __cil_tmp34 = (unsigned long )(issuer) + __cil_tmp33;
#line 179
  *((char *)__cil_tmp32) = *((char *)__cil_tmp34);
#line 180
  tmp___4 = X509_get_subject_name(client_cert);
#line 180
  __cil_tmp35 = 0 * 1UL;
#line 180
  __cil_tmp36 = (unsigned long )(subject) + __cil_tmp35;
#line 180
  __cil_tmp37 = (char *)__cil_tmp36;
#line 180
  __cil_tmp38 = (int )1024UL;
#line 180
  X509_NAME_oneline(tmp___4, __cil_tmp37, __cil_tmp38);
#line 182
  __cil_tmp39 = (unsigned long )ctx;
#line 182
  __cil_tmp40 = __cil_tmp39 + 176;
#line 182
  __cil_tmp41 = *((X509 **)__cil_tmp40);
#line 182
  tmp___5 = X509_get_issuer_name(__cil_tmp41);
#line 182
  __cil_tmp42 = 0 * 1UL;
#line 182
  __cil_tmp43 = (unsigned long )(issuer) + __cil_tmp42;
#line 182
  __cil_tmp44 = (char *)__cil_tmp43;
#line 182
  __cil_tmp45 = (int )1024UL;
#line 182
  X509_NAME_oneline(tmp___5, __cil_tmp44, __cil_tmp45);
#line 185
  __cil_tmp46 = 1024UL - 1UL;
#line 185
  __cil_tmp47 = __cil_tmp46 * 1UL;
#line 185
  __cil_tmp48 = (unsigned long )(subject) + __cil_tmp47;
#line 185
  *((char *)__cil_tmp48) = (char )'\000';
#line 186
  __cil_tmp49 = 1024UL - 1UL;
#line 186
  __cil_tmp50 = __cil_tmp49 * 1UL;
#line 186
  __cil_tmp51 = (unsigned long )(issuer) + __cil_tmp50;
#line 186
  *((char *)__cil_tmp51) = (char )'\000';
#line 191
  tmp___6 = X509_get_subject_name(client_cert);
#line 191
  __cil_tmp52 = 0 * 1UL;
#line 191
  __cil_tmp53 = (unsigned long )(common_name) + __cil_tmp52;
#line 191
  __cil_tmp54 = (char *)__cil_tmp53;
#line 191
  __cil_tmp55 = (int )1024UL;
#line 191
  X509_NAME_get_text_by_NID(tmp___6, 13, __cil_tmp54, __cil_tmp55);
#line 193
  __cil_tmp56 = 1024UL - 1UL;
#line 193
  __cil_tmp57 = __cil_tmp56 * 1UL;
#line 193
  __cil_tmp58 = (unsigned long )(common_name) + __cil_tmp57;
#line 193
  *((char *)__cil_tmp58) = (char )'\000';
  }
  {
#line 195
  __cil_tmp59 = (unsigned long )ctx;
#line 195
  __cil_tmp60 = __cil_tmp59 + 168;
#line 197
  if (*((int *)__cil_tmp60) == 2) {
    goto switch_0_2;
  } else {
#line 200
    if (*((int *)__cil_tmp60) == 9) {
      goto switch_0_9;
    } else {
#line 201
      if (*((int *)__cil_tmp60) == 13) {
        goto switch_0_9;
      } else {
#line 207
        if (*((int *)__cil_tmp60) == 10) {
          goto switch_0_10;
        } else {
#line 208
          if (*((int *)__cil_tmp60) == 14) {
            goto switch_0_10;
          } else {
#line 195
            if (0) {
              switch_0_2: /* CIL Label */ 
              {
#line 198
              __cil_tmp61 = 0 * 1UL;
#line 198
              __cil_tmp62 = (unsigned long )(issuer) + __cil_tmp61;
#line 198
              __cil_tmp63 = (char *)__cil_tmp62;
#line 198
              radlog(4, "issuer= %s\n", __cil_tmp63);
              }
              goto switch_0_break;
              switch_0_9: /* CIL Label */ 
              switch_0_13: /* CIL Label */ 
              {
#line 202
              radlog(4, "notBefore=");
              }
              goto switch_0_break;
              switch_0_10: /* CIL Label */ 
              switch_0_14: /* CIL Label */ 
              {
#line 209
              radlog(4, "notAfter=");
              }
              goto switch_0_break;
            } else {
              switch_0_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  }
#line 220
  if (depth == 0) {
    {
#line 226
    __cil_tmp64 = (unsigned long )conf;
#line 226
    __cil_tmp65 = __cil_tmp64 + 120;
#line 226
    if (*((char **)__cil_tmp65)) {
      {
#line 226
      __cil_tmp66 = 0 * 1UL;
#line 226
      __cil_tmp67 = (unsigned long )(issuer) + __cil_tmp66;
#line 226
      __cil_tmp68 = (char *)__cil_tmp67;
#line 226
      __cil_tmp69 = (char const   *)__cil_tmp68;
#line 226
      __cil_tmp70 = (unsigned long )conf;
#line 226
      __cil_tmp71 = __cil_tmp70 + 120;
#line 226
      __cil_tmp72 = *((char **)__cil_tmp71);
#line 226
      __cil_tmp73 = (char const   *)__cil_tmp72;
#line 226
      tmp___7 = strcmp(__cil_tmp69, __cil_tmp73);
      }
#line 226
      if (tmp___7 != 0) {
        {
#line 228
        __cil_tmp74 = 0 * 1UL;
#line 228
        __cil_tmp75 = (unsigned long )(issuer) + __cil_tmp74;
#line 228
        __cil_tmp76 = (char *)__cil_tmp75;
#line 228
        __cil_tmp77 = (unsigned long )conf;
#line 228
        __cil_tmp78 = __cil_tmp77 + 120;
#line 228
        __cil_tmp79 = *((char **)__cil_tmp78);
#line 228
        radlog(2, "rlm_eap_tls: Certificate issuer (%s) does not match specified value (%s)!",
               __cil_tmp76, __cil_tmp79);
#line 229
        my_ok = 0;
        }
      } else {

      }
    } else {

    }
    }
#line 237
    if (my_ok) {
      {
#line 237
      __cil_tmp80 = (unsigned long )conf;
#line 237
      __cil_tmp81 = __cil_tmp80 + 104;
#line 237
      if (*((char **)__cil_tmp81)) {
        {
#line 238
        __cil_tmp82 = 0 * 1UL;
#line 238
        __cil_tmp83 = (unsigned long )(cn_str) + __cil_tmp82;
#line 238
        __cil_tmp84 = (char *)__cil_tmp83;
#line 238
        __cil_tmp85 = (int )1024UL;
#line 238
        __cil_tmp86 = (unsigned long )conf;
#line 238
        __cil_tmp87 = __cil_tmp86 + 104;
#line 238
        __cil_tmp88 = *((char **)__cil_tmp87);
#line 238
        __cil_tmp89 = (char const   *)__cil_tmp88;
#line 238
        __cil_tmp90 = (unsigned long )handler;
#line 238
        __cil_tmp91 = __cil_tmp90 + 56;
#line 238
        __cil_tmp92 = *((REQUEST **)__cil_tmp91);
#line 238
        __cil_tmp93 = (void *)0;
#line 238
        __cil_tmp94 = (int (*)(char *out , int outlen , char const   *in ))__cil_tmp93;
#line 238
        tmp___9 = radius_xlat(__cil_tmp84, __cil_tmp85, __cil_tmp89, __cil_tmp92,
                              __cil_tmp94);
        }
#line 238
        if (tmp___9) {
#line 244
          if (debug_flag > 1) {
            {
#line 244
            __cil_tmp95 = 0 * 1UL;
#line 244
            __cil_tmp96 = (unsigned long )(common_name) + __cil_tmp95;
#line 244
            __cil_tmp97 = (char *)__cil_tmp96;
#line 244
            __cil_tmp98 = 0 * 1UL;
#line 244
            __cil_tmp99 = (unsigned long )(cn_str) + __cil_tmp98;
#line 244
            __cil_tmp100 = (char *)__cil_tmp99;
#line 244
            log_debug("    rlm_eap_tls: checking certificate CN (%s) with xlat\'ed value (%s)",
                      __cil_tmp97, __cil_tmp100);
            }
          } else {

          }
          {
#line 245
          __cil_tmp101 = 0 * 1UL;
#line 245
          __cil_tmp102 = (unsigned long )(cn_str) + __cil_tmp101;
#line 245
          __cil_tmp103 = (char *)__cil_tmp102;
#line 245
          __cil_tmp104 = (char const   *)__cil_tmp103;
#line 245
          __cil_tmp105 = 0 * 1UL;
#line 245
          __cil_tmp106 = (unsigned long )(common_name) + __cil_tmp105;
#line 245
          __cil_tmp107 = (char *)__cil_tmp106;
#line 245
          __cil_tmp108 = (char const   *)__cil_tmp107;
#line 245
          tmp___8 = strcmp(__cil_tmp104, __cil_tmp108);
          }
#line 245
          if (tmp___8 != 0) {
            {
#line 246
            __cil_tmp109 = 0 * 1UL;
#line 246
            __cil_tmp110 = (unsigned long )(common_name) + __cil_tmp109;
#line 246
            __cil_tmp111 = (char *)__cil_tmp110;
#line 246
            __cil_tmp112 = 0 * 1UL;
#line 246
            __cil_tmp113 = (unsigned long )(cn_str) + __cil_tmp112;
#line 246
            __cil_tmp114 = (char *)__cil_tmp113;
#line 246
            radlog(2, "rlm_eap_tls: Certificate CN (%s) does not match specified value (%s)!",
                   __cil_tmp111, __cil_tmp114);
#line 247
            my_ok = 0;
            }
          } else {

          }
        } else {
          {
#line 239
          __cil_tmp115 = (unsigned long )conf;
#line 239
          __cil_tmp116 = __cil_tmp115 + 104;
#line 239
          __cil_tmp117 = *((char **)__cil_tmp116);
#line 239
          radlog(4, "rlm_eap_tls (%s): xlat failed.", __cil_tmp117);
#line 242
          my_ok = 0;
          }
        }
      } else {

      }
      }
    } else {

    }
  } else {

  }
#line 253
  if (debug_flag > 0) {
    {
#line 254
    radlog(3, "chain-depth=%d, ", depth);
#line 255
    radlog(3, "error=%d", err);
#line 257
    __cil_tmp118 = (unsigned long )handler;
#line 257
    __cil_tmp119 = __cil_tmp118 + 64;
#line 257
    __cil_tmp120 = *((char **)__cil_tmp119);
#line 257
    radlog(3, "--> User-Name = %s", __cil_tmp120);
#line 258
    __cil_tmp121 = 0 * 1UL;
#line 258
    __cil_tmp122 = (unsigned long )(common_name) + __cil_tmp121;
#line 258
    __cil_tmp123 = (char *)__cil_tmp122;
#line 258
    radlog(3, "--> BUF-Name = %s", __cil_tmp123);
#line 259
    __cil_tmp124 = 0 * 1UL;
#line 259
    __cil_tmp125 = (unsigned long )(subject) + __cil_tmp124;
#line 259
    __cil_tmp126 = (char *)__cil_tmp125;
#line 259
    radlog(3, "--> subject = %s", __cil_tmp126);
#line 260
    __cil_tmp127 = 0 * 1UL;
#line 260
    __cil_tmp128 = (unsigned long )(issuer) + __cil_tmp127;
#line 260
    __cil_tmp129 = (char *)__cil_tmp128;
#line 260
    radlog(3, "--> issuer  = %s", __cil_tmp129);
#line 261
    radlog(3, "--> verify return:%d", my_ok);
    }
  } else {

  }
#line 263
  return (my_ok);
}
}
#line 274 "rlm_eap_tls.c"
static SSL_CTX *init_tls_ctx(EAP_TLS_CONF *conf ) 
{ SSL_METHOD *meth ;
  SSL_CTX *ctx ;
  X509_STORE *certstore ;
  int verify_mode ;
  int ctx_options ;
  int type ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  STACK *tmp___8 ;
  unsigned long tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned long tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  char *__cil_tmp30 ;
  void *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  char *__cil_tmp34 ;
  char const   *__cil_tmp35 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  void *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  char *__cil_tmp41 ;
  char const   *__cil_tmp42 ;
  void *__cil_tmp43 ;
  char *__cil_tmp44 ;
  void *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  char *__cil_tmp48 ;
  char const   *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  char *__cil_tmp52 ;
  char const   *__cil_tmp53 ;
  void *__cil_tmp54 ;
  char *__cil_tmp55 ;
  void *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  char *__cil_tmp59 ;
  char const   *__cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  char *__cil_tmp63 ;
  char const   *__cil_tmp64 ;
  void *__cil_tmp65 ;
  char *__cil_tmp66 ;
  void *__cil_tmp67 ;
  SSL_CTX const   *__cil_tmp68 ;
  void *__cil_tmp69 ;
  long __cil_tmp70 ;
  long __cil_tmp71 ;
  long __cil_tmp72 ;
  long __cil_tmp73 ;
  long __cil_tmp74 ;
  long __cil_tmp75 ;
  long __cil_tmp76 ;
  void *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  SSL_CTX const   *__cil_tmp80 ;
  void *__cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  void *__cil_tmp84 ;
  char *__cil_tmp85 ;
  void *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  int __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  char *__cil_tmp94 ;
  char const   *__cil_tmp95 ;
  void *__cil_tmp96 ;
  char *__cil_tmp97 ;
  void *__cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  char *__cil_tmp103 ;
  char const   *__cil_tmp104 ;
  void *__cil_tmp105 ;

  {
  {
#line 279
  verify_mode = 0;
#line 280
  ctx_options = 0;
#line 287
  SSL_library_init();
#line 288
  SSL_load_error_strings();
#line 290
  meth = TLSv1_method();
#line 291
  ctx = SSL_CTX_new(meth);
  }
  {
#line 296
  __cil_tmp28 = (unsigned long )conf;
#line 296
  __cil_tmp29 = __cil_tmp28 + 84;
#line 296
  if (*((int *)__cil_tmp29)) {
#line 297
    type = 1;
  } else {
#line 299
    type = 2;
  }
  }
#line 305
  if (*((char **)conf)) {
    {
#line 306
    __cil_tmp30 = *((char **)conf);
#line 306
    __cil_tmp31 = (void *)__cil_tmp30;
#line 306
    SSL_CTX_set_default_passwd_cb_userdata(ctx, __cil_tmp31);
#line 307
    SSL_CTX_set_default_passwd_cb(ctx, & cbtls_password);
    }
  } else {

  }
#line 319
  if (type == 1) {
    {
#line 320
    radlog(3, "rlm_eap_tls: Loading the certificate file as a chain");
#line 321
    __cil_tmp32 = (unsigned long )conf;
#line 321
    __cil_tmp33 = __cil_tmp32 + 16;
#line 321
    __cil_tmp34 = *((char **)__cil_tmp33);
#line 321
    __cil_tmp35 = (char const   *)__cil_tmp34;
#line 321
    tmp___1 = SSL_CTX_use_certificate_chain_file(ctx, __cil_tmp35);
    }
#line 321
    if (tmp___1) {

    } else {
      {
#line 322
      tmp = ERR_get_error();
#line 322
      __cil_tmp36 = (void *)0;
#line 322
      __cil_tmp37 = (char *)__cil_tmp36;
#line 322
      tmp___0 = ERR_error_string(tmp, __cil_tmp37);
#line 322
      radlog(4, "rlm_eap: SSL error %s", tmp___0);
#line 323
      radlog(4, "rlm_eap_tls: Error reading certificate file");
      }
      {
#line 324
      __cil_tmp38 = (void *)0;
#line 324
      return ((SSL_CTX *)__cil_tmp38);
      }
    }
  } else {
    {
#line 327
    __cil_tmp39 = (unsigned long )conf;
#line 327
    __cil_tmp40 = __cil_tmp39 + 16;
#line 327
    __cil_tmp41 = *((char **)__cil_tmp40);
#line 327
    __cil_tmp42 = (char const   *)__cil_tmp41;
#line 327
    tmp___4 = SSL_CTX_use_certificate_file(ctx, __cil_tmp42, type);
    }
#line 327
    if (tmp___4) {

    } else {
      {
#line 328
      tmp___2 = ERR_get_error();
#line 328
      __cil_tmp43 = (void *)0;
#line 328
      __cil_tmp44 = (char *)__cil_tmp43;
#line 328
      tmp___3 = ERR_error_string(tmp___2, __cil_tmp44);
#line 328
      radlog(4, "rlm_eap: SSL error %s", tmp___3);
#line 329
      radlog(4, "rlm_eap_tls: Error reading certificate file");
      }
      {
#line 330
      __cil_tmp45 = (void *)0;
#line 330
      return ((SSL_CTX *)__cil_tmp45);
      }
    }
  }
  {
#line 335
  __cil_tmp46 = (unsigned long )conf;
#line 335
  __cil_tmp47 = __cil_tmp46 + 40;
#line 335
  __cil_tmp48 = *((char **)__cil_tmp47);
#line 335
  __cil_tmp49 = (char const   *)__cil_tmp48;
#line 335
  __cil_tmp50 = (unsigned long )conf;
#line 335
  __cil_tmp51 = __cil_tmp50 + 32;
#line 335
  __cil_tmp52 = *((char **)__cil_tmp51);
#line 335
  __cil_tmp53 = (char const   *)__cil_tmp52;
#line 335
  tmp___7 = SSL_CTX_load_verify_locations(ctx, __cil_tmp49, __cil_tmp53);
  }
#line 335
  if (tmp___7) {

  } else {
    {
#line 336
    tmp___5 = ERR_get_error();
#line 336
    __cil_tmp54 = (void *)0;
#line 336
    __cil_tmp55 = (char *)__cil_tmp54;
#line 336
    tmp___6 = ERR_error_string(tmp___5, __cil_tmp55);
#line 336
    radlog(4, "rlm_eap: SSL error %s", tmp___6);
#line 337
    radlog(4, "rlm_eap_tls: Error reading Trusted root CA list");
    }
    {
#line 338
    __cil_tmp56 = (void *)0;
#line 338
    return ((SSL_CTX *)__cil_tmp56);
    }
  }
  {
#line 340
  __cil_tmp57 = (unsigned long )conf;
#line 340
  __cil_tmp58 = __cil_tmp57 + 40;
#line 340
  __cil_tmp59 = *((char **)__cil_tmp58);
#line 340
  __cil_tmp60 = (char const   *)__cil_tmp59;
#line 340
  tmp___8 = SSL_load_client_CA_file(__cil_tmp60);
#line 340
  SSL_CTX_set_client_CA_list(ctx, tmp___8);
#line 342
  __cil_tmp61 = (unsigned long )conf;
#line 342
  __cil_tmp62 = __cil_tmp61 + 8;
#line 342
  __cil_tmp63 = *((char **)__cil_tmp62);
#line 342
  __cil_tmp64 = (char const   *)__cil_tmp63;
#line 342
  tmp___11 = SSL_CTX_use_PrivateKey_file(ctx, __cil_tmp64, type);
  }
#line 342
  if (tmp___11) {

  } else {
    {
#line 343
    tmp___9 = ERR_get_error();
#line 343
    __cil_tmp65 = (void *)0;
#line 343
    __cil_tmp66 = (char *)__cil_tmp65;
#line 343
    tmp___10 = ERR_error_string(tmp___9, __cil_tmp66);
#line 343
    radlog(4, "rlm_eap: SSL error %s", tmp___10);
#line 344
    radlog(4, "rlm_eap_tls: Error reading private key file");
    }
    {
#line 345
    __cil_tmp67 = (void *)0;
#line 345
    return ((SSL_CTX *)__cil_tmp67);
    }
  }
  {
#line 351
  __cil_tmp68 = (SSL_CTX const   *)ctx;
#line 351
  tmp___12 = SSL_CTX_check_private_key(__cil_tmp68);
  }
#line 351
  if (tmp___12) {

  } else {
    {
#line 352
    radlog(4, "rlm_eap_tls: Private key does not match the certificate public key");
    }
    {
#line 353
    __cil_tmp69 = (void *)0;
#line 353
    return ((SSL_CTX *)__cil_tmp69);
    }
  }
  {
#line 359
  __cil_tmp70 = (long )ctx_options;
#line 359
  __cil_tmp71 = __cil_tmp70 | 16777216L;
#line 359
  ctx_options = (int )__cil_tmp71;
#line 360
  __cil_tmp72 = (long )ctx_options;
#line 360
  __cil_tmp73 = __cil_tmp72 | 33554432L;
#line 360
  ctx_options = (int )__cil_tmp73;
#line 371
  __cil_tmp74 = (long )ctx_options;
#line 371
  __cil_tmp75 = __cil_tmp74 | 1048576L;
#line 371
  ctx_options = (int )__cil_tmp75;
#line 372
  __cil_tmp76 = (long )ctx_options;
#line 372
  __cil_tmp77 = (void *)0;
#line 372
  SSL_CTX_ctrl(ctx, 32, __cil_tmp76, __cil_tmp77);
#line 389
  SSL_CTX_set_info_callback(ctx, & cbtls_info);
  }
  {
#line 395
  __cil_tmp78 = (unsigned long )conf;
#line 395
  __cil_tmp79 = __cil_tmp78 + 96;
#line 395
  if (*((int *)__cil_tmp79)) {
    {
#line 396
    __cil_tmp80 = (SSL_CTX const   *)ctx;
#line 396
    certstore = SSL_CTX_get_cert_store(__cil_tmp80);
    }
    {
#line 397
    __cil_tmp81 = (void *)0;
#line 397
    __cil_tmp82 = (unsigned long )__cil_tmp81;
#line 397
    __cil_tmp83 = (unsigned long )certstore;
#line 397
    if (__cil_tmp83 == __cil_tmp82) {
      {
#line 398
      tmp___13 = ERR_get_error();
#line 398
      __cil_tmp84 = (void *)0;
#line 398
      __cil_tmp85 = (char *)__cil_tmp84;
#line 398
      tmp___14 = ERR_error_string(tmp___13, __cil_tmp85);
#line 398
      radlog(4, "rlm_eap: SSL error %s", tmp___14);
#line 399
      radlog(4, "rlm_eap_tls: Error reading Certificate Store");
      }
      {
#line 400
      __cil_tmp86 = (void *)0;
#line 400
      return ((SSL_CTX *)__cil_tmp86);
      }
    } else {

    }
    }
    {
#line 402
    X509_STORE_set_flags(certstore, 4UL);
    }
  } else {

  }
  }
  {
#line 410
  verify_mode = verify_mode | 1;
#line 411
  verify_mode = verify_mode | 2;
#line 412
  verify_mode = verify_mode | 4;
#line 413
  SSL_CTX_set_verify(ctx, verify_mode, & cbtls_verify);
  }
  {
#line 415
  __cil_tmp87 = (unsigned long )conf;
#line 415
  __cil_tmp88 = __cil_tmp87 + 80;
#line 415
  if (*((int *)__cil_tmp88)) {
    {
#line 416
    __cil_tmp89 = (unsigned long )conf;
#line 416
    __cil_tmp90 = __cil_tmp89 + 80;
#line 416
    __cil_tmp91 = *((int *)__cil_tmp90);
#line 416
    SSL_CTX_set_verify_depth(ctx, __cil_tmp91);
    }
  } else {

  }
  }
  {
#line 420
  __cil_tmp92 = (unsigned long )conf;
#line 420
  __cil_tmp93 = __cil_tmp92 + 24;
#line 420
  __cil_tmp94 = *((char **)__cil_tmp93);
#line 420
  __cil_tmp95 = (char const   *)__cil_tmp94;
#line 420
  tmp___17 = RAND_load_file(__cil_tmp95, 1048576L);
  }
#line 420
  if (tmp___17) {

  } else {
    {
#line 421
    tmp___15 = ERR_get_error();
#line 421
    __cil_tmp96 = (void *)0;
#line 421
    __cil_tmp97 = (char *)__cil_tmp96;
#line 421
    tmp___16 = ERR_error_string(tmp___15, __cil_tmp97);
#line 421
    radlog(4, "rlm_eap: SSL error %s", tmp___16);
#line 422
    radlog(4, "rlm_eap_tls: Error loading randomness");
    }
    {
#line 423
    __cil_tmp98 = (void *)0;
#line 423
    return ((SSL_CTX *)__cil_tmp98);
    }
  }
  {
#line 429
  __cil_tmp99 = (unsigned long )conf;
#line 429
  __cil_tmp100 = __cil_tmp99 + 112;
#line 429
  if (*((char **)__cil_tmp100)) {
    {
#line 430
    __cil_tmp101 = (unsigned long )conf;
#line 430
    __cil_tmp102 = __cil_tmp101 + 112;
#line 430
    __cil_tmp103 = *((char **)__cil_tmp102);
#line 430
    __cil_tmp104 = (char const   *)__cil_tmp103;
#line 430
    tmp___18 = SSL_CTX_set_cipher_list(ctx, __cil_tmp104);
    }
#line 430
    if (tmp___18) {

    } else {
      {
#line 431
      radlog(4, "rlm_eap_tls: Error setting cipher list");
      }
      {
#line 432
      __cil_tmp105 = (void *)0;
#line 432
      return ((SSL_CTX *)__cil_tmp105);
      }
    }
  } else {

  }
  }
#line 436
  return (ctx);
}
}
#line 443 "rlm_eap_tls.c"
static int eaptls_detach(void *arg ) 
{ EAP_TLS_CONF *conf ;
  eap_tls_t *inst ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  void *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  char *__cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  char *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  char *__cil_tmp24 ;
  void *__cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  char *__cil_tmp28 ;
  void *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  char *__cil_tmp32 ;
  void *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  char *__cil_tmp36 ;
  void *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  char *__cil_tmp40 ;
  void *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  char *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  EAP_TLS_CONF *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  SSL_CTX *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;

  {
#line 448
  inst = (eap_tls_t *)arg;
#line 449
  conf = *((EAP_TLS_CONF **)inst);
#line 451
  if (conf) {
    {
#line 452
    __cil_tmp4 = (unsigned long )conf;
#line 452
    __cil_tmp5 = __cil_tmp4 + 48;
#line 452
    __cil_tmp6 = *((char **)__cil_tmp5);
#line 452
    __cil_tmp7 = (void *)__cil_tmp6;
#line 452
    free(__cil_tmp7);
#line 453
    __cil_tmp8 = (unsigned long )conf;
#line 453
    __cil_tmp9 = __cil_tmp8 + 32;
#line 453
    __cil_tmp10 = *((char **)__cil_tmp9);
#line 453
    __cil_tmp11 = (void *)__cil_tmp10;
#line 453
    free(__cil_tmp11);
#line 454
    __cil_tmp12 = (unsigned long )conf;
#line 454
    __cil_tmp13 = __cil_tmp12 + 16;
#line 454
    __cil_tmp14 = *((char **)__cil_tmp13);
#line 454
    __cil_tmp15 = (void *)__cil_tmp14;
#line 454
    free(__cil_tmp15);
#line 455
    __cil_tmp16 = (unsigned long )conf;
#line 455
    __cil_tmp17 = __cil_tmp16 + 8;
#line 455
    __cil_tmp18 = *((char **)__cil_tmp17);
#line 455
    __cil_tmp19 = (void *)__cil_tmp18;
#line 455
    free(__cil_tmp19);
#line 456
    __cil_tmp20 = *((char **)conf);
#line 456
    __cil_tmp21 = (void *)__cil_tmp20;
#line 456
    free(__cil_tmp21);
#line 457
    __cil_tmp22 = (unsigned long )conf;
#line 457
    __cil_tmp23 = __cil_tmp22 + 40;
#line 457
    __cil_tmp24 = *((char **)__cil_tmp23);
#line 457
    __cil_tmp25 = (void *)__cil_tmp24;
#line 457
    free(__cil_tmp25);
#line 458
    __cil_tmp26 = (unsigned long )conf;
#line 458
    __cil_tmp27 = __cil_tmp26 + 24;
#line 458
    __cil_tmp28 = *((char **)__cil_tmp27);
#line 458
    __cil_tmp29 = (void *)__cil_tmp28;
#line 458
    free(__cil_tmp29);
#line 460
    __cil_tmp30 = (unsigned long )conf;
#line 460
    __cil_tmp31 = __cil_tmp30 + 104;
#line 460
    __cil_tmp32 = *((char **)__cil_tmp31);
#line 460
    __cil_tmp33 = (void *)__cil_tmp32;
#line 460
    free(__cil_tmp33);
#line 461
    __cil_tmp34 = (unsigned long )conf;
#line 461
    __cil_tmp35 = __cil_tmp34 + 104;
#line 461
    __cil_tmp36 = *((char **)__cil_tmp35);
#line 461
    __cil_tmp37 = (void *)__cil_tmp36;
#line 461
    free(__cil_tmp37);
#line 462
    __cil_tmp38 = (unsigned long )conf;
#line 462
    __cil_tmp39 = __cil_tmp38 + 112;
#line 462
    __cil_tmp40 = *((char **)__cil_tmp39);
#line 462
    __cil_tmp41 = (void *)__cil_tmp40;
#line 462
    free(__cil_tmp41);
#line 463
    __cil_tmp42 = (unsigned long )conf;
#line 463
    __cil_tmp43 = __cil_tmp42 + 120;
#line 463
    __cil_tmp44 = *((char **)__cil_tmp43);
#line 463
    __cil_tmp45 = (void *)__cil_tmp44;
#line 463
    free(__cil_tmp45);
#line 465
    __cil_tmp46 = (void *)conf;
#line 465
    memset(__cil_tmp46, 0, 128UL);
#line 466
    __cil_tmp47 = *((EAP_TLS_CONF **)inst);
#line 466
    __cil_tmp48 = (void *)__cil_tmp47;
#line 466
    free(__cil_tmp48);
#line 467
    __cil_tmp49 = (void *)0;
#line 467
    *((EAP_TLS_CONF **)inst) = (EAP_TLS_CONF *)__cil_tmp49;
    }
  } else {

  }
  {
#line 470
  __cil_tmp50 = (unsigned long )inst;
#line 470
  __cil_tmp51 = __cil_tmp50 + 8;
#line 470
  if (*((SSL_CTX **)__cil_tmp51)) {
    {
#line 470
    __cil_tmp52 = (unsigned long )inst;
#line 470
    __cil_tmp53 = __cil_tmp52 + 8;
#line 470
    __cil_tmp54 = *((SSL_CTX **)__cil_tmp53);
#line 470
    SSL_CTX_free(__cil_tmp54);
    }
  } else {

  }
  }
  {
#line 471
  __cil_tmp55 = (unsigned long )inst;
#line 471
  __cil_tmp56 = __cil_tmp55 + 8;
#line 471
  __cil_tmp57 = (void *)0;
#line 471
  *((SSL_CTX **)__cil_tmp56) = (SSL_CTX *)__cil_tmp57;
#line 473
  __cil_tmp58 = (void *)inst;
#line 473
  free(__cil_tmp58);
  }
#line 475
  return (0);
}
}
#line 482 "rlm_eap_tls.c"
static int eaptls_attach(CONF_SECTION *cs , void **instance ) 
{ EAP_TLS_CONF *conf ;
  eap_tls_t *inst ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  CONF_PARSER *__cil_tmp18 ;
  CONF_PARSER const   *__cil_tmp19 ;
  int (*__cil_tmp20)(void *arg ) ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  void *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  SSL_CTX *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int (*__cil_tmp30)(void *arg ) ;
  void *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  SSL_CTX *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  char *__cil_tmp37 ;
  int (*__cil_tmp38)(void *arg ) ;
  void *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  SSL_CTX *__cil_tmp42 ;
  int (*__cil_tmp43)(void *arg ) ;
  void *__cil_tmp44 ;

  {
  {
#line 488
  tmp = malloc(16UL);
#line 488
  inst = (eap_tls_t *)tmp;
  }
#line 489
  if (! inst) {
    {
#line 490
    radlog(4, "rlm_eap_tls: out of memory");
    }
#line 491
    return (-1);
  } else {

  }
  {
#line 493
  __cil_tmp10 = (void *)inst;
#line 493
  memset(__cil_tmp10, 0, 16UL);
#line 498
  tmp___0 = malloc(128UL);
#line 498
  conf = (EAP_TLS_CONF *)tmp___0;
  }
  {
#line 499
  __cil_tmp11 = (void *)0;
#line 499
  __cil_tmp12 = (unsigned long )__cil_tmp11;
#line 499
  __cil_tmp13 = (unsigned long )conf;
#line 499
  if (__cil_tmp13 == __cil_tmp12) {
    {
#line 500
    radlog(4, "rlm_eap_tls: out of memory");
    }
#line 501
    return (-1);
  } else {

  }
  }
  {
#line 503
  __cil_tmp14 = (void *)conf;
#line 503
  memset(__cil_tmp14, 0, 128UL);
#line 505
  *((EAP_TLS_CONF **)inst) = conf;
#line 506
  __cil_tmp15 = (void *)conf;
#line 506
  __cil_tmp16 = 0 * 40UL;
#line 506
  __cil_tmp17 = (unsigned long )(module_config) + __cil_tmp16;
#line 506
  __cil_tmp18 = (CONF_PARSER *)__cil_tmp17;
#line 506
  __cil_tmp19 = (CONF_PARSER const   *)__cil_tmp18;
#line 506
  tmp___1 = cf_section_parse(cs, __cil_tmp15, __cil_tmp19);
  }
#line 506
  if (tmp___1 < 0) {
    {
#line 507
    __cil_tmp20 = & eaptls_detach;
#line 507
    __cil_tmp21 = (void *)inst;
#line 507
    (*__cil_tmp20)(__cil_tmp21);
    }
#line 508
    return (-1);
  } else {

  }
  {
#line 515
  __cil_tmp22 = (unsigned long )inst;
#line 515
  __cil_tmp23 = __cil_tmp22 + 8;
#line 515
  *((SSL_CTX **)__cil_tmp23) = init_tls_ctx(conf);
  }
  {
#line 516
  __cil_tmp24 = (void *)0;
#line 516
  __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 516
  __cil_tmp26 = (unsigned long )inst;
#line 516
  __cil_tmp27 = __cil_tmp26 + 8;
#line 516
  __cil_tmp28 = *((SSL_CTX **)__cil_tmp27);
#line 516
  __cil_tmp29 = (unsigned long )__cil_tmp28;
#line 516
  if (__cil_tmp29 == __cil_tmp25) {
    {
#line 517
    __cil_tmp30 = & eaptls_detach;
#line 517
    __cil_tmp31 = (void *)inst;
#line 517
    (*__cil_tmp30)(__cil_tmp31);
    }
#line 518
    return (-1);
  } else {

  }
  }
  {
#line 521
  __cil_tmp32 = (unsigned long )inst;
#line 521
  __cil_tmp33 = __cil_tmp32 + 8;
#line 521
  __cil_tmp34 = *((SSL_CTX **)__cil_tmp33);
#line 521
  __cil_tmp35 = (unsigned long )conf;
#line 521
  __cil_tmp36 = __cil_tmp35 + 48;
#line 521
  __cil_tmp37 = *((char **)__cil_tmp36);
#line 521
  tmp___2 = load_dh_params(__cil_tmp34, __cil_tmp37);
  }
#line 521
  if (tmp___2 < 0) {
    {
#line 522
    __cil_tmp38 = & eaptls_detach;
#line 522
    __cil_tmp39 = (void *)inst;
#line 522
    (*__cil_tmp38)(__cil_tmp39);
    }
#line 523
    return (-1);
  } else {

  }
  {
#line 525
  __cil_tmp40 = (unsigned long )inst;
#line 525
  __cil_tmp41 = __cil_tmp40 + 8;
#line 525
  __cil_tmp42 = *((SSL_CTX **)__cil_tmp41);
#line 525
  tmp___3 = generate_eph_rsa_key(__cil_tmp42);
  }
#line 525
  if (tmp___3 < 0) {
    {
#line 526
    __cil_tmp43 = & eaptls_detach;
#line 526
    __cil_tmp44 = (void *)inst;
#line 526
    (*__cil_tmp43)(__cil_tmp44);
    }
#line 527
    return (-1);
  } else {

  }
#line 530
  *instance = (void *)inst;
#line 532
  return (0);
}
}
#line 555 "rlm_eap_tls.c"
static int eaptls_initiate(void *type_arg , EAP_HANDLER *handler ) 
{ int status ;
  tls_session_t *ssn ;
  eap_tls_t *inst ;
  VALUE_PAIR *vp ;
  int client_cert ;
  int verify_mode ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  REQUEST *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  VALUE_PAIR *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  SSL_CTX *__cil_tmp23 ;
  SSL *__cil_tmp24 ;
  SSL *__cil_tmp25 ;
  void *__cil_tmp26 ;
  SSL *__cil_tmp27 ;
  EAP_TLS_CONF *__cil_tmp28 ;
  void *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  EAP_TLS_CONF *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  EAP_TLS_CONF *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  REQUEST *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  RADIUS_PACKET *__cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  VALUE_PAIR *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned int __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  uint32_t __cil_tmp55 ;
  uint32_t __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  uint32_t __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned int __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  EAP_DS *__cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  int __cil_tmp78 ;
  unsigned long __cil_tmp79 ;
  unsigned long __cil_tmp80 ;

  {
#line 561
  client_cert = 1;
#line 562
  verify_mode = 0;
#line 564
  inst = (eap_tls_t *)type_arg;
  {
#line 572
  __cil_tmp9 = (unsigned long )handler;
#line 572
  __cil_tmp10 = __cil_tmp9 + 40;
#line 572
  __cil_tmp11 = *((unsigned int *)__cil_tmp10);
#line 572
  if (__cil_tmp11 != 13U) {
    {
#line 573
    __cil_tmp12 = (unsigned long )handler;
#line 573
    __cil_tmp13 = __cil_tmp12 + 56;
#line 573
    __cil_tmp14 = *((REQUEST **)__cil_tmp13);
#line 573
    __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 573
    __cil_tmp16 = __cil_tmp15 + 40;
#line 573
    __cil_tmp17 = *((VALUE_PAIR **)__cil_tmp16);
#line 573
    vp = pairfind(__cil_tmp17, 1019);
    }
#line 575
    if (! vp) {
#line 576
      client_cert = 0;
    } else {
#line 578
      __cil_tmp18 = (unsigned long )vp;
#line 578
      __cil_tmp19 = __cil_tmp18 + 52;
#line 578
      __cil_tmp20 = *((uint32_t *)__cil_tmp19);
#line 578
      client_cert = (int )__cil_tmp20;
    }
  } else {

  }
  }
  {
#line 589
  __cil_tmp21 = (unsigned long )inst;
#line 589
  __cil_tmp22 = __cil_tmp21 + 8;
#line 589
  __cil_tmp23 = *((SSL_CTX **)__cil_tmp22);
#line 589
  ssn = eaptls_new_session(__cil_tmp23, client_cert);
  }
#line 590
  if (! ssn) {
#line 591
    return (0);
  } else {

  }
#line 597
  if (client_cert) {
#line 598
    if (debug_flag > 1) {
      {
#line 598
      log_debug(" rlm_eap_tls: Requiring client certificate");
      }
    } else {

    }
#line 599
    verify_mode = 1;
#line 600
    verify_mode = verify_mode | 2;
#line 601
    verify_mode = verify_mode | 4;
  } else {

  }
  {
#line 603
  __cil_tmp24 = *((SSL **)ssn);
#line 603
  SSL_set_verify(__cil_tmp24, verify_mode, & cbtls_verify);
#line 613
  __cil_tmp25 = *((SSL **)ssn);
#line 613
  __cil_tmp26 = (void *)handler;
#line 613
  SSL_set_ex_data(__cil_tmp25, 0, __cil_tmp26);
#line 614
  __cil_tmp27 = *((SSL **)ssn);
#line 614
  __cil_tmp28 = *((EAP_TLS_CONF **)inst);
#line 614
  __cil_tmp29 = (void *)__cil_tmp28;
#line 614
  SSL_set_ex_data(__cil_tmp27, 1, __cil_tmp29);
#line 616
  __cil_tmp30 = (unsigned long )ssn;
#line 616
  __cil_tmp31 = __cil_tmp30 + 65900;
#line 616
  __cil_tmp32 = *((EAP_TLS_CONF **)inst);
#line 616
  __cil_tmp33 = (unsigned long )__cil_tmp32;
#line 616
  __cil_tmp34 = __cil_tmp33 + 88;
#line 616
  *((int *)__cil_tmp31) = *((int *)__cil_tmp34);
#line 630
  __cil_tmp35 = (unsigned long )ssn;
#line 630
  __cil_tmp36 = __cil_tmp35 + 65888;
#line 630
  __cil_tmp37 = *((EAP_TLS_CONF **)inst);
#line 630
  __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 630
  __cil_tmp39 = __cil_tmp38 + 92;
#line 630
  __cil_tmp40 = *((int *)__cil_tmp39);
#line 630
  *((unsigned int *)__cil_tmp36) = (unsigned int )__cil_tmp40;
#line 631
  __cil_tmp41 = (unsigned long )handler;
#line 631
  __cil_tmp42 = __cil_tmp41 + 56;
#line 631
  __cil_tmp43 = *((REQUEST **)__cil_tmp42);
#line 631
  __cil_tmp44 = (unsigned long )__cil_tmp43;
#line 631
  __cil_tmp45 = __cil_tmp44 + 8;
#line 631
  __cil_tmp46 = *((RADIUS_PACKET **)__cil_tmp45);
#line 631
  __cil_tmp47 = (unsigned long )__cil_tmp46;
#line 631
  __cil_tmp48 = __cil_tmp47 + 72;
#line 631
  __cil_tmp49 = *((VALUE_PAIR **)__cil_tmp48);
#line 631
  vp = pairfind(__cil_tmp49, 12);
  }
#line 632
  if (vp) {
    {
#line 632
    __cil_tmp50 = (unsigned long )ssn;
#line 632
    __cil_tmp51 = __cil_tmp50 + 65888;
#line 632
    __cil_tmp52 = *((unsigned int *)__cil_tmp51);
#line 632
    __cil_tmp53 = (unsigned long )vp;
#line 632
    __cil_tmp54 = __cil_tmp53 + 52;
#line 632
    __cil_tmp55 = *((uint32_t *)__cil_tmp54);
#line 632
    __cil_tmp56 = __cil_tmp55 - 14U;
#line 632
    if (__cil_tmp56 < __cil_tmp52) {
#line 645
      __cil_tmp57 = (unsigned long )ssn;
#line 645
      __cil_tmp58 = __cil_tmp57 + 65888;
#line 645
      __cil_tmp59 = (unsigned long )vp;
#line 645
      __cil_tmp60 = __cil_tmp59 + 52;
#line 645
      __cil_tmp61 = *((uint32_t *)__cil_tmp60);
#line 645
      *((unsigned int *)__cil_tmp58) = __cil_tmp61 - 14U;
    } else {

    }
    }
  } else {

  }
#line 648
  __cil_tmp62 = (unsigned long )handler;
#line 648
  __cil_tmp63 = __cil_tmp62 + 88;
#line 648
  *((void **)__cil_tmp63) = (void *)ssn;
#line 649
  __cil_tmp64 = (unsigned long )handler;
#line 649
  __cil_tmp65 = __cil_tmp64 + 96;
#line 649
  *((void (**)(void *opaque ))__cil_tmp65) = & session_free;
#line 651
  if (debug_flag > 1) {
    {
#line 651
    log_debug("  rlm_eap_tls: Initiate");
    }
  } else {

  }
  {
#line 656
  __cil_tmp66 = (unsigned long )handler;
#line 656
  __cil_tmp67 = __cil_tmp66 + 40;
#line 656
  __cil_tmp68 = *((unsigned int *)__cil_tmp67);
#line 656
  if (__cil_tmp68 == 25U) {
#line 666
    __cil_tmp69 = (unsigned long )ssn;
#line 666
    __cil_tmp70 = __cil_tmp69 + 65904;
#line 666
    *((int *)__cil_tmp70) = 0;
#line 673
    __cil_tmp71 = (unsigned long )ssn;
#line 673
    __cil_tmp72 = __cil_tmp71 + 65900;
#line 673
    *((int *)__cil_tmp72) = 0;
  } else {

  }
  }
  {
#line 680
  __cil_tmp73 = (unsigned long )handler;
#line 680
  __cil_tmp74 = __cil_tmp73 + 80;
#line 680
  __cil_tmp75 = *((EAP_DS **)__cil_tmp74);
#line 680
  __cil_tmp76 = (unsigned long )ssn;
#line 680
  __cil_tmp77 = __cil_tmp76 + 65904;
#line 680
  __cil_tmp78 = *((int *)__cil_tmp77);
#line 680
  status = eaptls_start(__cil_tmp75, __cil_tmp78);
  }
#line 681
  if (debug_flag > 1) {
    {
#line 681
    log_debug("  rlm_eap_tls: Start returned %d", status);
    }
  } else {

  }
#line 682
  if (status == 0) {
#line 683
    return (0);
  } else {

  }
#line 688
  __cil_tmp79 = (unsigned long )handler;
#line 688
  __cil_tmp80 = __cil_tmp79 + 108;
#line 688
  *((int *)__cil_tmp80) = 2;
#line 690
  return (1);
}
}
#line 696 "rlm_eap_tls.c"
static int eaptls_authenticate(void *arg  __attribute__((__unused__)) , EAP_HANDLER *handler ) 
{ eaptls_status_t status ;
  tls_session_t *tls_session ;
  unsigned int i ;
  unsigned int data_len ;
  unsigned char buffer[1024] ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned int (*__cil_tmp13)(record_t *buf , void *ptr , unsigned int size ) ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  record_t *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  void *__cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  char const   * __restrict  __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  char const   * __restrict  __cil_tmp25 ;
  char const   * __restrict  __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned char __cil_tmp29 ;
  char const   * __restrict  __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  EAP_DS *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  EAP_DS *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  REQUEST *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  RADIUS_PACKET *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  VALUE_PAIR **__cil_tmp45 ;
  SSL *__cil_tmp46 ;

  {
#line 699
  __cil_tmp8 = (unsigned long )handler;
#line 699
  __cil_tmp9 = __cil_tmp8 + 88;
#line 699
  __cil_tmp10 = *((void **)__cil_tmp9);
#line 699
  tls_session = (tls_session_t *)__cil_tmp10;
#line 701
  if (debug_flag > 1) {
    {
#line 701
    log_debug("  rlm_eap_tls: Authenticate");
    }
  } else {

  }
  {
#line 703
  status = eaptls_process(handler);
  }
#line 704
  if (debug_flag > 1) {
    {
#line 704
    log_debug("  eaptls_process returned %d\n", status);
    }
  } else {

  }
#line 710
  if ((int )status == 3) {
    goto switch_1_3;
  } else {
#line 718
    if ((int )status == 13) {
      goto switch_1_13;
    } else {
#line 725
      if ((int )status == 7) {
        goto switch_1_7;
      } else {
        {
        goto switch_1_default;
#line 705
        if (0) {
          switch_1_3: /* CIL Label */ 
          goto switch_1_break;
          switch_1_13: /* CIL Label */ 
#line 719
          return (1);
          switch_1_7: /* CIL Label */ 
#line 726
          if (debug_flag > 1) {
            {
#line 726
            log_debug("  rlm_eap_tls: Received unexpected tunneled data after successful handshake.");
            }
          } else {

          }
#line 728
          if (debug_flag > 2) {
            {
#line 733
            __cil_tmp11 = (unsigned long )tls_session;
#line 733
            __cil_tmp12 = __cil_tmp11 + 65880;
#line 733
            __cil_tmp13 = *((unsigned int (**)(record_t *buf , void *ptr , unsigned int size ))__cil_tmp12);
#line 733
            __cil_tmp14 = (unsigned long )tls_session;
#line 733
            __cil_tmp15 = __cil_tmp14 + 33080;
#line 733
            __cil_tmp16 = (record_t *)__cil_tmp15;
#line 733
            __cil_tmp17 = 0 * 1UL;
#line 733
            __cil_tmp18 = (unsigned long )(buffer) + __cil_tmp17;
#line 733
            __cil_tmp19 = (unsigned char *)__cil_tmp18;
#line 733
            __cil_tmp20 = (void *)__cil_tmp19;
#line 733
            __cil_tmp21 = (unsigned int )1024UL;
#line 733
            data_len = (*__cil_tmp13)(__cil_tmp16, __cil_tmp20, __cil_tmp21);
#line 735
            log_debug("  Tunneled data (%u bytes)\n", data_len);
#line 736
            i = 0U;
            }
            {
#line 736
            while (1) {
              while_2_continue: /* CIL Label */ ;
#line 736
              if (i < data_len) {

              } else {
                goto while_2_break;
              }
              {
#line 737
              __cil_tmp22 = i & 15U;
#line 737
              if (__cil_tmp22 == 0U) {
                {
#line 737
                __cil_tmp23 = (char const   * __restrict  )"  %x: ";
#line 737
                printf(__cil_tmp23, i);
                }
              } else {

              }
              }
              {
#line 738
              __cil_tmp24 = i & 15U;
#line 738
              if (__cil_tmp24 == 15U) {
                {
#line 738
                __cil_tmp25 = (char const   * __restrict  )"\n";
#line 738
                printf(__cil_tmp25);
                }
              } else {

              }
              }
              {
#line 740
              __cil_tmp26 = (char const   * __restrict  )"%02x ";
#line 740
              __cil_tmp27 = i * 1UL;
#line 740
              __cil_tmp28 = (unsigned long )(buffer) + __cil_tmp27;
#line 740
              __cil_tmp29 = *((unsigned char *)__cil_tmp28);
#line 740
              printf(__cil_tmp26, __cil_tmp29);
#line 736
              i = i + 1U;
              }
            }
            while_2_break: /* CIL Label */ ;
            }
            {
#line 742
            __cil_tmp30 = (char const   * __restrict  )"\n";
#line 742
            printf(__cil_tmp30);
            }
          } else {

          }
          {
#line 746
          __cil_tmp31 = (unsigned long )handler;
#line 746
          __cil_tmp32 = __cil_tmp31 + 80;
#line 746
          __cil_tmp33 = *((EAP_DS **)__cil_tmp32);
#line 746
          eaptls_fail(__cil_tmp33, 0);
          }
#line 747
          return (0);
          goto switch_1_break;
          switch_1_default: /* CIL Label */ ;
#line 754
          return (0);
        } else {
          switch_1_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  {
#line 760
  __cil_tmp34 = (unsigned long )handler;
#line 760
  __cil_tmp35 = __cil_tmp34 + 80;
#line 760
  __cil_tmp36 = *((EAP_DS **)__cil_tmp35);
#line 760
  eaptls_success(__cil_tmp36, 0);
#line 761
  __cil_tmp37 = (unsigned long )handler;
#line 761
  __cil_tmp38 = __cil_tmp37 + 56;
#line 761
  __cil_tmp39 = *((REQUEST **)__cil_tmp38);
#line 761
  __cil_tmp40 = (unsigned long )__cil_tmp39;
#line 761
  __cil_tmp41 = __cil_tmp40 + 24;
#line 761
  __cil_tmp42 = *((RADIUS_PACKET **)__cil_tmp41);
#line 761
  __cil_tmp43 = (unsigned long )__cil_tmp42;
#line 761
  __cil_tmp44 = __cil_tmp43 + 72;
#line 761
  __cil_tmp45 = (VALUE_PAIR **)__cil_tmp44;
#line 761
  __cil_tmp46 = *((SSL **)tls_session);
#line 761
  eaptls_gen_mppe_keys(__cil_tmp45, __cil_tmp46, "client EAP encryption");
  }
#line 764
  return (1);
}
}
#line 771 "rlm_eap_tls.c"
EAP_TYPE rlm_eap_tls  =    {"eap_tls", & eaptls_attach, & eaptls_initiate, (int (*)(void *type_data , EAP_HANDLER *handler ))((void *)0),
    & eaptls_authenticate, & eaptls_detach};
