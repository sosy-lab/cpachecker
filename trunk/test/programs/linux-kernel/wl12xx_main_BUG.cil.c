/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 19 "include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 42 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 43 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 45 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 46 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 48 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 49 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 51 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 52 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 11 "include/asm-generic/types.h"
typedef unsigned short umode_t;
#line 14 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/types.h"
typedef u64 dma_addr_t;
#line 11 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_mode_t;
#line 12 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_nlink_t;
#line 13 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef long __kernel_off_t;
#line 18 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef unsigned int __kernel_size_t;
#line 19 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_ssize_t;
#line 21 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef long __kernel_time_t;
#line 25 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_clockid_t;
#line 30 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef unsigned int __kernel_uid32_t;
#line 31 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef unsigned int __kernel_gid32_t;
#line 38 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/posix_types_32.h"
typedef long long __kernel_loff_t;
#line 18 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 21 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 23 "include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 24 "include/linux/types.h"
typedef __kernel_nlink_t nlink_t;
#line 25 "include/linux/types.h"
typedef __kernel_off_t off_t;
#line 31 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 34 "include/linux/types.h"
typedef _Bool bool;
#line 36 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 37 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 50 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 59 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 64 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 74 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 88 "include/linux/types.h"
typedef unsigned char u_char;
#line 135 "include/linux/types.h"
typedef u64 sector_t;
#line 136 "include/linux/types.h"
typedef u64 blkcnt_t;
#line 168 "include/linux/types.h"
typedef __u16 __le16;
#line 169 "include/linux/types.h"
typedef __u16 __be16;
#line 171 "include/linux/types.h"
typedef __u32 __be32;
#line 176 "include/linux/types.h"
typedef __u32 __wsum;
#line 179 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 180 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 190 "include/linux/types.h"
struct __anonstruct_atomic_t_7 {
   int volatile   counter ;
};
#line 190 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_7 atomic_t;
#line 7 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/processor.h"
struct task_struct;
#line 7
struct task_struct;
#line 8
struct mm_struct;
#line 8
struct mm_struct;
#line 42 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long bx ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long bp ;
   unsigned long ax ;
   unsigned long ds ;
   unsigned long es ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 138 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 135 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/ptrace.h"
struct task_struct;
#line 191 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/vm86.h"
struct task_struct;
#line 60 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/alternative.h"
struct module;
#line 60
struct module;
#line 10 "include/asm-generic/bug.h"
struct bug_entry {
   unsigned long bug_addr ;
   unsigned short flags ;
};
#line 116 "include/linux/kernel.h"
struct completion;
#line 116
struct completion;
#line 117
struct pt_regs;
#line 211
struct pid;
#line 211
struct pid;
#line 8 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/current.h"
struct task_struct;
#line 10 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable-3level_types.h"
typedef u64 pgdval_t;
#line 11 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable-3level_types.h"
typedef u64 pgprotval_t;
#line 187 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 187 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 189 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_16 {
   pgdval_t pgd ;
};
#line 189 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_16 pgd_t;
#line 277
struct page;
#line 290
struct file;
#line 290
struct file;
#line 307
struct seq_file;
#line 307
struct seq_file;
#line 45 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/paravirt_types.h"
struct page;
#line 49
struct mm_struct;
#line 51
struct task_struct;
#line 52
struct cpumask;
#line 52
struct cpumask;
#line 321
struct raw_spinlock;
#line 321
struct raw_spinlock;
#line 13 "include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[((32U + 8U * sizeof(long )) - 1U) / (8U * sizeof(long ))] ;
};
#line 13 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 20 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/system.h"
struct task_struct;
#line 18 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/page.h"
struct page;
#line 10 "include/linux/personality.h"
struct exec_domain;
#line 10
struct exec_domain;
#line 11
struct pt_regs;
#line 91
struct map_segment;
#line 91 "include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 151 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 423
struct kmem_cache;
#line 625 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_33 {
   unsigned long seg ;
};
#line 625 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_33 mm_segment_t;
#line 19 "include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 540
struct hlist_node;
#line 540 "include/linux/list.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 544 "include/linux/list.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 12 "include/linux/thread_info.h"
struct timespec;
#line 12
struct timespec;
#line 18 "include/linux/thread_info.h"
struct __anonstruct____missing_field_name_35 {
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
#line 18 "include/linux/thread_info.h"
struct __anonstruct_futex_36 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 18 "include/linux/thread_info.h"
struct __anonstruct_nanosleep_37 {
   clockid_t index ;
   struct timespec *rmtp ;
   u64 expires ;
};
#line 18
struct pollfd;
#line 18 "include/linux/thread_info.h"
struct __anonstruct_poll_38 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 18 "include/linux/thread_info.h"
union __anonunion____missing_field_name_34 {
   struct __anonstruct____missing_field_name_35 __annonCompField16 ;
   struct __anonstruct_futex_36 futex ;
   struct __anonstruct_nanosleep_37 nanosleep ;
   struct __anonstruct_poll_38 poll ;
};
#line 18 "include/linux/thread_info.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_34 __annonCompField17 ;
};
#line 20 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/thread_info.h"
struct task_struct;
#line 21
struct exec_domain;
#line 141 "include/asm-generic/atomic-long.h"
typedef atomic_t atomic_long_t;
#line 26 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned long previous_esp ;
   __u8 supervisor_stack[0] ;
   int uaccess_err ;
};
#line 8 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/spinlock_types.h"
struct raw_spinlock {
   unsigned int slock ;
};
#line 8 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 14 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/spinlock_types.h"
struct __anonstruct_raw_rwlock_t_40 {
   unsigned int lock ;
};
#line 14 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/spinlock_types.h"
typedef struct __anonstruct_raw_rwlock_t_40 raw_rwlock_t;
#line 12 "include/linux/lockdep.h"
struct task_struct;
#line 366 "include/linux/lockdep.h"
struct lock_class_key {

};
#line 20 "include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_41 {
   raw_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 20 "include/linux/spinlock_types.h"
typedef struct __anonstruct_spinlock_t_41 spinlock_t;
#line 36 "include/linux/spinlock_types.h"
struct __anonstruct_rwlock_t_42 {
   raw_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 36 "include/linux/spinlock_types.h"
typedef struct __anonstruct_rwlock_t_42 rwlock_t;
#line 32 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_43 {
   unsigned int sequence ;
   spinlock_t lock ;
};
#line 32 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_43 seqlock_t;
#line 121 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 14 "include/linux/time.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 62 "include/linux/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 50 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 54 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 56
struct task_struct;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_44 {
   unsigned long bits[(((unsigned int )(1 << 4) + 8U * sizeof(long )) - 1U) / (8U * sizeof(long ))] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_44 nodemask_t;
#line 60 "include/linux/pageblock-flags.h"
struct page;
#line 48 "include/linux/mutex.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct thread_info *owner ;
};
#line 17 "include/linux/rwsem.h"
struct rw_semaphore;
#line 17
struct rw_semaphore;
#line 67 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/rwsem.h"
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
#line 8 "include/linux/memory_hotplug.h"
struct page;
#line 757 "include/linux/mmzone.h"
struct ctl_table;
#line 757
struct ctl_table;
#line 167 "include/linux/ioport.h"
struct device;
#line 167
struct device;
#line 110 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/mpspec.h"
struct device;
#line 46 "include/linux/ktime.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 10 "include/linux/timer.h"
struct tvec_base;
#line 10
struct tvec_base;
#line 12 "include/linux/timer.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_base *base ;
};
#line 16 "include/linux/workqueue.h"
struct work_struct;
#line 16
struct work_struct;
#line 25 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
};
#line 41 "include/linux/pm.h"
struct device;
#line 43 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 43 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 196 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
   int (*runtime_suspend)(struct device *dev ) ;
   int (*runtime_resume)(struct device *dev ) ;
   int (*runtime_idle)(struct device *dev ) ;
};
#line 351
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
#line 384
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 403
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_RESUME = 3
} ;
#line 410 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   spinlock_t lock ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int disable_depth : 3 ;
   unsigned int ignore_children : 1 ;
   unsigned int idle_notification : 1 ;
   unsigned int request_pending : 1 ;
   unsigned int deferred_resume : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
};
#line 11 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_111 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
#line 11 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_111 mm_context_t;
#line 10 "include/linux/gfp.h"
struct vm_area_struct;
#line 10
struct vm_area_struct;
#line 46 "include/linux/kmod.h"
struct file;
#line 103
struct file;
#line 284 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/elf.h"
struct task_struct;
#line 10 "include/linux/elf.h"
struct file;
#line 20 "include/linux/elf.h"
typedef __u32 Elf32_Addr;
#line 21 "include/linux/elf.h"
typedef __u16 Elf32_Half;
#line 24 "include/linux/elf.h"
typedef __u32 Elf32_Word;
#line 172 "include/linux/elf.h"
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
#line 172 "include/linux/elf.h"
typedef struct elf32_sym Elf32_Sym;
#line 20 "include/linux/sysfs.h"
struct kobject;
#line 20
struct kobject;
#line 21
struct module;
#line 28 "include/linux/sysfs.h"
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
#line 34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63
struct vm_area_struct;
#line 77 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 82
struct sysfs_dirent;
#line 82
struct sysfs_dirent;
#line 20 "include/linux/kref.h"
struct kref {
   atomic_t refcount ;
};
#line 59 "include/linux/kobject.h"
struct kset;
#line 59
struct kobj_type;
#line 59 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
#line 113 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
#line 120 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
#line 154 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
#line 32 "include/linux/moduleparam.h"
struct kernel_param;
#line 32
struct kernel_param;
#line 42
struct kparam_string;
#line 42
struct kparam_array;
#line 42 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_121 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 42 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   u16 perm ;
   u16 flags ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   union __anonunion____missing_field_name_121 __annonCompField18 ;
};
#line 56 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
#line 234
struct module;
#line 25 "include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 49 "include/linux/rcupdate.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
#line 20 "include/linux/tracepoint.h"
struct module;
#line 21
struct tracepoint;
#line 21
struct tracepoint;
#line 23 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   int state ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   void **funcs ;
} __attribute__((__aligned__(32))) ;
#line 37 "include/linux/slub_def.h"
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
#line 48 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 64 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 71 "include/linux/slub_def.h"
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   unsigned long min_partial ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 4] ;
   struct kmem_cache_cpu *cpu_slab[32] ;
};
#line 8 "include/asm-generic/module.h"
struct mod_arch_specific {

};
#line 11 "include/trace/events/module.h"
struct module;
#line 35 "include/linux/module.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 47
struct module;
#line 49 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 59
struct module_param_attrs;
#line 59 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 72
struct exception_table_entry;
#line 72
struct exception_table_entry;
#line 227
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 234
struct module_sect_attrs;
#line 234
struct module_notes_attrs;
#line 234
struct ftrace_event_call;
#line 234 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64U - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf32_Sym *symtab ;
   Elf32_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct tracepoint *tracepoints ;
   unsigned int num_tracepoints ;
   char const   **trace_bprintk_fmt_start ;
   unsigned int num_trace_bprintk_fmt ;
   struct ftrace_event_call *trace_events ;
   unsigned int num_trace_events ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   char *refptr ;
   ctor_fn_t *ctors ;
   unsigned int num_ctors ;
};
#line 665
struct device_driver;
#line 665
struct device_driver;
#line 667
struct module;
#line 10 "include/linux/irqreturn.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 83 "include/linux/irq.h"
struct proc_dir_entry;
#line 83
struct proc_dir_entry;
#line 16 "include/linux/profile.h"
struct proc_dir_entry;
#line 17
struct pt_regs;
#line 65
struct task_struct;
#line 66
struct mm_struct;
#line 88
struct pt_regs;
#line 133 "include/linux/hardirq.h"
struct task_struct;
#line 100 "include/linux/rbtree.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 110 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 149 "include/linux/interrupt.h"
struct device;
#line 612
struct seq_file;
#line 11 "include/linux/firmware.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
};
#line 16
struct device;
#line 19 "include/linux/klist.h"
struct klist_node;
#line 19
struct klist_node;
#line 39 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 16 "include/linux/semaphore.h"
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
#line 4 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/device.h"
struct dev_archdata {
   void *acpi_handle ;
   void *iommu ;
};
#line 29 "include/linux/device.h"
struct device;
#line 30
struct device_private;
#line 30
struct device_private;
#line 31
struct device_driver;
#line 32
struct driver_private;
#line 32
struct driver_private;
#line 33
struct class;
#line 33
struct class;
#line 34
struct class_private;
#line 34
struct class_private;
#line 35
struct bus_type;
#line 35
struct bus_type;
#line 36
struct bus_type_private;
#line 36
struct bus_type_private;
#line 38 "include/linux/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
#line 51
struct device_attribute;
#line 51
struct driver_attribute;
#line 51 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops  const  *pm ;
   struct bus_type_private *p ;
};
#line 122 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 157 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
#line 189
struct class_attribute;
#line 189 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   char *(*devnode)(struct device *dev , mode_t *mode ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops  const  *pm ;
   struct class_private *p ;
};
#line 211
struct device_type;
#line 252 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
#line 299 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   char *(*devnode)(struct device *dev , mode_t *mode ) ;
   void (*release)(struct device *dev ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 310 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
#line 370 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 379
struct dma_coherent_mem;
#line 379 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type *type ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device *dev ) ;
};
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 407 "include/linux/mod_devicetable.h"
struct spi_device_id {
   char name[32] ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 68 "include/linux/spi/spi.h"
struct spi_master;
#line 68 "include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 mode ;
   u8 bits_per_word ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32] ;
};
#line 143
struct spi_message;
#line 143
struct spi_message;
#line 174 "include/linux/spi/spi.h"
struct spi_driver {
   struct spi_device_id  const  *id_table ;
   int (*probe)(struct spi_device *spi ) ;
   int (*remove)(struct spi_device *spi ) ;
   void (*shutdown)(struct spi_device *spi ) ;
   int (*suspend)(struct spi_device *spi , pm_message_t mesg ) ;
   int (*resume)(struct spi_device *spi ) ;
   struct device_driver driver ;
};
#line 234 "include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u16 flags ;
   int (*setup)(struct spi_device *spi ) ;
   int (*transfer)(struct spi_device *spi , struct spi_message *mesg ) ;
   void (*cleanup)(struct spi_device *spi ) ;
};
#line 465 "include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int is_dma_mapped : 1 ;
   void (*complete)(void *context ) ;
   void *context ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};
#line 14 "include/linux/prio_tree.h"
struct prio_tree_node;
#line 14 "include/linux/prio_tree.h"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
#line 20 "include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
#line 28 "include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
#line 23 "include/linux/mm_types.h"
struct address_space;
#line 23
struct address_space;
#line 28 "include/linux/mm_types.h"
typedef atomic_long_t mm_counter_t;
#line 40 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_130 {
   u16 inuse ;
   u16 objects ;
};
#line 40 "include/linux/mm_types.h"
union __anonunion____missing_field_name_129 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_130 __annonCompField19 ;
};
#line 40 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_132 {
   unsigned long private ;
   struct address_space *mapping ;
};
#line 40 "include/linux/mm_types.h"
union __anonunion____missing_field_name_131 {
   struct __anonstruct____missing_field_name_132 __annonCompField21 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
#line 40 "include/linux/mm_types.h"
union __anonunion____missing_field_name_133 {
   unsigned long index ;
   void *freelist ;
};
#line 40 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_129 __annonCompField20 ;
   union __anonunion____missing_field_name_131 __annonCompField22 ;
   union __anonunion____missing_field_name_133 __annonCompField23 ;
   struct list_head lru ;
};
#line 134 "include/linux/mm_types.h"
struct __anonstruct_vm_set_135 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
#line 134 "include/linux/mm_types.h"
union __anonunion_shared_134 {
   struct __anonstruct_vm_set_135 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
#line 134
struct anon_vma;
#line 134
struct vm_operations_struct;
#line 134
struct mempolicy;
#line 134 "include/linux/mm_types.h"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_134 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
   struct mempolicy *vm_policy ;
};
#line 191 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 196 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 202
struct linux_binfmt;
#line 202
struct mmu_notifier_mm;
#line 202 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[42] ;
   struct linux_binfmt *binfmt ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
};
#line 11 "include/linux/socket.h"
struct sockaddr;
#line 16 "include/linux/uio.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 29 "include/linux/socket.h"
struct seq_file;
#line 34 "include/linux/socket.h"
typedef unsigned short sa_family_t;
#line 40 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 62 "include/linux/net.h"
struct poll_table_struct;
#line 62
struct poll_table_struct;
#line 63
struct pipe_inode_info;
#line 63
struct pipe_inode_info;
#line 64
struct inode;
#line 64
struct inode;
#line 65
struct net;
#line 65
struct net;
#line 129
struct fasync_struct;
#line 129
struct sock;
#line 148
struct vm_area_struct;
#line 149
struct page;
#line 150
struct kiocb;
#line 150
struct kiocb;
#line 151
struct sockaddr;
#line 153
struct module;
#line 207
struct iovec;
#line 32 "include/linux/sysctl.h"
struct completion;
#line 947
struct ctl_table;
#line 948
struct nsproxy;
#line 948
struct nsproxy;
#line 949
struct ctl_table_root;
#line 949
struct ctl_table_root;
#line 951 "include/linux/sysctl.h"
struct ctl_table_set {
   struct list_head list ;
   struct ctl_table_set *parent ;
   int (*is_seen)(struct ctl_table_set * ) ;
};
#line 961
struct ctl_table_header;
#line 961
struct ctl_table_header;
#line 976 "include/linux/sysctl.h"
typedef int ctl_handler(struct ctl_table *table , void *oldval , size_t *oldlenp ,
                        void *newval , size_t newlen );
#line 980 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *ctl , int write , void *buffer , size_t *lenp ,
                         loff_t *ppos );
#line 1052 "include/linux/sysctl.h"
struct ctl_table {
   int ctl_name ;
   char const   *procname ;
   void *data ;
   int maxlen ;
   mode_t mode ;
   struct ctl_table *child ;
   struct ctl_table *parent ;
   proc_handler *proc_handler ;
   ctl_handler *strategy ;
   void *extra1 ;
   void *extra2 ;
};
#line 1067 "include/linux/sysctl.h"
struct ctl_table_root {
   struct list_head root_list ;
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *root , struct nsproxy *namespaces ) ;
   int (*permissions)(struct ctl_table_root *root , struct nsproxy *namespaces , struct ctl_table *table ) ;
};
#line 1078 "include/linux/sysctl.h"
struct ctl_table_header {
   struct ctl_table *ctl_table ;
   struct list_head ctl_entry ;
   int used ;
   int count ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_table *attached_by ;
   struct ctl_table *attached_to ;
   struct ctl_table_header *parent ;
};
#line 95 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
#line 109 "include/net/checksum.h"
struct sk_buff;
#line 109
struct sk_buff;
#line 12 "include/linux/bug.h"
struct pt_regs;
#line 6 "include/asm-generic/scatterlist.h"
struct scatterlist {
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 8 "include/linux/debug_locks.h"
struct task_struct;
#line 48
struct task_struct;
#line 16 "include/linux/mm.h"
struct mempolicy;
#line 17
struct anon_vma;
#line 18
struct file_ra_state;
#line 18
struct file_ra_state;
#line 20
struct writeback_control;
#line 20
struct writeback_control;
#line 26 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable_32.h"
struct mm_struct;
#line 27
struct vm_area_struct;
#line 554 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/pgtable.h"
struct vm_area_struct;
#line 167 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 184 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
   int (*set_policy)(struct vm_area_struct *vma , struct mempolicy *new ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *vma , unsigned long addr ) ;
   int (*migrate)(struct vm_area_struct *vma , nodemask_t const   *from , nodemask_t const   *to ,
                  unsigned long flags ) ;
};
#line 226
struct inode;
#line 199 "include/linux/page-flags.h"
struct page;
#line 8 "include/linux/vmalloc.h"
struct vm_area_struct;
#line 25 "include/linux/dma-debug.h"
struct device;
#line 26
struct scatterlist;
#line 27
struct bus_type;
#line 6 "include/linux/swiotlb.h"
struct device;
#line 8
struct scatterlist;
#line 33 "include/linux/dmaengine.h"
typedef s32 dma_cookie_t;
#line 94 "include/linux/skbuff.h"
struct net_device;
#line 94
struct net_device;
#line 95
struct scatterlist;
#line 96
struct pipe_inode_info;
#line 99 "include/linux/skbuff.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 105 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned int mask ;
   unsigned long data[32U / sizeof(unsigned long )] ;
};
#line 114 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 123
struct sk_buff;
#line 255 "include/linux/skbuff.h"
typedef unsigned char *sk_buff_data_t;
#line 313
struct sec_path;
#line 313 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_198 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 313 "include/linux/skbuff.h"
union __anonunion____missing_field_name_197 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_198 __annonCompField25 ;
};
#line 313 "include/linux/skbuff.h"
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   struct sock *sk ;
   ktime_t tstamp ;
   struct net_device *dev ;
   unsigned long _skb_dst ;
   struct sec_path *sp ;
   char cb[48] ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion____missing_field_name_197 __annonCompField26 ;
   __u32 priority ;
   int flags1_begin[0] ;
   __u8 local_df : 1 ;
   __u8 cloned : 1 ;
   __u8 ip_summed : 2 ;
   __u8 nohdr : 1 ;
   __u8 nfctinfo : 3 ;
   __u8 pkt_type : 3 ;
   __u8 fclone : 2 ;
   __u8 ipvs_property : 1 ;
   __u8 peeked : 1 ;
   __u8 nf_trace : 1 ;
   __be16 protocol : 16 ;
   int flags1_end[0] ;
   void (*destructor)(struct sk_buff *skb ) ;
   struct nf_conntrack *nfct ;
   struct sk_buff *nfct_reasm ;
   struct nf_bridge_info *nf_bridge ;
   int iif ;
   __u16 tc_index ;
   __u16 tc_verd ;
   int flags2_begin[0] ;
   __u16 queue_mapping : 16 ;
   __u8 ndisc_nodetype : 2 ;
   int flags2_end[0] ;
   dma_cookie_t dma_cookie ;
   __u32 secmark ;
   __u32 mark ;
   __u16 vlan_tci ;
   sk_buff_data_t transport_header ;
   sk_buff_data_t network_header ;
   sk_buff_data_t mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 425
struct dst_entry;
#line 37 "include/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_199 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 37 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_199 sync_serial_settings;
#line 43 "include/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_200 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 43 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_200 te1_settings;
#line 50 "include/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_201 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 50 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_201 raw_hdlc_proto;
#line 55 "include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_202 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 55 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_202 fr_proto;
#line 65 "include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_203 {
   unsigned int dlci ;
};
#line 65 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_203 fr_proto_pvc;
#line 69 "include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_204 {
   unsigned int dlci ;
   char master[16] ;
};
#line 69 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_204 fr_proto_pvc_info;
#line 74 "include/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_205 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 74 "include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_205 cisco_proto;
#line 128 "include/linux/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 139 "include/linux/if.h"
union __anonunion_ifs_ifsu_208 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 139 "include/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_208 ifs_ifsu ;
};
#line 164 "include/linux/if.h"
union __anonunion_ifr_ifrn_209 {
   char ifrn_name[16] ;
};
#line 164 "include/linux/if.h"
union __anonunion_ifr_ifru_210 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 164 "include/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_209 ifr_ifrn ;
   union __anonunion_ifr_ifru_210 ifr_ifru ;
};
#line 19 "include/linux/ethtool.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 reserved2 ;
   __u32 lp_advertising ;
   __u32 reserved[2] ;
};
#line 54 "include/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32] ;
   char version[32] ;
   char fw_version[32] ;
   char bus_info[32] ;
   char reserved1[32] ;
   char reserved2[12] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 72 "include/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6] ;
};
#line 86 "include/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0] ;
};
#line 94 "include/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0] ;
};
#line 103 "include/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 199 "include/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 221 "include/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 260 "include/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0] ;
};
#line 269 "include/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0] ;
};
#line 299 "include/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 307 "include/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 314 "include/linux/ethtool.h"
struct ethtool_rawip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __u8 hdata[64] ;
};
#line 320 "include/linux/ethtool.h"
struct ethtool_ether_spec {
   __be16 ether_type ;
   __u8 frame_size ;
   __u8 eframe[16] ;
};
#line 329 "include/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 338 "include/linux/ethtool.h"
union __anonunion_h_u_212 {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_rawip4_spec raw_ip4_spec ;
   struct ethtool_ether_spec ether_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   __u8 hdata[64] ;
};
#line 338 "include/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union __anonunion_h_u_212 h_u ;
   union __anonunion_h_u_212 m_u ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 355 "include/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0] ;
};
#line 371 "include/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128] ;
};
#line 379
struct net_device;
#line 456 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   u32 (*get_rx_csum)(struct net_device * ) ;
   int (*set_rx_csum)(struct net_device * , u32  ) ;
   u32 (*get_tx_csum)(struct net_device * ) ;
   int (*set_tx_csum)(struct net_device * , u32  ) ;
   u32 (*get_sg)(struct net_device * ) ;
   int (*set_sg)(struct net_device * , u32  ) ;
   u32 (*get_tso)(struct net_device * ) ;
   int (*set_tso)(struct net_device * , u32  ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32 stringset , u8 * ) ;
   int (*phys_id)(struct net_device * , u32  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_ufo)(struct net_device * ) ;
   int (*set_ufo)(struct net_device * , u32  ) ;
   u32 (*get_flags)(struct net_device * ) ;
   int (*set_flags)(struct net_device * , u32  ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*self_test_count)(struct net_device * ) ;
   int (*get_stats_count)(struct net_device * ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , void * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
};
#line 4 "include/net/netns/core.h"
struct ctl_table_header;
#line 5
struct prot_inuse;
#line 5
struct prot_inuse;
#line 7 "include/net/netns/core.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 72 "include/net/snmp.h"
struct ipstats_mib {
   unsigned long mibs[31] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 80 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 85 "include/net/snmp.h"
struct icmpmsg_mib {
   unsigned long mibs[512] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 91 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[4] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 96 "include/net/snmp.h"
struct icmpv6msg_mib {
   unsigned long mibs[512] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 103 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[15] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 109 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[7] ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 115 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[75] ;
};
#line 121 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[26] ;
};
#line 6 "include/net/netns/mib.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics[2] ;
   struct ipstats_mib *ip_statistics[2] ;
   struct linux_mib *net_statistics[2] ;
   struct udp_mib *udp_statistics[2] ;
   struct udp_mib *udplite_statistics[2] ;
   struct icmp_mib *icmp_statistics[2] ;
   struct icmpmsg_mib *icmpmsg_statistics[2] ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6[2] ;
   struct udp_mib *udplite_stats_in6[2] ;
   struct ipstats_mib *ipv6_statistics[2] ;
   struct icmpv6_mib *icmpv6_statistics[2] ;
   struct icmpv6msg_mib *icmpv6msg_statistics[2] ;
   struct linux_xfrm_mib *xfrm_statistics[2] ;
};
#line 7 "include/net/netns/unix.h"
struct ctl_table_header;
#line 8 "include/net/netns/unix.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 10 "include/net/netns/packet.h"
struct netns_packet {
   rwlock_t sklist_lock ;
   struct hlist_head sklist ;
};
#line 4 "include/net/inet_frag.h"
struct netns_frags {
   int nqueues ;
   atomic_t mem ;
   struct list_head lru_list ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 10 "include/net/netns/ipv4.h"
struct ctl_table_header;
#line 11
struct ipv4_devconf;
#line 11
struct ipv4_devconf;
#line 12
struct fib_rules_ops;
#line 12
struct fib_rules_ops;
#line 13
struct hlist_head;
#line 14
struct sock;
#line 16
struct xt_table;
#line 16
struct mfc_cache;
#line 16
struct vif_device;
#line 16 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *tcp_sock ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
   int nat_vmalloced ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   int sysctl_rt_cache_rebuild_count ;
   int current_rt_cache_rebuild_count ;
   struct timer_list rt_secret_timer ;
   atomic_t rt_genid ;
   struct sock *mroute_sk ;
   struct mfc_cache **mfc_cache_array ;
   struct vif_device *vif_table ;
   int maxvif ;
   atomic_t cache_resolve_queue_len ;
   int mroute_do_assert ;
   int mroute_do_pim ;
   int mroute_reg_vif_num ;
};
#line 5 "include/net/dst_ops.h"
struct dst_entry;
#line 7
struct net_device;
#line 8
struct sk_buff;
#line 10 "include/net/dst_ops.h"
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *ops ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32 cookie ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device *dev , int how ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry *dst , u32 mtu ) ;
   int (*local_out)(struct sk_buff *skb ) ;
   atomic_t entries ;
   struct kmem_cache *kmem_cachep ;
};
#line 11 "include/net/netns/ipv6.h"
struct ctl_table_header;
#line 13 "include/net/netns/ipv6.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *table ;
   struct ctl_table_header *frags_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int icmpv6_time ;
};
#line 30
struct ipv6_devconf;
#line 30
struct rt6_info;
#line 30
struct rt6_statistics;
#line 30
struct fib6_table;
#line 30
struct mfc6_cache;
#line 30
struct mif_device;
#line 30 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mroute6_sk ;
   struct mfc6_cache **mfc6_cache_array ;
   struct mif_device *vif6_table ;
   int maxvif ;
   atomic_t cache_resolve_queue_len ;
   int mroute_do_assert ;
   int mroute_do_pim ;
   int mroute_reg_vif_num ;
};
#line 4 "include/net/netns/dccp.h"
struct sock;
#line 6 "include/net/netns/dccp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 88 "include/linux/netfilter.h"
struct sk_buff;
#line 87 "include/net/flow.h"
struct net;
#line 88
struct sock;
#line 11 "include/linux/dcache.h"
struct nameidata;
#line 11
struct nameidata;
#line 12
struct path;
#line 12
struct path;
#line 13
struct vfsmount;
#line 13
struct vfsmount;
#line 33 "include/linux/dcache.h"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
#line 89 "include/linux/dcache.h"
union __anonunion_d_u_231 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
#line 89
struct dentry_operations;
#line 89
struct super_block;
#line 89 "include/linux/dcache.h"
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   int d_mounted ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_231 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   unsigned char d_iname[40] ;
};
#line 134 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
#line 4 "include/linux/path.h"
struct dentry;
#line 5
struct vfsmount;
#line 7 "include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 61 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 61 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 6 "include/linux/pid.h"
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 50
struct pid_namespace;
#line 50 "include/linux/pid.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 57 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
#line 100
struct pid_namespace;
#line 18 "include/linux/capability.h"
struct task_struct;
#line 568
struct dentry;
#line 16 "include/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
#line 384 "include/linux/fs.h"
struct export_operations;
#line 384
struct export_operations;
#line 386
struct iovec;
#line 387
struct nameidata;
#line 388
struct kiocb;
#line 389
struct pipe_inode_info;
#line 390
struct poll_table_struct;
#line 391
struct kstatfs;
#line 391
struct kstatfs;
#line 392
struct vm_area_struct;
#line 393
struct vfsmount;
#line 394
struct cred;
#line 394
struct cred;
#line 446 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 106 "include/linux/quota.h"
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
#line 127 "include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 50 "include/linux/dqblk_xfs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
#line 137 "include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 137 "include/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 143 "include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 17 "include/linux/dqblk_qtree.h"
struct dquot;
#line 17
struct dquot;
#line 182 "include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
#line 183 "include/linux/quota.h"
typedef long long qsize_t;
#line 197 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 212
struct quota_format_type;
#line 212
struct quota_format_type;
#line 214 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 227
struct super_block;
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
#line 284 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
#line 295 "include/linux/quota.h"
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , qsize_t  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , qsize_t  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   int (*reserve_space)(struct inode * , qsize_t  , int  ) ;
   int (*claim_space)(struct inode * , qsize_t  ) ;
   void (*release_rsv)(struct inode * , qsize_t  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 322 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * , int  ) ;
   int (*quota_off)(struct super_block * , int  , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
#line 336 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 380 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
#line 509 "include/linux/fs.h"
struct page;
#line 510
struct address_space;
#line 511
struct writeback_control;
#line 554 "include/linux/fs.h"
union __anonunion_arg_238 {
   char *buf ;
   void *data ;
};
#line 554 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_237 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_238 arg ;
   int error ;
};
#line 554 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_237 read_descriptor_t;
#line 567 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
};
#line 617
struct backing_dev_info;
#line 617
struct backing_dev_info;
#line 618 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 642
struct hd_struct;
#line 642
struct gendisk;
#line 642 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 716
struct posix_acl;
#line 716
struct posix_acl;
#line 719
struct inode_operations;
#line 719
struct file_operations;
#line 719
struct file_lock;
#line 719
struct cdev;
#line 719 "include/linux/fs.h"
union __anonunion____missing_field_name_239 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 719 "include/linux/fs.h"
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   u64 i_version ;
   loff_t i_size ;
   seqcount_t i_size_seqcount ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   blkcnt_t i_blocks ;
   unsigned int i_blkbits ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_239 __annonCompField27 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_mark_entries ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   void *i_private ;
};
#line 874 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
#line 885 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 908 "include/linux/fs.h"
union __anonunion_f_u_240 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
#line 908 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_240 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct address_space *f_mapping ;
};
#line 1027
struct files_struct;
#line 1027 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 1029 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 1034 "include/linux/fs.h"
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
#line 8 "include/linux/nfs_fs_i.h"
struct nlm_lockowner;
#line 8
struct nlm_lockowner;
#line 13 "include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 19
struct nfs4_lock_state;
#line 19
struct nfs4_lock_state;
#line 20 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 1056 "include/linux/fs.h"
struct __anonstruct_afs_242 {
   struct list_head link ;
   int state ;
};
#line 1056 "include/linux/fs.h"
union __anonunion_fl_u_241 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_242 afs ;
};
#line 1056 "include/linux/fs.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_241 fl_u ;
};
#line 1281 "include/linux/fs.h"
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
#line 1316
struct file_system_type;
#line 1316
struct super_operations;
#line 1316
struct xattr_handler;
#line 1316
struct mtd_info;
#line 1316 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_need_sync ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
   char *s_options ;
};
#line 1435 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1482 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
};
#line 1511 "include/linux/fs.h"
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  ) ;
   int (*check_acl)(struct inode * , int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
};
#line 1541
struct seq_file;
#line 1555 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
};
#line 1738 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
#line 2477
struct ctl_table;
#line 10 "include/linux/proc_fs.h"
struct net;
#line 11
struct completion;
#line 12
struct mm_struct;
#line 46 "include/linux/proc_fs.h"
typedef int read_proc_t(char *page , char **start , off_t off , int count , int *eof ,
                        void *data );
#line 48 "include/linux/proc_fs.h"
typedef int write_proc_t(struct file *file , char const   *buffer , unsigned long count ,
                         void *data );
#line 51 "include/linux/proc_fs.h"
struct proc_dir_entry {
   unsigned int low_ino ;
   unsigned short namelen ;
   char const   *name ;
   mode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   spinlock_t pde_unload_lock ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
};
#line 117
struct pid_namespace;
#line 261
struct ctl_table_header;
#line 262
struct ctl_table;
#line 7 "include/net/netns/x_tables.h"
struct ebt_table;
#line 7
struct ebt_table;
#line 9 "include/net/netns/x_tables.h"
struct netns_xt {
   struct list_head tables[13] ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 17 "include/linux/list_nulls.h"
struct hlist_nulls_node;
#line 17 "include/linux/list_nulls.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 21 "include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 8 "include/net/netns/conntrack.h"
struct ctl_table_header;
#line 11
struct ip_conntrack_stat;
#line 11 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   unsigned int htable_size ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct ip_conntrack_stat *stat ;
   int sysctl_events ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_acct ;
   int sysctl_checksum ;
   unsigned int sysctl_log_invalid ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   int hash_vmalloc ;
   int expect_vmalloc ;
   char *slabname ;
};
#line 9 "include/net/netns/xfrm.h"
struct ctl_table_header;
#line 11 "include/net/netns/xfrm.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
#line 16 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   wait_queue_head_t km_waitq ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6] ;
   struct xfrm_policy_hash policy_bydst[6] ;
   unsigned int policy_count[6] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
};
#line 24 "include/net/net_namespace.h"
struct proc_dir_entry;
#line 25
struct net_device;
#line 26
struct sock;
#line 27
struct ctl_table_header;
#line 28
struct net_generic;
#line 28
struct net_generic;
#line 29
struct sock;
#line 31 "include/net/net_namespace.h"
struct net {
   atomic_t count ;
   struct list_head list ;
   struct work_struct work ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct net_device *loopback_dev ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   struct list_head rules_ops ;
   spinlock_t rules_mod_lock ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_dccp dccp ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_xfrm xfrm ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
};
#line 10 "include/linux/seq_file.h"
struct seq_operations;
#line 11
struct file;
#line 12
struct path;
#line 13
struct inode;
#line 14
struct dentry;
#line 16 "include/linux/seq_file.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   void *private ;
};
#line 29 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *m , loff_t *pos ) ;
   void (*stop)(struct seq_file *m , void *v ) ;
   void *(*next)(struct seq_file *m , void *v , loff_t *pos ) ;
   int (*show)(struct seq_file *m , void *v ) ;
};
#line 6 "include/linux/seq_file_net.h"
struct net;
#line 266 "include/net/net_namespace.h"
struct ctl_table;
#line 267
struct ctl_table_header;
#line 27 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   u8 (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   u8 (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   u8 (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   u8 (*getapp)(struct net_device * , u8  , u16  ) ;
};
#line 53 "include/linux/netdevice.h"
struct vlan_group;
#line 53
struct vlan_group;
#line 54
struct netpoll_info;
#line 54
struct netpoll_info;
#line 56
struct wireless_dev;
#line 56
struct wireless_dev;
#line 83
enum netdev_tx {
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 1,
    NETDEV_TX_LOCKED = -1
} ;
#line 88 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 128 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 178
struct neighbour;
#line 178
struct neighbour;
#line 179
struct neigh_parms;
#line 179
struct neigh_parms;
#line 180
struct sk_buff;
#line 192 "include/linux/netdevice.h"
struct dev_addr_list {
   struct dev_addr_list *next ;
   u8 da_addr[32] ;
   u8 da_addrlen ;
   u8 da_synced ;
   int da_users ;
   int da_gusers ;
};
#line 225 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 230 "include/linux/netdevice.h"
struct hh_cache {
   struct hh_cache *hh_next ;
   atomic_t hh_refcnt ;
   __be16 hh_type  __attribute__((__aligned__((1) <<  (4) ))) ;
   u16 hh_len ;
   int (*hh_output)(struct sk_buff *skb ) ;
   seqlock_t hh_lock ;
   unsigned long hh_data[128U / sizeof(long )] ;
};
#line 276 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *skb , struct net_device *dev , unsigned short type ,
                 void const   *daddr , void const   *saddr , unsigned int len ) ;
   int (*parse)(struct sk_buff  const  *skb , unsigned char *haddr ) ;
   int (*rebuild)(struct sk_buff *skb ) ;
   int (*cache)(struct neighbour  const  *neigh , struct hh_cache *hh ) ;
   void (*cache_update)(struct hh_cache *hh , struct net_device  const  *dev , unsigned char const   *haddr ) ;
};
#line 466
struct Qdisc;
#line 466 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   unsigned long state ;
   struct Qdisc *qdisc_sleeping ;
   spinlock_t _xmit_lock  __attribute__((__aligned__((1) <<  (4) ))) ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long tx_bytes ;
   unsigned long tx_packets ;
   unsigned long tx_dropped ;
} __attribute__((__aligned__((1) <<  (4) ))) ;
#line 582 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *dev ) ;
   void (*ndo_uninit)(struct net_device *dev ) ;
   int (*ndo_open)(struct net_device *dev ) ;
   int (*ndo_stop)(struct net_device *dev ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *skb , struct net_device *dev ) ;
   u16 (*ndo_select_queue)(struct net_device *dev , struct sk_buff *skb ) ;
   void (*ndo_change_rx_flags)(struct net_device *dev , int flags ) ;
   void (*ndo_set_rx_mode)(struct net_device *dev ) ;
   void (*ndo_set_multicast_list)(struct net_device *dev ) ;
   int (*ndo_set_mac_address)(struct net_device *dev , void *addr ) ;
   int (*ndo_validate_addr)(struct net_device *dev ) ;
   int (*ndo_do_ioctl)(struct net_device *dev , struct ifreq *ifr , int cmd ) ;
   int (*ndo_set_config)(struct net_device *dev , struct ifmap *map ) ;
   int (*ndo_change_mtu)(struct net_device *dev , int new_mtu ) ;
   int (*ndo_neigh_setup)(struct net_device *dev , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device *dev ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *dev ) ;
   void (*ndo_vlan_rx_register)(struct net_device *dev , struct vlan_group *grp ) ;
   void (*ndo_vlan_rx_add_vid)(struct net_device *dev , unsigned short vid ) ;
   void (*ndo_vlan_rx_kill_vid)(struct net_device *dev , unsigned short vid ) ;
   void (*ndo_poll_controller)(struct net_device *dev ) ;
   int (*ndo_fcoe_enable)(struct net_device *dev ) ;
   int (*ndo_fcoe_disable)(struct net_device *dev ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *dev , u16 xid , struct scatterlist *sgl ,
                             unsigned int sgc ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *dev , u16 xid ) ;
};
#line 651
struct iw_handler_def;
#line 651
struct iw_public_data;
#line 651
enum __anonenum_reg_state_254 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
} ;
#line 651
struct net_bridge_port;
#line 651
struct macvlan_port;
#line 651
struct garp_port;
#line 651
struct rtnl_link_ops;
#line 651 "include/linux/netdevice.h"
struct net_device {
   char name[16] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   unsigned int irq ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   unsigned long features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned short gflags ;
   unsigned short priv_flags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   struct net_device *master ;
   unsigned char perm_addr[32] ;
   unsigned char addr_len ;
   unsigned short dev_id ;
   struct netdev_hw_addr_list uc ;
   int uc_promisc ;
   spinlock_t addr_list_lock ;
   struct dev_addr_list *mc_list ;
   int mc_count ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   void *dsa_ptr ;
   void *atalk_ptr ;
   void *ip_ptr ;
   void *dn_ptr ;
   void *ip6_ptr ;
   void *ec_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_hw_addr_list dev_addrs ;
   unsigned char broadcast[32] ;
   struct netdev_queue rx_queue ;
   struct netdev_queue *_tx  __attribute__((__aligned__((1) <<  (4) ))) ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   atomic_t refcnt  __attribute__((__aligned__((1) <<  (4) ))) ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct net_device *link_watch_next ;
   enum __anonenum_reg_state_254 reg_state ;
   void (*destructor)(struct net_device *dev ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   void *ml_priv ;
   struct net_bridge_port *br_port ;
   struct macvlan_port *macvlan_port ;
   struct garp_port *garp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[3] ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned long vlan_features ;
   unsigned int gso_max_size ;
   struct dcbnl_rtnl_ops *dcbnl_ops ;
   unsigned int fcoe_ddp_xid ;
};
#line 27 "include/linux/spi/wl12xx.h"
struct wl12xx_platform_data {
   void (*set_power)(bool enable ) ;
};
#line 671 "include/linux/wireless.h"
struct iw_param {
   __s32 value ;
   __u8 fixed ;
   __u8 disabled ;
   __u16 flags ;
};
#line 683 "include/linux/wireless.h"
struct iw_point {
   void *pointer ;
   __u16 length ;
   __u16 flags ;
};
#line 711 "include/linux/wireless.h"
struct iw_freq {
   __s32 m ;
   __s16 e ;
   __u8 i ;
   __u8 flags ;
};
#line 722 "include/linux/wireless.h"
struct iw_quality {
   __u8 qual ;
   __u8 level ;
   __u8 noise ;
   __u8 updated ;
};
#line 738 "include/linux/wireless.h"
struct iw_discarded {
   __u32 nwid ;
   __u32 code ;
   __u32 fragment ;
   __u32 retries ;
   __u32 misc ;
};
#line 751 "include/linux/wireless.h"
struct iw_missed {
   __u32 beacon ;
};
#line 897 "include/linux/wireless.h"
struct iw_statistics {
   __u16 status ;
   struct iw_quality qual ;
   struct iw_discarded discard ;
   struct iw_missed miss ;
};
#line 919 "include/linux/wireless.h"
union iwreq_data {
   char name[16] ;
   struct iw_point essid ;
   struct iw_param nwid ;
   struct iw_freq freq ;
   struct iw_param sens ;
   struct iw_param bitrate ;
   struct iw_param txpower ;
   struct iw_param rts ;
   struct iw_param frag ;
   __u32 mode ;
   struct iw_param retry ;
   struct iw_point encoding ;
   struct iw_param power ;
   struct iw_quality qual ;
   struct sockaddr ap_addr ;
   struct sockaddr addr ;
   struct iw_param param ;
   struct iw_point data ;
};
#line 1083 "include/linux/wireless.h"
struct iw_priv_args {
   __u32 cmd ;
   __u16 set_args ;
   __u16 get_args ;
   char name[16] ;
};
#line 739 "include/linux/ieee80211.h"
struct ieee80211_mcs_info {
   u8 rx_mask[10] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3] ;
} __attribute__((__packed__)) ;
#line 22 "include/linux/debugfs.h"
struct file_operations;
#line 30 "include/linux/netlink.h"
struct net;
#line 779 "include/linux/nl80211.h"
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    __NL80211_IFTYPE_AFTER_LAST = 8,
    NL80211_IFTYPE_MAX = 7
} ;
#line 1029
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
} ;
#line 1258
enum nl80211_channel_type {
    NL80211_CHAN_NO_HT = 0,
    NL80211_CHAN_HT20 = 1,
    NL80211_CHAN_HT40MINUS = 2,
    NL80211_CHAN_HT40PLUS = 3
} ;
#line 1322
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    __NL80211_AUTHTYPE_NUM = 4,
    NL80211_AUTHTYPE_MAX = 3,
    NL80211_AUTHTYPE_AUTOMATIC = 4
} ;
#line 21 "include/net/regulatory.h"
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
} ;
#line 51 "include/net/regulatory.h"
struct regulatory_request {
   int wiphy_idx ;
   enum nl80211_reg_initiator initiator ;
   char alpha2[2] ;
   bool intersect ;
   u32 country_ie_checksum ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};
#line 61 "include/net/regulatory.h"
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};
#line 67 "include/net/regulatory.h"
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};
#line 72 "include/net/regulatory.h"
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   u32 flags ;
};
#line 78 "include/net/regulatory.h"
struct ieee80211_regdomain {
   u32 n_reg_rules ;
   char alpha2[2] ;
   struct ieee80211_reg_rule reg_rules[] ;
};
#line 303 "include/net/iw_handler.h"
struct iw_request_info {
   __u16 cmd ;
   __u16 flags ;
};
#line 309
struct net_device;
#line 315 "include/net/iw_handler.h"
typedef int (*iw_handler)(struct net_device *dev , struct iw_request_info *info ,
                          union iwreq_data *wrqu , char *extra );
#line 324 "include/net/iw_handler.h"
struct iw_handler_def {
   __u16 num_standard ;
   __u16 num_private ;
   __u16 num_private_args ;
   iw_handler const   *standard ;
   iw_handler const   *private ;
   struct iw_priv_args  const  *private_args ;
   struct iw_statistics *(*get_wireless_stats)(struct net_device *dev ) ;
};
#line 396 "include/net/iw_handler.h"
struct iw_spy_data {
   int spy_number ;
   u_char spy_address[8][6] ;
   struct iw_quality spy_stat[8] ;
   struct iw_quality spy_thr_low ;
   struct iw_quality spy_thr_high ;
   u_char spy_thr_under[8] ;
};
#line 419
struct libipw_device;
#line 419
struct libipw_device;
#line 421 "include/net/iw_handler.h"
struct iw_public_data {
   struct iw_spy_data *spy_data ;
   struct libipw_device *libipw ;
};
#line 41 "include/net/cfg80211.h"
enum ieee80211_band {
    IEEE80211_BAND_2GHZ = 0,
    IEEE80211_BAND_5GHZ = 1,
    IEEE80211_NUM_BANDS = 2
} ;
#line 96 "include/net/cfg80211.h"
struct ieee80211_channel {
   enum ieee80211_band band ;
   u16 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
   int max_power ;
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
   int orig_mpwr ;
};
#line 151 "include/net/cfg80211.h"
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};
#line 169 "include/net/cfg80211.h"
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};
#line 192 "include/net/cfg80211.h"
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum ieee80211_band band ;
   int n_channels ;
   int n_bitrates ;
   struct ieee80211_sta_ht_cap ht_cap ;
};
#line 530
struct wiphy;
#line 530
struct wiphy;
#line 533
struct ieee80211_channel;
#line 540 "include/net/cfg80211.h"
struct cfg80211_ssid {
   u8 ssid[32] ;
   u8 ssid_len ;
};
#line 557 "include/net/cfg80211.h"
struct cfg80211_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   u8 const   *ie ;
   size_t ie_len ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   bool aborted ;
   struct ieee80211_channel *channels[0] ;
};
#line 580
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
} ;
#line 642 "include/net/cfg80211.h"
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
   u32 ciphers_pairwise[5] ;
   int n_akm_suites ;
   u32 akm_suites[2] ;
   bool control_port ;
};
#line 750 "include/net/cfg80211.h"
struct cfg80211_ibss_params {
   u8 *ssid ;
   u8 *bssid ;
   struct ieee80211_channel *channel ;
   u8 *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   bool channel_fixed ;
   bool privacy ;
};
#line 782 "include/net/cfg80211.h"
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   u8 *bssid ;
   u8 *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 *ie ;
   size_t ie_len ;
   bool privacy ;
   struct cfg80211_crypto_settings crypto ;
   u8 const   *key ;
   u8 key_len ;
   u8 key_idx ;
};
#line 1115 "include/net/cfg80211.h"
struct wiphy {
   u8 perm_addr[6] ;
   u16 interface_modes ;
   bool custom_regulatory ;
   bool strict_regulatory ;
   bool disable_beacon_hints ;
   bool netnsok ;
   bool ps_default ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
   u8 max_scan_ssids ;
   u16 max_scan_ie_len ;
   int n_cipher_suites ;
   u32 const   *cipher_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   void const   *privid ;
   struct ieee80211_supported_band *bands[2] ;
   int (*reg_notifier)(struct wiphy *wiphy , struct regulatory_request *request ) ;
   struct ieee80211_regdomain  const  *regd ;
   struct device dev ;
   struct dentry *debugfsdir ;
   struct net *_net ;
   char priv[0]  __attribute__((__aligned__(32))) ;
};
#line 1293
struct cfg80211_conn;
#line 1293
struct cfg80211_conn;
#line 1294
struct cfg80211_internal_bss;
#line 1294
struct cfg80211_internal_bss;
#line 1295
struct cfg80211_cached_keys;
#line 1295
struct cfg80211_cached_keys;
#line 1318
enum __anonenum_sme_state_284 {
    CFG80211_SME_IDLE = 0,
    CFG80211_SME_CONNECTING = 1,
    CFG80211_SME_CONNECTED = 2
} ;
#line 1318 "include/net/cfg80211.h"
struct __anonstruct_wext_285 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 *ie ;
   size_t ie_len ;
   u8 bssid[6] ;
   u8 prev_bssid[6] ;
   u8 ssid[32] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool ps ;
   bool prev_bssid_valid ;
   int ps_timeout ;
};
#line 1318 "include/net/cfg80211.h"
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   struct mutex mtx ;
   struct work_struct cleanup_work ;
   u8 ssid[32] ;
   u8 ssid_len ;
   enum __anonenum_sme_state_284 sme_state ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *authtry_bsses[4] ;
   struct cfg80211_internal_bss *auth_bsses[4] ;
   struct cfg80211_internal_bss *current_bss ;
   struct __anonstruct_wext_285 wext ;
};
#line 111 "include/net/mac80211.h"
struct ieee80211_tx_queue_params {
   u16 txop ;
   u16 cw_min ;
   u16 cw_max ;
   u8 aifs ;
};
#line 125 "include/net/mac80211.h"
struct ieee80211_tx_queue_stats {
   unsigned int len ;
   unsigned int limit ;
   unsigned int count ;
};
#line 131 "include/net/mac80211.h"
struct ieee80211_low_level_stats {
   unsigned int dot11ACKFailureCount ;
   unsigned int dot11RTSFailureCount ;
   unsigned int dot11FCSErrorCount ;
   unsigned int dot11RTSSuccessCount ;
};
#line 199 "include/net/mac80211.h"
struct ieee80211_bss_conf {
   u8 const   *bssid ;
   bool assoc ;
   u16 aid ;
   bool use_cts_prot ;
   bool use_short_preamble ;
   bool use_short_slot ;
   bool enable_beacon ;
   u8 dtim_period ;
   u16 beacon_int ;
   u16 assoc_capability ;
   u64 timestamp ;
   u32 basic_rates ;
   u16 ht_operation_mode ;
};
#line 399
struct ieee80211_vif;
#line 399
struct ieee80211_key_conf;
#line 399
struct ieee80211_sta;
#line 633 "include/net/mac80211.h"
struct ieee80211_conf {
   u32 flags ;
   int power_level ;
   int dynamic_ps_timeout ;
   int max_sleep_period ;
   u16 listen_interval ;
   u8 long_frame_max_tx_count ;
   u8 short_frame_max_tx_count ;
   struct ieee80211_channel *channel ;
   enum nl80211_channel_type channel_type ;
};
#line 658 "include/net/mac80211.h"
struct ieee80211_vif {
   enum nl80211_iftype type ;
   struct ieee80211_bss_conf bss_conf ;
   u8 drv_priv[0]  __attribute__((__aligned__(sizeof(void *)))) ;
};
#line 694 "include/net/mac80211.h"
struct ieee80211_if_init_conf {
   enum nl80211_iftype type ;
   struct ieee80211_vif *vif ;
   void *mac_addr ;
};
#line 707
enum ieee80211_key_alg {
    ALG_WEP = 0,
    ALG_TKIP = 1,
    ALG_CCMP = 2,
    ALG_AES_CMAC = 3
} ;
#line 763 "include/net/mac80211.h"
struct ieee80211_key_conf {
   enum ieee80211_key_alg alg ;
   u8 icv_len ;
   u8 iv_len ;
   u8 hw_key_idx ;
   u8 flags ;
   s8 keyidx ;
   u8 keylen ;
   u8 key[0] ;
};
#line 783
enum set_key_cmd {
    SET_KEY = 0,
    DISABLE_KEY = 1
} ;
#line 804 "include/net/mac80211.h"
struct ieee80211_sta {
   u32 supp_rates[2] ;
   u8 addr[6] ;
   u16 aid ;
   struct ieee80211_sta_ht_cap ht_cap ;
   u8 drv_priv[0]  __attribute__((__aligned__(sizeof(void *)))) ;
};
#line 826
enum sta_notify_cmd {
    STA_NOTIFY_ADD = 0,
    STA_NOTIFY_REMOVE = 1,
    STA_NOTIFY_SLEEP = 2,
    STA_NOTIFY_AWAKE = 3
} ;
#line 975 "include/net/mac80211.h"
struct ieee80211_hw {
   struct ieee80211_conf conf ;
   struct wiphy *wiphy ;
   char const   *rate_control_algorithm ;
   void *priv ;
   u32 flags ;
   unsigned int extra_tx_headroom ;
   int channel_change_time ;
   int vif_data_size ;
   int sta_data_size ;
   u16 queues ;
   u16 max_listen_interval ;
   s8 max_signal ;
   u8 max_rates ;
   u8 max_rate_tries ;
};
#line 1298
enum ieee80211_ampdu_mlme_action {
    IEEE80211_AMPDU_RX_START = 0,
    IEEE80211_AMPDU_RX_STOP = 1,
    IEEE80211_AMPDU_TX_START = 2,
    IEEE80211_AMPDU_TX_STOP = 3,
    IEEE80211_AMPDU_TX_OPERATIONAL = 4
} ;
#line 1467 "include/net/mac80211.h"
struct ieee80211_ops {
   int (*tx)(struct ieee80211_hw *hw , struct sk_buff *skb ) ;
   int (*start)(struct ieee80211_hw *hw ) ;
   void (*stop)(struct ieee80211_hw *hw ) ;
   int (*add_interface)(struct ieee80211_hw *hw , struct ieee80211_if_init_conf *conf ) ;
   void (*remove_interface)(struct ieee80211_hw *hw , struct ieee80211_if_init_conf *conf ) ;
   int (*config)(struct ieee80211_hw *hw , u32 changed ) ;
   void (*bss_info_changed)(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                            struct ieee80211_bss_conf *info , u32 changed ) ;
   u64 (*prepare_multicast)(struct ieee80211_hw *hw , int mc_count , struct dev_addr_list *mc_list ) ;
   void (*configure_filter)(struct ieee80211_hw *hw , unsigned int changed_flags ,
                            unsigned int *total_flags , u64 multicast ) ;
   int (*set_tim)(struct ieee80211_hw *hw , struct ieee80211_sta *sta , bool set ) ;
   int (*set_key)(struct ieee80211_hw *hw , enum set_key_cmd cmd , struct ieee80211_vif *vif ,
                  struct ieee80211_sta *sta , struct ieee80211_key_conf *key ) ;
   void (*update_tkip_key)(struct ieee80211_hw *hw , struct ieee80211_key_conf *conf ,
                           u8 const   *address , u32 iv32 , u16 *phase1key ) ;
   int (*hw_scan)(struct ieee80211_hw *hw , struct cfg80211_scan_request *req ) ;
   void (*sw_scan_start)(struct ieee80211_hw *hw ) ;
   void (*sw_scan_complete)(struct ieee80211_hw *hw ) ;
   int (*get_stats)(struct ieee80211_hw *hw , struct ieee80211_low_level_stats *stats ) ;
   void (*get_tkip_seq)(struct ieee80211_hw *hw , u8 hw_key_idx , u32 *iv32 , u16 *iv16 ) ;
   int (*set_rts_threshold)(struct ieee80211_hw *hw , u32 value ) ;
   void (*sta_notify)(struct ieee80211_hw *hw , struct ieee80211_vif *vif , enum sta_notify_cmd  ,
                      struct ieee80211_sta *sta ) ;
   int (*conf_tx)(struct ieee80211_hw *hw , u16 queue , struct ieee80211_tx_queue_params  const  *params ) ;
   int (*get_tx_stats)(struct ieee80211_hw *hw , struct ieee80211_tx_queue_stats *stats ) ;
   u64 (*get_tsf)(struct ieee80211_hw *hw ) ;
   void (*set_tsf)(struct ieee80211_hw *hw , u64 tsf ) ;
   void (*reset_tsf)(struct ieee80211_hw *hw ) ;
   int (*tx_last_beacon)(struct ieee80211_hw *hw ) ;
   int (*ampdu_action)(struct ieee80211_hw *hw , enum ieee80211_ampdu_mlme_action action ,
                       struct ieee80211_sta *sta , u16 tid , u16 *ssn ) ;
   void (*rfkill_poll)(struct ieee80211_hw *hw ) ;
   int (*testmode_cmd)(struct ieee80211_hw *hw , void *data , int len ) ;
};
#line 109 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct boot_attr {
   u32 radio_type ;
   u8 mac_clock ;
   u8 arm_clock ;
   int firmware_debug ;
   u32 minor ;
   u32 major ;
   u32 bugfix ;
};
#line 119
enum wl12xx_state {
    WL12XX_STATE_OFF = 0,
    WL12XX_STATE_ON = 1,
    WL12XX_STATE_PLT = 2
} ;
#line 133 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct wl12xx_partition {
   u32 size ;
   u32 start ;
};
#line 138 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct wl12xx_partition_set {
   struct wl12xx_partition mem ;
   struct wl12xx_partition reg ;
};
#line 143
struct wl12xx;
#line 143
struct wl12xx;
#line 146
enum wl12xx_acx_int_reg;
#line 146 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct wl12xx_chip {
   u32 id ;
   char const   *fw_filename ;
   char const   *nvs_filename ;
   char fw_ver[21] ;
   unsigned int power_on_sleep ;
   int intr_cmd_complete ;
   int intr_init_complete ;
   int (*op_upload_fw)(struct wl12xx *wl ) ;
   int (*op_upload_nvs)(struct wl12xx *wl ) ;
   int (*op_boot)(struct wl12xx *wl ) ;
   void (*op_set_ecpu_ctrl)(struct wl12xx *wl , u32 flag ) ;
   void (*op_target_enable_interrupts)(struct wl12xx *wl ) ;
   int (*op_hw_init)(struct wl12xx *wl ) ;
   int (*op_plt_init)(struct wl12xx *wl ) ;
   struct wl12xx_partition_set *p_table ;
   enum wl12xx_acx_int_reg *acx_reg_table ;
};
#line 170
struct acx_statistics;
#line 170 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct wl12xx_stats {
   struct acx_statistics *fw_stats ;
   unsigned long fw_stats_update ;
   unsigned int retry_count ;
   unsigned int excessive_retries ;
};
#line 178 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct wl12xx_debugfs {
   struct dentry *rootdir ;
   struct dentry *fw_statistics ;
   struct dentry *tx_internal_desc_overflow ;
   struct dentry *rx_out_of_mem ;
   struct dentry *rx_hdr_overflow ;
   struct dentry *rx_hw_stuck ;
   struct dentry *rx_dropped ;
   struct dentry *rx_fcs_err ;
   struct dentry *rx_xfr_hint_trig ;
   struct dentry *rx_path_reset ;
   struct dentry *rx_reset_counter ;
   struct dentry *dma_rx_requested ;
   struct dentry *dma_rx_errors ;
   struct dentry *dma_tx_requested ;
   struct dentry *dma_tx_errors ;
   struct dentry *isr_cmd_cmplt ;
   struct dentry *isr_fiqs ;
   struct dentry *isr_rx_headers ;
   struct dentry *isr_rx_mem_overflow ;
   struct dentry *isr_rx_rdys ;
   struct dentry *isr_irqs ;
   struct dentry *isr_tx_procs ;
   struct dentry *isr_decrypt_done ;
   struct dentry *isr_dma0_done ;
   struct dentry *isr_dma1_done ;
   struct dentry *isr_tx_exch_complete ;
   struct dentry *isr_commands ;
   struct dentry *isr_rx_procs ;
   struct dentry *isr_hw_pm_mode_changes ;
   struct dentry *isr_host_acknowledges ;
   struct dentry *isr_pci_pm ;
   struct dentry *isr_wakeups ;
   struct dentry *isr_low_rssi ;
   struct dentry *wep_addr_key_count ;
   struct dentry *wep_default_key_count ;
   struct dentry *wep_key_not_found ;
   struct dentry *wep_decrypt_fail ;
   struct dentry *wep_packets ;
   struct dentry *wep_interrupt ;
   struct dentry *pwr_ps_enter ;
   struct dentry *pwr_elp_enter ;
   struct dentry *pwr_missing_bcns ;
   struct dentry *pwr_wake_on_host ;
   struct dentry *pwr_wake_on_timer_exp ;
   struct dentry *pwr_tx_with_ps ;
   struct dentry *pwr_tx_without_ps ;
   struct dentry *pwr_rcvd_beacons ;
   struct dentry *pwr_power_save_off ;
   struct dentry *pwr_enable_ps ;
   struct dentry *pwr_disable_ps ;
   struct dentry *pwr_fix_tsf_ps ;
   struct dentry *pwr_rcvd_awake_beacons ;
   struct dentry *mic_rx_pkts ;
   struct dentry *mic_calc_failure ;
   struct dentry *aes_encrypt_fail ;
   struct dentry *aes_decrypt_fail ;
   struct dentry *aes_encrypt_packets ;
   struct dentry *aes_decrypt_packets ;
   struct dentry *aes_encrypt_interrupt ;
   struct dentry *aes_decrypt_interrupt ;
   struct dentry *event_heart_beat ;
   struct dentry *event_calibration ;
   struct dentry *event_rx_mismatch ;
   struct dentry *event_rx_mem_empty ;
   struct dentry *event_rx_pool ;
   struct dentry *event_oom_late ;
   struct dentry *event_phy_transmit_error ;
   struct dentry *event_tx_stuck ;
   struct dentry *ps_pspoll_timeouts ;
   struct dentry *ps_upsd_timeouts ;
   struct dentry *ps_upsd_max_sptime ;
   struct dentry *ps_upsd_max_apturn ;
   struct dentry *ps_pspoll_max_apturn ;
   struct dentry *ps_pspoll_utilization ;
   struct dentry *ps_upsd_utilization ;
   struct dentry *rxpipe_rx_prep_beacon_drop ;
   struct dentry *rxpipe_descr_host_int_trig_rx_data ;
   struct dentry *rxpipe_beacon_buffer_thres_host_int_trig_rx_data ;
   struct dentry *rxpipe_missed_beacon_host_int_trig_rx_data ;
   struct dentry *rxpipe_tx_xfr_host_int_trig_rx_data ;
   struct dentry *tx_queue_len ;
   struct dentry *retry_count ;
   struct dentry *excessive_retries ;
};
#line 279
struct acx_data_path_params_resp;
#line 279 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
struct wl12xx {
   struct ieee80211_hw *hw ;
   bool mac80211_registered ;
   struct spi_device *spi ;
   void (*set_power)(bool enable ) ;
   int irq ;
   enum wl12xx_state state ;
   struct mutex mutex ;
   int physical_mem_addr ;
   int physical_reg_addr ;
   int virtual_mem_addr ;
   int virtual_reg_addr ;
   struct wl12xx_chip chip ;
   int cmd_box_addr ;
   int event_box_addr ;
   struct boot_attr boot_attr ;
   u8 *fw ;
   size_t fw_len ;
   u8 *nvs ;
   size_t nvs_len ;
   u8 bssid[6] ;
   u8 mac_addr[6] ;
   u8 bss_type ;
   u8 listen_int ;
   int channel ;
   void *target_mem_map ;
   struct acx_data_path_params_resp *data_path ;
   u32 data_in_count ;
   struct sk_buff_head tx_queue ;
   bool tx_queue_stopped ;
   struct work_struct tx_work ;
   struct work_struct filter_work ;
   struct sk_buff *tx_frames[16] ;
   u32 next_tx_complete ;
   u32 rx_counter ;
   u32 rx_handled ;
   u32 rx_current_buffer ;
   u32 rx_last_id ;
   u32 intr_mask ;
   struct work_struct irq_work ;
   u32 event_mask ;
   u32 mbox_ptr[2] ;
   bool scanning ;
   u16 aid ;
   u32 default_key ;
   unsigned int tx_mgmt_frm_rate ;
   unsigned int tx_mgmt_frm_mod ;
   unsigned int rx_config ;
   unsigned int rx_filter ;
   bool elp ;
   bool psm ;
   bool psm_requested ;
   int power_level ;
   struct wl12xx_stats stats ;
   struct wl12xx_debugfs debugfs ;
};
#line 61 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct ieee80211_header {
   __le16 frame_ctl ;
   __le16 duration_id ;
   u8 da[6] ;
   u8 sa[6] ;
   u8 bssid[6] ;
   __le16 seq_ctl ;
   u8 payload[0] ;
} __attribute__((__packed__)) ;
#line 71 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct wl12xx_ie_header {
   u8 id ;
   u8 len ;
} __attribute__((__packed__)) ;
#line 78 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct wl12xx_ie_ssid {
   struct wl12xx_ie_header header ;
   char ssid[32] ;
} __attribute__((__packed__)) ;
#line 83 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct wl12xx_ie_rates {
   struct wl12xx_ie_header header ;
   u8 rates[32] ;
} __attribute__((__packed__)) ;
#line 120 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct wl12xx_null_data_template {
   struct ieee80211_header header ;
} __attribute__((__packed__)) ;
#line 124 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct wl12xx_ps_poll_template {
   u16 fc ;
   u16 aid ;
   u8 bssid[6] ;
   u8 ta[6] ;
} __attribute__((__packed__)) ;
#line 136 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx_80211.h"
struct wl12xx_probe_req_template {
   struct ieee80211_header header ;
   struct wl12xx_ie_ssid ssid ;
   struct wl12xx_ie_rates rates ;
   struct wl12xx_ie_rates ext_rates ;
} __attribute__((__packed__)) ;
#line 167 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/reg.h"
enum wl12xx_acx_int_reg {
    ACX_REG_INTERRUPT_TRIG = 0,
    ACX_REG_INTERRUPT_TRIG_H = 1,
    ACX_REG_INTERRUPT_MASK = 2,
    ACX_REG_HINT_MASK_SET = 3,
    ACX_REG_HINT_MASK_CLR = 4,
    ACX_REG_INTERRUPT_NO_CLEAR = 5,
    ACX_REG_INTERRUPT_CLEAR = 6,
    ACX_REG_INTERRUPT_ACK = 7,
    ACX_REG_SLV_SOFT_RESET = 8,
    ACX_REG_EE_START = 9,
    ACX_REG_ECPU_CONTROL = 10,
    ACX_REG_TABLE_LEN = 11
} ;
#line 31 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_header {
   u16 id ;
   u16 len ;
};
#line 178 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_data_path_params_resp {
   struct acx_header header ;
   u16 rx_packet_ring_chunk_size ;
   u16 tx_packet_ring_chunk_size ;
   u8 rx_packet_ring_chunk_num ;
   u8 tx_packet_ring_chunk_num ;
   u8 pad[2] ;
   u32 rx_packet_ring_addr ;
   u32 tx_packet_ring_addr ;
   u32 rx_control_addr ;
   u32 tx_control_addr ;
   u32 tx_complete_addr ;
} __attribute__((__packed__)) ;
#line 350
enum acx_slot_type {
    SLOT_TIME_LONG = 0,
    SLOT_TIME_SHORT = 1,
    DEFAULT_SLOT_TIME = 1,
    MAX_SLOT_TIMES = 255
} ;
#line 790 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_set_key {
   u8 addr[6] ;
   u16 key_action ;
   u16 reserved_1 ;
   u8 key_size ;
   u8 key_type ;
   u8 ssid_profile ;
   u8 id ;
   u8 reserved_2[6] ;
   u8 key[32] ;
   u16 ac_seq_num16[4] ;
   u32 ac_seq_num32[4] ;
} __attribute__((__packed__)) ;
#line 843
enum acx_ps_mode {
    STATION_ACTIVE_MODE = 0,
    STATION_POWER_SAVE_MODE = 1
} ;
#line 888
enum acx_preamble_type {
    ACX_PREAMBLE_LONG = 0,
    ACX_PREAMBLE_SHORT = 1
} ;
#line 903
enum acx_ctsprotect_type {
    CTSPROTECT_DISABLE = 0,
    CTSPROTECT_ENABLE = 1
} ;
#line 914 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_tx_statistics {
   u32 internal_desc_overflow ;
} __attribute__((__packed__)) ;
#line 918 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_rx_statistics {
   u32 out_of_mem ;
   u32 hdr_overflow ;
   u32 hw_stuck ;
   u32 dropped ;
   u32 fcs_err ;
   u32 xfr_hint_trig ;
   u32 path_reset ;
   u32 reset_counter ;
} __attribute__((__packed__)) ;
#line 929 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_dma_statistics {
   u32 rx_requested ;
   u32 rx_errors ;
   u32 tx_requested ;
   u32 tx_errors ;
} __attribute__((__packed__)) ;
#line 936 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_isr_statistics {
   u32 cmd_cmplt ;
   u32 fiqs ;
   u32 rx_headers ;
   u32 rx_completes ;
   u32 rx_mem_overflow ;
   u32 rx_rdys ;
   u32 irqs ;
   u32 tx_procs ;
   u32 decrypt_done ;
   u32 dma0_done ;
   u32 dma1_done ;
   u32 tx_exch_complete ;
   u32 commands ;
   u32 rx_procs ;
   u32 hw_pm_mode_changes ;
   u32 host_acknowledges ;
   u32 pci_pm ;
   u32 wakeups ;
   u32 low_rssi ;
} __attribute__((__packed__)) ;
#line 995 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_wep_statistics {
   u32 addr_key_count ;
   u32 default_key_count ;
   u32 reserved ;
   u32 key_not_found ;
   u32 decrypt_fail ;
   u32 packets ;
   u32 interrupt ;
} __attribute__((__packed__)) ;
#line 1019 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_pwr_statistics {
   u32 ps_enter ;
   u32 elp_enter ;
   u32 missing_bcns ;
   u32 wake_on_host ;
   u32 wake_on_timer_exp ;
   u32 tx_with_ps ;
   u32 tx_without_ps ;
   u32 rcvd_beacons ;
   u32 power_save_off ;
   u16 enable_ps ;
   u16 disable_ps ;
   u32 fix_tsf_ps ;
   u32 cont_miss_bcns_spread[10] ;
   u32 rcvd_awake_beacons ;
} __attribute__((__packed__)) ;
#line 1077 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_mic_statistics {
   u32 rx_pkts ;
   u32 calc_failure ;
} __attribute__((__packed__)) ;
#line 1082 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_aes_statistics {
   u32 encrypt_fail ;
   u32 decrypt_fail ;
   u32 encrypt_packets ;
   u32 decrypt_packets ;
   u32 encrypt_interrupt ;
   u32 decrypt_interrupt ;
} __attribute__((__packed__)) ;
#line 1091 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_event_statistics {
   u32 heart_beat ;
   u32 calibration ;
   u32 rx_mismatch ;
   u32 rx_mem_empty ;
   u32 rx_pool ;
   u32 oom_late ;
   u32 phy_transmit_error ;
   u32 tx_stuck ;
} __attribute__((__packed__)) ;
#line 1102 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_ps_statistics {
   u32 pspoll_timeouts ;
   u32 upsd_timeouts ;
   u32 upsd_max_sptime ;
   u32 upsd_max_apturn ;
   u32 pspoll_max_apturn ;
   u32 pspoll_utilization ;
   u32 upsd_utilization ;
} __attribute__((__packed__)) ;
#line 1112 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_rxpipe_statistics {
   u32 rx_prep_beacon_drop ;
   u32 descr_host_int_trig_rx_data ;
   u32 beacon_buffer_thres_host_int_trig_rx_data ;
   u32 missed_beacon_host_int_trig_rx_data ;
   u32 tx_xfr_host_int_trig_rx_data ;
} __attribute__((__packed__)) ;
#line 1120 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
struct acx_statistics {
   struct acx_header header ;
   struct acx_tx_statistics tx ;
   struct acx_rx_statistics rx ;
   struct acx_dma_statistics dma ;
   struct acx_isr_statistics isr ;
   struct acx_wep_statistics wep ;
   struct acx_pwr_statistics pwr ;
   struct acx_aes_statistics aes ;
   struct acx_mic_statistics mic ;
   struct acx_event_statistics event ;
   struct acx_ps_statistics ps ;
   struct acx_rxpipe_statistics rxpipe ;
} __attribute__((__packed__)) ;
#line 103 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/cmd.h"
struct wl12xx_command {
   u16 id ;
   u16 status ;
   u8 parameters[572] ;
};
#line 164 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/cmd.h"
struct basic_scan_parameters {
   u32 rx_config_options ;
   u32 rx_filter_options ;
   u16 scan_options ;
   u8 num_channels ;
   u8 num_probe_requests ;
   u16 tx_rate ;
   u8 tid_trigger ;
   u8 ssid_len ;
   u32 ssid[8] ;
} __attribute__((__packed__)) ;
#line 193 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/cmd.h"
struct basic_scan_channel_parameters {
   u32 min_duration ;
   u32 max_duration ;
   u32 bssid_lsb ;
   u16 bssid_msb ;
   u8 early_termination ;
   u8 tx_power_att ;
   u8 channel ;
   u8 pad[3] ;
} __attribute__((__packed__)) ;
#line 213 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/cmd.h"
struct cmd_scan {
   struct basic_scan_parameters params ;
   struct basic_scan_channel_parameters channels[16] ;
} __attribute__((__packed__)) ;
#line 81 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/tx.h"
struct tx_control {
   unsigned int rate_policy : 3 ;
   unsigned int ack_policy : 1 ;
   unsigned int packet_type : 2 ;
   unsigned int qos : 1 ;
   unsigned int tx_complete : 1 ;
   unsigned int xfer_pad : 1 ;
   unsigned int reserved : 7 ;
} __attribute__((__packed__)) ;
#line 113 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/tx.h"
struct tx_double_buffer_desc {
   u16 length ;
   u16 rate ;
   u32 expiry_time ;
   u8 xmit_queue ;
   u8 id ;
   struct tx_control control ;
   u16 frag_threshold ;
   u8 num_mem_blocks ;
   u8 reserved ;
} __attribute__((__packed__)) ;
#line 1109 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
struct __anonstruct_310 {
   int  : 0 ;
};
#line 1109 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
struct __anonstruct_311 {
   int  : 0 ;
};
#line 1 "<compiler builtins>"
long __builtin_expect(long  , long  ) ;
#line 21 "include/linux/log2.h"
extern  __attribute__((__noreturn__)) int ____ilog2_NaN(void)  __attribute__((__const__)) ;
#line 63 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   *file , int const   line ) ;
#line 241 "include/linux/kernel.h"
extern int ( /* format attribute */ __attribute__((__regparm__(0))) printk)(char const   *fmt 
                                                                            , ...)  __attribute__((__cold__)) ;
#line 32 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/string_32.h"
__inline static void *( __attribute__((__always_inline__)) __memcpy)(void *to , void const   *from ,
                                                                     size_t n ) 
{ int d0 ;
  int d1 ;
  int d2 ;

  {
#line 35
  __asm__  volatile   ("rep ; movsl\n\t"
                       "movl %4,%%ecx\n\t"
                       "andl $3,%%ecx\n\t"
                       "jz 1f\n\t"
                       "rep ; movsb\n\t"
                       "1:": "=&c" (d0), "=&D" (d1), "=&S" (d2): "0" (n / 4U), "g" (n),
                       "1" ((long )to), "2" ((long )from): "memory");
#line 44
  return (to);
}
}
#line 51 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/string_32.h"
__inline static void *( __attribute__((__always_inline__)) __constant_memcpy)(void *to ,
                                                                              void const   *from ,
                                                                              size_t n ) 
{ long esi ;
  long edi ;
  int ecx ;

  {
#line 55
  if (! n) {
#line 56
    return (to);
  } else {

  }
#line 59
  if ((int )n == 1) {
    goto switch_0_1;
  } else {
#line 62
    if ((int )n == 2) {
      goto switch_0_2;
    } else {
#line 65
      if ((int )n == 4) {
        goto switch_0_4;
      } else {
#line 68
        if ((int )n == 3) {
          goto switch_0_3;
        } else {
#line 72
          if ((int )n == 5) {
            goto switch_0_5;
          } else {
#line 76
            if ((int )n == 6) {
              goto switch_0_6;
            } else {
#line 80
              if ((int )n == 8) {
                goto switch_0_8;
              } else {
#line 58
                if (0) {
                  switch_0_1: /* CIL Label */ 
#line 60
                  *((char *)to) = *((char *)from);
#line 61
                  return (to);
                  switch_0_2: /* CIL Label */ 
#line 63
                  *((short *)to) = *((short *)from);
#line 64
                  return (to);
                  switch_0_4: /* CIL Label */ 
#line 66
                  *((int *)to) = *((int *)from);
#line 67
                  return (to);
                  switch_0_3: /* CIL Label */ 
#line 69
                  *((short *)to) = *((short *)from);
#line 70
                  *((char *)to + 2) = *((char *)from + 2);
#line 71
                  return (to);
                  switch_0_5: /* CIL Label */ 
#line 73
                  *((int *)to) = *((int *)from);
#line 74
                  *((char *)to + 4) = *((char *)from + 4);
#line 75
                  return (to);
                  switch_0_6: /* CIL Label */ 
#line 77
                  *((int *)to) = *((int *)from);
#line 78
                  *((short *)to + 2) = *((short *)from + 2);
#line 79
                  return (to);
                  switch_0_8: /* CIL Label */ 
#line 81
                  *((int *)to) = *((int *)from);
#line 82
                  *((int *)to + 1) = *((int *)from + 1);
#line 83
                  return (to);
                } else {
                  switch_0_break: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 86
  esi = (long )from;
#line 87
  edi = (long )to;
#line 88
  if (n >= 20U) {
#line 91
    __asm__  volatile   ("rep ; movsl": "=&c" (ecx), "=&D" (edi), "=&S" (esi): "0" (n / 4U),
                         "1" (edi), "2" (esi): "memory");
  } else {
#line 98
    if (n >= 16U) {
#line 99
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    } else {

    }
#line 103
    if (n >= 12U) {
#line 104
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    } else {

    }
#line 108
    if (n >= 8U) {
#line 109
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    } else {

    }
#line 113
    if (n >= 4U) {
#line 114
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    } else {

    }
  }
#line 121
  if ((int )(n % 4U) == 0) {
    goto switch_1_0;
  } else {
#line 123
    if ((int )(n % 4U) == 1) {
      goto switch_1_1;
    } else {
#line 129
      if ((int )(n % 4U) == 2) {
        goto switch_1_2;
      } else {
        {
        goto switch_1_default;
#line 119
        if (0) {
          switch_1_0: /* CIL Label */ 
#line 122
          return (to);
          switch_1_1: /* CIL Label */ 
#line 124
          __asm__  volatile   ("movsb": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
#line 128
          return (to);
          switch_1_2: /* CIL Label */ 
#line 130
          __asm__  volatile   ("movsw": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
#line 134
          return (to);
          switch_1_default: /* CIL Label */ 
#line 136
          __asm__  volatile   ("movsw\n\tmovsb": "=&D" (edi), "=&S" (esi): "0" (edi),
                               "1" (esi): "memory");
#line 140
          return (to);
        } else {
          switch_1_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
#line 251 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/string_32.h"
__inline static void *( __attribute__((__always_inline__)) __constant_c_and_count_memset)(void *s ,
                                                                                          unsigned long pattern ,
                                                                                          size_t count ) 
{ int d0 ;
  int d1 ;
  unsigned long eax ;

  {
#line 256
  if ((int )count == 0) {
    goto switch_2_0;
  } else {
#line 258
    if ((int )count == 1) {
      goto switch_2_1;
    } else {
#line 261
      if ((int )count == 2) {
        goto switch_2_2;
      } else {
#line 264
        if ((int )count == 3) {
          goto switch_2_3;
        } else {
#line 268
          if ((int )count == 4) {
            goto switch_2_4;
          } else {
#line 255
            if (0) {
              switch_2_0: /* CIL Label */ 
#line 257
              return (s);
              switch_2_1: /* CIL Label */ 
#line 259
              *((unsigned char *)s) = (unsigned char )(pattern & 255UL);
#line 260
              return (s);
              switch_2_2: /* CIL Label */ 
#line 262
              *((unsigned short *)s) = (unsigned short )(pattern & 65535UL);
#line 263
              return (s);
              switch_2_3: /* CIL Label */ 
#line 265
              *((unsigned short *)s) = (unsigned short )(pattern & 65535UL);
#line 266
              *((unsigned char *)s + 2) = (unsigned char )(pattern & 255UL);
#line 267
              return (s);
              switch_2_4: /* CIL Label */ 
#line 269
              *((unsigned long *)s) = pattern;
#line 270
              return (s);
            } else {
              switch_2_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 286
  eax = pattern;
#line 290
  if ((int )(count % 4U) == 0) {
    goto switch_3_0;
  } else {
#line 293
    if ((int )(count % 4U) == 1) {
      goto switch_3_1;
    } else {
#line 296
      if ((int )(count % 4U) == 2) {
        goto switch_3_2;
      } else {
        {
        goto switch_3_default;
#line 289
        if (0) {
          switch_3_0: /* CIL Label */ 
#line 291
          __asm__  volatile   ("rep ; stosl"
                               "": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
#line 292
          return (s);
          switch_3_1: /* CIL Label */ 
#line 294
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
#line 295
          return (s);
          switch_3_2: /* CIL Label */ 
#line 297
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
#line 298
          return (s);
          switch_3_default: /* CIL Label */ 
#line 300
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax),
                               "0" (count / 4U), "1" ((long )s): "memory");
#line 301
          return (s);
        } else {
          switch_3_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
#line 101 "include/linux/string.h"
extern int __builtin_memcmp(void const   * , void const   * , __kernel_size_t  ) ;
#line 9 "include/asm-generic/getorder.h"
__inline static int ( __attribute__((__always_inline__)) get_order)(unsigned long size )  __attribute__((__const__)) ;
#line 9 "include/asm-generic/getorder.h"
__inline static int ( __attribute__((__always_inline__)) get_order)(unsigned long size ) 
{ int order ;

  {
#line 13
  size = (size - 1UL) >> 11;
#line 14
  order = -1;
  {
#line 15
  while (1) {
    while_4_continue: /* CIL Label */ ;
#line 16
    size = size >> 1;
#line 17
    order = order + 1;
#line 15
    if (size) {

    } else {
      goto while_4_break;
    }
  }
  while_4_break: /* CIL Label */ ;
  }
#line 19
  return (order);
}
}
#line 28 "include/linux/list.h"
__inline static void ( __attribute__((__always_inline__)) INIT_LIST_HEAD)(struct list_head *list ) 
{ 

  {
#line 30
  list->next = list;
#line 31
  list->prev = list;
#line 32
  return;
}
}
#line 178 "/home/mutilin/.ldv/ldv/envs/1/linux-2.6.32.9/arch/x86/include/asm/thread_info.h"
register unsigned long current_stack_pointer  __asm__("esp") __attribute__((__used__))  ;
#line 94 "include/linux/spinlock.h"
extern void __spin_lock_init(spinlock_t *lock , char const   *name , struct lock_class_key *key ) ;
#line 107 "include/linux/mutex.h"
extern void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) ;
#line 136
void mutex_lock(struct mutex *lock ) ;
#line 137
int mutex_lock_interruptible(struct mutex *lock ) ;
#line 138
int mutex_lock_killable(struct mutex *lock ) ;
#line 151
int mutex_trylock(struct mutex *lock ) ;
#line 152
void mutex_unlock(struct mutex *lock ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int msecs ) ;
#line 212 "include/linux/workqueue.h"
extern int schedule_work(struct work_struct *work ) ;
#line 226
extern int cancel_work_sync(struct work_struct *work ) ;
#line 314 "include/linux/gfp.h"
extern unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 201 "include/linux/rcupdate.h"
__inline static void ( __attribute__((__always_inline__)) rcu_read_lock_sched_notrace)(void)  __attribute__((__no_instrument_function__)) ;
#line 201 "include/linux/rcupdate.h"
__inline static void ( __attribute__((__always_inline__)) rcu_read_lock_sched_notrace)(void) 
{ 

  {
  {
#line 203
  while (1) {
    while_5_continue: /* CIL Label */ ;
    goto while_5_break;
  }
  while_5_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 220
__inline static void ( __attribute__((__always_inline__)) rcu_read_unlock_sched_notrace)(void)  __attribute__((__no_instrument_function__)) ;
#line 220 "include/linux/rcupdate.h"
__inline static void ( __attribute__((__always_inline__)) rcu_read_unlock_sched_notrace)(void) 
{ 

  {
  {
#line 223
  while (1) {
    while_6_continue: /* CIL Label */ ;
    goto while_6_break;
  }
  while_6_break: /* CIL Label */ ;
  }
#line 224
  return;
}
}
#line 138 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 47 "include/trace/events/kmem.h"
extern struct tracepoint __tracepoint_kmalloc ;
#line 47 "include/trace/events/kmem.h"
__inline static void ( __attribute__((__always_inline__)) trace_kmalloc)(unsigned long call_site ,
                                                                         void const   *ptr ,
                                                                         size_t bytes_req ,
                                                                         size_t bytes_alloc ,
                                                                         gfp_t gfp_flags ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 47
  tmp = __builtin_expect((long )(! (! __tracepoint_kmalloc.state)), 0L);
  }
#line 47
  if (tmp) {
    {
#line 47
    while (1) {
      while_7_continue: /* CIL Label */ ;
      {
#line 47
      rcu_read_lock_sched_notrace();
#line 47
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmalloc.funcs));
      }
      {
#line 47
      while (1) {
        while_8_continue: /* CIL Label */ ;
        goto while_8_break;
      }
      while_8_break: /* CIL Label */ ;
      }
#line 47
      it_func = _________p1;
#line 47
      if (it_func) {
        {
#line 47
        while (1) {
          while_9_continue: /* CIL Label */ ;
          {
#line 47
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags ))*it_func))(call_site,
                                                                         ptr, bytes_req,
                                                                         bytes_alloc,
                                                                         gfp_flags);
#line 47
          it_func = it_func + 1;
          }
#line 47
          if (*it_func) {

          } else {
            goto while_9_break;
          }
        }
        while_9_break: /* CIL Label */ ;
        }
      } else {

      }
      {
#line 47
      rcu_read_unlock_sched_notrace();
      }
      goto while_7_break;
    }
    while_7_break: /* CIL Label */ ;
    }
  } else {

  }
#line 47
  return;
}
}
#line 63 "include/linux/kmemleak.h"
__inline static void ( __attribute__((__always_inline__)) kmemleak_alloc)(void const   *ptr ,
                                                                          size_t size ,
                                                                          int min_count ,
                                                                          gfp_t gfp ) 
{ 

  {
#line 66
  return;
}
}
#line 142 "include/linux/slub_def.h"
extern struct kmem_cache kmalloc_caches[14] ;
#line 148 "include/linux/slub_def.h"
__inline static int ( __attribute__((__always_inline__)) kmalloc_index)(size_t size ) 
{ int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;

  {
#line 150
  if (! size) {
#line 151
    return (0);
  } else {

  }
#line 153
  if (size <= 8U) {
#line 154
    if (8ULL & (1ULL << 63)) {
#line 154
      tmp___63 = 63;
    } else {
#line 154
      if (8ULL & (1ULL << 62)) {
#line 154
        tmp___62 = 62;
      } else {
#line 154
        if (8ULL & (1ULL << 61)) {
#line 154
          tmp___61 = 61;
        } else {
#line 154
          if (8ULL & (1ULL << 60)) {
#line 154
            tmp___60 = 60;
          } else {
#line 154
            if (8ULL & (1ULL << 59)) {
#line 154
              tmp___59 = 59;
            } else {
#line 154
              if (8ULL & (1ULL << 58)) {
#line 154
                tmp___58 = 58;
              } else {
#line 154
                if (8ULL & (1ULL << 57)) {
#line 154
                  tmp___57 = 57;
                } else {
#line 154
                  if (8ULL & (1ULL << 56)) {
#line 154
                    tmp___56 = 56;
                  } else {
#line 154
                    if (8ULL & (1ULL << 55)) {
#line 154
                      tmp___55 = 55;
                    } else {
#line 154
                      if (8ULL & (1ULL << 54)) {
#line 154
                        tmp___54 = 54;
                      } else {
#line 154
                        if (8ULL & (1ULL << 53)) {
#line 154
                          tmp___53 = 53;
                        } else {
#line 154
                          if (8ULL & (1ULL << 52)) {
#line 154
                            tmp___52 = 52;
                          } else {
#line 154
                            if (8ULL & (1ULL << 51)) {
#line 154
                              tmp___51 = 51;
                            } else {
#line 154
                              if (8ULL & (1ULL << 50)) {
#line 154
                                tmp___50 = 50;
                              } else {
#line 154
                                if (8ULL & (1ULL << 49)) {
#line 154
                                  tmp___49 = 49;
                                } else {
#line 154
                                  if (8ULL & (1ULL << 48)) {
#line 154
                                    tmp___48 = 48;
                                  } else {
#line 154
                                    if (8ULL & (1ULL << 47)) {
#line 154
                                      tmp___47 = 47;
                                    } else {
#line 154
                                      if (8ULL & (1ULL << 46)) {
#line 154
                                        tmp___46 = 46;
                                      } else {
#line 154
                                        if (8ULL & (1ULL << 45)) {
#line 154
                                          tmp___45 = 45;
                                        } else {
#line 154
                                          if (8ULL & (1ULL << 44)) {
#line 154
                                            tmp___44 = 44;
                                          } else {
#line 154
                                            if (8ULL & (1ULL << 43)) {
#line 154
                                              tmp___43 = 43;
                                            } else {
#line 154
                                              if (8ULL & (1ULL << 42)) {
#line 154
                                                tmp___42 = 42;
                                              } else {
#line 154
                                                if (8ULL & (1ULL << 41)) {
#line 154
                                                  tmp___41 = 41;
                                                } else {
#line 154
                                                  if (8ULL & (1ULL << 40)) {
#line 154
                                                    tmp___40 = 40;
                                                  } else {
#line 154
                                                    if (8ULL & (1ULL << 39)) {
#line 154
                                                      tmp___39 = 39;
                                                    } else {
#line 154
                                                      if (8ULL & (1ULL << 38)) {
#line 154
                                                        tmp___38 = 38;
                                                      } else {
#line 154
                                                        if (8ULL & (1ULL << 37)) {
#line 154
                                                          tmp___37 = 37;
                                                        } else {
#line 154
                                                          if (8ULL & (1ULL << 36)) {
#line 154
                                                            tmp___36 = 36;
                                                          } else {
#line 154
                                                            if (8ULL & (1ULL << 35)) {
#line 154
                                                              tmp___35 = 35;
                                                            } else {
#line 154
                                                              if (8ULL & (1ULL << 34)) {
#line 154
                                                                tmp___34 = 34;
                                                              } else {
#line 154
                                                                if (8ULL & (1ULL << 33)) {
#line 154
                                                                  tmp___33 = 33;
                                                                } else {
#line 154
                                                                  if (8ULL & (1ULL << 32)) {
#line 154
                                                                    tmp___32 = 32;
                                                                  } else {
#line 154
                                                                    if (8ULL & (1ULL << 31)) {
#line 154
                                                                      tmp___31 = 31;
                                                                    } else {
#line 154
                                                                      if (8ULL & (1ULL << 30)) {
#line 154
                                                                        tmp___30 = 30;
                                                                      } else {
#line 154
                                                                        if (8ULL & (1ULL << 29)) {
#line 154
                                                                          tmp___29 = 29;
                                                                        } else {
#line 154
                                                                          if (8ULL & (1ULL << 28)) {
#line 154
                                                                            tmp___28 = 28;
                                                                          } else {
#line 154
                                                                            if (8ULL & (1ULL << 27)) {
#line 154
                                                                              tmp___27 = 27;
                                                                            } else {
#line 154
                                                                              if (8ULL & (1ULL << 26)) {
#line 154
                                                                                tmp___26 = 26;
                                                                              } else {
#line 154
                                                                                if (8ULL & (1ULL << 25)) {
#line 154
                                                                                  tmp___25 = 25;
                                                                                } else {
#line 154
                                                                                  if (8ULL & (1ULL << 24)) {
#line 154
                                                                                    tmp___24 = 24;
                                                                                  } else {
#line 154
                                                                                    if (8ULL & (1ULL << 23)) {
#line 154
                                                                                      tmp___23 = 23;
                                                                                    } else {
#line 154
                                                                                      if (8ULL & (1ULL << 22)) {
#line 154
                                                                                        tmp___22 = 22;
                                                                                      } else {
#line 154
                                                                                        if (8ULL & (1ULL << 21)) {
#line 154
                                                                                          tmp___21 = 21;
                                                                                        } else {
#line 154
                                                                                          if (8ULL & (1ULL << 20)) {
#line 154
                                                                                            tmp___20 = 20;
                                                                                          } else {
#line 154
                                                                                            if (8ULL & (1ULL << 19)) {
#line 154
                                                                                              tmp___19 = 19;
                                                                                            } else {
#line 154
                                                                                              if (8ULL & (1ULL << 18)) {
#line 154
                                                                                                tmp___18 = 18;
                                                                                              } else {
#line 154
                                                                                                if (8ULL & (1ULL << 17)) {
#line 154
                                                                                                  tmp___17 = 17;
                                                                                                } else {
#line 154
                                                                                                  if (8ULL & (1ULL << 16)) {
#line 154
                                                                                                    tmp___16 = 16;
                                                                                                  } else {
#line 154
                                                                                                    if (8ULL & (1ULL << 15)) {
#line 154
                                                                                                      tmp___15 = 15;
                                                                                                    } else {
#line 154
                                                                                                      if (8ULL & (1ULL << 14)) {
#line 154
                                                                                                        tmp___14 = 14;
                                                                                                      } else {
#line 154
                                                                                                        if (8ULL & (1ULL << 13)) {
#line 154
                                                                                                          tmp___13 = 13;
                                                                                                        } else {
#line 154
                                                                                                          if (8ULL & (1ULL << 12)) {
#line 154
                                                                                                            tmp___12 = 12;
                                                                                                          } else {
#line 154
                                                                                                            if (8ULL & (1ULL << 11)) {
#line 154
                                                                                                              tmp___11 = 11;
                                                                                                            } else {
#line 154
                                                                                                              if (8ULL & (1ULL << 10)) {
#line 154
                                                                                                                tmp___10 = 10;
                                                                                                              } else {
#line 154
                                                                                                                if (8ULL & (1ULL << 9)) {
#line 154
                                                                                                                  tmp___9 = 9;
                                                                                                                } else {
#line 154
                                                                                                                  if (8ULL & (1ULL << 8)) {
#line 154
                                                                                                                    tmp___8 = 8;
                                                                                                                  } else {
#line 154
                                                                                                                    if (8ULL & (1ULL << 7)) {
#line 154
                                                                                                                      tmp___7 = 7;
                                                                                                                    } else {
#line 154
                                                                                                                      if (8ULL & (1ULL << 6)) {
#line 154
                                                                                                                        tmp___6 = 6;
                                                                                                                      } else {
#line 154
                                                                                                                        if (8ULL & (1ULL << 5)) {
#line 154
                                                                                                                          tmp___5 = 5;
                                                                                                                        } else {
#line 154
                                                                                                                          if (8ULL & (1ULL << 4)) {
#line 154
                                                                                                                            tmp___4 = 4;
                                                                                                                          } else {
#line 154
                                                                                                                            if (8ULL & (1ULL << 3)) {
#line 154
                                                                                                                              tmp___3 = 3;
                                                                                                                            } else {
#line 154
                                                                                                                              if (8ULL & (1ULL << 2)) {
#line 154
                                                                                                                                tmp___2 = 2;
                                                                                                                              } else {
#line 154
                                                                                                                                if (8ULL & (1ULL << 1)) {
#line 154
                                                                                                                                  tmp___1 = 1;
                                                                                                                                } else {
                                                                                                                                  {
#line 154
                                                                                                                                  tmp___0 = ____ilog2_NaN();
#line 154
                                                                                                                                  tmp___1 = tmp___0;
                                                                                                                                  }
                                                                                                                                }
#line 154
                                                                                                                                tmp___2 = tmp___1;
                                                                                                                              }
#line 154
                                                                                                                              tmp___3 = tmp___2;
                                                                                                                            }
#line 154
                                                                                                                            tmp___4 = tmp___3;
                                                                                                                          }
#line 154
                                                                                                                          tmp___5 = tmp___4;
                                                                                                                        }
#line 154
                                                                                                                        tmp___6 = tmp___5;
                                                                                                                      }
#line 154
                                                                                                                      tmp___7 = tmp___6;
                                                                                                                    }
#line 154
                                                                                                                    tmp___8 = tmp___7;
                                                                                                                  }
#line 154
                                                                                                                  tmp___9 = tmp___8;
                                                                                                                }
#line 154
                                                                                                                tmp___10 = tmp___9;
                                                                                                              }
#line 154
                                                                                                              tmp___11 = tmp___10;
                                                                                                            }
#line 154
                                                                                                            tmp___12 = tmp___11;
                                                                                                          }
#line 154
                                                                                                          tmp___13 = tmp___12;
                                                                                                        }
#line 154
                                                                                                        tmp___14 = tmp___13;
                                                                                                      }
#line 154
                                                                                                      tmp___15 = tmp___14;
                                                                                                    }
#line 154
                                                                                                    tmp___16 = tmp___15;
                                                                                                  }
#line 154
                                                                                                  tmp___17 = tmp___16;
                                                                                                }
#line 154
                                                                                                tmp___18 = tmp___17;
                                                                                              }
#line 154
                                                                                              tmp___19 = tmp___18;
                                                                                            }
#line 154
                                                                                            tmp___20 = tmp___19;
                                                                                          }
#line 154
                                                                                          tmp___21 = tmp___20;
                                                                                        }
#line 154
                                                                                        tmp___22 = tmp___21;
                                                                                      }
#line 154
                                                                                      tmp___23 = tmp___22;
                                                                                    }
#line 154
                                                                                    tmp___24 = tmp___23;
                                                                                  }
#line 154
                                                                                  tmp___25 = tmp___24;
                                                                                }
#line 154
                                                                                tmp___26 = tmp___25;
                                                                              }
#line 154
                                                                              tmp___27 = tmp___26;
                                                                            }
#line 154
                                                                            tmp___28 = tmp___27;
                                                                          }
#line 154
                                                                          tmp___29 = tmp___28;
                                                                        }
#line 154
                                                                        tmp___30 = tmp___29;
                                                                      }
#line 154
                                                                      tmp___31 = tmp___30;
                                                                    }
#line 154
                                                                    tmp___32 = tmp___31;
                                                                  }
#line 154
                                                                  tmp___33 = tmp___32;
                                                                }
#line 154
                                                                tmp___34 = tmp___33;
                                                              }
#line 154
                                                              tmp___35 = tmp___34;
                                                            }
#line 154
                                                            tmp___36 = tmp___35;
                                                          }
#line 154
                                                          tmp___37 = tmp___36;
                                                        }
#line 154
                                                        tmp___38 = tmp___37;
                                                      }
#line 154
                                                      tmp___39 = tmp___38;
                                                    }
#line 154
                                                    tmp___40 = tmp___39;
                                                  }
#line 154
                                                  tmp___41 = tmp___40;
                                                }
#line 154
                                                tmp___42 = tmp___41;
                                              }
#line 154
                                              tmp___43 = tmp___42;
                                            }
#line 154
                                            tmp___44 = tmp___43;
                                          }
#line 154
                                          tmp___45 = tmp___44;
                                        }
#line 154
                                        tmp___46 = tmp___45;
                                      }
#line 154
                                      tmp___47 = tmp___46;
                                    }
#line 154
                                    tmp___48 = tmp___47;
                                  }
#line 154
                                  tmp___49 = tmp___48;
                                }
#line 154
                                tmp___50 = tmp___49;
                              }
#line 154
                              tmp___51 = tmp___50;
                            }
#line 154
                            tmp___52 = tmp___51;
                          }
#line 154
                          tmp___53 = tmp___52;
                        }
#line 154
                        tmp___54 = tmp___53;
                      }
#line 154
                      tmp___55 = tmp___54;
                    }
#line 154
                    tmp___56 = tmp___55;
                  }
#line 154
                  tmp___57 = tmp___56;
                }
#line 154
                tmp___58 = tmp___57;
              }
#line 154
              tmp___59 = tmp___58;
            }
#line 154
            tmp___60 = tmp___59;
          }
#line 154
          tmp___61 = tmp___60;
        }
#line 154
        tmp___62 = tmp___61;
      }
#line 154
      tmp___63 = tmp___62;
    }
#line 154
    return (tmp___63);
  } else {

  }
#line 156
  if (size > 64U) {
#line 156
    if (size <= 96U) {
#line 157
      return (1);
    } else {

    }
  } else {

  }
#line 158
  if (size > 128U) {
#line 158
    if (size <= 192U) {
#line 159
      return (2);
    } else {

    }
  } else {

  }
#line 160
  if (size <= 8U) {
#line 160
    return (3);
  } else {

  }
#line 161
  if (size <= 16U) {
#line 161
    return (4);
  } else {

  }
#line 162
  if (size <= 32U) {
#line 162
    return (5);
  } else {

  }
#line 163
  if (size <= 64U) {
#line 163
    return (6);
  } else {

  }
#line 164
  if (size <= 128U) {
#line 164
    return (7);
  } else {

  }
#line 165
  if (size <= 256U) {
#line 165
    return (8);
  } else {

  }
#line 166
  if (size <= 512U) {
#line 166
    return (9);
  } else {

  }
#line 167
  if (size <= 1024U) {
#line 167
    return (10);
  } else {

  }
#line 168
  if (size <= 2048U) {
#line 168
    return (11);
  } else {

  }
#line 169
  if (size <= 4096U) {
#line 169
    return (12);
  } else {

  }
#line 174
  if (size <= 8192U) {
#line 174
    return (13);
  } else {

  }
#line 175
  if (size <= 16384U) {
#line 175
    return (14);
  } else {

  }
#line 176
  if (size <= 32768U) {
#line 176
    return (15);
  } else {

  }
#line 177
  if (size <= 65536U) {
#line 177
    return (16);
  } else {

  }
#line 178
  if (size <= 131072U) {
#line 178
    return (17);
  } else {

  }
#line 179
  if (size <= 262144U) {
#line 179
    return (18);
  } else {

  }
#line 180
  if (size <= 524288U) {
#line 180
    return (19);
  } else {

  }
#line 181
  if (size <= 1048576U) {
#line 181
    return (20);
  } else {

  }
#line 182
  if (size <= 2097152U) {
#line 182
    return (21);
  } else {

  }
#line 183
  return (-1);
}
}
#line 200 "include/linux/slub_def.h"
__inline static struct kmem_cache *( __attribute__((__always_inline__)) kmalloc_slab)(size_t size ) 
{ int index ;
  int tmp ;

  {
  {
#line 202
  tmp = kmalloc_index(size);
#line 202
  index = tmp;
  }
#line 204
  if (index == 0) {
#line 205
    return ((struct kmem_cache *)((void *)0));
  } else {

  }
#line 207
  return (& kmalloc_caches[index]);
}
}
#line 217
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 218
extern void *__kmalloc(size_t size , gfp_t flags ) ;
#line 223 "include/linux/slub_def.h"
__inline static void *( __attribute__((__always_inline__)) kmem_cache_alloc_notrace)(struct kmem_cache *s ,
                                                                                     gfp_t gfpflags ) 
{ void *tmp ;

  {
  {
#line 226
  tmp = kmem_cache_alloc(s, gfpflags);
  }
#line 226
  return (tmp);
}
}
#line 230 "include/linux/slub_def.h"
__inline static void *( __attribute__((__always_inline__)) kmalloc_large)(size_t size ,
                                                                          gfp_t flags ) 
{ unsigned int order ;
  int tmp ;
  void *ret ;
  unsigned long tmp___0 ;

  {
  {
#line 232
  tmp = get_order((unsigned long )size);
#line 232
  order = (unsigned int )tmp;
#line 233
  tmp___0 = __get_free_pages(flags | 16384U, order);
#line 233
  ret = (void *)tmp___0;
#line 235
  kmemleak_alloc((void const   *)ret, size, 1, flags);
  }
  {
#line 236
  trace_kmalloc((unsigned long )((void *)0), (void const   *)ret, size, (unsigned int )((1UL << 12) << order),
                flags);
  }
#line 238
  return (ret);
}
}
#line 241 "include/linux/slub_def.h"
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *ret ;
  void *tmp ;
  struct kmem_cache *s ;
  struct kmem_cache *tmp___0 ;
  void *tmp___1 ;

  {
#line 245
  if (0) {
#line 246
    if ((unsigned long )size > 2UL * (1UL << 12)) {
      {
#line 247
      tmp = kmalloc_large(size, flags);
      }
#line 247
      return (tmp);
    } else {

    }
#line 249
    if (! (flags & 1U)) {
      {
#line 250
      tmp___0 = kmalloc_slab(size);
#line 250
      s = tmp___0;
      }
#line 252
      if (! s) {
#line 253
        return ((void *)16);
      } else {

      }
      {
#line 255
      ret = kmem_cache_alloc_notrace(s, flags);
      }
      {
#line 257
      trace_kmalloc((unsigned long )((void *)0), (void const   *)ret, size, (unsigned int )s->size,
                    flags);
      }
#line 259
      return (ret);
    } else {

    }
  } else {

  }
  {
#line 262
  tmp___1 = __kmalloc(size, flags);
  }
#line 262
  return (tmp___1);
}
}
#line 313 "include/linux/slab.h"
__inline static void *( __attribute__((__always_inline__)) kzalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp ;

  {
  {
#line 315
  tmp = kmalloc(size, flags | 32768U);
  }
#line 315
  return (tmp);
}
}
#line 68 "include/linux/module.h"
int init_module(void) ;
#line 69
void cleanup_module(void) ;
#line 88
extern struct module __this_module ;
#line 409 "include/linux/irq.h"
extern int set_irq_type(unsigned int irq , unsigned int type ) ;
#line 111 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                irqreturn_t (*thread_fn)(int  , void * ) , unsigned long flags ,
                                char const   *name , void *dev ) ;
#line 116 "include/linux/interrupt.h"
__inline static int ( __attribute__((__always_inline__)) request_irq)(unsigned int irq ,
                                                                      irqreturn_t (*handler)(int  ,
                                                                                             void * ) ,
                                                                      unsigned long flags ,
                                                                      char const   *name ,
                                                                      void *dev ) 
{ int tmp ;

  {
  {
#line 120
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))((void *)0),
                             flags, name, dev);
  }
#line 120
  return (tmp);
}
}
#line 147
extern void free_irq(unsigned int  , void * ) ;
#line 186
extern void disable_irq(unsigned int irq ) ;
#line 37 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  **fw , char const   *name , struct device *device ) ;
#line 44
extern void release_firmware(struct firmware  const  *fw ) ;
#line 145 "include/linux/device.h"
extern void driver_unregister(struct device_driver *drv ) ;
#line 494
extern void *dev_get_drvdata(struct device  const  *dev ) ;
#line 495
extern void dev_set_drvdata(struct device *dev , void *data ) ;
#line 29 "include/linux/spi/spi.h"
extern struct bus_type spi_bus_type ;
#line 189
extern int spi_register_driver(struct spi_driver *sdrv ) ;
#line 196 "include/linux/spi/spi.h"
__inline static void ( __attribute__((__always_inline__)) spi_unregister_driver)(struct spi_driver *sdrv ) 
{ 

  {
#line 198
  if (sdrv) {
    {
#line 199
    driver_unregister(& sdrv->driver);
    }
  } else {

  }
#line 200
  return;
}
}
#line 542
extern int spi_setup(struct spi_device *spi ) ;
#line 53 "include/linux/random.h"
extern void get_random_bytes(void *buf , int nbytes ) ;
#line 441 "include/linux/skbuff.h"
extern void consume_skb(struct sk_buff *skb ) ;
#line 795 "include/linux/skbuff.h"
__inline static __u32 ( __attribute__((__always_inline__)) skb_queue_len)(struct sk_buff_head  const  *list_ ) 
{ 

  {
#line 797
  return ((unsigned int )list_->qlen);
}
}
#line 810 "include/linux/skbuff.h"
__inline static void ( __attribute__((__always_inline__)) __skb_queue_head_init)(struct sk_buff_head *list ) 
{ struct sk_buff *tmp ;

  {
#line 812
  tmp = (struct sk_buff *)list;
#line 812
  list->next = tmp;
#line 812
  list->prev = tmp;
#line 813
  list->qlen = 0U;
#line 814
  return;
}
}
#line 826 "include/linux/skbuff.h"
static struct lock_class_key __key___2  ;
#line 824 "include/linux/skbuff.h"
__inline static void ( __attribute__((__always_inline__)) skb_queue_head_init)(struct sk_buff_head *list ) 
{ 

  {
  {
#line 826
  while (1) {
    while_10_continue: /* CIL Label */ ;
    {
#line 826
    __spin_lock_init(& list->lock, "&list->lock", & __key___2);
    }
    goto while_10_break;
  }
  while_10_break: /* CIL Label */ ;
  }
  {
#line 827
  __skb_queue_head_init(list);
  }
#line 828
  return;
}
}
#line 986
extern void skb_queue_tail(struct sk_buff_head *list , struct sk_buff *newsk ) ;
#line 60 "include/linux/etherdevice.h"
__inline static int ( __attribute__((__always_inline__)) is_zero_ether_addr)(u8 const   *addr ) 
{ 

  {
#line 62
  return (! ((((((int const   )*(addr + 0) | (int const   )*(addr + 1)) | (int const   )*(addr + 2)) | (int const   )*(addr + 3)) | (int const   )*(addr + 4)) | (int const   )*(addr + 5)));
}
}
#line 94 "include/linux/etherdevice.h"
__inline static int ( __attribute__((__always_inline__)) is_broadcast_ether_addr)(u8 const   *addr ) 
{ 

  {
#line 96
  return (((((((int const   )*(addr + 0) & (int const   )*(addr + 1)) & (int const   )*(addr + 2)) & (int const   )*(addr + 3)) & (int const   )*(addr + 4)) & (int const   )*(addr + 5)) == 255);
}
}
#line 1226 "include/net/cfg80211.h"
__inline static void ( __attribute__((__always_inline__)) set_wiphy_dev)(struct wiphy *wiphy ,
                                                                         struct device *dev ) 
{ 

  {
#line 1228
  wiphy->dev.parent = dev;
#line 1229
  return;
}
}
#line 1388
extern int ieee80211_frequency_to_channel(int freq ) ;
#line 1011 "include/net/mac80211.h"
__inline static void ( __attribute__((__always_inline__)) SET_IEEE80211_DEV)(struct ieee80211_hw *hw ,
                                                                             struct device *dev ) 
{ 

  {
  {
#line 1013
  set_wiphy_dev(hw->wiphy, dev);
  }
#line 1014
  return;
}
}
#line 1022 "include/net/mac80211.h"
__inline static void ( __attribute__((__always_inline__)) SET_IEEE80211_PERM_ADDR)(struct ieee80211_hw *hw ,
                                                                                   u8 *addr ) 
{ 

  {
  {
#line 1024
  __constant_memcpy((void *)((hw->wiphy)->perm_addr), (void const   *)addr, 6U);
  }
#line 1025
  return;
}
}
#line 1535
extern struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len , struct ieee80211_ops  const  *ops ) ;
#line 1547
extern int ieee80211_register_hw(struct ieee80211_hw *hw ) ;
#line 1639
extern void ieee80211_unregister_hw(struct ieee80211_hw *hw ) ;
#line 1650
extern void ieee80211_free_hw(struct ieee80211_hw *hw ) ;
#line 1744
extern struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw , struct ieee80211_vif *vif ) ;
#line 1905
extern void ieee80211_stop_queues(struct ieee80211_hw *hw ) ;
#line 1925
extern void ieee80211_scan_completed(struct ieee80211_hw *hw , bool aborted ) ;
#line 387 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl12xx.h"
int wl12xx_plt_start(struct wl12xx *wl ) ;
#line 388
int wl12xx_plt_stop(struct wl12xx *wl ) ;
#line 1215 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/acx.h"
extern int wl12xx_acx_station_id(struct wl12xx *wl ) ;
#line 1220
extern int wl12xx_acx_tx_power(struct wl12xx *wl , int power ) ;
#line 1228
extern int wl12xx_acx_slot(struct wl12xx *wl , enum acx_slot_type slot_time ) ;
#line 1231
extern int wl12xx_acx_rts_threshold(struct wl12xx *wl , u16 rts_threshold ) ;
#line 1238
extern int wl12xx_acx_aid(struct wl12xx *wl , u16 aid ) ;
#line 1240
extern int wl12xx_acx_set_preamble(struct wl12xx *wl , enum acx_preamble_type preamble ) ;
#line 1241
extern int wl12xx_acx_cts_protect(struct wl12xx *wl , enum acx_ctsprotect_type ctsprotect ) ;
#line 37 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/wl1251.h"
extern void wl1251_setup(struct wl12xx *wl ) ;
#line 30 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/cmd.h"
extern int wl12xx_cmd_send(struct wl12xx *wl , u16 type , void *buf , size_t buf_len ) ;
#line 38
extern int wl12xx_cmd_join(struct wl12xx *wl , u8 bss_type , u8 dtim_interval , u16 beacon_interval ,
                           u8 wait ) ;
#line 42
extern int wl12xx_cmd_template_set(struct wl12xx *wl , u16 cmd_id , void *buf , size_t buf_len ) ;
#line 75 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/spi.h"
extern void wl12xx_spi_read(struct wl12xx *wl , int addr , void *buf , size_t len ) ;
#line 76
extern void wl12xx_spi_write(struct wl12xx *wl , int addr , void *buf , size_t len ) ;
#line 79
extern void wl12xx_spi_mem_read(struct wl12xx *wl , int addr , void *buf , size_t len ) ;
#line 85
extern u32 wl12xx_reg_read32(struct wl12xx *wl , int addr ) ;
#line 89
extern void wl12xx_spi_reset(struct wl12xx *wl ) ;
#line 90
extern void wl12xx_spi_init(struct wl12xx *wl ) ;
#line 91
extern void wl12xx_set_partition(struct wl12xx *wl , u32 part_start , u32 part_size ,
                                 u32 reg_start , u32 reg_size ) ;
#line 95 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/spi.h"
__inline static u32 ( __attribute__((__always_inline__)) wl12xx_read32)(struct wl12xx *wl ,
                                                                        int addr ) 
{ u32 response ;

  {
  {
#line 99
  wl12xx_spi_read(wl, addr, (void *)(& response), sizeof(u32 ));
  }
#line 101
  return (response);
}
}
#line 104 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/spi.h"
__inline static void ( __attribute__((__always_inline__)) wl12xx_write32)(struct wl12xx *wl ,
                                                                          int addr ,
                                                                          u32 val ) 
{ 

  {
  {
#line 106
  wl12xx_spi_write(wl, addr, (void *)(& val), sizeof(u32 ));
  }
#line 107
  return;
}
}
#line 211 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/tx.h"
extern void wl12xx_tx_work(struct work_struct *work ) ;
#line 213
extern void wl12xx_tx_flush(struct wl12xx *wl ) ;
#line 31 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/ps.h"
extern int wl12xx_ps_set_mode(struct wl12xx *wl , enum acx_ps_mode mode ) ;
#line 29 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/debugfs.h"
extern int wl12xx_debugfs_init(struct wl12xx *wl ) ;
#line 30
extern void wl12xx_debugfs_exit(struct wl12xx *wl ) ;
#line 31
extern void wl12xx_debugfs_reset(struct wl12xx *wl ) ;
#line 47 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_disable_interrupts(struct wl12xx *wl ) 
{ 

  {
  {
#line 49
  disable_irq((unsigned int )wl->irq);
  }
#line 50
  return;
}
}
#line 52 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_power_off(struct wl12xx *wl ) 
{ 

  {
  {
#line 54
  (*(wl->set_power))((_Bool)0);
  }
#line 55
  return;
}
}
#line 57 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_power_on(struct wl12xx *wl ) 
{ 

  {
  {
#line 59
  (*(wl->set_power))((_Bool)1);
  }
#line 60
  return;
}
}
#line 62 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static irqreturn_t wl12xx_irq(int irq , void *cookie ) 
{ struct wl12xx *wl ;

  {
  {
#line 66
  while (1) {
    while_11_continue: /* CIL Label */ ;
    goto while_11_break;
  }
  while_11_break: /* CIL Label */ ;
  }
  {
#line 68
  wl = (struct wl12xx *)cookie;
#line 70
  schedule_work(& wl->irq_work);
  }
#line 72
  return ((enum irqreturn )1);
}
}
#line 75 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_fetch_firmware(struct wl12xx *wl ) 
{ struct firmware  const  *fw ;
  int ret ;
  void *tmp ;

  {
  {
#line 80
  ret = request_firmware(& fw, wl->chip.fw_filename, & (wl->spi)->dev);
  }
#line 82
  if (ret < 0) {
    {
#line 83
    printk("<3>wl12xx: ERROR could not get firmware: %d\n", ret);
    }
#line 84
    return (ret);
  } else {

  }
#line 87
  if (fw->size % 4U) {
    {
#line 88
    printk("<3>wl12xx: ERROR firmware size is not multiple of 32 bits: %zu\n", fw->size);
#line 90
    ret = -84;
    }
    goto out;
  } else {

  }
  {
#line 94
  wl->fw_len = (unsigned int )fw->size;
#line 95
  tmp = kmalloc(wl->fw_len, 208U);
#line 95
  wl->fw = (u8 *)tmp;
  }
#line 97
  if (! wl->fw) {
    {
#line 98
    printk("<3>wl12xx: ERROR could not allocate memory for the firmware\n");
#line 99
    ret = -12;
    }
    goto out;
  } else {

  }
  {
#line 103
  __memcpy((void *)wl->fw, (void const   *)fw->data, wl->fw_len);
#line 105
  ret = 0;
  }
  out: 
  {
#line 108
  release_firmware(fw);
  }
#line 110
  return (ret);
}
}
#line 113 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_fetch_nvs(struct wl12xx *wl ) 
{ struct firmware  const  *fw ;
  int ret ;
  void *tmp ;

  {
  {
#line 118
  ret = request_firmware(& fw, wl->chip.nvs_filename, & (wl->spi)->dev);
  }
#line 120
  if (ret < 0) {
    {
#line 121
    printk("<3>wl12xx: ERROR could not get nvs file: %d\n", ret);
    }
#line 122
    return (ret);
  } else {

  }
#line 125
  if (fw->size % 4U) {
    {
#line 126
    printk("<3>wl12xx: ERROR nvs size is not multiple of 32 bits: %zu\n", fw->size);
#line 128
    ret = -84;
    }
    goto out;
  } else {

  }
  {
#line 132
  wl->nvs_len = (unsigned int )fw->size;
#line 133
  tmp = kmalloc(wl->nvs_len, 208U);
#line 133
  wl->nvs = (u8 *)tmp;
  }
#line 135
  if (! wl->nvs) {
    {
#line 136
    printk("<3>wl12xx: ERROR could not allocate memory for the nvs file\n");
#line 137
    ret = -12;
    }
    goto out;
  } else {

  }
  {
#line 141
  __memcpy((void *)wl->nvs, (void const   *)fw->data, wl->nvs_len);
#line 143
  ret = 0;
  }
  out: 
  {
#line 146
  release_firmware(fw);
  }
#line 148
  return (ret);
}
}
#line 151 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_fw_wakeup(struct wl12xx *wl ) 
{ u32 elp_reg ;

  {
  {
#line 155
  elp_reg = 1U;
#line 156
  wl12xx_write32(wl, 131068, elp_reg);
#line 157
  elp_reg = wl12xx_read32(wl, 131068);
  }
#line 159
  if (! (elp_reg & 2U)) {
    {
#line 160
    printk("<4>wl12xx: WARNING WLAN not ready\n");
#line 161
    elp_reg = 5U;
#line 162
    wl12xx_write32(wl, 131068, elp_reg);
    }
  } else {

  }
#line 164
  return;
}
}
#line 166 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_chip_wakeup(struct wl12xx *wl ) 
{ int ret ;

  {
  {
#line 168
  ret = 0;
#line 170
  wl12xx_power_on(wl);
#line 171
  msleep(wl->chip.power_on_sleep);
#line 172
  wl12xx_spi_reset(wl);
#line 173
  wl12xx_spi_init(wl);
#line 177
  wl12xx_set_partition(wl, 0U, 0U, 3145728U, 34816U);
#line 184
  wl12xx_fw_wakeup(wl);
#line 189
  wl->chip.id = wl12xx_reg_read32(wl, 3167860);
  }
#line 194
  if ((int )wl->chip.id == 117637377) {
    goto switch_12_117637377;
  } else {
#line 201
    if ((int )wl->chip.id == 67305729) {
      goto switch_12_67305729;
    } else {
#line 202
      if ((int )wl->chip.id == 117506305) {
        goto switch_12_67305729;
      } else {
#line 203
        if ((int )wl->chip.id == 117571841) {
          goto switch_12_67305729;
        } else {
          {
          goto switch_12_67305729;
#line 193
          if (0) {
            switch_12_117637377: /* CIL Label */ 
            {
#line 195
            while (1) {
              while_13_continue: /* CIL Label */ ;
              goto while_13_break;
            }
            while_13_break: /* CIL Label */ ;
            }
            {
#line 198
            wl1251_setup(wl);
            }
            goto switch_12_break;
            switch_12_67305729: /* CIL Label */ 
            switch_12_117506305: /* CIL Label */ 
            switch_12_117571841: /* CIL Label */ 
            switch_12_default: /* CIL Label */ 
            {
#line 205
            printk("<3>wl12xx: ERROR unsupported chip id: 0x%x\n", wl->chip.id);
#line 206
            ret = -19;
            }
            goto out;
          } else {
            switch_12_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
#line 210
  if ((unsigned int )wl->fw == (unsigned int )((void *)0)) {
    {
#line 211
    ret = wl12xx_fetch_firmware(wl);
    }
#line 212
    if (ret < 0) {
      goto out;
    } else {

    }
  } else {

  }
#line 217
  if ((unsigned int )wl->nvs == (unsigned int )((void *)0)) {
    {
#line 218
    ret = wl12xx_fetch_nvs(wl);
    }
#line 219
    if (ret < 0) {
      goto out;
    } else {

    }
  } else {

  }
  out: 
#line 224
  return (ret);
}
}
#line 227 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_filter_work(struct work_struct *work ) 
{ struct wl12xx *wl ;
  struct work_struct  const  *__mptr ;
  int ret ;

  {
  {
#line 230
  __mptr = (struct work_struct  const  *)work;
#line 230
  wl = (struct wl12xx *)((char *)__mptr - (unsigned int )(& ((struct wl12xx *)0)->filter_work));
#line 233
  mutex_lock(& wl->mutex);
  }
#line 235
  if ((unsigned int )wl->state == 0U) {
    goto out;
  } else {

  }
  {
#line 238
  ret = wl12xx_cmd_join(wl, wl->bss_type, (unsigned char)1, (unsigned short)100, (unsigned char)0);
  }
#line 239
  if (ret < 0) {
    goto out;
  } else {

  }
  out: 
  {
#line 243
  mutex_unlock(& wl->mutex);
  }
#line 244
  return;
}
}
#line 246 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
int wl12xx_plt_start(struct wl12xx *wl ) 
{ int ret ;

  {
  {
#line 250
  printk("<6>wl12xx: power up\n");
  }
#line 252
  if ((unsigned int )wl->state != 0U) {
    {
#line 253
    printk("<3>wl12xx: ERROR cannot go into PLT state because not in off state: %d\n",
           wl->state);
    }
#line 255
    return (-16);
  } else {

  }
  {
#line 258
  wl->state = (enum wl12xx_state )2;
#line 260
  ret = wl12xx_chip_wakeup(wl);
  }
#line 261
  if (ret < 0) {
#line 262
    return (ret);
  } else {

  }
  {
#line 264
  ret = (*(wl->chip.op_boot))(wl);
  }
#line 265
  if (ret < 0) {
#line 266
    return (ret);
  } else {

  }
  {
#line 268
  printk("<6>wl12xx: firmware booted in PLT mode (%s)\n", wl->chip.fw_ver);
#line 270
  ret = (*(wl->chip.op_plt_init))(wl);
  }
#line 271
  if (ret < 0) {
#line 272
    return (ret);
  } else {

  }
#line 274
  return (0);
}
}
#line 277 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
int wl12xx_plt_stop(struct wl12xx *wl ) 
{ 

  {
  {
#line 279
  printk("<6>wl12xx: power down\n");
  }
#line 281
  if ((unsigned int )wl->state != 2U) {
    {
#line 282
    printk("<3>wl12xx: ERROR cannot power down because not in PLT state: %d\n", wl->state);
    }
#line 284
    return (-16);
  } else {

  }
  {
#line 287
  wl12xx_disable_interrupts(wl);
#line 288
  wl12xx_power_off(wl);
#line 290
  wl->state = (enum wl12xx_state )0;
  }
#line 292
  return (0);
}
}
#line 296 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_tx(struct ieee80211_hw *hw , struct sk_buff *skb ) 
{ struct wl12xx *wl ;
  __u32 tmp ;

  {
  {
#line 298
  wl = (struct wl12xx *)hw->priv;
#line 300
  skb_queue_tail(& wl->tx_queue, skb);
#line 302
  schedule_work(& wl->tx_work);
#line 308
  tmp = skb_queue_len((struct sk_buff_head  const  *)(& wl->tx_queue));
  }
#line 308
  if (tmp >= 20U) {
    {
#line 309
    ieee80211_stop_queues(wl->hw);
#line 316
    wl->tx_queue_stopped = (_Bool)1;
    }
  } else {

  }
#line 319
  return (0);
}
}
#line 322 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_start(struct ieee80211_hw *hw ) 
{ struct wl12xx *wl ;
  int ret ;

  {
#line 324
  wl = (struct wl12xx *)hw->priv;
#line 325
  ret = 0;
  {
#line 327
  while (1) {
    while_14_continue: /* CIL Label */ ;
    goto while_14_break;
  }
  while_14_break: /* CIL Label */ ;
  }
  {
#line 329
  mutex_lock(& wl->mutex);
  }
#line 331
  if ((unsigned int )wl->state != 0U) {
    {
#line 332
    printk("<3>wl12xx: ERROR cannot start because not in off state: %d\n", wl->state);
#line 334
    ret = -16;
    }
    goto out;
  } else {

  }
  {
#line 338
  ret = wl12xx_chip_wakeup(wl);
  }
#line 339
  if (ret < 0) {
#line 340
    return (ret);
  } else {

  }
  {
#line 342
  ret = (*(wl->chip.op_boot))(wl);
  }
#line 343
  if (ret < 0) {
    goto out;
  } else {

  }
  {
#line 346
  ret = (*(wl->chip.op_hw_init))(wl);
  }
#line 347
  if (ret < 0) {
    goto out;
  } else {

  }
  {
#line 350
  ret = wl12xx_acx_station_id(wl);
  }
#line 351
  if (ret < 0) {
    goto out;
  } else {

  }
  {
#line 354
  wl->state = (enum wl12xx_state )1;
#line 356
  printk("<7>wl12xx: firmware booted (%s)\n", wl->chip.fw_ver);
  }
  out: 
#line 359
  if (ret < 0) {
    {
#line 360
    wl12xx_power_off(wl);
    }
  } else {

  }
  {
#line 362
  mutex_unlock(& wl->mutex);
  }
#line 364
  return (ret);
}
}
#line 367 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_op_stop(struct ieee80211_hw *hw ) 
{ struct wl12xx *wl ;
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 369
  wl = (struct wl12xx *)hw->priv;
#line 371
  printk("<7>wl12xx: down\n");
  }
  {
#line 373
  while (1) {
    while_15_continue: /* CIL Label */ ;
    goto while_15_break;
  }
  while_15_break: /* CIL Label */ ;
  }
  {
#line 375
  mutex_lock(& wl->mutex);
#line 377
  __ret_warn_on = ! (! ((unsigned int )wl->state != 1U));
#line 377
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 377
  if (tmp) {
    {
#line 377
    warn_slowpath_null("/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c",
                       (int const   )377);
    }
  } else {

  }
  {
#line 377
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 379
  if (wl->scanning) {
    {
#line 380
    mutex_unlock(& wl->mutex);
#line 381
    ieee80211_scan_completed(wl->hw, (_Bool)1);
#line 382
    mutex_lock(& wl->mutex);
#line 383
    wl->scanning = (_Bool)0;
    }
  } else {

  }
  {
#line 386
  wl->state = (enum wl12xx_state )0;
#line 388
  wl12xx_disable_interrupts(wl);
#line 390
  mutex_unlock(& wl->mutex);
#line 392
  cancel_work_sync(& wl->irq_work);
#line 393
  cancel_work_sync(& wl->tx_work);
#line 394
  cancel_work_sync(& wl->filter_work);
#line 396
  mutex_lock(& wl->mutex);
#line 399
  wl12xx_tx_flush(wl);
#line 401
  wl12xx_power_off(wl);
#line 403
  __constant_c_and_count_memset((void *)(wl->bssid), 0UL, 6U);
#line 404
  wl->listen_int = (unsigned char)1;
#line 405
  wl->bss_type = (unsigned char)255;
#line 407
  wl->data_in_count = 0U;
#line 408
  wl->rx_counter = 0U;
#line 409
  wl->rx_handled = 0U;
#line 410
  wl->rx_current_buffer = 0U;
#line 411
  wl->rx_last_id = 0U;
#line 412
  wl->next_tx_complete = 0U;
#line 413
  wl->elp = (_Bool)0;
#line 414
  wl->psm = (_Bool)0;
#line 415
  wl->tx_queue_stopped = (_Bool)0;
#line 416
  wl->power_level = 20;
#line 418
  wl12xx_debugfs_reset(wl);
#line 420
  mutex_unlock(& wl->mutex);
  }
#line 421
  return;
}
}
#line 423 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_add_interface(struct ieee80211_hw *hw , struct ieee80211_if_init_conf *conf ) 
{ struct wl12xx *wl ;
  int ret ;
  int tmp___0 ;

  {
#line 426
  wl = (struct wl12xx *)hw->priv;
#line 428
  ret = 0;
  {
#line 430
  while (1) {
    while_16_continue: /* CIL Label */ ;
    goto while_16_break;
  }
  while_16_break: /* CIL Label */ ;
  }
  {
#line 433
  mutex_lock(& wl->mutex);
  }
#line 436
  if ((int )conf->type == 2) {
    goto switch_17_2;
  } else {
#line 439
    if ((int )conf->type == 1) {
      goto switch_17_1;
    } else {
      {
      goto switch_17_default;
#line 435
      if (0) {
        switch_17_2: /* CIL Label */ 
#line 437
        wl->bss_type = (unsigned char)2;
        goto switch_17_break;
        switch_17_1: /* CIL Label */ 
#line 440
        wl->bss_type = (unsigned char)0;
        goto switch_17_break;
        switch_17_default: /* CIL Label */ 
#line 443
        ret = -95;
        goto out;
      } else {
        switch_17_break: /* CIL Label */ ;
      }
      }
    }
  }
  {
#line 447
  tmp___0 = __builtin_memcmp((void const   *)(wl->mac_addr), (void const   *)conf->mac_addr,
                             6U);
  }
#line 447
  if (tmp___0) {
    {
#line 448
    __constant_memcpy((void *)(wl->mac_addr), (void const   *)conf->mac_addr, 6U);
#line 449
    SET_IEEE80211_PERM_ADDR(wl->hw, wl->mac_addr);
#line 450
    ret = wl12xx_acx_station_id(wl);
    }
#line 451
    if (ret < 0) {
      goto out;
    } else {

    }
  } else {

  }
  out: 
  {
#line 456
  mutex_unlock(& wl->mutex);
  }
#line 457
  return (ret);
}
}
#line 460 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_op_remove_interface(struct ieee80211_hw *hw , struct ieee80211_if_init_conf *conf ) 
{ 

  {
  {
#line 463
  while (1) {
    while_18_continue: /* CIL Label */ ;
    goto while_18_break;
  }
  while_18_break: /* CIL Label */ ;
  }
#line 464
  return;
}
}
#line 466 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_build_null_data(struct wl12xx *wl ) 
{ struct wl12xx_null_data_template template ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 470
  tmp = is_zero_ether_addr((u8 const   *)(wl->bssid));
  }
#line 470
  if (tmp) {
    {
#line 474
    __constant_c_and_count_memset((void *)(template.header.da), 4294967295UL, 6U);
#line 475
    __constant_c_and_count_memset((void *)(template.header.bssid), 4294967295UL, 6U);
    }
  } else {
    {
#line 471
    __constant_memcpy((void *)(template.header.da), (void const   *)(wl->bssid), 6U);
#line 472
    __constant_memcpy((void *)(template.header.bssid), (void const   *)(wl->bssid),
                      6U);
    }
  }
  {
#line 478
  __constant_memcpy((void *)(template.header.sa), (void const   *)(wl->mac_addr),
                    6U);
#line 479
  template.header.frame_ctl = (unsigned short)72;
#line 482
  tmp___0 = wl12xx_cmd_template_set(wl, (unsigned short)21, (void *)(& template),
                                    sizeof(template));
  }
#line 482
  return (tmp___0);
}
}
#line 487 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_build_ps_poll(struct wl12xx *wl , u16 aid ) 
{ struct wl12xx_ps_poll_template template ;
  int tmp ;

  {
  {
#line 491
  __constant_memcpy((void *)(template.bssid), (void const   *)(wl->bssid), 6U);
#line 492
  __constant_memcpy((void *)(template.ta), (void const   *)(wl->mac_addr), 6U);
#line 493
  template.aid = aid;
#line 494
  template.fc = (unsigned short)164;
#line 496
  tmp = wl12xx_cmd_template_set(wl, (unsigned short)30, (void *)(& template), sizeof(template));
  }
#line 496
  return (tmp);
}
}
#line 501 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_config(struct ieee80211_hw *hw , u32 changed ) 
{ struct wl12xx *wl ;
  struct ieee80211_conf *conf ;
  int channel ;
  int ret ;

  {
  {
#line 503
  wl = (struct wl12xx *)hw->priv;
#line 504
  conf = & hw->conf;
#line 505
  ret = 0;
#line 507
  channel = ieee80211_frequency_to_channel((int )(conf->channel)->center_freq);
  }
  {
#line 509
  while (1) {
    while_19_continue: /* CIL Label */ ;
    goto while_19_break;
  }
  while_19_break: /* CIL Label */ ;
  }
  {
#line 514
  mutex_lock(& wl->mutex);
  }
#line 516
  if (channel != wl->channel) {
    {
#line 518
    ret = wl12xx_cmd_join(wl, wl->bss_type, (unsigned char)1, (unsigned short)100,
                          (unsigned char)0);
    }
#line 519
    if (ret < 0) {
      goto out;
    } else {

    }
#line 522
    wl->channel = channel;
  } else {

  }
  {
#line 525
  ret = wl12xx_build_null_data(wl);
  }
#line 526
  if (ret < 0) {
    goto out;
  } else {

  }
#line 529
  if (conf->flags & 2U) {
#line 529
    if (! wl->psm_requested) {
      {
#line 530
      printk("<7>wl12xx: psm enabled\n");
#line 532
      wl->psm_requested = (_Bool)1;
#line 539
      ret = wl12xx_ps_set_mode(wl, (enum acx_ps_mode )1);
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 540
    if (! (conf->flags & 2U)) {
#line 540
      if (wl->psm_requested) {
        {
#line 542
        printk("<7>wl12xx: psm disabled\n");
#line 544
        wl->psm_requested = (_Bool)0;
        }
#line 546
        if (wl->psm) {
          {
#line 547
          ret = wl12xx_ps_set_mode(wl, (enum acx_ps_mode )0);
          }
        } else {

        }
      } else {

      }
    } else {

    }
  }
#line 550
  if (conf->power_level != wl->power_level) {
    {
#line 551
    ret = wl12xx_acx_tx_power(wl, conf->power_level);
    }
#line 552
    if (ret < 0) {
      goto out;
    } else {

    }
#line 555
    wl->power_level = conf->power_level;
  } else {

  }
  out: 
  {
#line 559
  mutex_unlock(& wl->mutex);
  }
#line 560
  return (ret);
}
}
#line 570 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_op_configure_filter(struct ieee80211_hw *hw , unsigned int changed ,
                                       unsigned int *total , int mc_count , struct dev_addr_list *mc_list ) 
{ struct wl12xx *wl ;

  {
#line 576
  wl = (struct wl12xx *)hw->priv;
  {
#line 578
  while (1) {
    while_20_continue: /* CIL Label */ ;
    goto while_20_break;
  }
  while_20_break: /* CIL Label */ ;
  }
#line 580
  *total = *total & 119U;
#line 581
  changed = changed & 119U;
#line 583
  if (changed == 0U) {
#line 585
    return;
  } else {

  }
#line 589
  wl->rx_config = (unsigned int )((1UL << 4) | (1UL << 5));
#line 590
  wl->rx_filter = (unsigned int )(((((((1UL << 2) | (1UL << 4)) | (1UL << 6)) | (1UL << 7)) | (1UL << 9)) | (1UL << 10)) | (1UL << 11));
#line 592
  if (*total & 1U) {
#line 593
    wl->rx_config = (unsigned int )((unsigned long )wl->rx_config | (1UL << 5));
#line 594
    wl->rx_config = (unsigned int )((unsigned long )wl->rx_config | (1UL << 3));
  } else {

  }
#line 596
  if (*total & 2U) {
#line 601
    wl->rx_config = (unsigned int )((unsigned long )wl->rx_config & ~ (1UL << 6));
  } else {

  }
#line 602
  if (*total & 4U) {
#line 603
    wl->rx_filter = (unsigned int )((unsigned long )wl->rx_filter | (1UL << 5));
  } else {

  }
#line 604
  if (*total & 16U) {
#line 605
    wl->rx_config = (unsigned int )((unsigned long )wl->rx_config & ~ (1UL << 5));
#line 606
    wl->rx_config = (unsigned int )((unsigned long )wl->rx_config & ~ (1UL << 10));
  } else {

  }
#line 608
  if (*total & 32U) {
#line 609
    wl->rx_filter = (unsigned int )((unsigned long )wl->rx_filter | (1UL << 7));
  } else {

  }
#line 610
  if (*total & 64U) {
#line 611
    wl->rx_filter = (unsigned int )((unsigned long )wl->rx_filter & ~ (1UL << 5));
  } else {

  }
#line 619
  return;
}
}
#line 622 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_set_key_type(struct wl12xx *wl , struct acx_set_key *key , enum set_key_cmd cmd ,
                               struct ieee80211_key_conf *mac80211_key , u8 const   *addr ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 628
  if ((int )mac80211_key->alg == 0) {
    goto switch_21_0;
  } else {
#line 636
    if ((int )mac80211_key->alg == 1) {
      goto switch_21_1;
    } else {
#line 644
      if ((int )mac80211_key->alg == 2) {
        goto switch_21_2;
      } else {
        {
        goto switch_21_default;
#line 627
        if (0) {
          switch_21_0: /* CIL Label */ 
          {
#line 629
          tmp = is_broadcast_ether_addr(addr);
          }
#line 629
          if (tmp) {
#line 630
            key->key_type = (unsigned char)0;
          } else {
#line 632
            key->key_type = (unsigned char)1;
          }
#line 634
          mac80211_key->hw_key_idx = (unsigned char )mac80211_key->keyidx;
          goto switch_21_break;
          switch_21_1: /* CIL Label */ 
          {
#line 637
          tmp___0 = is_broadcast_ether_addr(addr);
          }
#line 637
          if (tmp___0) {
#line 638
            key->key_type = (unsigned char)10;
          } else {
#line 640
            key->key_type = (unsigned char)11;
          }
#line 642
          mac80211_key->hw_key_idx = (unsigned char )mac80211_key->keyidx;
          goto switch_21_break;
          switch_21_2: /* CIL Label */ 
          {
#line 645
          tmp___1 = is_broadcast_ether_addr(addr);
          }
#line 645
          if (tmp___1) {
#line 646
            key->key_type = (unsigned char)4;
          } else {
#line 648
            key->key_type = (unsigned char)5;
          }
#line 649
          mac80211_key->flags = (unsigned char )((int )mac80211_key->flags | 2);
          goto switch_21_break;
          switch_21_default: /* CIL Label */ 
          {
#line 652
          printk("<3>wl12xx: ERROR Unknown key algo 0x%x\n", mac80211_key->alg);
          }
#line 653
          return (-95);
        } else {
          switch_21_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
#line 656
  return (0);
}
}
#line 669
static int wl12xx_op_set_key(struct ieee80211_hw *hw , enum set_key_cmd cmd , struct ieee80211_vif *vif ,
                             struct ieee80211_sta *sta , struct ieee80211_key_conf *key ) ;
#line 669 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static u8 const   bcast_addr[6]  = {      (u8 const   )255,      (u8 const   )255,      (u8 const   )255,      (u8 const   )255, 
        (u8 const   )255,      (u8 const   )255};
#line 659 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_set_key(struct ieee80211_hw *hw , enum set_key_cmd cmd , struct ieee80211_vif *vif ,
                             struct ieee80211_sta *sta , struct ieee80211_key_conf *key ) 
{ struct wl12xx *wl ;
  struct acx_set_key wl_key ;
  u8 const   *addr ;
  int ret ;
  int tmp___2 ;

  {
#line 664
  wl = (struct wl12xx *)hw->priv;
  {
#line 672
  while (1) {
    while_22_continue: /* CIL Label */ ;
    goto while_22_break;
  }
  while_22_break: /* CIL Label */ ;
  }
  {
#line 674
  __constant_c_and_count_memset((void *)(& wl_key), 0UL, sizeof(wl_key));
  }
#line 676
  if (sta) {
#line 676
    addr = (u8 const   *)(sta->addr);
  } else {
#line 676
    addr = bcast_addr;
  }
  {
#line 678
  while (1) {
    while_23_continue: /* CIL Label */ ;
    goto while_23_break;
  }
  while_23_break: /* CIL Label */ ;
  }
  {
#line 679
  while (1) {
    while_24_continue: /* CIL Label */ ;
    goto while_24_break;
  }
  while_24_break: /* CIL Label */ ;
  }
  {
#line 680
  while (1) {
    while_25_continue: /* CIL Label */ ;
    goto while_25_break;
  }
  while_25_break: /* CIL Label */ ;
  }
  {
#line 682
  while (1) {
    while_26_continue: /* CIL Label */ ;
    goto while_26_break;
  }
  while_26_break: /* CIL Label */ ;
  }
  {
#line 684
  mutex_lock(& wl->mutex);
  }
#line 687
  if ((int )cmd == 0) {
    goto switch_27_0;
  } else {
#line 690
    if ((int )cmd == 1) {
      goto switch_27_1;
    } else {
      {
      goto switch_27_default;
#line 686
      if (0) {
        switch_27_0: /* CIL Label */ 
#line 688
        wl_key.key_action = (unsigned short)1;
        goto switch_27_break;
        switch_27_1: /* CIL Label */ 
#line 691
        wl_key.key_action = (unsigned short)2;
        goto switch_27_break;
        switch_27_default: /* CIL Label */ 
        {
#line 694
        printk("<3>wl12xx: ERROR Unsupported key cmd 0x%x\n", cmd);
        }
        goto switch_27_break;
      } else {
        switch_27_break: /* CIL Label */ ;
      }
      }
    }
  }
  {
#line 698
  ret = wl12xx_set_key_type(wl, & wl_key, cmd, key, addr);
  }
#line 699
  if (ret < 0) {
    {
#line 700
    printk("<3>wl12xx: ERROR Set KEY type failed\n");
    }
    goto out;
  } else {

  }
#line 704
  if ((int )wl_key.key_type != 0) {
    {
#line 705
    __constant_memcpy((void *)(wl_key.addr), (void const   *)addr, 6U);
    }
  } else {

  }
#line 707
  if ((int )wl_key.key_type == 10) {
    {
#line 715
    __constant_memcpy((void *)(wl_key.key), (void const   *)(key->key), 16U);
#line 716
    __constant_memcpy((void *)(wl_key.key + 16), (void const   *)(key->key + 24),
                      8U);
#line 717
    __constant_memcpy((void *)(wl_key.key + 24), (void const   *)(key->key + 16),
                      8U);
    }
  } else {
#line 707
    if ((int )wl_key.key_type == 11) {
      {
#line 715
      __constant_memcpy((void *)(wl_key.key), (void const   *)(key->key), 16U);
#line 716
      __constant_memcpy((void *)(wl_key.key + 16), (void const   *)(key->key + 24),
                        8U);
#line 717
      __constant_memcpy((void *)(wl_key.key + 24), (void const   *)(key->key + 16),
                        8U);
      }
    } else {
      {
#line 720
      __memcpy((void *)(wl_key.key), (void const   *)(key->key), (unsigned int )key->keylen);
      }
    }
  }
#line 722
  wl_key.key_size = key->keylen;
#line 724
  wl_key.id = (unsigned char )key->keyidx;
#line 725
  wl_key.ssid_profile = (unsigned char)0;
  {
#line 727
  while (1) {
    while_28_continue: /* CIL Label */ ;
    goto while_28_break;
  }
  while_28_break: /* CIL Label */ ;
  }
  {
#line 729
  tmp___2 = wl12xx_cmd_send(wl, (unsigned short)12, (void *)(& wl_key), sizeof(wl_key));
  }
#line 729
  if (tmp___2 < 0) {
    {
#line 730
    printk("<3>wl12xx: ERROR Set KEY failed\n");
#line 731
    ret = -95;
    }
    goto out;
  } else {

  }
  out: 
  {
#line 736
  mutex_unlock(& wl->mutex);
  }
#line 737
  return (ret);
}
}
#line 740 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_build_basic_rates(char *rates ) 
{ u8 index ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;

  {
#line 742
  index = (u8 )0;
#line 744
  tmp = index;
#line 744
  index = (u8 )((int )index + 1);
#line 744
  *(rates + tmp) = (char)-126;
#line 745
  tmp___0 = index;
#line 745
  index = (u8 )((int )index + 1);
#line 745
  *(rates + tmp___0) = (char)-124;
#line 746
  tmp___1 = index;
#line 746
  index = (u8 )((int )index + 1);
#line 746
  *(rates + tmp___1) = (char)-117;
#line 747
  tmp___2 = index;
#line 747
  index = (u8 )((int )index + 1);
#line 747
  *(rates + tmp___2) = (char)-106;
#line 749
  return ((int )index);
}
}
#line 752 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_build_extended_rates(char *rates ) 
{ u8 index ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___6 ;

  {
#line 754
  index = (u8 )0;
#line 756
  tmp = index;
#line 756
  index = (u8 )((int )index + 1);
#line 756
  *(rates + tmp) = (char)12;
#line 757
  tmp___0 = index;
#line 757
  index = (u8 )((int )index + 1);
#line 757
  *(rates + tmp___0) = (char)18;
#line 758
  tmp___1 = index;
#line 758
  index = (u8 )((int )index + 1);
#line 758
  *(rates + tmp___1) = (char)24;
#line 759
  tmp___2 = index;
#line 759
  index = (u8 )((int )index + 1);
#line 759
  *(rates + tmp___2) = (char)36;
#line 760
  tmp___3 = index;
#line 760
  index = (u8 )((int )index + 1);
#line 760
  *(rates + tmp___3) = (char)48;
#line 761
  tmp___4 = index;
#line 761
  index = (u8 )((int )index + 1);
#line 761
  *(rates + tmp___4) = (char)72;
#line 762
  tmp___5 = index;
#line 762
  index = (u8 )((int )index + 1);
#line 762
  *(rates + tmp___5) = (char)96;
#line 763
  tmp___6 = index;
#line 763
  index = (u8 )((int )index + 1);
#line 763
  *(rates + tmp___6) = (char)108;
#line 765
  return ((int )index);
}
}
#line 769 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_build_probe_req(struct wl12xx *wl , u8 *ssid , size_t ssid_len ) 
{ struct wl12xx_probe_req_template template ;
  struct wl12xx_ie_rates *rates ;
  char *ptr ;
  u16 size ;
  int tmp ;
  int tmp___0 ;
  int tmp___2 ;

  {
  {
#line 776
  ptr = (char *)(& template);
#line 777
  size = (unsigned short )sizeof(struct ieee80211_header );
#line 779
  __constant_c_and_count_memset((void *)(template.header.da), 4294967295UL, 6U);
#line 780
  __constant_c_and_count_memset((void *)(template.header.bssid), 4294967295UL, 6U);
#line 781
  __constant_memcpy((void *)(template.header.sa), (void const   *)(wl->mac_addr),
                    6U);
#line 782
  template.header.frame_ctl = (unsigned short)64;
#line 786
  template.ssid.header.id = (unsigned char)0;
#line 787
  template.ssid.header.len = (unsigned char )ssid_len;
  }
#line 788
  if (ssid_len) {
#line 788
    if (ssid) {
      {
#line 789
      __memcpy((void *)(template.ssid.ssid), (void const   *)ssid, ssid_len);
      }
    } else {

    }
  } else {

  }
  {
#line 790
  size = (unsigned short )((unsigned int )size + (sizeof(struct wl12xx_ie_header ) + ssid_len));
#line 791
  ptr = ptr + (int )size;
#line 794
  rates = (struct wl12xx_ie_rates *)ptr;
#line 795
  rates->header.id = (unsigned char)1;
#line 796
  tmp = wl12xx_build_basic_rates((char *)(rates->rates));
#line 796
  rates->header.len = (unsigned char )tmp;
#line 797
  size = (unsigned short )((unsigned int )size + (sizeof(struct wl12xx_ie_header ) + (unsigned int )rates->header.len));
#line 798
  ptr = ptr + (sizeof(struct wl12xx_ie_header ) + (unsigned int )rates->header.len);
#line 801
  rates = (struct wl12xx_ie_rates *)ptr;
#line 802
  rates->header.id = (unsigned char)50;
#line 803
  tmp___0 = wl12xx_build_extended_rates((char *)(rates->rates));
#line 803
  rates->header.len = (unsigned char )tmp___0;
#line 804
  size = (unsigned short )((unsigned int )size + (sizeof(struct wl12xx_ie_header ) + (unsigned int )rates->header.len));
  }
  {
#line 806
  while (1) {
    while_29_continue: /* CIL Label */ ;
    goto while_29_break;
  }
  while_29_break: /* CIL Label */ ;
  }
  {
#line 808
  tmp___2 = wl12xx_cmd_template_set(wl, (unsigned short)22, (void *)(& template),
                                    (unsigned int )size);
  }
#line 808
  return (tmp___2);
}
}
#line 812 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_hw_scan(struct wl12xx *wl , u8 *ssid , size_t len , u8 active_scan ,
                          u8 high_prio , u8 num_channels , u8 probe_requests ) 
{ int i ;
  int ret ;
  u32 split_scan ;
  u16 scan_options ;
  struct cmd_scan *params ;
  struct wl12xx_command *cmd_answer ;
  void *tmp ;

  {
#line 817
  split_scan = (u32 )0;
#line 818
  scan_options = (u16 )0;
#line 822
  if (wl->scanning) {
#line 823
    return (-22);
  } else {

  }
  {
#line 825
  tmp = kzalloc(sizeof(*params), 208U);
#line 825
  params = (struct cmd_scan *)tmp;
  }
#line 826
  if (! params) {
#line 827
    return (-12);
  } else {

  }
#line 829
  params->params.rx_config_options = (unsigned int )(1UL << 3);
#line 830
  params->params.rx_filter_options = (unsigned int )(((1UL << 2) | (1UL << 4)) | (1UL << 9));
#line 834
  if (! active_scan) {
#line 835
    scan_options = (unsigned short )((unsigned long )scan_options | 1UL);
  } else {

  }
#line 836
  if (high_prio) {
#line 837
    scan_options = (unsigned short )((unsigned long )scan_options | (1UL << 3));
  } else {

  }
#line 838
  params->params.scan_options = scan_options;
#line 840
  params->params.num_channels = num_channels;
#line 841
  params->params.num_probe_requests = probe_requests;
#line 842
  params->params.tx_rate = (unsigned short )(1 << 1);
#line 843
  params->params.tid_trigger = (unsigned char)0;
#line 845
  i = 0;
  {
#line 845
  while (1) {
    while_30_continue: /* CIL Label */ ;
#line 845
    if (i < (int )num_channels) {

    } else {
      goto while_30_break;
    }
    {
#line 846
    params->channels[i].min_duration = 30000U;
#line 847
    params->channels[i].max_duration = 60000U;
#line 848
    __constant_c_and_count_memset((void *)(& params->channels[i].bssid_lsb), 4294967295UL,
                                  4U);
#line 849
    __constant_c_and_count_memset((void *)(& params->channels[i].bssid_msb), 4294967295UL,
                                  2U);
#line 850
    params->channels[i].early_termination = (unsigned char)0;
#line 851
    params->channels[i].tx_power_att = (unsigned char)0;
#line 852
    params->channels[i].channel = (unsigned char )(i + 1);
#line 853
    __constant_c_and_count_memset((void *)(params->channels[i].pad), 0UL, 3U);
#line 845
    i = i + 1;
    }
  }
  while_30_break: /* CIL Label */ ;
  }
#line 856
  i = (int )num_channels;
  {
#line 856
  while (1) {
    while_31_continue: /* CIL Label */ ;
#line 856
    if (i < 16) {

    } else {
      goto while_31_break;
    }
    {
#line 857
    __constant_c_and_count_memset((void *)(& params->channels[i]), 0UL, sizeof(struct basic_scan_channel_parameters ));
#line 856
    i = i + 1;
    }
  }
  while_31_break: /* CIL Label */ ;
  }
#line 860
  if (len) {
#line 860
    if (ssid) {
      {
#line 861
      params->params.ssid_len = (unsigned char )len;
#line 862
      __memcpy((void *)(params->params.ssid), (void const   *)ssid, len);
      }
    } else {
      {
#line 864
      params->params.ssid_len = (unsigned char)0;
#line 865
      __constant_c_and_count_memset((void *)(params->params.ssid), 0UL, 32U);
      }
    }
  } else {
    {
#line 864
    params->params.ssid_len = (unsigned char)0;
#line 865
    __constant_c_and_count_memset((void *)(params->params.ssid), 0UL, 32U);
    }
  }
  {
#line 868
  ret = wl12xx_build_probe_req(wl, ssid, len);
  }
#line 869
  if (ret < 0) {
    {
#line 870
    printk("<3>wl12xx: ERROR PROBE request template failed\n");
    }
    goto out;
  } else {

  }
  {
#line 874
  ret = wl12xx_cmd_send(wl, (unsigned short)47, (void *)(& split_scan), sizeof(u32 ));
  }
#line 876
  if (ret < 0) {
    {
#line 877
    printk("<3>wl12xx: ERROR Split SCAN failed\n");
    }
    goto out;
  } else {

  }
  {
#line 881
  while (1) {
    while_32_continue: /* CIL Label */ ;
    goto while_32_break;
  }
  while_32_break: /* CIL Label */ ;
  }
  {
#line 883
  wl->scanning = (_Bool)1;
#line 885
  ret = wl12xx_cmd_send(wl, (unsigned short)8, (void *)params, sizeof(*params));
  }
#line 886
  if (ret < 0) {
    {
#line 887
    printk("<3>wl12xx: ERROR SCAN failed\n");
    }
  } else {

  }
  {
#line 889
  wl12xx_spi_mem_read(wl, wl->cmd_box_addr, (void *)params, sizeof(*params));
#line 891
  cmd_answer = (struct wl12xx_command *)params;
  }
#line 892
  if ((int )cmd_answer->status != 1) {
    {
#line 893
    printk("<3>wl12xx: ERROR TEST command answer error: %d\n", cmd_answer->status);
#line 895
    wl->scanning = (_Bool)0;
#line 896
    ret = -5;
    }
    goto out;
  } else {

  }
  out: 
  {
#line 901
  kfree((void const   *)params);
  }
#line 902
  return (ret);
}
}
#line 906 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_hw_scan(struct ieee80211_hw *hw , struct cfg80211_scan_request *req ) 
{ struct wl12xx *wl ;
  int ret ;
  u8 *ssid ;
  size_t ssid_len ;

  {
#line 909
  wl = (struct wl12xx *)hw->priv;
#line 911
  ssid = (u8 *)((void *)0);
#line 912
  ssid_len = (size_t )0;
  {
#line 914
  while (1) {
    while_33_continue: /* CIL Label */ ;
    goto while_33_break;
  }
  while_33_break: /* CIL Label */ ;
  }
#line 916
  if (req->n_ssids) {
#line 917
    ssid = (req->ssids + 0)->ssid;
#line 918
    ssid_len = (unsigned int )(req->ssids + 0)->ssid_len;
  } else {

  }
  {
#line 921
  mutex_lock(& wl->mutex);
#line 922
  ret = wl12xx_hw_scan((struct wl12xx *)hw->priv, ssid, ssid_len, (unsigned char)1,
                       (unsigned char)0, (unsigned char)13, (unsigned char)3);
#line 923
  mutex_unlock(& wl->mutex);
  }
#line 925
  return (ret);
}
}
#line 928 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_op_set_rts_threshold(struct ieee80211_hw *hw , u32 value ) 
{ struct wl12xx *wl ;
  int ret ;

  {
  {
#line 930
  wl = (struct wl12xx *)hw->priv;
#line 933
  ret = wl12xx_acx_rts_threshold(wl, (unsigned short )value);
  }
#line 935
  if (ret < 0) {
    {
#line 936
    printk("<4>wl12xx: WARNING wl12xx_op_set_rts_threshold failed: %d\n", ret);
    }
  } else {

  }
#line 938
  return (ret);
}
}
#line 941 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void wl12xx_op_bss_info_changed(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                       struct ieee80211_bss_conf *bss_conf , u32 changed ) 
{ enum acx_ps_mode mode ;
  struct wl12xx *wl ;
  struct sk_buff *beacon ;
  int ret ;

  {
#line 947
  wl = (struct wl12xx *)hw->priv;
  {
#line 951
  while (1) {
    while_34_continue: /* CIL Label */ ;
    goto while_34_break;
  }
  while_34_break: /* CIL Label */ ;
  }
  {
#line 953
  mutex_lock(& wl->mutex);
  }
#line 955
  if (changed & 1U) {
#line 956
    if (bss_conf->assoc) {
      {
#line 957
      wl->aid = bss_conf->aid;
#line 959
      ret = wl12xx_build_ps_poll(wl, wl->aid);
      }
#line 960
      if (ret < 0) {
        goto out;
      } else {

      }
      {
#line 963
      ret = wl12xx_acx_aid(wl, wl->aid);
      }
#line 964
      if (ret < 0) {
        goto out;
      } else {

      }
#line 968
      if (wl->psm_requested) {
#line 968
        if (! wl->psm) {
          {
#line 969
          mode = (enum acx_ps_mode )1;
#line 970
          ret = wl12xx_ps_set_mode(wl, mode);
          }
#line 971
          if (ret < 0) {
            goto out;
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 976
  if (changed & 8U) {
#line 977
    if (bss_conf->use_short_slot) {
      {
#line 978
      ret = wl12xx_acx_slot(wl, (enum acx_slot_type )1);
      }
    } else {
      {
#line 980
      ret = wl12xx_acx_slot(wl, (enum acx_slot_type )0);
      }
    }
#line 981
    if (ret < 0) {
      {
#line 982
      printk("<4>wl12xx: WARNING Set slot time failed %d\n", ret);
      }
      goto out;
    } else {

    }
  } else {

  }
#line 987
  if (changed & 4U) {
#line 988
    if (bss_conf->use_short_preamble) {
      {
#line 989
      wl12xx_acx_set_preamble(wl, (enum acx_preamble_type )1);
      }
    } else {
      {
#line 991
      wl12xx_acx_set_preamble(wl, (enum acx_preamble_type )0);
      }
    }
  } else {

  }
#line 994
  if (changed & 2U) {
#line 995
    if (bss_conf->use_cts_prot) {
      {
#line 996
      ret = wl12xx_acx_cts_protect(wl, (enum acx_ctsprotect_type )1);
      }
    } else {
      {
#line 998
      ret = wl12xx_acx_cts_protect(wl, (enum acx_ctsprotect_type )0);
      }
    }
#line 999
    if (ret < 0) {
      {
#line 1000
      printk("<4>wl12xx: WARNING Set ctsprotect failed %d\n", ret);
      }
      goto out;
    } else {

    }
  } else {

  }
#line 1005
  if (changed & 128U) {
    {
#line 1006
    __constant_memcpy((void *)(wl->bssid), (void const   *)bss_conf->bssid, 6U);
#line 1008
    ret = wl12xx_build_null_data(wl);
    }
#line 1009
    if (ret < 0) {
      goto out;
    } else {

    }
#line 1012
    if ((int )wl->bss_type != 0) {
      {
#line 1013
      ret = wl12xx_cmd_join(wl, wl->bss_type, (unsigned char)5, (unsigned short)100,
                            (unsigned char)1);
      }
#line 1014
      if (ret < 0) {
        goto out;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1019
  if (changed & 256U) {
    {
#line 1020
    beacon = ieee80211_beacon_get(hw, vif);
#line 1021
    ret = wl12xx_cmd_template_set(wl, (unsigned short)19, (void *)beacon->data, beacon->len);
    }
#line 1024
    if (ret < 0) {
      {
#line 1025
      consume_skb(beacon);
      }
      goto out;
    } else {

    }
    {
#line 1029
    ret = wl12xx_cmd_template_set(wl, (unsigned short)20, (void *)beacon->data, beacon->len);
#line 1032
    consume_skb(beacon);
    }
#line 1034
    if (ret < 0) {
      goto out;
    } else {

    }
    {
#line 1037
    ret = wl12xx_cmd_join(wl, wl->bss_type, (unsigned char)1, (unsigned short)100,
                          (unsigned char)0);
    }
#line 1039
    if (ret < 0) {
      goto out;
    } else {

    }
  } else {

  }
  out: 
  {
#line 1044
  mutex_unlock(& wl->mutex);
  }
#line 1045
  return;
}
}
#line 1049 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static struct ieee80211_rate wl12xx_rates[12]  = 
#line 1049
  {      {0U, (u16 )10, (u16 )1, (u16 )1}, 
        {(u32 )1, (u16 )20, (u16 )2, (u16 )2}, 
        {(u32 )1, (u16 )55, (u16 )4, (u16 )4}, 
        {(u32 )1, (u16 )110, (u16 )32, (u16 )32}, 
        {0U, (u16 )60, (u16 )8, (u16 )8}, 
        {0U, (u16 )90, (u16 )16, (u16 )16}, 
        {0U, (u16 )120, (u16 )64, (u16 )64}, 
        {0U, (u16 )180, (u16 )128, (u16 )128}, 
        {0U, (u16 )240, (u16 )512, (u16 )512}, 
        {0U, (u16 )360, (u16 )1024, (u16 )1024}, 
        {0U, (u16 )480, (u16 )2048, (u16 )2048}, 
        {0U, (u16 )540, (u16 )4096, (u16 )4096}};
#line 1092 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static struct ieee80211_channel wl12xx_channels[13]  = 
#line 1092
  {      {0, (u16 )2412, (u16 )1, 0U, 0, 0, (_Bool)0, 0U, 0, 0}, 
        {0, (u16 )2417, (u16 )2, 0U, 0, 0, (_Bool)0, 0U, 0, 0}, 
        {0, (u16 )2422, (u16 )3, 0U, 0, 0, (_Bool)0, 0U, 0, 0}, 
        {0, (u16 )2427, (u16 )4, 0U, 0, 0, (_Bool)0, 0U, 0, 0}, 
        {0, (u16 )2432, (u16 )5, 0U, 0, 0, (_Bool)0, 0U, 0, 0}, 
        {0, (u16 )2437, (u16 )6, 0U, 0, 0, (_Bool)0, 0U, 0, 0}, 
        {0, (u16 )2442, (u16 )7, 0U, 0, 0, (_Bool)0, 0U, 0, 0}, 
        {0, (u16 )2447, (u16 )8, 0U, 0, 0, (_Bool)0, 0U, 0, 0}, 
        {0, (u16 )2452, (u16 )9, 0U, 0, 0, (_Bool)0, 0U, 0, 0}, 
        {0, (u16 )2457, (u16 )10, 0U, 0, 0, (_Bool)0, 0U, 0, 0}, 
        {0, (u16 )2462, (u16 )11, 0U, 0, 0, (_Bool)0, 0U, 0, 0}, 
        {0, (u16 )2467, (u16 )12, 0U, 0, 0, (_Bool)0, 0U, 0, 0}, 
        {0, (u16 )2472, (u16 )13, 0U, 0, 0, (_Bool)0, 0U, 0, 0}};
#line 1109 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static struct ieee80211_supported_band wl12xx_band_2ghz  =    {wl12xx_channels, wl12xx_rates, 0, (int )(sizeof(wl12xx_channels) / sizeof(wl12xx_channels[0]) + sizeof(struct __anonstruct_310 )),
    (int )(sizeof(wl12xx_rates) / sizeof(wl12xx_rates[0]) + sizeof(struct __anonstruct_311 )),
    {(unsigned short)0, (_Bool)0, (unsigned char)0, (unsigned char)0, {{(unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0},
                                                                       (unsigned short)0,
                                                                       (unsigned char)0,
                                                                       {(unsigned char)0,
                                                                        (unsigned char)0,
                                                                        (unsigned char)0}}}};
#line 1116 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static struct ieee80211_ops  const  wl12xx_ops  = 
#line 1116
     {& wl12xx_op_tx, & wl12xx_op_start, & wl12xx_op_stop, & wl12xx_op_add_interface,
    & wl12xx_op_remove_interface, & wl12xx_op_config, & wl12xx_op_bss_info_changed,
    (u64 (*)(struct ieee80211_hw *hw , int mc_count , struct dev_addr_list *mc_list ))0,
    (void (*)(struct ieee80211_hw *hw , unsigned int changed_flags , unsigned int *total_flags ,
              u64 multicast ))(& wl12xx_op_configure_filter), (int (*)(struct ieee80211_hw *hw ,
                                                                       struct ieee80211_sta *sta ,
                                                                       bool set ))0,
    & wl12xx_op_set_key, (void (*)(struct ieee80211_hw *hw , struct ieee80211_key_conf *conf ,
                                   u8 const   *address , u32 iv32 , u16 *phase1key ))0,
    & wl12xx_op_hw_scan, (void (*)(struct ieee80211_hw *hw ))0, (void (*)(struct ieee80211_hw *hw ))0,
    (int (*)(struct ieee80211_hw *hw , struct ieee80211_low_level_stats *stats ))0,
    (void (*)(struct ieee80211_hw *hw , u8 hw_key_idx , u32 *iv32 , u16 *iv16 ))0,
    & wl12xx_op_set_rts_threshold, (void (*)(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                             enum sta_notify_cmd  , struct ieee80211_sta *sta ))0,
    (int (*)(struct ieee80211_hw *hw , u16 queue , struct ieee80211_tx_queue_params  const  *params ))0,
    (int (*)(struct ieee80211_hw *hw , struct ieee80211_tx_queue_stats *stats ))0,
    (u64 (*)(struct ieee80211_hw *hw ))0, (void (*)(struct ieee80211_hw *hw , u64 tsf ))0,
    (void (*)(struct ieee80211_hw *hw ))0, (int (*)(struct ieee80211_hw *hw ))0, (int (*)(struct ieee80211_hw *hw ,
                                                                                          enum ieee80211_ampdu_mlme_action action ,
                                                                                          struct ieee80211_sta *sta ,
                                                                                          u16 tid ,
                                                                                          u16 *ssn ))0,
    (void (*)(struct ieee80211_hw *hw ))0, (int (*)(struct ieee80211_hw *hw , void *data ,
                                                    int len ))0};
#line 1130 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_register_hw(struct wl12xx *wl ) 
{ int ret ;

  {
#line 1134
  if (wl->mac80211_registered) {
#line 1135
    return (0);
  } else {

  }
  {
#line 1137
  SET_IEEE80211_PERM_ADDR(wl->hw, wl->mac_addr);
#line 1139
  ret = ieee80211_register_hw(wl->hw);
  }
#line 1140
  if (ret < 0) {
    {
#line 1141
    printk("<3>wl12xx: ERROR unable to register mac80211 hw: %d\n", ret);
    }
#line 1142
    return (ret);
  } else {

  }
  {
#line 1145
  wl->mac80211_registered = (_Bool)1;
#line 1147
  printk("<6>wl12xx: loaded\n");
  }
#line 1149
  return (0);
}
}
#line 1152 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int wl12xx_init_ieee80211(struct wl12xx *wl ) 
{ 

  {
  {
#line 1155
  (wl->hw)->extra_tx_headroom = sizeof(struct tx_double_buffer_desc ) + 4U;
#line 1160
  (wl->hw)->channel_change_time = 10000;
#line 1162
  (wl->hw)->flags = 192U;
#line 1165
  ((wl->hw)->wiphy)->interface_modes = (unsigned short )(1UL << 2);
#line 1166
  ((wl->hw)->wiphy)->max_scan_ssids = (unsigned char)1;
#line 1167
  ((wl->hw)->wiphy)->bands[0] = & wl12xx_band_2ghz;
#line 1169
  SET_IEEE80211_DEV(wl->hw, & (wl->spi)->dev);
  }
#line 1171
  return (0);
}
}
#line 1181
static int __attribute__((__cold__))  wl12xx_probe(struct spi_device *spi )  __attribute__((__section__(".devinit.text"))) ;
#line 1181 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static u8 const   nokia_oui[3]  = {      (u8 const   )0,      (u8 const   )31,      (u8 const   )223};
#line 1241 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static struct lock_class_key __key___3  ;
#line 1175
static int __attribute__((__cold__))  wl12xx_probe(struct spi_device *spi )  __attribute__((__section__(".devinit.text"))) ;
#line 1175 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int __attribute__((__cold__))  wl12xx_probe(struct spi_device *spi ) 
{ struct wl12xx_platform_data *pdata ;
  struct ieee80211_hw *hw ;
  struct wl12xx *wl ;
  int ret ;
  int i ;
  atomic_long_t __constr_expr_0 ;
  atomic_long_t __constr_expr_1 ;

  {
#line 1183
  pdata = (struct wl12xx_platform_data *)spi->dev.platform_data;
#line 1184
  if (! pdata) {
    {
#line 1185
    printk("<3>wl12xx: ERROR no platform data\n");
    }
#line 1186
    return ((int __attribute__((__cold__))  )-19);
  } else {

  }
  {
#line 1189
  hw = ieee80211_alloc_hw(sizeof(*wl), & wl12xx_ops);
  }
#line 1190
  if (! hw) {
    {
#line 1191
    printk("<3>wl12xx: ERROR could not alloc ieee80211_hw\n");
    }
#line 1192
    return ((int __attribute__((__cold__))  )-12);
  } else {

  }
  {
#line 1195
  wl = (struct wl12xx *)hw->priv;
#line 1196
  __constant_c_and_count_memset((void *)wl, 0UL, sizeof(*wl));
#line 1198
  wl->hw = hw;
#line 1199
  dev_set_drvdata(& spi->dev, (void *)wl);
#line 1200
  wl->spi = spi;
#line 1202
  wl->data_in_count = 0U;
#line 1204
  skb_queue_head_init(& wl->tx_queue);
  }
  {
#line 1206
  while (1) {
    while_35_continue: /* CIL Label */ ;
    {
#line 1206
    __constr_expr_0.counter = (int volatile   )0;
#line 1206
    wl->tx_work.data = __constr_expr_0;
#line 1206
    INIT_LIST_HEAD(& wl->tx_work.entry);
    }
    {
#line 1206
    while (1) {
      while_36_continue: /* CIL Label */ ;
#line 1206
      wl->tx_work.func = & wl12xx_tx_work;
      goto while_36_break;
    }
    while_36_break: /* CIL Label */ ;
    }
    goto while_35_break;
  }
  while_35_break: /* CIL Label */ ;
  }
  {
#line 1207
  while (1) {
    while_37_continue: /* CIL Label */ ;
    {
#line 1207
    __constr_expr_1.counter = (int volatile   )0;
#line 1207
    wl->filter_work.data = __constr_expr_1;
#line 1207
    INIT_LIST_HEAD(& wl->filter_work.entry);
    }
    {
#line 1207
    while (1) {
      while_38_continue: /* CIL Label */ ;
#line 1207
      wl->filter_work.func = & wl12xx_filter_work;
      goto while_38_break;
    }
    while_38_break: /* CIL Label */ ;
    }
    goto while_37_break;
  }
  while_37_break: /* CIL Label */ ;
  }
#line 1208
  wl->channel = 1;
#line 1209
  wl->scanning = (_Bool)0;
#line 1210
  wl->default_key = 0U;
#line 1211
  wl->listen_int = (unsigned char)1;
#line 1212
  wl->rx_counter = 0U;
#line 1213
  wl->rx_handled = 0U;
#line 1214
  wl->rx_current_buffer = 0U;
#line 1215
  wl->rx_last_id = 0U;
#line 1216
  wl->rx_config = (unsigned int )((1UL << 4) | (1UL << 5));
#line 1217
  wl->rx_filter = (unsigned int )(((((((1UL << 2) | (1UL << 4)) | (1UL << 6)) | (1UL << 7)) | (1UL << 9)) | (1UL << 10)) | (1UL << 11));
#line 1218
  wl->elp = (_Bool)0;
#line 1219
  wl->psm = (_Bool)0;
#line 1220
  wl->psm_requested = (_Bool)0;
#line 1221
  wl->tx_queue_stopped = (_Bool)0;
#line 1222
  wl->power_level = 20;
#line 1226
  wl->chip.power_on_sleep = 200U;
#line 1228
  i = 0;
  {
#line 1228
  while (1) {
    while_39_continue: /* CIL Label */ ;
#line 1228
    if (i < 16) {

    } else {
      goto while_39_break;
    }
#line 1229
    wl->tx_frames[i] = (struct sk_buff *)((void *)0);
#line 1228
    i = i + 1;
  }
  while_39_break: /* CIL Label */ ;
  }
  {
#line 1231
  wl->next_tx_complete = 0U;
#line 1237
  __constant_memcpy((void *)(wl->mac_addr), (void const   *)(nokia_oui), 3U);
#line 1238
  get_random_bytes((void *)(wl->mac_addr + 3), 3);
#line 1240
  wl->state = (enum wl12xx_state )0;
  }
  {
#line 1241
  while (1) {
    while_40_continue: /* CIL Label */ ;
    {
#line 1241
    __mutex_init(& wl->mutex, "&wl->mutex", & __key___3);
    }
    goto while_40_break;
  }
  while_40_break: /* CIL Label */ ;
  }
  {
#line 1243
  wl->tx_mgmt_frm_rate = 20U;
#line 1244
  wl->tx_mgmt_frm_mod = 0U;
#line 1248
  spi->bits_per_word = (unsigned char)32;
#line 1250
  ret = spi_setup(spi);
  }
#line 1251
  if (ret < 0) {
    {
#line 1252
    printk("<3>wl12xx: ERROR spi_setup failed\n");
    }
    goto out_free;
  } else {

  }
#line 1256
  wl->set_power = pdata->set_power;
#line 1257
  if (! wl->set_power) {
    {
#line 1258
    printk("<3>wl12xx: ERROR set power function missing in platform data\n");
    }
#line 1259
    return ((int __attribute__((__cold__))  )-19);
  } else {

  }
#line 1262
  wl->irq = spi->irq;
#line 1263
  if (wl->irq < 0) {
    {
#line 1264
    printk("<3>wl12xx: ERROR irq missing in platform data\n");
    }
#line 1265
    return ((int __attribute__((__cold__))  )-19);
  } else {

  }
  {
#line 1268
  ret = request_irq((unsigned int )wl->irq, & wl12xx_irq, 0UL, "wl12xx", (void *)wl);
  }
#line 1269
  if (ret < 0) {
    {
#line 1270
    printk("<3>wl12xx: ERROR request_irq() failed: %d\n", ret);
    }
    goto out_free;
  } else {

  }
  {
#line 1274
  set_irq_type((unsigned int )wl->irq, 1U);
#line 1276
  disable_irq((unsigned int )wl->irq);
#line 1278
  ret = wl12xx_init_ieee80211(wl);
  }
#line 1279
  if (ret) {
    goto out_irq;
  } else {

  }
  {
#line 1282
  ret = wl12xx_register_hw(wl);
  }
#line 1283
  if (ret) {
    goto out_irq;
  } else {

  }
  {
#line 1286
  wl12xx_debugfs_init(wl);
#line 1288
  printk("<6>wl12xx: initialized\n");
  }
#line 1290
  return ((int __attribute__((__cold__))  )0);
  out_irq: 
  {
#line 1293
  free_irq((unsigned int )wl->irq, (void *)wl);
  }
  out_free: 
  {
#line 1296
  ieee80211_free_hw(hw);
  }
#line 1298
  return ((int __attribute__((__cold__))  )ret);
}
}
#line 1301
static int __attribute__((__cold__))  wl12xx_remove(struct spi_device *spi )  __attribute__((__section__(".devexit.text"))) ;
#line 1301 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int __attribute__((__cold__))  wl12xx_remove(struct spi_device *spi ) 
{ struct wl12xx *wl ;
  void *tmp ;

  {
  {
#line 1303
  tmp = dev_get_drvdata((struct device  const  *)(& spi->dev));
#line 1303
  wl = (struct wl12xx *)tmp;
#line 1305
  ieee80211_unregister_hw(wl->hw);
#line 1307
  wl12xx_debugfs_exit(wl);
#line 1309
  free_irq((unsigned int )wl->irq, (void *)wl);
#line 1310
  kfree((void const   *)wl->target_mem_map);
#line 1311
  kfree((void const   *)wl->data_path);
#line 1312
  kfree((void const   *)wl->fw);
#line 1313
  wl->fw = (u8 *)((void *)0);
#line 1314
  kfree((void const   *)wl->nvs);
#line 1315
  wl->nvs = (u8 *)((void *)0);
#line 1316
  ieee80211_free_hw(wl->hw);
  }
#line 1318
  return ((int __attribute__((__cold__))  )0);
}
}
#line 1322 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static struct spi_driver wl12xx_spi_driver  =    {(struct spi_device_id  const  *)0, (int (*)(struct spi_device *spi ))(& wl12xx_probe),
    (int (*)(struct spi_device *spi ))(& wl12xx_remove), (void (*)(struct spi_device *spi ))0,
    (int (*)(struct spi_device *spi , pm_message_t mesg ))0, (int (*)(struct spi_device *spi ))0,
    {"wl12xx", & spi_bus_type, & __this_module, (char const   *)0, (_Bool)0, (int (*)(struct device *dev ))0,
     (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0, (int (*)(struct device *dev ,
                                                                                 pm_message_t state ))0,
     (int (*)(struct device *dev ))0, (struct attribute_group  const  **)0, (struct dev_pm_ops  const  *)0,
     (struct driver_private *)0}};
#line 1333
static int __attribute__((__cold__))  wl12xx_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1333 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int __attribute__((__cold__))  wl12xx_init(void) 
{ int ret ;

  {
  {
#line 1337
  ret = spi_register_driver(& wl12xx_spi_driver);
  }
#line 1338
  if (ret < 0) {
    {
#line 1339
    printk("<3>wl12xx: ERROR failed to register spi driver: %d\n", ret);
    }
    goto out;
  } else {

  }
  out: 
#line 1344
  return ((int __attribute__((__cold__))  )ret);
}
}
#line 1347
static void __attribute__((__cold__))  wl12xx_exit(void)  __attribute__((__section__(".exit.text"))) ;
#line 1347 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static void __attribute__((__cold__))  wl12xx_exit(void) 
{ 

  {
  {
#line 1349
  spi_unregister_driver(& wl12xx_spi_driver);
#line 1351
  printk("<6>wl12xx: unloaded\n");
  }
#line 1352
  return;
}
}
#line 1354 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
int init_module(void) 
{ int __attribute__((__cold__))  tmp ;

  {
  {
#line 1354
  tmp = wl12xx_init();
  }
#line 1354
  return ((int )tmp);
}
}
#line 1355 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
void cleanup_module(void) 
{ 

  {
  {
#line 1355
  wl12xx_exit();
  }
#line 1355
  return;
}
}
#line 1357 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static char const   __mod_license1357[12]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
#line 1357
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'\000'};
#line 1358 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static char const   __mod_author1359[84]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
#line 1358
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'=',      (char const   )'K', 
        (char const   )'a',      (char const   )'l',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'V',      (char const   )'a',      (char const   )'l', 
        (char const   )'o',      (char const   )' ',      (char const   )'<',      (char const   )'K', 
        (char const   )'a',      (char const   )'l',      (char const   )'l',      (char const   )'e', 
        (char const   )'.',      (char const   )'V',      (char const   )'a',      (char const   )'l', 
        (char const   )'o',      (char const   )'@',      (char const   )'n',      (char const   )'o', 
        (char const   )'k',      (char const   )'i',      (char const   )'a',      (char const   )'.', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'>', 
        (char const   )',',      (char const   )' ',      (char const   )'L',      (char const   )'u', 
        (char const   )'c',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )'o',      (char const   )' ',      (char const   )'C',      (char const   )'o', 
        (char const   )'e',      (char const   )'l',      (char const   )'h',      (char const   )'o', 
        (char const   )' ',      (char const   )'<',      (char const   )'l',      (char const   )'u', 
        (char const   )'c',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )'o',      (char const   )'.',      (char const   )'c',      (char const   )'o', 
        (char const   )'e',      (char const   )'l',      (char const   )'h',      (char const   )'o', 
        (char const   )'@',      (char const   )'n',      (char const   )'o',      (char const   )'k', 
        (char const   )'i',      (char const   )'a',      (char const   )'.',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'>',      (char const   )'\000'};
#line 1370
void check_final_state(void) ;
#line 1371
extern void check_return_value(int res ) ;
#line 1372
extern int IN_INTERRUPT ;
#line 1501 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
static int __attribute__((__cold__))  rtmp0  __attribute__((__section__(".devinit.text")))  ;
#line 1373 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/main.c.common.c"
void ldv_main1(void) 
{ struct ieee80211_hw *var0 ;
  struct sk_buff *var1 ;
  struct ieee80211_hw *var2 ;
  struct ieee80211_hw *var3 ;
  struct ieee80211_hw *var4 ;
  struct ieee80211_if_init_conf *var5 ;
  struct ieee80211_hw *var6 ;
  struct ieee80211_if_init_conf *var7 ;
  struct ieee80211_hw *var8 ;
  u32 var9 ;
  struct ieee80211_hw *var10 ;
  unsigned int var11 ;
  unsigned int *var12 ;
  int var13 ;
  struct dev_addr_list *var14 ;
  struct ieee80211_hw *var15 ;
  enum set_key_cmd var16 ;
  struct ieee80211_vif *var17 ;
  struct ieee80211_sta *var18 ;
  struct ieee80211_key_conf *var19 ;
  struct ieee80211_hw *var20 ;
  struct cfg80211_scan_request *var21 ;
  struct ieee80211_hw *var22 ;
  u32 var23 ;
  struct ieee80211_hw *var24 ;
  struct ieee80211_vif *var25 ;
  struct ieee80211_bss_conf *var26 ;
  u32 var27 ;
  struct spi_device *var28 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  int __attribute__((__cold__))  tmp___22 ;

  {
  {
#line 1376
  IN_INTERRUPT = 1;
#line 1509
  tmp = kmalloc(1U, 208U);
#line 1509
  var0 = (struct ieee80211_hw *)tmp;
#line 1510
  tmp___0 = kmalloc(1U, 208U);
#line 1510
  var1 = (struct sk_buff *)tmp___0;
#line 1519
  tmp___1 = kmalloc(1U, 208U);
#line 1519
  var2 = (struct ieee80211_hw *)tmp___1;
#line 1528
  tmp___2 = kmalloc(1U, 208U);
#line 1528
  var3 = (struct ieee80211_hw *)tmp___2;
#line 1537
  tmp___3 = kmalloc(1U, 208U);
#line 1537
  var4 = (struct ieee80211_hw *)tmp___3;
#line 1538
  tmp___4 = kmalloc(1U, 208U);
#line 1538
  var5 = (struct ieee80211_if_init_conf *)tmp___4;
#line 1547
  tmp___5 = kmalloc(1U, 208U);
#line 1547
  var6 = (struct ieee80211_hw *)tmp___5;
#line 1548
  tmp___6 = kmalloc(1U, 208U);
#line 1548
  var7 = (struct ieee80211_if_init_conf *)tmp___6;
#line 1557
  tmp___7 = kmalloc(1U, 208U);
#line 1557
  var8 = (struct ieee80211_hw *)tmp___7;
#line 1566
  tmp___8 = kmalloc(1U, 208U);
#line 1566
  var10 = (struct ieee80211_hw *)tmp___8;
#line 1567
  tmp___9 = kmalloc(1U, 208U);
#line 1567
  var12 = (unsigned int *)tmp___9;
#line 1568
  tmp___10 = kmalloc(1U, 208U);
#line 1568
  var14 = (struct dev_addr_list *)tmp___10;
#line 1577
  tmp___11 = kmalloc(1U, 208U);
#line 1577
  var15 = (struct ieee80211_hw *)tmp___11;
#line 1578
  tmp___12 = kmalloc(1U, 208U);
#line 1578
  var17 = (struct ieee80211_vif *)tmp___12;
#line 1579
  tmp___13 = kmalloc(1U, 208U);
#line 1579
  var18 = (struct ieee80211_sta *)tmp___13;
#line 1580
  tmp___14 = kmalloc(1U, 208U);
#line 1580
  var19 = (struct ieee80211_key_conf *)tmp___14;
#line 1589
  tmp___15 = kmalloc(1U, 208U);
#line 1589
  var20 = (struct ieee80211_hw *)tmp___15;
#line 1590
  tmp___16 = kmalloc(1U, 208U);
#line 1590
  var21 = (struct cfg80211_scan_request *)tmp___16;
#line 1599
  tmp___17 = kmalloc(1U, 208U);
#line 1599
  var22 = (struct ieee80211_hw *)tmp___17;
#line 1608
  tmp___18 = kmalloc(1U, 208U);
#line 1608
  var24 = (struct ieee80211_hw *)tmp___18;
#line 1609
  tmp___19 = kmalloc(1U, 208U);
#line 1609
  var25 = (struct ieee80211_vif *)tmp___19;
#line 1610
  tmp___20 = kmalloc(1U, 208U);
#line 1610
  var26 = (struct ieee80211_bss_conf *)tmp___20;
#line 1622
  tmp___21 = kmalloc(1U, 208U);
#line 1622
  var28 = (struct spi_device *)tmp___21;
#line 1637
  tmp___22 = wl12xx_init();
  }
#line 1637
  if (tmp___22) {
#line 1638
    return;
  } else {

  }
  {
#line 1642
  wl12xx_op_tx(var0, var1);
#line 1651
  wl12xx_op_start(var2);
#line 1660
  wl12xx_op_stop(var3);
#line 1669
  wl12xx_op_add_interface(var4, var5);
#line 1678
  wl12xx_op_remove_interface(var6, var7);
#line 1687
  wl12xx_op_config(var8, var9);
#line 1696
  wl12xx_op_configure_filter(var10, var11, var12, var13, var14);
#line 1705
  wl12xx_op_set_key(var15, var16, var17, var18, var19);
#line 1714
  wl12xx_op_hw_scan(var20, var21);
#line 1723
  wl12xx_op_set_rts_threshold(var22, var23);
#line 1732
  wl12xx_op_bss_info_changed(var24, var25, var26, var27);
#line 1744
  rtmp0 = wl12xx_probe(var28);
#line 1745
  check_return_value((int )rtmp0);
  }
#line 1746
  if (rtmp0) {
#line 1747
    return;
  } else {

  }
  {
#line 1758
  wl12xx_exit();
#line 1762
  check_final_state();
  }
#line 1763
  return;
}
}
#line 5 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/engine-blast-assert.h"
void __blast_assert(void) 
{ 

  {
  ERROR: 
  goto ERROR;
}
}
#line 4 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/engine-blast.h"
extern int __undefined_int(void) ;
#line 5 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int ldv_mutex  =    1;
#line 17 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int mutex_lock_interruptible(struct mutex *lock ) 
{ int tmp ;

  {
#line 19
  if (IN_INTERRUPT == 1) {

  } else {
    {
#line 19
    __blast_assert();
    }
  }
#line 20
  if (ldv_mutex == 1) {

  } else {
    {
#line 20
    __blast_assert();
    }
  }
  {
#line 21
  tmp = __undefined_int();
  }
#line 21
  if (tmp) {
#line 22
    ldv_mutex = 2;
#line 23
    return (0);
  } else {
#line 25
    ldv_mutex = 1;
#line 26
    return (-4);
  }
}
}
#line 30 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int mutex_lock_killable(struct mutex *lock ) 
{ int tmp ;

  {
#line 32
  if (IN_INTERRUPT == 1) {

  } else {
    {
#line 32
    __blast_assert();
    }
  }
#line 33
  if (ldv_mutex == 1) {

  } else {
    {
#line 33
    __blast_assert();
    }
  }
  {
#line 34
  tmp = __undefined_int();
  }
#line 34
  if (tmp) {
#line 35
    ldv_mutex = 2;
#line 36
    return (0);
  } else {
#line 38
    ldv_mutex = 1;
#line 39
    return (-4);
  }
}
}
#line 43 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
void mutex_lock(struct mutex *lock ) 
{ 

  {
#line 44
  if (IN_INTERRUPT == 1) {

  } else {
    {
#line 44
    __blast_assert();
    }
  }
#line 45
  if (ldv_mutex == 1) {

  } else {
    {
#line 45
    __blast_assert();
    }
  }
#line 46
  ldv_mutex = 2;
#line 47
  return;
}
}
#line 49 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
int mutex_trylock(struct mutex *lock ) 
{ int tmp ;

  {
#line 50
  if (IN_INTERRUPT == 1) {

  } else {
    {
#line 50
    __blast_assert();
    }
  }
#line 51
  if (ldv_mutex == 1) {

  } else {
    {
#line 51
    __blast_assert();
    }
  }
  {
#line 52
  tmp = __undefined_int();
  }
#line 52
  if (tmp) {
#line 53
    ldv_mutex = 2;
#line 54
    return (1);
  } else {
#line 56
    ldv_mutex = 1;
#line 57
    return (0);
  }
}
}
#line 61 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
void mutex_unlock(struct mutex *lock ) 
{ 

  {
#line 62
  if (IN_INTERRUPT == 1) {

  } else {
    {
#line 62
    __blast_assert();
    }
  }
#line 63
  if (ldv_mutex == 2) {

  } else {
    {
#line 63
    __blast_assert();
    }
  }
#line 64
  ldv_mutex = 1;
#line 65
  return;
}
}
#line 67 "/home/mutilin/opt/workdir/1/dscv_tempdir/dscv/ri/32_1/kernel-rules/files/model0032.c"
void check_final_state(void) 
{ 

  {
#line 68
  if (ldv_mutex == 1) {

  } else {
    {
#line 68
    __blast_assert();
    }
  }
#line 69
  return;
}
}

int main(void) {
  ldv_main1();
  return 0;
}
