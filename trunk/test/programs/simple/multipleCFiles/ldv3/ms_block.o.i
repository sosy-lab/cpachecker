// SPDX-FileCopyrightText: The Linux kernel authors
//
// SPDX-License-Identifier: GPL-2.0-only

# 1 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c"





typedef struct __va_list_tag __va_list_tag;
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list[1U];
# 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list[1U];
struct ftrace_branch_data
{
# 80 "include/linux/compiler.h"
  char const *func;
  char const *file;
  unsigned int line;
# 93 "include/linux/compiler.h"
  union
  {
# 87 "include/linux/compiler.h"
    struct
    {
# 85 "include/linux/compiler.h"
      long unsigned int correct;
      long unsigned int incorrect;
    } ldv_803;
# 91 "include/linux/compiler.h"
    struct
    {
# 89 "include/linux/compiler.h"
      long unsigned int miss;
      long unsigned int hit;
    } ldv_807;
    long unsigned int miss_hit[2U];
  } ldv_809;
};
struct kernel_symbol
{
# 28 "include/linux/export.h"
  long unsigned int value;
  char const *name;
};
# 33 "include/linux/export.h"
extern struct module __this_module;
enum ldv_501
{
  false = 0,
  true = 1
};
# 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
typedef unsigned char __u8;
# 22 "include/uapi/asm-generic/int-ll64.h"
typedef short int __s16;
typedef short unsigned int __u16;
# 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
typedef unsigned int __u32;
# 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long int __s64;
typedef long long unsigned int __u64;
# 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
typedef unsigned char u8;
# 18 "include/asm-generic/int-ll64.h"
typedef short int s16;
typedef short unsigned int u16;
# 21 "include/asm-generic/int-ll64.h"
typedef int s32;
typedef unsigned int u32;
# 24 "include/asm-generic/int-ll64.h"
typedef long long int s64;
typedef long long unsigned int u64;
typedef struct
{
# 25 "./include/uapi/linux/posix_types.h"
  long unsigned int fds_bits[16U];
} __kernel_fd_set;
# 29 "./include/uapi/linux/posix_types.h"
typedef void (*__kernel_sighandler_t)(int);
# 32 "./include/uapi/linux/posix_types.h"
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;
# 10 "./arch/x86/include/uapi/asm/posix_types_64.h"
typedef short unsigned int __kernel_old_uid_t;
typedef short unsigned int __kernel_old_gid_t;
# 14 "./arch/x86/include/uapi/asm/posix_types_64.h"
typedef long unsigned int __kernel_old_dev_t;
# 14 "./include/uapi/asm-generic/posix_types.h"
typedef long int __kernel_long_t;
typedef long unsigned int __kernel_ulong_t;
# 19 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_ino_t;
# 23 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_mode_t;
# 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
# 31 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_ipc_pid_t;
# 35 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;
# 40 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
# 44 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_daddr_t;
# 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;
# 80 "./include/uapi/asm-generic/posix_types.h"
typedef struct
{
# 79 "./include/uapi/asm-generic/posix_types.h"
  int val[2U];
} __kernel_fsid_t;
# 86 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
typedef long long int __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char *__kernel_caddr_t;
typedef short unsigned int __kernel_uid16_t;
typedef short unsigned int __kernel_gid16_t;
# 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;
# 39 "include/uapi/linux/types.h"
typedef __u16 __sum16;
typedef __u32 __wsum;
# 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
# 14 "include/linux/types.h"
typedef __kernel_fd_set fd_set;
typedef __kernel_dev_t dev_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef short unsigned int umode_t;
typedef __u32 nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_daddr_t daddr_t;
typedef __kernel_key_t key_t;
typedef __kernel_suseconds_t suseconds_t;
typedef __kernel_timer_t timer_t;
typedef __kernel_clockid_t clockid_t;
typedef __kernel_mqd_t mqd_t;
# 29 "include/linux/types.h"
typedef _Bool bool;
# 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_uid16_t uid16_t;
typedef __kernel_gid16_t gid16_t;
# 36 "include/linux/types.h"
typedef long unsigned int uintptr_t;
# 40 "include/linux/types.h"
typedef __kernel_old_uid_t old_uid_t;
typedef __kernel_old_gid_t old_gid_t;
# 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
# 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
# 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
# 64 "include/linux/types.h"
typedef __kernel_ptrdiff_t ptrdiff_t;
# 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
# 74 "include/linux/types.h"
typedef __kernel_clock_t clock_t;
# 79 "include/linux/types.h"
typedef __kernel_caddr_t *caddr_t;
# 83 "include/linux/types.h"
typedef unsigned char u_char;
typedef short unsigned int u_short;
typedef unsigned int u_int;
typedef long unsigned int u_long;
# 89 "include/linux/types.h"
typedef unsigned char unchar;
typedef short unsigned int ushort;
typedef unsigned int uint;
typedef long unsigned int ulong;
# 97 "include/linux/types.h"
typedef __u8 u_int8_t;
typedef __s8 int8_t;
typedef __u16 u_int16_t;
typedef __s16 int16_t;
typedef __u32 u_int32_t;
typedef __s32 int32_t;
# 106 "include/linux/types.h"
typedef __u8 uint8_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;
# 111 "include/linux/types.h"
typedef __u64 uint64_t;
typedef __u64 u_int64_t;
typedef __s64 int64_t;
# 133 "include/linux/types.h"
typedef long unsigned int sector_t;
typedef long unsigned int blkcnt_t;
# 147 "include/linux/types.h"
typedef u64 dma_addr_t;
# 158 "include/linux/types.h"
typedef unsigned int gfp_t;
typedef unsigned int fmode_t;
typedef unsigned int oom_flags_t;
# 163 "include/linux/types.h"
typedef u64 phys_addr_t;
# 168 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
# 174 "include/linux/types.h"
typedef long unsigned int irq_hw_number_t;
# 178 "include/linux/types.h"
typedef struct
{
# 177 "include/linux/types.h"
  int counter;
} atomic_t;
# 183 "include/linux/types.h"
typedef struct
{
# 182 "include/linux/types.h"
  long int counter;
} atomic64_t;
struct list_head
{
# 187 "include/linux/types.h"
  struct list_head *next;
# 187 "include/linux/types.h"
  struct list_head *prev;
};
struct hlist_head
{
  struct hlist_node *first;
};
struct hlist_node
{
  struct hlist_node *next;
# 195 "include/linux/types.h"
  struct hlist_node **pprev;
};
struct ustat
{
  __kernel_daddr_t f_tfree;
  __kernel_ino_t f_tinode;
  char f_fname[6U];
  char f_fpack[6U];
};
struct callback_head
{
# 211 "include/linux/types.h"
  struct callback_head *next;
  void (*func)(struct callback_head *);
};
# 24 "include/linux/bitops.h"
unsigned int __sw_hweight8(unsigned int);
unsigned int __sw_hweight16(unsigned int);
unsigned int __sw_hweight32(unsigned int);
long unsigned int __sw_hweight64(__u64);
# 216 "./arch/x86/include/asm/segment.h"
extern char const early_idt_handlers[32U][9U];
# 267 "./arch/x86/include/asm/segment.h"
static inline long unsigned int get_limit(long unsigned int segment)
{
  long unsigned int __limit;
  asm ( "lsll %1,%0" : "=r" ( __limit ) : "r" ( segment ) ) ;
  return __limit + 1UL;
}
# 49 "./arch/x86/include/asm/page_types.h"
int devmem_is_allowed(long unsigned int);
# 51 "./arch/x86/include/asm/page_types.h"
extern long unsigned int max_low_pfn_mapped;
extern long unsigned int max_pfn_mapped;
# 54 "./arch/x86/include/asm/page_types.h"
static inline phys_addr_t get_max_mapped(void)
{
  return ( phys_addr_t ) ( ( long long unsigned int ) max_pfn_mapped << 12 );
}
# 59 "./arch/x86/include/asm/page_types.h"
bool pfn_range_is_mapped(long unsigned int, long unsigned int);
# 61 "./arch/x86/include/asm/page_types.h"
long unsigned int init_memory_mapping(long unsigned int, long unsigned int);
# 64 "./arch/x86/include/asm/page_types.h"
void initmem_init(void);
struct pt_regs
{
# 34 "./arch/x86/include/asm/ptrace.h"
  long unsigned int r15;
  long unsigned int r14;
  long unsigned int r13;
  long unsigned int r12;
  long unsigned int bp;
  long unsigned int bx;
# 41 "./arch/x86/include/asm/ptrace.h"
  long unsigned int r11;
  long unsigned int r10;
  long unsigned int r9;
  long unsigned int r8;
  long unsigned int ax;
  long unsigned int cx;
  long unsigned int dx;
  long unsigned int si;
  long unsigned int di;
  long unsigned int orig_ax;
# 53 "./arch/x86/include/asm/ptrace.h"
  long unsigned int ip;
  long unsigned int cs;
  long unsigned int flags;
  long unsigned int sp;
  long unsigned int ss;
};
struct desc_struct
{
# 34 "./arch/x86/include/asm/desc_defs.h"
  union
  {
# 27 "./arch/x86/include/asm/desc_defs.h"
    struct
    {
# 25 "./arch/x86/include/asm/desc_defs.h"
      unsigned int a;
      unsigned int b;
    } ldv_1016;
# 33 "./arch/x86/include/asm/desc_defs.h"
    struct
    {
# 29 "./arch/x86/include/asm/desc_defs.h"
      u16 limit0;
      u16 base0;
      unsigned char base1;
# 31 "./arch/x86/include/asm/desc_defs.h"
      unsigned char type : 4;
# 31 "./arch/x86/include/asm/desc_defs.h"
      unsigned char s : 1;
# 31 "./arch/x86/include/asm/desc_defs.h"
      unsigned char dpl : 2;
# 31 "./arch/x86/include/asm/desc_defs.h"
      unsigned char p : 1;
      unsigned char limit : 4;
# 32 "./arch/x86/include/asm/desc_defs.h"
      unsigned char avl : 1;
# 32 "./arch/x86/include/asm/desc_defs.h"
      unsigned char l : 1;
# 32 "./arch/x86/include/asm/desc_defs.h"
      unsigned char d : 1;
# 32 "./arch/x86/include/asm/desc_defs.h"
      unsigned char g : 1;
# 32 "./arch/x86/include/asm/desc_defs.h"
      unsigned char base2;
    } ldv_1031;
  } ldv_1032;
};
enum ldv_678
{
  GATE_INTERRUPT = 14,
  GATE_TRAP = 15,
  GATE_CALL = 12,
  GATE_TASK = 5
};
struct gate_struct64
{
# 52 "./arch/x86/include/asm/desc_defs.h"
  u16 offset_low;
  u16 segment;
  unsigned char ist : 3;
# 54 "./arch/x86/include/asm/desc_defs.h"
  unsigned char zero0 : 5;
# 54 "./arch/x86/include/asm/desc_defs.h"
  unsigned char type : 5;
# 54 "./arch/x86/include/asm/desc_defs.h"
  unsigned char dpl : 2;
# 54 "./arch/x86/include/asm/desc_defs.h"
  unsigned char p : 1;
  u16 offset_middle;
  u32 offset_high;
  u32 zero1;
};
enum ldv_682
{
  DESC_TSS = 9,
  DESC_LDT = 2,
  DESCTYPE_S = 16
};
struct ldttss_desc64
{
# 72 "./arch/x86/include/asm/desc_defs.h"
  u16 limit0;
  u16 base0;
  unsigned char base1;
# 74 "./arch/x86/include/asm/desc_defs.h"
  unsigned char type : 5;
# 74 "./arch/x86/include/asm/desc_defs.h"
  unsigned char dpl : 2;
# 74 "./arch/x86/include/asm/desc_defs.h"
  unsigned char p : 1;
  unsigned char limit1 : 4;
# 75 "./arch/x86/include/asm/desc_defs.h"
  unsigned char zero0 : 3;
# 75 "./arch/x86/include/asm/desc_defs.h"
  unsigned char g : 1;
# 75 "./arch/x86/include/asm/desc_defs.h"
  unsigned char base2;
  u32 base3;
  u32 zero1;
};
# 81 "./arch/x86/include/asm/desc_defs.h"
typedef struct gate_struct64 gate_desc;
typedef struct ldttss_desc64 ldt_desc;
typedef struct ldttss_desc64 tss_desc;
struct desc_ptr
{
# 95 "./arch/x86/include/asm/desc_defs.h"
  short unsigned int size;
  long unsigned int address;
};
# 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef long unsigned int pteval_t;
typedef long unsigned int pmdval_t;
typedef long unsigned int pudval_t;
typedef long unsigned int pgdval_t;
typedef long unsigned int pgprotval_t;
# 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct
{
# 18 "./arch/x86/include/asm/pgtable_64_types.h"
  pteval_t pte;
} pte_t;
struct pgprot
{
# 242 "./arch/x86/include/asm/pgtable_types.h"
  pgprotval_t pgprot;
};
# 242 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
# 244 "./arch/x86/include/asm/pgtable_types.h"
typedef struct
{
# 244 "./arch/x86/include/asm/pgtable_types.h"
  pgdval_t pgd;
} pgd_t;
static inline pgd_t native_make_pgd(pgdval_t val)
{
  return ( pgd_t ) { . pgd = val };
}
# 251 "./arch/x86/include/asm/pgtable_types.h"
static inline pgdval_t native_pgd_val(pgd_t pgd)
{
  return pgd . pgd;
}
# 256 "./arch/x86/include/asm/pgtable_types.h"
static inline pgdval_t pgd_flags(pgd_t pgd)
{
  return native_pgd_val ( pgd ) & 18446673704965378047UL;
}
# 262 "./arch/x86/include/asm/pgtable_types.h"
typedef struct
{
# 262 "./arch/x86/include/asm/pgtable_types.h"
  pudval_t pud;
} pud_t;
static inline pud_t native_make_pud(pmdval_t val)
{
  return ( pud_t ) { . pud = val };
}
# 269 "./arch/x86/include/asm/pgtable_types.h"
static inline pudval_t native_pud_val(pud_t pud)
{
  return pud . pud;
}
# 283 "./arch/x86/include/asm/pgtable_types.h"
typedef struct
{
# 283 "./arch/x86/include/asm/pgtable_types.h"
  pmdval_t pmd;
} pmd_t;
static inline pmd_t native_make_pmd(pmdval_t val)
{
  return ( pmd_t ) { . pmd = val };
}
# 290 "./arch/x86/include/asm/pgtable_types.h"
static inline pmdval_t native_pmd_val(pmd_t pmd)
{
  return pmd . pmd;
}
# 303 "./arch/x86/include/asm/pgtable_types.h"
static inline pudval_t pud_flags(pud_t pud)
{
  return native_pud_val ( pud ) & 18446673704965378047UL;
}
# 308 "./arch/x86/include/asm/pgtable_types.h"
static inline pmdval_t pmd_flags(pmd_t pmd)
{
  return native_pmd_val ( pmd ) & 18446673704965378047UL;
}
# 313 "./arch/x86/include/asm/pgtable_types.h"
static inline pte_t native_make_pte(pteval_t val)
{
  return ( pte_t ) { . pte = val };
}
# 318 "./arch/x86/include/asm/pgtable_types.h"
static inline pteval_t native_pte_val(pte_t pte)
{
  return pte . pte;
}
# 323 "./arch/x86/include/asm/pgtable_types.h"
static inline pteval_t pte_flags(pte_t pte)
{
  return native_pte_val ( pte ) & 18446673704965378047UL;
}
# 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
# 334 "./arch/x86/include/asm/pgtable_types.h"
extern pteval_t __supported_pte_mask;
void set_nx(void);
extern int nx_enabled;
# 339 "./arch/x86/include/asm/pgtable_types.h"
pgprot_t pgprot_writecombine(pgprot_t);
struct file;
# 346 "./arch/x86/include/asm/pgtable_types.h"
pgprot_t phys_mem_access_prot(struct file *, long unsigned int, long unsigned int, pgprot_t);
# 348 "./arch/x86/include/asm/pgtable_types.h"
int phys_mem_access_prot_allowed(struct file *, long unsigned int, long unsigned int, pgprot_t *);
# 352 "./arch/x86/include/asm/pgtable_types.h"
void set_pte_vaddr(long unsigned int, pte_t);
struct seq_file;
# 361 "./arch/x86/include/asm/pgtable_types.h"
void arch_report_meminfo(struct seq_file *);
enum pg_level
{
  PG_LEVEL_NONE = 0,
  PG_LEVEL_4K = 1,
  PG_LEVEL_2M = 2,
  PG_LEVEL_1G = 3,
  PG_LEVEL_NUM = 4
};
# 372 "./arch/x86/include/asm/pgtable_types.h"
void update_page_count(int, long unsigned int);
# 383 "./arch/x86/include/asm/pgtable_types.h"
pte_t *lookup_address(long unsigned int, unsigned int *);
pte_t *lookup_address_in_pgd(pgd_t *, long unsigned int, unsigned int *);
# 386 "./arch/x86/include/asm/pgtable_types.h"
phys_addr_t slow_virt_to_phys(void *);
int kernel_map_pages_in_pgd(pgd_t *, u64, long unsigned int, unsigned int, long unsigned int);
# 389 "./arch/x86/include/asm/pgtable_types.h"
void kernel_unmap_pages_in_pgd(pgd_t *, long unsigned int, unsigned int);
struct thread_struct;
struct tss_struct;
struct mm_struct;
struct task_struct;
struct cpumask;
struct paravirt_callee_save
{
# 60 "./arch/x86/include/asm/paravirt_types.h"
  void *func;
};
struct pv_info
{
# 65 "./arch/x86/include/asm/paravirt_types.h"
  unsigned int kernel_rpl;
  int shared_kernel_pmd;
# 69 "./arch/x86/include/asm/paravirt_types.h"
  u16 extra_user_64bit_cs;
# 72 "./arch/x86/include/asm/paravirt_types.h"
  int paravirt_enabled;
  char const *name;
};
struct pv_init_ops
{
# 85 "./arch/x86/include/asm/paravirt_types.h"
  unsigned int (*patch)(u8, u16, void *, long unsigned int, unsigned int);
};
struct pv_lazy_ops
{
# 92 "./arch/x86/include/asm/paravirt_types.h"
  void (*enter)(void);
  void (*leave)(void);
  void (*flush)(void);
};
struct pv_time_ops
{
  long long unsigned int (*sched_clock)(void);
  long long unsigned int (*steal_clock)(int);
  long unsigned int (*get_tsc_khz)(void);
};
struct pv_cpu_ops
{
# 105 "./arch/x86/include/asm/paravirt_types.h"
  long unsigned int (*get_debugreg)(int);
  void (*set_debugreg)(int, long unsigned int);
# 108 "./arch/x86/include/asm/paravirt_types.h"
  void (*clts)(void);
# 110 "./arch/x86/include/asm/paravirt_types.h"
  long unsigned int (*read_cr0)(void);
  void (*write_cr0)(long unsigned int);
# 113 "./arch/x86/include/asm/paravirt_types.h"
  long unsigned int (*read_cr4_safe)(void);
  long unsigned int (*read_cr4)(void);
  void (*write_cr4)(long unsigned int);
# 118 "./arch/x86/include/asm/paravirt_types.h"
  long unsigned int (*read_cr8)(void);
  void (*write_cr8)(long unsigned int);
# 123 "./arch/x86/include/asm/paravirt_types.h"
  void (*load_tr_desc)(void);
  void (*load_gdt)(struct desc_ptr const *);
  void (*load_idt)(struct desc_ptr const *);
# 127 "./arch/x86/include/asm/paravirt_types.h"
  void (*store_idt)(struct desc_ptr *);
  void (*set_ldt)(void const *, unsigned int);
  long unsigned int (*store_tr)(void);
  void (*load_tls)(struct thread_struct *, unsigned int);
# 132 "./arch/x86/include/asm/paravirt_types.h"
  void (*load_gs_index)(unsigned int);
# 134 "./arch/x86/include/asm/paravirt_types.h"
  void (*write_ldt_entry)(struct desc_struct *, int, void const *);
# 136 "./arch/x86/include/asm/paravirt_types.h"
  void (*write_gdt_entry)(struct desc_struct *, int, void const *, int);
# 138 "./arch/x86/include/asm/paravirt_types.h"
  void (*write_idt_entry)(gate_desc *, int, gate_desc const *);
# 140 "./arch/x86/include/asm/paravirt_types.h"
  void (*alloc_ldt)(struct desc_struct *, unsigned int);
  void (*free_ldt)(struct desc_struct *, unsigned int);
# 143 "./arch/x86/include/asm/paravirt_types.h"
  void (*load_sp0)(struct tss_struct *, struct thread_struct *);
# 145 "./arch/x86/include/asm/paravirt_types.h"
  void (*set_iopl_mask)(unsigned int);
# 147 "./arch/x86/include/asm/paravirt_types.h"
  void (*wbinvd)(void);
  void (*io_delay)(void);
# 151 "./arch/x86/include/asm/paravirt_types.h"
  void (*cpuid)(unsigned int *, unsigned int *, unsigned int *, unsigned int *);
# 156 "./arch/x86/include/asm/paravirt_types.h"
  u64 (*read_msr)(unsigned int, int *);
  int (*write_msr)(unsigned int, unsigned int, unsigned int);
# 159 "./arch/x86/include/asm/paravirt_types.h"
  u64 (*read_tsc)(void);
  u64 (*read_pmc)(int);
  long long unsigned int (*read_tscp)(unsigned int *);
# 169 "./arch/x86/include/asm/paravirt_types.h"
  void (*irq_enable_sysexit)(void);
# 177 "./arch/x86/include/asm/paravirt_types.h"
  void (*usergs_sysret64)(void);
# 185 "./arch/x86/include/asm/paravirt_types.h"
  void (*usergs_sysret32)(void);
# 189 "./arch/x86/include/asm/paravirt_types.h"
  void (*iret)(void);
# 191 "./arch/x86/include/asm/paravirt_types.h"
  void (*swapgs)(void);
# 193 "./arch/x86/include/asm/paravirt_types.h"
  void (*start_context_switch)(struct task_struct *);
  void (*end_context_switch)(struct task_struct *);
};
struct pv_irq_ops
{
# 207 "./arch/x86/include/asm/paravirt_types.h"
  struct paravirt_callee_save save_fl;
  struct paravirt_callee_save restore_fl;
  struct paravirt_callee_save irq_disable;
  struct paravirt_callee_save irq_enable;
# 212 "./arch/x86/include/asm/paravirt_types.h"
  void (*safe_halt)(void);
  void (*halt)(void);
# 216 "./arch/x86/include/asm/paravirt_types.h"
  void (*adjust_exception_frame)(void);
};
struct pv_apic_ops
{
# 222 "./arch/x86/include/asm/paravirt_types.h"
  void (*startup_ipi_hook)(int, long unsigned int, long unsigned int);
};
struct pv_mmu_ops
{
# 229 "./arch/x86/include/asm/paravirt_types.h"
  long unsigned int (*read_cr2)(void);
  void (*write_cr2)(long unsigned int);
# 232 "./arch/x86/include/asm/paravirt_types.h"
  long unsigned int (*read_cr3)(void);
  void (*write_cr3)(long unsigned int);
# 239 "./arch/x86/include/asm/paravirt_types.h"
  void (*activate_mm)(struct mm_struct *, struct mm_struct *);
# 241 "./arch/x86/include/asm/paravirt_types.h"
  void (*dup_mmap)(struct mm_struct *, struct mm_struct *);
# 243 "./arch/x86/include/asm/paravirt_types.h"
  void (*exit_mmap)(struct mm_struct *);
# 247 "./arch/x86/include/asm/paravirt_types.h"
  void (*flush_tlb_user)(void);
  void (*flush_tlb_kernel)(void);
  void (*flush_tlb_single)(long unsigned int);
  void (*flush_tlb_others)(struct cpumask const *, struct mm_struct *, long unsigned int, long unsigned int);
# 256 "./arch/x86/include/asm/paravirt_types.h"
  int (*pgd_alloc)(struct mm_struct *);
  void (*pgd_free)(struct mm_struct *, pgd_t *);
# 263 "./arch/x86/include/asm/paravirt_types.h"
  void (*alloc_pte)(struct mm_struct *, long unsigned int);
  void (*alloc_pmd)(struct mm_struct *, long unsigned int);
  void (*alloc_pud)(struct mm_struct *, long unsigned int);
  void (*release_pte)(long unsigned int);
  void (*release_pmd)(long unsigned int);
  void (*release_pud)(long unsigned int);
# 271 "./arch/x86/include/asm/paravirt_types.h"
  void (*set_pte)(pte_t *, pte_t);
  void (*set_pte_at)(struct mm_struct *, long unsigned int, pte_t *, pte_t);
# 274 "./arch/x86/include/asm/paravirt_types.h"
  void (*set_pmd)(pmd_t *, pmd_t);
  void (*set_pmd_at)(struct mm_struct *, long unsigned int, pmd_t *, pmd_t);
# 277 "./arch/x86/include/asm/paravirt_types.h"
  void (*pte_update)(struct mm_struct *, long unsigned int, pte_t *);
# 279 "./arch/x86/include/asm/paravirt_types.h"
  void (*pte_update_defer)(struct mm_struct *, long unsigned int, pte_t *);
# 281 "./arch/x86/include/asm/paravirt_types.h"
  void (*pmd_update)(struct mm_struct *, long unsigned int, pmd_t *);
# 283 "./arch/x86/include/asm/paravirt_types.h"
  void (*pmd_update_defer)(struct mm_struct *, long unsigned int, pmd_t *);
# 286 "./arch/x86/include/asm/paravirt_types.h"
  pte_t (*ptep_modify_prot_start)(struct mm_struct *, long unsigned int, pte_t *);
# 288 "./arch/x86/include/asm/paravirt_types.h"
  void (*ptep_modify_prot_commit)(struct mm_struct *, long unsigned int, pte_t *, pte_t);
# 291 "./arch/x86/include/asm/paravirt_types.h"
  struct paravirt_callee_save pte_val;
  struct paravirt_callee_save make_pte;
# 294 "./arch/x86/include/asm/paravirt_types.h"
  struct paravirt_callee_save pgd_val;
  struct paravirt_callee_save make_pgd;
# 306 "./arch/x86/include/asm/paravirt_types.h"
  void (*set_pud)(pud_t *, pud_t);
# 308 "./arch/x86/include/asm/paravirt_types.h"
  struct paravirt_callee_save pmd_val;
  struct paravirt_callee_save make_pmd;
# 312 "./arch/x86/include/asm/paravirt_types.h"
  struct paravirt_callee_save pud_val;
  struct paravirt_callee_save make_pud;
# 315 "./arch/x86/include/asm/paravirt_types.h"
  void (*set_pgd)(pgd_t *, pgd_t);
# 319 "./arch/x86/include/asm/paravirt_types.h"
  struct pv_lazy_ops lazy_mode;
# 325 "./arch/x86/include/asm/paravirt_types.h"
  void (*set_fixmap)(unsigned int, phys_addr_t, pgprot_t);
};
struct arch_spinlock;
# 18 "./arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
typedef u32 __ticketpair_t;
struct __raw_tickets
{
# 30 "./arch/x86/include/asm/spinlock_types.h"
  __ticket_t head;
# 30 "./arch/x86/include/asm/spinlock_types.h"
  __ticket_t tail;
};
struct arch_spinlock
{
# 32 "./arch/x86/include/asm/spinlock_types.h"
  union
  {
# 28 "./arch/x86/include/asm/spinlock_types.h"
    __ticketpair_t head_tail;
# 31 "./arch/x86/include/asm/spinlock_types.h"
    struct __raw_tickets tickets;
  } ldv_1452;
};
# 33 "./arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
struct qrwlock
{
# 12 "include/asm-generic/qrwlock_types.h"
  atomic_t cnts;
  arch_spinlock_t lock;
};
# 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
struct pv_lock_ops
{
# 337 "./arch/x86/include/asm/paravirt_types.h"
  struct paravirt_callee_save lock_spinning;
  void (*unlock_kick)(struct arch_spinlock *, __ticket_t);
};
struct paravirt_patch_template
{
# 345 "./arch/x86/include/asm/paravirt_types.h"
  struct pv_init_ops pv_init_ops;
  struct pv_time_ops pv_time_ops;
  struct pv_cpu_ops pv_cpu_ops;
  struct pv_irq_ops pv_irq_ops;
  struct pv_apic_ops pv_apic_ops;
  struct pv_mmu_ops pv_mmu_ops;
  struct pv_lock_ops pv_lock_ops;
};
# 354 "./arch/x86/include/asm/paravirt_types.h"
extern struct pv_info pv_info;
extern struct pv_init_ops pv_init_ops;
extern struct pv_time_ops pv_time_ops;
extern struct pv_cpu_ops pv_cpu_ops;
extern struct pv_irq_ops pv_irq_ops;
extern struct pv_apic_ops pv_apic_ops;
extern struct pv_mmu_ops pv_mmu_ops;
extern struct pv_lock_ops pv_lock_ops;
# 397 "./arch/x86/include/asm/paravirt_types.h"
unsigned int paravirt_patch_nop(void);
unsigned int paravirt_patch_ident_32(void *, unsigned int);
unsigned int paravirt_patch_ident_64(void *, unsigned int);
unsigned int paravirt_patch_ignore(unsigned int);
unsigned int paravirt_patch_call(void *, void const *, u16, long unsigned int, u16, unsigned int);
# 405 "./arch/x86/include/asm/paravirt_types.h"
unsigned int paravirt_patch_jmp(void *, void const *, long unsigned int, unsigned int);
# 407 "./arch/x86/include/asm/paravirt_types.h"
unsigned int paravirt_patch_default(u8, u16, void *, long unsigned int, unsigned int);
# 410 "./arch/x86/include/asm/paravirt_types.h"
unsigned int paravirt_patch_insns(void *, unsigned int, char const *, char const *);
# 413 "./arch/x86/include/asm/paravirt_types.h"
unsigned int native_patch(u8, u16, void *, long unsigned int, unsigned int);
# 416 "./arch/x86/include/asm/paravirt_types.h"
int paravirt_disable_iospace(void);
enum paravirt_lazy_mode
{
  PARAVIRT_LAZY_NONE = 0,
  PARAVIRT_LAZY_MMU = 1,
  PARAVIRT_LAZY_CPU = 2
};
# 681 "./arch/x86/include/asm/paravirt_types.h"
enum paravirt_lazy_mode paravirt_get_lazy_mode(void);
void paravirt_start_context_switch(struct task_struct *);
void paravirt_end_context_switch(struct task_struct *);
# 685 "./arch/x86/include/asm/paravirt_types.h"
void paravirt_enter_lazy_mmu(void);
void paravirt_leave_lazy_mmu(void);
void paravirt_flush_lazy_mmu(void);
# 689 "./arch/x86/include/asm/paravirt_types.h"
void _paravirt_nop(void);
u32 _paravirt_ident_32(u32);
u64 _paravirt_ident_64(u64);
struct paravirt_patch_site
{
# 697 "./arch/x86/include/asm/paravirt_types.h"
  u8 *instr;
  u8 instrtype;
  u8 len;
  u16 clobbers;
};
# 703 "./arch/x86/include/asm/paravirt_types.h"
extern struct paravirt_patch_site __parainstructions[];
extern struct paravirt_patch_site __parainstructions_end[];
struct cpuinfo_x86;
# 70 "./arch/x86/include/asm/ptrace.h"
long unsigned int profile_pc(struct pt_regs *);
# 74 "./arch/x86/include/asm/ptrace.h"
long unsigned int convert_ip_to_linear(struct task_struct *, struct pt_regs *);
void send_sigtrap(struct task_struct *, struct pt_regs *, int, int);
# 78 "./arch/x86/include/asm/ptrace.h"
long int syscall_trace_enter(struct pt_regs *);
void syscall_trace_leave(struct pt_regs *);
# 81 "./arch/x86/include/asm/ptrace.h"
static inline long unsigned int regs_return_value(struct pt_regs *regs)
{
  return ( * regs ) . ax;
}
# 93 "./arch/x86/include/asm/ptrace.h"
static inline int user_mode(struct pt_regs *regs)
{
# 98 "./arch/x86/include/asm/ptrace.h"
  return ( ( * regs ) . cs & 3UL ) != 0UL;
}
# 102 "./arch/x86/include/asm/ptrace.h"
static inline int user_mode_vm(struct pt_regs *regs)
{
# 108 "./arch/x86/include/asm/ptrace.h"
  return user_mode ( regs );
}
# 112 "./arch/x86/include/asm/ptrace.h"
static inline int v8086_mode(struct pt_regs *regs)
{
# 117 "./arch/x86/include/asm/ptrace.h"
  return 0;
}
# 122 "./arch/x86/include/asm/ptrace.h"
static inline bool user_64bit_mode(struct pt_regs *regs)
{
# 132 "./arch/x86/include/asm/ptrace.h"
  return ( bool ) ( ( * regs ) . cs == 51UL || ( * regs ) . cs == ( long unsigned int ) pv_info . extra_user_64bit_cs );
}
# 147 "./arch/x86/include/asm/ptrace.h"
static inline long unsigned int kernel_stack_pointer(struct pt_regs *regs)
{
  return ( * regs ) . sp;
}
# 22 "include/asm-generic/ptrace.h"
static inline long unsigned int instruction_pointer(struct pt_regs *regs)
{
  return ( * regs ) . ip;
}
static inline void instruction_pointer_set(struct pt_regs *regs, long unsigned int val)
{
# 29 "include/asm-generic/ptrace.h"
  ( * regs ) . ip = val;
}
# 44 "include/asm-generic/ptrace.h"
static inline long unsigned int user_stack_pointer(struct pt_regs *regs)
{
  return ( * regs ) . sp;
}
static inline void user_stack_pointer_set(struct pt_regs *regs, long unsigned int val)
{
# 51 "include/asm-generic/ptrace.h"
  ( * regs ) . sp = val;
}
# 62 "include/asm-generic/ptrace.h"
static inline long unsigned int frame_pointer(struct pt_regs *regs)
{
  return ( * regs ) . bp;
}
static inline void frame_pointer_set(struct pt_regs *regs, long unsigned int val)
{
# 69 "include/asm-generic/ptrace.h"
  ( * regs ) . bp = val;
}
# 160 "./arch/x86/include/asm/ptrace.h"
int regs_query_register_offset(char const *);
char const *regs_query_register_name(unsigned int);
# 173 "./arch/x86/include/asm/ptrace.h"
static inline long unsigned int regs_get_register(struct pt_regs *regs, unsigned int offset)
{
# 176 "./arch/x86/include/asm/ptrace.h"
  if (__builtin_expect ( offset > 160U , 0L ) != 0L)
    return 0UL;
# 187 "./arch/x86/include/asm/ptrace.h"
  return * ( long unsigned int *) ( ( long unsigned int ) offset + ( long unsigned int ) regs );
}
# 198 "./arch/x86/include/asm/ptrace.h"
static inline int regs_within_kernel_stack(struct pt_regs *regs, long unsigned int addr)
{
# 201 "./arch/x86/include/asm/ptrace.h"
  return ( ( kernel_stack_pointer
# 202 "./arch/x86/include/asm/ptrace.h"
  ( regs )
# 201 "./arch/x86/include/asm/ptrace.h"
  ^ addr ) & 18446744073709535232UL ) == 0UL;
}
# 214 "./arch/x86/include/asm/ptrace.h"
static inline long unsigned int regs_get_kernel_stack_nth(struct pt_regs *regs, unsigned int n)
{
# 217 "./arch/x86/include/asm/ptrace.h"
  long unsigned int *addr = ( long unsigned int *) kernel_stack_pointer ( regs );
  addr += ( long unsigned int ) n;
  if (regs_within_kernel_stack ( regs , ( long unsigned int ) addr ) != 0)
  {
# 220 "./arch/x86/include/asm/ptrace.h"
    return * addr;
  }
  else
# 222 "./arch/x86/include/asm/ptrace.h"
    return 0UL;
}
struct user_desc;
# 251 "./arch/x86/include/asm/ptrace.h"
int do_get_thread_area(struct task_struct *, int, struct user_desc *);
# 253 "./arch/x86/include/asm/ptrace.h"
int do_set_thread_area(struct task_struct *, int, struct user_desc *, int);
struct alt_instr
{
# 47 "./arch/x86/include/asm/alternative.h"
  s32 instr_offset;
  s32 repl_offset;
  u16 cpuid;
  u8 instrlen;
  u8 replacementlen;
};
# 54 "./arch/x86/include/asm/alternative.h"
void alternative_instructions(void);
void apply_alternatives(struct alt_instr *, struct alt_instr *);
# 60 "./arch/x86/include/asm/alternative.h"
void alternatives_smp_module_add(struct module *, char *, void *, void *, void *, void *);
# 63 "./arch/x86/include/asm/alternative.h"
void alternatives_smp_module_del(struct module *);
void alternatives_enable_smp(void);
int alternatives_text_reserved(void *, void *);
extern bool skip_smp_alternatives;
# 253 "./arch/x86/include/asm/cpufeature.h"
extern char const *const x86_cap_flags[352U];
extern char const *const x86_power_flags[32U];
# 260 "./arch/x86/include/asm/cpufeature.h"
extern char const *const x86_bug_flags[32U];
# 376 "./arch/x86/include/asm/cpufeature.h"
void warn_pre_alternatives(void);
bool __static_cpu_has_safe(u16);
# 384 "./arch/x86/include/asm/cpufeature.h"
static inline bool __static_cpu_has(u16 bit)
{
# 431 "./arch/x86/include/asm/cpufeature.h"
  u8 flag;
# 433 "./arch/x86/include/asm/cpufeature.h"
  asm volatile ( "1: movb $0,%0\n2:\n.section .altinstructions,\"a\"\n .long 1b - .\n .long 3f - .\n .word %P1\n .byte 2b - 1b\n .byte 4f - 3f\n.previous\n.section .discard,\"aw\",@progbits\n .byte 0xff + (4f-3f) - (2b-1b)\n.previous\n.section .altinstr_replacement,\"ax\"\n3: movb $1,%0\n4:\n.previous\n" : "=qm" ( flag ) : "i" ( bit ) ) ;
# 450 "./arch/x86/include/asm/cpufeature.h"
  return ( unsigned char ) flag != 0U;
}
# 464 "./arch/x86/include/asm/cpufeature.h"
static inline bool _static_cpu_has_safe(u16 bit)
{
# 501 "./arch/x86/include/asm/cpufeature.h"
  u8 flag;
# 503 "./arch/x86/include/asm/cpufeature.h"
  asm volatile ( "1: movb $2,%0\n2:\n.section .altinstructions,\"a\"\n .long 1b - .\n .long 3f - .\n .word %P2\n .byte 2b - 1b\n .byte 4f - 3f\n.previous\n.section .discard,\"aw\",@progbits\n .byte 0xff + (4f-3f) - (2b-1b)\n.previous\n.section .altinstr_replacement,\"ax\"\n3: movb $0,%0\n4:\n.previous\n.section .altinstructions,\"a\"\n .long 1b - .\n .long 5f - .\n .word %P1\n .byte 4b - 3b\n .byte 6f - 5f\n.previous\n.section .discard,\"aw\",@progbits\n .byte 0xff + (6f-5f) - (4b-3b)\n.previous\n.section .altinstr_replacement,\"ax\"\n5: movb $1,%0\n6:\n.previous\n" : "=qm" ( flag ) : "i" ( bit ) , "i" ( 117 ) ) ;
# 535 "./arch/x86/include/asm/cpufeature.h"
  return ( unsigned char ) flag == 2U ? ( int ) __static_cpu_has_safe ( ( int ) bit ) != 0 : ( unsigned char ) flag != 0U;
}
# 215 "./arch/x86/include/asm/alternative.h"
void apply_paravirt(struct paravirt_patch_site *, struct paravirt_patch_site *);
# 225 "./arch/x86/include/asm/alternative.h"
void *text_poke_early(void *, void const *, size_t);
# 241 "./arch/x86/include/asm/alternative.h"
void *text_poke(void *, void const *, size_t);
int poke_int3_handler(struct pt_regs *);
void *text_poke_bp(void *, void const *, size_t, void *);
# 142 "./arch/x86/include/asm/nops.h"
extern unsigned char const *const *ideal_nops;
void arch_init_ideal_nops(void);
# 151 "./arch/x86/include/asm/barrier.h"
static inline void rdtsc_barrier(void)
{
  asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 3*32+17)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\tmfence\n6641:\n\t.popsection" : : : "memory" ) ;
  asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 3*32+18)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\tlfence\n6641:\n\t.popsection" : : : "memory" ) ;
}
# 72 "./arch/x86/include/asm/bitops.h"
static inline void set_bit(long int nr, long unsigned int volatile *addr)
{
  if (0)
  {
# 75 "./arch/x86/include/asm/bitops.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; orb %1,%0" : "+m" (
# 76 "./arch/x86/include/asm/bitops.h"
    * ( ( long int volatile *) addr + ( long unsigned int ) ( nr >> 3 ) ) ) : "iq" (
# 77 "./arch/x86/include/asm/bitops.h"
    ( unsigned char ) ( 1 << ( ( int ) nr & 7 ) ) ) : "memory" ) ;
  }
  else
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0" : "+m" (
# 81 "./arch/x86/include/asm/bitops.h"
    * ( long int volatile *) addr ) : "Ir" ( nr ) : "memory" ) ;
}
# 94 "./arch/x86/include/asm/bitops.h"
static inline void __set_bit(long int nr, long unsigned int volatile *addr)
{
  asm volatile ( "bts %1,%0" : "+m" ( * ( long int volatile *) addr ) : "Ir" ( nr ) : "memory" ) ;
}
# 110 "./arch/x86/include/asm/bitops.h"
static inline void clear_bit(long int nr, long unsigned int volatile *addr)
{
  if (0)
  {
# 113 "./arch/x86/include/asm/bitops.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; andb %1,%0" : "+m" (
# 114 "./arch/x86/include/asm/bitops.h"
    * ( ( long int volatile *) addr + ( long unsigned int ) ( nr >> 3 ) ) ) : "iq" (
# 115 "./arch/x86/include/asm/bitops.h"
    ~ ( unsigned char ) ( 1 << ( ( int ) nr & 7 ) ) ) ) ;
  }
  else
# 117 "./arch/x86/include/asm/bitops.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0" : "+m" (
# 118 "./arch/x86/include/asm/bitops.h"
    * ( long int volatile *) addr ) : "Ir" ( nr ) ) ;
}
# 131 "./arch/x86/include/asm/bitops.h"
static inline void clear_bit_unlock(long int nr, long unsigned int volatile *addr)
{
  asm volatile ( "" : : : "memory" ) ;
  clear_bit ( nr , addr );
}
# 137 "./arch/x86/include/asm/bitops.h"
static inline void __clear_bit(long int nr, long unsigned int volatile *addr)
{
  asm volatile ( "btr %1,%0" : "+m" ( * ( long int volatile *) addr ) : "Ir" ( nr ) ) ;
}
# 154 "./arch/x86/include/asm/bitops.h"
static inline void __clear_bit_unlock(long int nr, long unsigned int volatile *addr)
{
  asm volatile ( "" : : : "memory" ) ;
  __clear_bit ( nr , addr );
}
# 169 "./arch/x86/include/asm/bitops.h"
static inline void __change_bit(long int nr, long unsigned int volatile *addr)
{
  asm volatile ( "btc %1,%0" : "+m" ( * ( long int volatile *) addr ) : "Ir" ( nr ) ) ;
}
# 183 "./arch/x86/include/asm/bitops.h"
static inline void change_bit(long int nr, long unsigned int volatile *addr)
{
  if (0)
  {
# 186 "./arch/x86/include/asm/bitops.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xorb %1,%0" : "+m" (
# 187 "./arch/x86/include/asm/bitops.h"
    * ( ( long int volatile *) addr + ( long unsigned int ) ( nr >> 3 ) ) ) : "iq" (
# 188 "./arch/x86/include/asm/bitops.h"
    ( unsigned char ) ( 1 << ( ( int ) nr & 7 ) ) ) ) ;
  }
  else
# 190 "./arch/x86/include/asm/bitops.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btc %1,%0" : "+m" (
# 191 "./arch/x86/include/asm/bitops.h"
    * ( long int volatile *) addr ) : "Ir" ( nr ) ) ;
}
# 204 "./arch/x86/include/asm/bitops.h"
static inline int test_and_set_bit(long int nr, long unsigned int volatile *addr)
{
  {
# 206 "./arch/x86/include/asm/bitops.h"
    char c;
# 206 "./arch/x86/include/asm/bitops.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1" : "+m" ( * addr ) , "=qm" ( c ) : "Ir" ( nr ) : "memory" ) ;
# 206 "./arch/x86/include/asm/bitops.h"
    return ( signed char ) c != 0;
  }
}
# 217 "./arch/x86/include/asm/bitops.h"
static inline int test_and_set_bit_lock(long int nr, long unsigned int volatile *addr)
{
  return test_and_set_bit ( nr , addr );
}
# 231 "./arch/x86/include/asm/bitops.h"
static inline int __test_and_set_bit(long int nr, long unsigned int volatile *addr)
{
  int oldbit;
# 235 "./arch/x86/include/asm/bitops.h"
  asm ( "bts %2,%1\n\tsbb %0,%0" : "=r" ( oldbit ) , "+m" (
# 237 "./arch/x86/include/asm/bitops.h"
  * ( long int volatile *) addr ) : "Ir" ( nr ) ) ;
# 239 "./arch/x86/include/asm/bitops.h"
  return oldbit;
}
# 250 "./arch/x86/include/asm/bitops.h"
static inline int test_and_clear_bit(long int nr, long unsigned int volatile *addr)
{
  {
# 252 "./arch/x86/include/asm/bitops.h"
    char c;
# 252 "./arch/x86/include/asm/bitops.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1" : "+m" ( * addr ) , "=qm" ( c ) : "Ir" ( nr ) : "memory" ) ;
# 252 "./arch/x86/include/asm/bitops.h"
    return ( signed char ) c != 0;
  }
}
# 271 "./arch/x86/include/asm/bitops.h"
static inline int __test_and_clear_bit(long int nr, long unsigned int volatile *addr)
{
  int oldbit;
# 275 "./arch/x86/include/asm/bitops.h"
  asm volatile ( "btr %2,%1\n\tsbb %0,%0" : "=r" ( oldbit ) , "+m" (
# 277 "./arch/x86/include/asm/bitops.h"
  * ( long int volatile *) addr ) : "Ir" ( nr ) ) ;
# 279 "./arch/x86/include/asm/bitops.h"
  return oldbit;
}
# 283 "./arch/x86/include/asm/bitops.h"
static inline int __test_and_change_bit(long int nr, long unsigned int volatile *addr)
{
  int oldbit;
# 287 "./arch/x86/include/asm/bitops.h"
  asm volatile ( "btc %2,%1\n\tsbb %0,%0" : "=r" ( oldbit ) , "+m" (
# 289 "./arch/x86/include/asm/bitops.h"
  * ( long int volatile *) addr ) : "Ir" ( nr ) : "memory" ) ;
# 292 "./arch/x86/include/asm/bitops.h"
  return oldbit;
}
# 303 "./arch/x86/include/asm/bitops.h"
static inline int test_and_change_bit(long int nr, long unsigned int volatile *addr)
{
  {
# 305 "./arch/x86/include/asm/bitops.h"
    char c;
# 305 "./arch/x86/include/asm/bitops.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btc %2, %0; setc %1" : "+m" ( * addr ) , "=qm" ( c ) : "Ir" ( nr ) : "memory" ) ;
# 305 "./arch/x86/include/asm/bitops.h"
    return ( signed char ) c != 0;
  }
}
static inline int constant_test_bit(long int nr, long unsigned int const volatile *addr)
{
  return
# 311 "./arch/x86/include/asm/bitops.h"
  ( int ) ( ( long unsigned int ) * ( addr + ( long unsigned int ) ( nr >> 6 ) ) >> ( ( int ) nr & 63 ) ) & 1;
}
# 314 "./arch/x86/include/asm/bitops.h"
static inline int variable_test_bit(long int nr, long unsigned int const volatile *addr)
{
  int oldbit;
# 318 "./arch/x86/include/asm/bitops.h"
  asm volatile ( "bt %2,%1\n\tsbb %0,%0" : "=r" ( oldbit ) : "m" (
# 321 "./arch/x86/include/asm/bitops.h"
  * ( long unsigned int *) addr ) , "Ir" ( nr ) ) ;
# 323 "./arch/x86/include/asm/bitops.h"
  return oldbit;
}
# 346 "./arch/x86/include/asm/bitops.h"
static inline long unsigned int __ffs(long unsigned int word)
{
  asm ( "rep; bsf %1,%0" : "=r" ( word ) : "rm" ( word ) ) ;
# 351 "./arch/x86/include/asm/bitops.h"
  return word;
}
# 360 "./arch/x86/include/asm/bitops.h"
static inline long unsigned int ffz(long unsigned int word)
{
  asm ( "rep; bsf %1,%0" : "=r" ( word ) : "r" (
# 364 "./arch/x86/include/asm/bitops.h"
  ~ word ) ) ;
  return word;
}
# 374 "./arch/x86/include/asm/bitops.h"
static inline long unsigned int __fls(long unsigned int word)
{
  asm ( "bsr %1,%0" : "=r" ( word ) : "rm" ( word ) ) ;
# 379 "./arch/x86/include/asm/bitops.h"
  return word;
}
# 396 "./arch/x86/include/asm/bitops.h"
static inline int ffs(int x)
{
  int r;
# 410 "./arch/x86/include/asm/bitops.h"
  asm ( "bsfl %1,%0" : "=r" ( r ) : "rm" ( x ) , "0" ( -1 ) ) ;
# 423 "./arch/x86/include/asm/bitops.h"
  return r + 1;
}
# 437 "./arch/x86/include/asm/bitops.h"
static inline int fls(int x)
{
  int r;
# 451 "./arch/x86/include/asm/bitops.h"
  asm ( "bsrl %1,%0" : "=r" ( r ) : "rm" ( x ) , "0" ( -1 ) ) ;
# 464 "./arch/x86/include/asm/bitops.h"
  return r + 1;
}
# 479 "./arch/x86/include/asm/bitops.h"
static inline int fls64(__u64 x)
{
  int bitpos = -1;
# 487 "./arch/x86/include/asm/bitops.h"
  asm ( "bsrq %1,%q0" : "+r" ( bitpos ) : "rm" ( x ) ) ;
# 490 "./arch/x86/include/asm/bitops.h"
  return bitpos + 1;
}
# 14 "include/asm-generic/bitops/find.h"
long unsigned int find_next_bit(long unsigned int const *, long unsigned int, long unsigned int);
# 28 "include/asm-generic/bitops/find.h"
long unsigned int find_next_zero_bit(long unsigned int const *, long unsigned int, long unsigned int);
# 42 "include/asm-generic/bitops/find.h"
long unsigned int find_first_bit(long unsigned int const *, long unsigned int);
# 53 "include/asm-generic/bitops/find.h"
long unsigned int find_first_zero_bit(long unsigned int const *, long unsigned int);
# 12 "include/asm-generic/bitops/sched.h"
static inline int sched_find_first_bit(long unsigned int const *b)
{
# 15 "include/asm-generic/bitops/sched.h"
  if (( long unsigned int ) * b != 0UL)
    return ( int ) __ffs ( * b );
  return ( int ) ( ( unsigned int ) __ffs ( * ( b + 1UL ) ) + 64U );
}
# 24 "./arch/x86/include/asm/arch_hweight.h"
static inline unsigned int __arch_hweight32(unsigned int w)
{
  unsigned int res = 0U;
# 28 "./arch/x86/include/asm/arch_hweight.h"
  asm ( "661:\n\tcall __sw_hweight32\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 4*32+23)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0xf3,0x40,0x0f,0xb8,0xc7\n6641:\n\t.popsection" : "=a" ( res ) : "D" ( w ) ) ;
# 32 "./arch/x86/include/asm/arch_hweight.h"
  return res;
}
# 35 "./arch/x86/include/asm/arch_hweight.h"
static inline unsigned int __arch_hweight16(unsigned int w)
{
  return __arch_hweight32 ( w & 65535U );
}
# 40 "./arch/x86/include/asm/arch_hweight.h"
static inline unsigned int __arch_hweight8(unsigned int w)
{
  return __arch_hweight32 ( w & 255U );
}
# 45 "./arch/x86/include/asm/arch_hweight.h"
static inline long unsigned int __arch_hweight64(__u64 w)
{
  long unsigned int res = 0UL;
# 53 "./arch/x86/include/asm/arch_hweight.h"
  asm ( "661:\n\tcall __sw_hweight64\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 4*32+23)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0xf3,0x48,0x0f,0xb8,0xc7\n6641:\n\t.popsection" : "=a" ( res ) : "D" ( w ) ) ;
# 58 "./arch/x86/include/asm/arch_hweight.h"
  return res;
}
# 7 "./arch/x86/include/uapi/asm/swab.h"
static inline __u32 __arch_swab32(__u32 val)
{
  asm ( "bswapl %0" : "=r" ( val ) : "0" ( val ) ) ;
  return val;
}
# 14 "./arch/x86/include/uapi/asm/swab.h"
static inline __u64 __arch_swab64(__u64 val)
{
# 30 "./arch/x86/include/uapi/asm/swab.h"
  asm ( "bswapq %0" : "=r" ( val ) : "0" ( val ) ) ;
  return val;
}
# 46 "include/uapi/linux/swab.h"
static inline __u16 __fswab16(__u16 val)
{
# 53 "include/uapi/linux/swab.h"
  return ( __u16 ) ( ( short int ) ( ( int ) val << 8 ) | ( short int ) ( val >> 8 ) );
}
# 57 "include/uapi/linux/swab.h"
static inline __u32 __fswab32(__u32 val)
{
# 62 "include/uapi/linux/swab.h"
  return __arch_swab32 ( val );
}
# 68 "include/uapi/linux/swab.h"
static inline __u64 __fswab64(__u64 val)
{
# 73 "include/uapi/linux/swab.h"
  return __arch_swab64 ( val );
}
# 83 "include/uapi/linux/swab.h"
static inline __u32 __fswahw32(__u32 val)
{
# 88 "include/uapi/linux/swab.h"
  return (((val) << (16)) | ((val) >> (8 * sizeof (val) - 16)));
}
# 92 "include/uapi/linux/swab.h"
static inline __u32 __fswahb32(__u32 val)
{
# 97 "include/uapi/linux/swab.h"
  return ( val & 16711935U ) << 8 | ( val & 4278255360U ) >> 8;
}
# 154 "include/uapi/linux/swab.h"
static inline __u16 __swab16p(__u16 const *p)
{
# 159 "include/uapi/linux/swab.h"
  return __fswab16 ( ( int ) * p );
}
# 167 "include/uapi/linux/swab.h"
static inline __u32 __swab32p(__u32 const *p)
{
# 172 "include/uapi/linux/swab.h"
  return __fswab32 ( * p );
}
# 180 "include/uapi/linux/swab.h"
static inline __u64 __swab64p(__u64 const *p)
{
# 185 "include/uapi/linux/swab.h"
  return __fswab64 ( * p );
}
# 195 "include/uapi/linux/swab.h"
static inline __u32 __swahw32p(__u32 const *p)
{
# 200 "include/uapi/linux/swab.h"
  return __fswahw32 ( * p );
}
# 210 "include/uapi/linux/swab.h"
static inline __u32 __swahb32p(__u32 const *p)
{
# 215 "include/uapi/linux/swab.h"
  return __fswahb32 ( * p );
}
# 223 "include/uapi/linux/swab.h"
static inline void __swab16s(__u16 *p)
{
# 228 "include/uapi/linux/swab.h"
  * p = __swab16p ( ( __u16 const *) p );
}
# 235 "include/uapi/linux/swab.h"
static inline void __swab32s(__u32 *p)
{
# 240 "include/uapi/linux/swab.h"
  * p = __swab32p ( ( __u32 const *) p );
}
# 248 "include/uapi/linux/swab.h"
static inline void __swab64s(__u64 *p)
{
# 253 "include/uapi/linux/swab.h"
  * p = __swab64p ( ( __u64 const *) p );
}
# 263 "include/uapi/linux/swab.h"
static inline void __swahw32s(__u32 *p)
{
# 268 "include/uapi/linux/swab.h"
  * p = __swahw32p ( ( __u32 const *) p );
}
# 278 "include/uapi/linux/swab.h"
static inline void __swahb32s(__u32 *p)
{
# 283 "include/uapi/linux/swab.h"
  * p = __swahb32p ( ( __u32 const *) p );
}
# 43 "include/uapi/linux/byteorder/little_endian.h"
static inline __le64 __cpu_to_le64p(__u64 const *p)
{
  return ( __le64 ) * p;
}
static inline __u64 __le64_to_cpup(__le64 const *p)
{
  return ( __u64 ) * p;
}
static inline __le32 __cpu_to_le32p(__u32 const *p)
{
  return ( __le32 ) * p;
}
static inline __u32 __le32_to_cpup(__le32 const *p)
{
  return ( __u32 ) * p;
}
static inline __le16 __cpu_to_le16p(__u16 const *p)
{
  return ( __le16 ) * p;
}
static inline __u16 __le16_to_cpup(__le16 const *p)
{
  return ( __u16 ) * p;
}
static inline __be64 __cpu_to_be64p(__u64 const *p)
{
  return ( __be64 ) __swab64p ( p );
}
static inline __u64 __be64_to_cpup(__be64 const *p)
{
  return __swab64p ( ( __u64 const *) p );
}
static inline __be32 __cpu_to_be32p(__u32 const *p)
{
  return ( __be32 ) __swab32p ( p );
}
static inline __u32 __be32_to_cpup(__be32 const *p)
{
  return __swab32p ( ( __u32 const *) p );
}
static inline __be16 __cpu_to_be16p(__u16 const *p)
{
  return ( __be16 ) __swab16p ( p );
}
static inline __u16 __be16_to_cpup(__be16 const *p)
{
  return __swab16p ( ( __u16 const *) p );
}
# 143 "include/linux/byteorder/generic.h"
static inline void le16_add_cpu(__le16 *var, u16 val)
{
  * var = ( short unsigned int ) * var + ( short unsigned int ) val;
}
# 148 "include/linux/byteorder/generic.h"
static inline void le32_add_cpu(__le32 *var, u32 val)
{
  * var = * var + ( __le32 ) val;
}
# 153 "include/linux/byteorder/generic.h"
static inline void le64_add_cpu(__le64 *var, u64 val)
{
  * var = ( long long unsigned int ) * var + ( long long unsigned int ) val;
}
# 158 "include/linux/byteorder/generic.h"
static inline void be16_add_cpu(__be16 *var, u16 val)
{
  * var = ( short unsigned int ) __fswab16 ( ( int ) ( __fswab16 ( ( int ) * var ) + ( __u16 ) val ) );
}
# 163 "include/linux/byteorder/generic.h"
static inline void be32_add_cpu(__be32 *var, u32 val)
{
  * var = ( unsigned int ) __fswab32 ( ( unsigned int ) __fswab32 ( * var ) + ( unsigned int ) val );
}
# 168 "include/linux/byteorder/generic.h"
static inline void be64_add_cpu(__be64 *var, u64 val)
{
  * var = ( long long unsigned int ) __fswab64 ( ( long long unsigned int ) __fswab64 ( * var ) + ( long long unsigned int ) val );
}
# 11 "include/asm-generic/bitops/le.h"
static inline long unsigned int find_next_zero_bit_le(void const *addr, long unsigned int size, long unsigned int offset)
{
# 14 "include/asm-generic/bitops/le.h"
  return find_next_zero_bit ( ( long unsigned int const *) addr , size , offset );
}
# 17 "include/asm-generic/bitops/le.h"
static inline long unsigned int find_next_bit_le(void const *addr, long unsigned int size, long unsigned int offset)
{
# 20 "include/asm-generic/bitops/le.h"
  return find_next_bit ( ( long unsigned int const *) addr , size , offset );
}
# 23 "include/asm-generic/bitops/le.h"
static inline long unsigned int find_first_zero_bit_le(void const *addr, long unsigned int size)
{
# 26 "include/asm-generic/bitops/le.h"
  return find_first_zero_bit ( ( long unsigned int const *) addr , size );
}
# 52 "include/asm-generic/bitops/le.h"
static inline int test_bit_le(int nr, void const *addr)
{
  return variable_test_bit ( ( long int ) nr , ( long unsigned int const volatile *) addr );
}
# 57 "include/asm-generic/bitops/le.h"
static inline void set_bit_le(int nr, void *addr)
{
  set_bit ( ( long int ) nr , ( long unsigned int volatile *) addr );
}
# 62 "include/asm-generic/bitops/le.h"
static inline void clear_bit_le(int nr, void *addr)
{
  clear_bit ( ( long int ) nr , ( long unsigned int volatile *) addr );
}
# 67 "include/asm-generic/bitops/le.h"
static inline void __set_bit_le(int nr, void *addr)
{
  __set_bit ( ( long int ) nr , ( long unsigned int volatile *) addr );
}
# 72 "include/asm-generic/bitops/le.h"
static inline void __clear_bit_le(int nr, void *addr)
{
  __clear_bit ( ( long int ) nr , ( long unsigned int volatile *) addr );
}
# 77 "include/asm-generic/bitops/le.h"
static inline int test_and_set_bit_le(int nr, void *addr)
{
  return test_and_set_bit ( ( long int ) nr , ( long unsigned int volatile *) addr );
}
# 82 "include/asm-generic/bitops/le.h"
static inline int test_and_clear_bit_le(int nr, void *addr)
{
  return test_and_clear_bit ( ( long int ) nr , ( long unsigned int volatile *) addr );
}
# 87 "include/asm-generic/bitops/le.h"
static inline int __test_and_set_bit_le(int nr, void *addr)
{
  return __test_and_set_bit ( ( long int ) nr , ( long unsigned int volatile *) addr );
}
# 92 "include/asm-generic/bitops/le.h"
static inline int __test_and_clear_bit_le(int nr, void *addr)
{
  return __test_and_clear_bit ( ( long int ) nr , ( long unsigned int volatile *) addr );
}
# 42 "include/linux/bitops.h"
void __smp_mb__before_atomic(void);
# 40 "include/linux/bitops.h"
static inline void smp_mb__before_clear_bit(void)
{
  void __smp_mb__before_atomic(void);
  __smp_mb__before_atomic ( );
}
# 50 "include/linux/bitops.h"
void __smp_mb__after_atomic(void);
# 48 "include/linux/bitops.h"
static inline void smp_mb__after_clear_bit(void)
{
  void __smp_mb__after_atomic(void);
  __smp_mb__after_atomic ( );
}
# 77 "include/linux/bitops.h"
static inline int get_bitmask_order(unsigned int count)
{
  int order;
# 81 "include/linux/bitops.h"
  order = fls ( ( int ) count );
  return order;
}
# 85 "include/linux/bitops.h"
static inline int get_count_order(unsigned int count)
{
  int order;
# 89 "include/linux/bitops.h"
  order = fls ( ( int ) count ) + -1;
  if (( count - 1U & count ) != 0U)
    order ++;
  return order;
}
# 95 "include/linux/bitops.h"
static inline long unsigned int hweight_long(long unsigned int w)
{
  return __arch_hweight64 ( ( __u64 ) w );
}
# 105 "include/linux/bitops.h"
static inline __u64 rol64(__u64 word, unsigned int shift)
{
  return (((word) << (shift)) | ((word) >> (8 * sizeof (word) - shift)));
}
# 115 "include/linux/bitops.h"
static inline __u64 ror64(__u64 word, unsigned int shift)
{
  return (((word) >> (shift)) | ((word) << (8 * sizeof (word) - shift)));
}
# 125 "include/linux/bitops.h"
static inline __u32 rol32(__u32 word, unsigned int shift)
{
  return (((word) << (shift)) | ((word) >> (8 * sizeof (word) - shift)));
}
# 135 "include/linux/bitops.h"
static inline __u32 ror32(__u32 word, unsigned int shift)
{
  return (((word) >> (shift)) | ((word) << (8 * sizeof (word) - shift)));
}
# 145 "include/linux/bitops.h"
static inline __u16 rol16(__u16 word, unsigned int shift)
{
  return ( __u16 ) ( ( short int ) ( ( int ) word << ( int ) shift ) | ( short int ) ( ( int ) word >> ( int ) ( 16U - shift ) ) );
}
# 155 "include/linux/bitops.h"
static inline __u16 ror16(__u16 word, unsigned int shift)
{
  return ( __u16 ) ( ( short int ) ( ( int ) word >> ( int ) shift ) | ( short int ) ( ( int ) word << ( int ) ( 16U - shift ) ) );
}
# 165 "include/linux/bitops.h"
static inline __u8 rol8(__u8 word, unsigned int shift)
{
  return ( __u8 ) ( ( signed char ) ( ( int ) word << ( int ) shift ) | ( signed char ) ( ( int ) word >> ( int ) ( 8U - shift ) ) );
}
# 175 "include/linux/bitops.h"
static inline __u8 ror8(__u8 word, unsigned int shift)
{
  return ( __u8 ) ( ( signed char ) ( ( int ) word >> ( int ) shift ) | ( signed char ) ( ( int ) word << ( int ) ( 8U - shift ) ) );
}
# 185 "include/linux/bitops.h"
static inline __s32 sign_extend32(__u32 value, int index)
{
  __u8 shift = 31U - ( __u8 ) index;
  return ( __s32 ) ( ( int ) ( value << ( int ) shift ) >> ( int ) shift );
}
# 191 "include/linux/bitops.h"
static inline unsigned int fls_long(long unsigned int l)
{
  if (0)
    return ( unsigned int ) fls ( ( int ) l );
  return ( unsigned int ) fls64 ( ( __u64 ) l );
}
# 206 "include/linux/bitops.h"
static inline long unsigned int __ffs64(u64 word)
{
# 214 "include/linux/bitops.h"
  return __ffs ( ( long unsigned int ) word );
}
# 242 "include/linux/bitops.h"
long unsigned int find_last_bit(long unsigned int const *, long unsigned int);
# 22 "include/linux/log2.h"
int ____ilog2_NaN(void);
# 32 "include/linux/log2.h"
static inline int __ilog2_u32(u32 n)
{
  return fls ( ( int ) n ) + -1;
}
# 40 "include/linux/log2.h"
static inline int __ilog2_u64(u64 n)
{
  return fls64 ( n ) + -1;
}
# 52 "include/linux/log2.h"
static inline bool is_power_of_2(long unsigned int n)
{
  return ( bool ) ( n != 0UL && ( n - 1UL & n ) == 0UL );
}
# 61 "include/linux/log2.h"
static inline long unsigned int __roundup_pow_of_two(long unsigned int n)
{
  return 1UL << ( int ) fls_long ( n - 1UL );
}
# 70 "include/linux/log2.h"
static inline long unsigned int __rounddown_pow_of_two(long unsigned int n)
{
  return 1UL << ( int ) ( fls_long ( n ) - 1U );
}
# 135 "include/linux/init.h"
typedef int (*initcall_t)(void);
typedef void (*exitcall_t)(void);
# 138 "include/linux/init.h"
extern initcall_t __con_initcall_start[];
# 138 "include/linux/init.h"
extern initcall_t __con_initcall_end[];
extern initcall_t __security_initcall_start[];
# 139 "include/linux/init.h"
extern initcall_t __security_initcall_end[];
# 142 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
# 145 "include/linux/init.h"
int do_one_initcall(initcall_t);
extern char boot_command_line[];
extern char *saved_command_line;
extern unsigned int reset_devices;
# 151 "include/linux/init.h"
void setup_arch(char **);
void prepare_namespace(void);
void load_default_modules(void);
int init_rootfs(void);
# 156 "include/linux/init.h"
extern void (*late_time_init)(void);
# 158 "include/linux/init.h"
extern bool initcall_debug;
struct sysinfo
{
# 8 "./include/uapi/linux/sysinfo.h"
  __kernel_long_t uptime;
  __kernel_ulong_t loads[3U];
  __kernel_ulong_t totalram;
  __kernel_ulong_t freeram;
  __kernel_ulong_t sharedram;
  __kernel_ulong_t bufferram;
  __kernel_ulong_t totalswap;
  __kernel_ulong_t freeswap;
  __u16 procs;
  __u16 pad;
  __kernel_ulong_t totalhigh;
  __kernel_ulong_t freehigh;
  __u32 mem_unit;
  char _f[0U];
};
# 10 "include/linux/printk.h"
extern char const linux_banner[];
extern char const linux_proc_banner[];
# 13 "include/linux/printk.h"
char *log_buf_addr_get(void);
u32 log_buf_len_get(void);
# 16 "include/linux/printk.h"
static inline int printk_get_level(char const *buffer)
{
  if (( signed char ) * buffer == 1 && ( signed char ) * ( buffer + 1UL ) != 0)
    switch (( int ) * ( buffer + 1UL ))
    {
# 21 "include/linux/printk.h"
      case 100:;
      return ( int ) * ( buffer + 1UL );
    }
# 25 "include/linux/printk.h"
  return 0;
}
# 28 "include/linux/printk.h"
static inline char const *printk_skip_level(char const *buffer)
{
  if (printk_get_level ( buffer ) != 0)
    return buffer + 2UL;
# 33 "include/linux/printk.h"
  return buffer;
}
# 47 "include/linux/printk.h"
extern int console_printk[];
# 54 "include/linux/printk.h"
static inline void console_silent(void)
{
  console_printk [ 0 ] = 0;
}
# 59 "include/linux/printk.h"
static inline void console_verbose(void)
{
  if (console_printk [ 0 ] != 0)
    console_printk [ 0 ] = 15;
}
struct va_format
{
  char const *fmt;
  va_list *va;
};
# 113 "include/linux/printk.h"
static inline int no_printk(char const *fmt, ...)
{
  return 0;
}
# 120 "include/linux/printk.h"
void early_printk(char const *, ...);
void early_vprintk(char const *, __va_list_tag *);
# 129 "include/linux/printk.h"
int vprintk_emit(int, int, char const *, size_t, char const *, __va_list_tag *);
# 134 "include/linux/printk.h"
int vprintk(char const *, __va_list_tag *);
# 137 "include/linux/printk.h"
int printk_emit(int, int, char const *, size_t, char const *, ...);
# 142 "include/linux/printk.h"
int printk(char const *, ...);
# 147 "include/linux/printk.h"
int printk_deferred(char const *, ...);
# 154 "include/linux/printk.h"
int __printk_ratelimit(char const *);
# 156 "include/linux/printk.h"
bool printk_timed_ratelimit(long unsigned int *, unsigned int);
# 159 "include/linux/printk.h"
extern int printk_delay_msec;
extern int dmesg_restrict;
extern int kptr_restrict;
# 163 "include/linux/printk.h"
void wake_up_klogd(void);
# 165 "include/linux/printk.h"
void log_buf_kexec_setup(void);
void setup_log_buf(int);
void dump_stack_set_arch_desc(char const *, ...);
void dump_stack_print_info(char const *);
void show_regs_print_info(char const *);
# 221 "include/linux/printk.h"
void dump_stack(void);
struct _ddebug
{
# 14 "include/linux/dynamic_debug.h"
  char const *modname;
  char const *function;
  char const *filename;
  char const *format;
  unsigned int lineno : 18;
# 35 "include/linux/dynamic_debug.h"
  unsigned char flags;
};
# 39 "include/linux/dynamic_debug.h"
int ddebug_add_module(struct _ddebug *, unsigned int, char const *);
# 43 "include/linux/dynamic_debug.h"
int ddebug_remove_module(char const *);
# 45 "include/linux/dynamic_debug.h"
int __dynamic_pr_debug(struct _ddebug *, char const *, ...);
# 47 "include/linux/dynamic_debug.h"
int ddebug_dyndbg_module_param_cb(char *, char *, char const *);
struct device;
# 53 "include/linux/dynamic_debug.h"
int __dynamic_dev_dbg(struct _ddebug *, struct device const *, char const *, ...);
struct net_device;
# 59 "include/linux/dynamic_debug.h"
int __dynamic_netdev_dbg(struct _ddebug *, struct net_device const *, char const *, ...);
# 403 "include/linux/printk.h"
extern struct file_operations const kmsg_fops;
enum ldv_1630
{
  DUMP_PREFIX_NONE = 0,
  DUMP_PREFIX_ADDRESS = 1,
  DUMP_PREFIX_OFFSET = 2
};
void hex_dump_to_buffer(void const *, size_t, int, int, char *, size_t, bool);
# 414 "include/linux/printk.h"
void print_hex_dump(char const *, char const *, int, int, int, void const *, size_t, bool);
struct completion;
struct user;
# 165 "include/linux/kernel.h"
void __might_sleep(char const *, int, int);
# 223 "include/linux/kernel.h"
static inline u32 reciprocal_scale(u32 val, u32 ep_ro)
{
  return ( u32 ) ( ( long long unsigned int ) val * ( long long unsigned int ) ep_ro >> 32 );
}
# 230 "include/linux/kernel.h"
void might_fault(void);
# 235 "include/linux/kernel.h"
extern struct atomic_notifier_head panic_notifier_list;
extern long int (*panic_blink)(int);
# 238 "include/linux/kernel.h"
void panic(char const *, ...);
# 240 "include/linux/kernel.h"
void oops_enter(void);
void oops_exit(void);
void print_oops_end_marker(void);
int oops_may_print(void);
void do_exit(long int);
# 246 "include/linux/kernel.h"
void complete_and_exit(struct completion *, long int);
# 250 "include/linux/kernel.h"
int _kstrtoul(char const *, unsigned int, long unsigned int *);
int _kstrtol(char const *, unsigned int, long int *);
# 253 "include/linux/kernel.h"
int kstrtoull(char const *, unsigned int, long long unsigned int *);
int kstrtoll(char const *, unsigned int, long long int *);
# 272 "include/linux/kernel.h"
static inline int kstrtoul(char const *s, unsigned int base, long unsigned int *res)
{
# 278 "include/linux/kernel.h"
  if (1)
  {
    return kstrtoull ( s , base , ( long long unsigned int *) res );
  }
  else
# 282 "include/linux/kernel.h"
    return _kstrtoul ( s , base , res );
}
# 301 "include/linux/kernel.h"
static inline int kstrtol(char const *s, unsigned int base, long int *res)
{
# 307 "include/linux/kernel.h"
  if (1)
  {
    return kstrtoll ( s , base , ( long long int *) res );
  }
  else
# 311 "include/linux/kernel.h"
    return _kstrtol ( s , base , res );
}
# 314 "include/linux/kernel.h"
int kstrtouint(char const *, unsigned int, unsigned int *);
int kstrtoint(char const *, unsigned int, int *);
# 317 "include/linux/kernel.h"
static inline int kstrtou64(char const *s, unsigned int base, u64 *res)
{
  return kstrtoull ( s , base , ( long long unsigned int *) res );
}
# 322 "include/linux/kernel.h"
static inline int kstrtos64(char const *s, unsigned int base, s64 *res)
{
  return kstrtoll ( s , base , ( long long int *) res );
}
# 327 "include/linux/kernel.h"
static inline int kstrtou32(char const *s, unsigned int base, u32 *res)
{
  return kstrtouint ( s , base , ( unsigned int *) res );
}
# 332 "include/linux/kernel.h"
static inline int kstrtos32(char const *s, unsigned int base, s32 *res)
{
  return kstrtoint ( s , base , ( int *) res );
}
# 337 "include/linux/kernel.h"
int kstrtou16(char const *, unsigned int, u16 *);
int kstrtos16(char const *, unsigned int, s16 *);
int kstrtou8(char const *, unsigned int, u8 *);
int kstrtos8(char const *, unsigned int, s8 *);
# 342 "include/linux/kernel.h"
int kstrtoull_from_user(char const *, size_t, unsigned int, long long unsigned int *);
int kstrtoll_from_user(char const *, size_t, unsigned int, long long int *);
int kstrtoul_from_user(char const *, size_t, unsigned int, long unsigned int *);
int kstrtol_from_user(char const *, size_t, unsigned int, long int *);
int kstrtouint_from_user(char const *, size_t, unsigned int, unsigned int *);
int kstrtoint_from_user(char const *, size_t, unsigned int, int *);
int kstrtou16_from_user(char const *, size_t, unsigned int, u16 *);
int kstrtos16_from_user(char const *, size_t, unsigned int, s16 *);
int kstrtou8_from_user(char const *, size_t, unsigned int, u8 *);
int kstrtos8_from_user(char const *, size_t, unsigned int, s8 *);
# 353 "include/linux/kernel.h"
static inline int kstrtou64_from_user(char const *s, size_t count, unsigned int base, u64 *res)
{
  return kstrtoull_from_user ( s , count , base , ( long long unsigned int *) res );
}
# 358 "include/linux/kernel.h"
static inline int kstrtos64_from_user(char const *s, size_t count, unsigned int base, s64 *res)
{
  return kstrtoll_from_user ( s , count , base , ( long long int *) res );
}
# 363 "include/linux/kernel.h"
static inline int kstrtou32_from_user(char const *s, size_t count, unsigned int base, u32 *res)
{
  return kstrtouint_from_user ( s , count , base , ( unsigned int *) res );
}
# 368 "include/linux/kernel.h"
static inline int kstrtos32_from_user(char const *s, size_t count, unsigned int base, s32 *res)
{
  return kstrtoint_from_user ( s , count , base , ( int *) res );
}
# 375 "include/linux/kernel.h"
long unsigned int simple_strtoul(char const *, char **, unsigned int);
long int simple_strtol(char const *, char **, unsigned int);
long long unsigned int simple_strtoull(char const *, char **, unsigned int);
long long int simple_strtoll(char const *, char **, unsigned int);
# 384 "include/linux/kernel.h"
int num_to_str(char *, int, long long unsigned int);
# 388 "include/linux/kernel.h"
int sprintf(char *, char const *, ...);
int vsprintf(char *, char const *, __va_list_tag *);
# 391 "include/linux/kernel.h"
int snprintf(char *, size_t, char const *, ...);
# 393 "include/linux/kernel.h"
int vsnprintf(char *, size_t, char const *, __va_list_tag *);
# 395 "include/linux/kernel.h"
int scnprintf(char *, size_t, char const *, ...);
# 397 "include/linux/kernel.h"
int vscnprintf(char *, size_t, char const *, __va_list_tag *);
# 399 "include/linux/kernel.h"
char *kasprintf(gfp_t, char const *, ...);
char *kvasprintf(gfp_t, char const *, __va_list_tag *);
# 403 "include/linux/kernel.h"
int sscanf(char const *, char const *, ...);
# 405 "include/linux/kernel.h"
int vsscanf(char const *, char const *, __va_list_tag *);
# 407 "include/linux/kernel.h"
int get_option(char **, int *);
char *get_options(char const *, int, int *);
long long unsigned int memparse(char const *, char **);
# 411 "include/linux/kernel.h"
int core_kernel_text(long unsigned int);
int core_kernel_data(long unsigned int);
int __kernel_text_address(long unsigned int);
int kernel_text_address(long unsigned int);
int func_ptr_is_kernel_text(void *);
struct pid;
# 418 "include/linux/kernel.h"
struct pid *session_of_pgrp(struct pid *);
# 420 "include/linux/kernel.h"
long unsigned int int_sqrt(long unsigned int);
# 422 "include/linux/kernel.h"
void bust_spinlocks(int);
extern int oops_in_progress;
extern int panic_timeout;
extern int panic_on_oops;
extern int panic_on_unrecovered_nmi;
extern int panic_on_io_nmi;
extern int sysctl_panic_on_stackoverflow;
# 433 "include/linux/kernel.h"
static inline void set_arch_panic_timeout(int timeout, int arch_default_timeout)
{
  if (panic_timeout == arch_default_timeout)
    panic_timeout = timeout;
}
char const *print_tainted(void);
enum lockdep_ok
{
  LOCKDEP_STILL_OK = 0,
  LOCKDEP_NOW_UNRELIABLE = 1
};
# 443 "include/linux/kernel.h"
void add_taint(unsigned int, enum lockdep_ok);
int test_taint(unsigned int);
long unsigned int get_taint(void);
extern int root_mountflags;
# 448 "include/linux/kernel.h"
extern bool early_boot_irqs_disabled;
enum system_states
{
  SYSTEM_BOOTING = 0,
  SYSTEM_RUNNING = 1,
  SYSTEM_HALT = 2,
  SYSTEM_POWER_OFF = 3,
  SYSTEM_RESTART = 4
};
extern enum system_states system_state;
# 475 "include/linux/kernel.h"
extern char const hex_asc[];
# 479 "include/linux/kernel.h"
static inline char *hex_byte_pack(char *buf, u8 byte)
{
  * buf ++ = hex_asc [ ( int ) ( byte >> 4 ) ];
  * buf ++ = hex_asc [ ( int ) byte & 15 ];
  return buf;
}
# 486 "include/linux/kernel.h"
extern char const hex_asc_upper[];
# 490 "include/linux/kernel.h"
static inline char *hex_byte_pack_upper(char *buf, u8 byte)
{
  * buf ++ = hex_asc_upper [ ( int ) ( byte >> 4 ) ];
  * buf ++ = hex_asc_upper [ ( int ) byte & 15 ];
  return buf;
}
# 497 "include/linux/kernel.h"
int hex_to_bin(char);
int hex2bin(u8 *, char const *, size_t);
# 500 "include/linux/kernel.h"
bool mac_pton(char const *, u8 *);
# 523 "include/linux/kernel.h"
void tracing_off_permanent(void);
enum ftrace_dump_mode
{
  DUMP_NONE = 0,
  DUMP_ALL = 1,
  DUMP_ORIG = 2
};
# 535 "include/linux/kernel.h"
void tracing_on(void);
void tracing_off(void);
int tracing_is_on(void);
void tracing_snapshot(void);
void tracing_snapshot_alloc(void);
# 541 "include/linux/kernel.h"
void tracing_start(void);
void tracing_stop(void);
# 545 "include/linux/kernel.h"
static inline void ____trace_printk_check_format(char const *fmt, ...)
{
}
# 608 "include/linux/kernel.h"
int __trace_bprintk(long unsigned int, char const *, ...);
# 611 "include/linux/kernel.h"
int __trace_printk(long unsigned int, char const *, ...);
# 648 "include/linux/kernel.h"
int __trace_bputs(long unsigned int, char const *);
int __trace_puts(long unsigned int, char const *, int);
# 651 "include/linux/kernel.h"
void trace_dump_stack(int);
# 671 "include/linux/kernel.h"
int __ftrace_vbprintk(long unsigned int, char const *, __va_list_tag *);
# 674 "include/linux/kernel.h"
int __ftrace_vprintk(long unsigned int, char const *, __va_list_tag *);
# 676 "include/linux/kernel.h"
void ftrace_dump(enum ftrace_dump_mode);
# 87 "./arch/x86/include/asm/percpu.h"
void __bad_percpu_size(void);
# 491 "./arch/x86/include/asm/percpu.h"
static inline int x86_this_cpu_constant_test_bit(unsigned int nr, long unsigned int const *addr)
{
# 494 "./arch/x86/include/asm/percpu.h"
  long unsigned int *a = ( long unsigned int *) addr + ( long unsigned int ) ( nr / 64U );
# 497 "./arch/x86/include/asm/percpu.h"
  return ( int ) ( ({
# 497 "./arch/x86/include/asm/percpu.h"
    long unsigned int pfo_ret__;
    {
# 497 "./arch/x86/include/asm/percpu.h"
      switch (8UL)
      {
# 497 "./arch/x86/include/asm/percpu.h"
        case 1:;
# 497 "./arch/x86/include/asm/percpu.h"
        asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( * a ) ) ;
# 497 "./arch/x86/include/asm/percpu.h"
        goto ldv_2605;
# 497 "./arch/x86/include/asm/percpu.h"
        case 2:;
# 497 "./arch/x86/include/asm/percpu.h"
        asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( * a ) ) ;
# 497 "./arch/x86/include/asm/percpu.h"
        goto ldv_2605;
# 497 "./arch/x86/include/asm/percpu.h"
        case 4:;
# 497 "./arch/x86/include/asm/percpu.h"
        asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( * a ) ) ;
# 497 "./arch/x86/include/asm/percpu.h"
        goto ldv_2605;
# 497 "./arch/x86/include/asm/percpu.h"
        case 8:;
# 497 "./arch/x86/include/asm/percpu.h"
        asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( * a ) ) ;
# 497 "./arch/x86/include/asm/percpu.h"
        goto ldv_2605;
# 497 "./arch/x86/include/asm/percpu.h"
        default:;
# 497 "./arch/x86/include/asm/percpu.h"
        __bad_percpu_size ( );
      }
# 497 "./arch/x86/include/asm/percpu.h"
      ldv_2605:;
    }
# 497 "./arch/x86/include/asm/percpu.h"
    pfo_ret__;
  } )
# 497 "./arch/x86/include/asm/percpu.h"
  >> ( ( int ) nr & 63 ) ) & 1;
}
# 503 "./arch/x86/include/asm/percpu.h"
static inline int x86_this_cpu_variable_test_bit(int nr, long unsigned int const *addr)
{
# 506 "./arch/x86/include/asm/percpu.h"
  int oldbit;
# 508 "./arch/x86/include/asm/percpu.h"
  asm volatile ( "bt %%gs:%P2,%1\n\tsbb %0,%0" : "=r" ( oldbit ) : "m" (
# 511 "./arch/x86/include/asm/percpu.h"
  * ( long unsigned int *) addr ) , "Ir" ( nr ) ) ;
# 513 "./arch/x86/include/asm/percpu.h"
  return oldbit;
}
# 300 "include/linux/percpu-defs.h"
void __bad_size_call_parameter(void);
# 305 "include/linux/percpu-defs.h"
static inline void __this_cpu_preempt_check(char const *op)
{
}
# 18 "include/asm-generic/percpu.h"
extern long unsigned int __per_cpu_offset[8192U];
# 47 "include/asm-generic/percpu.h"
void setup_per_cpu_areas(void);
# 525 "./arch/x86/include/asm/percpu.h"
extern char __pcpu_scope_this_cpu_off;
# 525 "./arch/x86/include/asm/percpu.h"
extern long unsigned int this_cpu_off;
# 10 "./arch/x86/include/asm/current.h"
extern char __pcpu_scope_current_task;
# 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task;
# 12 "./arch/x86/include/asm/current.h"
static inline struct task_struct *get_current(void)
{
  return ({
# 14 "./arch/x86/include/asm/current.h"
    struct task_struct *pfo_ret__;
    {
# 14 "./arch/x86/include/asm/current.h"
      switch (8UL)
      {
# 14 "./arch/x86/include/asm/current.h"
        case 1:;
# 14 "./arch/x86/include/asm/current.h"
        asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "p" ( & current_task ) ) ;
# 14 "./arch/x86/include/asm/current.h"
        goto ldv_2633;
# 14 "./arch/x86/include/asm/current.h"
        case 2:;
# 14 "./arch/x86/include/asm/current.h"
        asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "p" ( & current_task ) ) ;
# 14 "./arch/x86/include/asm/current.h"
        goto ldv_2633;
# 14 "./arch/x86/include/asm/current.h"
        case 4:;
# 14 "./arch/x86/include/asm/current.h"
        asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "p" ( & current_task ) ) ;
# 14 "./arch/x86/include/asm/current.h"
        goto ldv_2633;
# 14 "./arch/x86/include/asm/current.h"
        case 8:;
# 14 "./arch/x86/include/asm/current.h"
        asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "p" ( & current_task ) ) ;
# 14 "./arch/x86/include/asm/current.h"
        goto ldv_2633;
# 14 "./arch/x86/include/asm/current.h"
        default:;
# 14 "./arch/x86/include/asm/current.h"
        __bad_percpu_size ( );
      }
# 14 "./arch/x86/include/asm/current.h"
      ldv_2633:;
    }
# 14 "./arch/x86/include/asm/current.h"
    pfo_ret__;
  } );
}
# 24 "include/linux/list.h"
static inline void INIT_LIST_HEAD(struct list_head *list)
{
  ( * list ) . next = list;
  ( * list ) . prev = list;
}
# 47 "include/linux/list.h"
void __list_add(struct list_head *, struct list_head *, struct list_head *);
# 60 "include/linux/list.h"
static inline void list_add(struct list_head *new, struct list_head *head)
{
  __list_add ( new , head , ( * head ) . next );
}
# 74 "include/linux/list.h"
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
  __list_add ( new , ( * head ) . prev , head );
}
# 86 "include/linux/list.h"
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
  ( * next ) . prev = prev;
  ( * prev ) . next = next;
}
# 111 "include/linux/list.h"
void __list_del_entry(struct list_head *);
void list_del(struct list_head *);
# 122 "include/linux/list.h"
static inline void list_replace(struct list_head *old, struct list_head *new)
{
# 125 "include/linux/list.h"
  ( * new ) . next = ( * old ) . next;
  ( * ( * new ) . next ) . prev = new;
  ( * new ) . prev = ( * old ) . prev;
  ( * ( * new ) . prev ) . next = new;
}
# 131 "include/linux/list.h"
static inline void list_replace_init(struct list_head *old, struct list_head *new)
{
# 134 "include/linux/list.h"
  list_replace ( old , new );
  INIT_LIST_HEAD ( old );
}
# 142 "include/linux/list.h"
static inline void list_del_init(struct list_head *entry)
{
  __list_del_entry ( entry );
  INIT_LIST_HEAD ( entry );
}
# 153 "include/linux/list.h"
static inline void list_move(struct list_head *list, struct list_head *head)
{
  __list_del_entry ( list );
  list_add ( list , head );
}
# 164 "include/linux/list.h"
static inline void list_move_tail(struct list_head *list, struct list_head *head)
{
# 167 "include/linux/list.h"
  __list_del_entry ( list );
  list_add_tail ( list , head );
}
# 176 "include/linux/list.h"
static inline int list_is_last(struct list_head const *list, struct list_head const *head)
{
# 179 "include/linux/list.h"
  return ( struct list_head const *) ( * list ) . next == head;
}
# 186 "include/linux/list.h"
static inline int list_empty(struct list_head const *head)
{
  return ( struct list_head const *) ( * head ) . next == head;
}
# 204 "include/linux/list.h"
static inline int list_empty_careful(struct list_head const *head)
{
  struct list_head *next = ( * head ) . next;
  return ( struct list_head const *) next == head && ( struct list_head *) ( * head ) . prev == next;
}
# 214 "include/linux/list.h"
static inline void list_rotate_left(struct list_head *head)
{
  struct list_head *first;
# 218 "include/linux/list.h"
  if (list_empty ( ( struct list_head const *) head ) == 0)
  {
# 219 "include/linux/list.h"
    first = ( * head ) . next;
    list_move_tail ( first , head );
  }
}
# 228 "include/linux/list.h"
static inline int list_is_singular(struct list_head const *head)
{
  return list_empty ( head ) == 0 && ( * head ) . next == ( * head ) . prev;
}
# 233 "include/linux/list.h"
static inline void __list_cut_position(struct list_head *list, struct list_head *head, struct list_head *entry)
{
# 236 "include/linux/list.h"
  struct list_head *new_first = ( * entry ) . next;
  ( * list ) . next = ( * head ) . next;
  ( * ( * list ) . next ) . prev = list;
  ( * list ) . prev = entry;
  ( * entry ) . next = list;
  ( * head ) . next = new_first;
  ( * new_first ) . prev = head;
}
# 259 "include/linux/list.h"
static inline void list_cut_position(struct list_head *list, struct list_head *head, struct list_head *entry)
{
# 262 "include/linux/list.h"
  if (list_empty ( ( struct list_head const *) head ) != 0)
    return;
  if (list_is_singular ( ( struct list_head const *) head ) != 0 && ( (
# 265 "include/linux/list.h"
  * head ) . next != entry && head != entry ))
    return;
  if (entry == head)
  {
# 268 "include/linux/list.h"
    INIT_LIST_HEAD ( list );
  }
  else
# 270 "include/linux/list.h"
    __list_cut_position ( list , head , entry );
}
# 273 "include/linux/list.h"
static inline void __list_splice(struct list_head const *list, struct list_head *prev, struct list_head *next)
{
# 277 "include/linux/list.h"
  struct list_head *first = ( * list ) . next;
  struct list_head *last = ( * list ) . prev;
# 280 "include/linux/list.h"
  ( * first ) . prev = prev;
  ( * prev ) . next = first;
# 283 "include/linux/list.h"
  ( * last ) . next = next;
  ( * next ) . prev = last;
}
# 292 "include/linux/list.h"
static inline void list_splice(struct list_head const *list, struct list_head *head)
{
# 295 "include/linux/list.h"
  if (list_empty ( list ) == 0)
    __list_splice ( list , head , ( * head ) . next );
}
# 304 "include/linux/list.h"
static inline void list_splice_tail(struct list_head *list, struct list_head *head)
{
# 307 "include/linux/list.h"
  if (list_empty ( ( struct list_head const *) list ) == 0)
    __list_splice ( ( struct list_head const *) list , ( * head ) . prev , head );
}
# 318 "include/linux/list.h"
static inline void list_splice_init(struct list_head *list, struct list_head *head)
{
# 321 "include/linux/list.h"
  if (list_empty ( ( struct list_head const *) list ) == 0)
  {
# 322 "include/linux/list.h"
    __list_splice ( ( struct list_head const *) list , head , ( * head ) . next );
    INIT_LIST_HEAD ( list );
  }
}
# 335 "include/linux/list.h"
static inline void list_splice_tail_init(struct list_head *list, struct list_head *head)
{
# 338 "include/linux/list.h"
  if (list_empty ( ( struct list_head const *) list ) == 0)
  {
# 339 "include/linux/list.h"
    __list_splice ( ( struct list_head const *) list , ( * head ) . prev , head );
    INIT_LIST_HEAD ( list );
  }
}
# 597 "include/linux/list.h"
static inline void INIT_HLIST_NODE(struct hlist_node *h)
{
  ( * h ) . next = ( ( struct hlist_node *) 0 );
  ( * h ) . pprev = ( ( struct hlist_node **) 0 );
}
# 603 "include/linux/list.h"
static inline int hlist_unhashed(struct hlist_node const *h)
{
  return ( * h ) . pprev == ( ( struct hlist_node **const ) 0 );
}
# 608 "include/linux/list.h"
static inline int hlist_empty(struct hlist_head const *h)
{
  return ( * h ) . first == ( ( struct hlist_node *const ) 0 );
}
# 613 "include/linux/list.h"
static inline void __hlist_del(struct hlist_node *n)
{
  struct hlist_node *next = ( * n ) . next;
  struct hlist_node **pprev = ( * n ) . pprev;
  * pprev = next;
  if (next != ( ( struct hlist_node *) 0 ))
    ( * next ) . pprev = pprev;
}
# 622 "include/linux/list.h"
static inline void hlist_del(struct hlist_node *n)
{
  __hlist_del ( n );
  ( * n ) . next = ( ( struct hlist_node *) -2401263026317557504 );
  ( * n ) . pprev = ( ( struct hlist_node **) -2401263026316508672 );
}
# 629 "include/linux/list.h"
static inline void hlist_del_init(struct hlist_node *n)
{
  if (hlist_unhashed ( ( struct hlist_node const *) n ) == 0)
  {
# 632 "include/linux/list.h"
    __hlist_del ( n );
    INIT_HLIST_NODE ( n );
  }
}
# 637 "include/linux/list.h"
static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
{
  struct hlist_node *first = ( * h ) . first;
  ( * n ) . next = first;
  if (first != ( ( struct hlist_node *) 0 ))
    ( * first ) . pprev = & ( * n ) . next;
  ( * h ) . first = n;
  ( * n ) . pprev = & ( * h ) . first;
}
# 648 "include/linux/list.h"
static inline void hlist_add_before(struct hlist_node *n, struct hlist_node *next)
{
# 651 "include/linux/list.h"
  ( * n ) . pprev = ( * next ) . pprev;
  ( * n ) . next = next;
  ( * next ) . pprev = & ( * n ) . next;
  * ( * n ) . pprev = n;
}
# 657 "include/linux/list.h"
static inline void hlist_add_behind(struct hlist_node *n, struct hlist_node *prev)
{
# 660 "include/linux/list.h"
  ( * n ) . next = ( * prev ) . next;
  ( * prev ) . next = n;
  ( * n ) . pprev = & ( * prev ) . next;
# 664 "include/linux/list.h"
  if (( * n ) . next != ( ( struct hlist_node *) 0 ))
    ( * ( * n ) . next ) . pprev = & ( * n ) . next;
}
# 669 "include/linux/list.h"
static inline void hlist_add_fake(struct hlist_node *n)
{
  ( * n ) . pprev = & ( * n ) . next;
}
# 678 "include/linux/list.h"
static inline void hlist_move_list(struct hlist_head *old, struct hlist_head *new)
{
# 681 "include/linux/list.h"
  ( * new ) . first = ( * old ) . first;
  if (( * new ) . first != ( ( struct hlist_node *) 0 ))
    ( * ( * new ) . first ) . pprev = & ( * new ) . first;
  ( * old ) . first = ( ( struct hlist_node *) 0 );
}
struct lockdep_map;
# 16 "include/linux/lockdep.h"
extern int prove_locking;
extern int lock_stat;
struct vm86_regs
{
# 66 "./arch/x86/include/uapi/asm/vm86.h"
  long int ebx;
  long int ecx;
  long int edx;
  long int esi;
  long int edi;
  long int ebp;
  long int eax;
  long int __null_ds;
  long int __null_es;
  long int __null_fs;
  long int __null_gs;
  long int orig_eax;
  long int eip;
  short unsigned int cs;
# 79 "./arch/x86/include/uapi/asm/vm86.h"
  short unsigned int __csh;
  long int eflags;
  long int esp;
  short unsigned int ss;
# 82 "./arch/x86/include/uapi/asm/vm86.h"
  short unsigned int __ssh;
# 86 "./arch/x86/include/uapi/asm/vm86.h"
  short unsigned int es;
# 86 "./arch/x86/include/uapi/asm/vm86.h"
  short unsigned int __esh;
  short unsigned int ds;
# 87 "./arch/x86/include/uapi/asm/vm86.h"
  short unsigned int __dsh;
  short unsigned int fs;
# 88 "./arch/x86/include/uapi/asm/vm86.h"
  short unsigned int __fsh;
  short unsigned int gs;
# 89 "./arch/x86/include/uapi/asm/vm86.h"
  short unsigned int __gsh;
};
struct revectored_struct
{
  long unsigned int __map[8U];
};
struct vm86_struct
{
  struct vm86_regs regs;
  long unsigned int flags;
  long unsigned int screen_bitmap;
  long unsigned int cpu_type;
  struct revectored_struct int_revectored;
  struct revectored_struct int21_revectored;
};
struct vm86plus_info_struct
{
# 111 "./arch/x86/include/uapi/asm/vm86.h"
  unsigned char force_return_for_pic : 1;
  unsigned char vm86dbg_active : 1;
  unsigned char vm86dbg_TFpendig : 1;
  unsigned int unused : 28;
  unsigned char is_vm86pus : 1;
  unsigned char vm86dbg_intxxtab[32U];
};
struct vm86plus_struct
{
# 119 "./arch/x86/include/uapi/asm/vm86.h"
  struct vm86_regs regs;
  long unsigned int flags;
  long unsigned int screen_bitmap;
  long unsigned int cpu_type;
  struct revectored_struct int_revectored;
  struct revectored_struct int21_revectored;
  struct vm86plus_info_struct vm86plus;
};
struct kernel_vm86_regs
{
# 21 "./arch/x86/include/asm/vm86.h"
  struct pt_regs pt;
# 25 "./arch/x86/include/asm/vm86.h"
  short unsigned int es;
# 25 "./arch/x86/include/asm/vm86.h"
  short unsigned int __esh;
  short unsigned int ds;
# 26 "./arch/x86/include/asm/vm86.h"
  short unsigned int __dsh;
  short unsigned int fs;
# 27 "./arch/x86/include/asm/vm86.h"
  short unsigned int __fsh;
  short unsigned int gs;
# 28 "./arch/x86/include/asm/vm86.h"
  short unsigned int __gsh;
};
struct kernel_vm86_struct
{
  struct kernel_vm86_regs regs;
# 42 "./arch/x86/include/asm/vm86.h"
  long unsigned int flags;
  long unsigned int screen_bitmap;
  long unsigned int cpu_type;
  struct revectored_struct int_revectored;
  struct revectored_struct int21_revectored;
  struct vm86plus_info_struct vm86plus;
  struct pt_regs *regs32;
};
# 75 "./arch/x86/include/asm/vm86.h"
static inline int handle_vm86_trap(struct kernel_vm86_regs *a, long int b, int c)
{
  return 0;
}
struct math_emu_info
{
# 12 "./arch/x86/include/asm/math_emu.h"
  long int ___orig_eip;
# 16 "./arch/x86/include/asm/math_emu.h"
  union
  {
# 14 "./arch/x86/include/asm/math_emu.h"
    struct pt_regs *regs;
    struct kernel_vm86_regs *vm86;
  } ldv_2857;
};
struct _fpx_sw_bytes
{
# 24 "./arch/x86/include/uapi/asm/sigcontext.h"
  __u32 magic1;
  __u32 extended_size;
# 28 "./arch/x86/include/uapi/asm/sigcontext.h"
  __u64 xstate_bv;
# 33 "./arch/x86/include/uapi/asm/sigcontext.h"
  __u32 xstate_size;
# 38 "./arch/x86/include/uapi/asm/sigcontext.h"
  __u32 padding[7U];
};
struct _fpstate
{
# 137 "./arch/x86/include/uapi/asm/sigcontext.h"
  __u16 cwd;
  __u16 swd;
  __u16 twd;
# 141 "./arch/x86/include/uapi/asm/sigcontext.h"
  __u16 fop;
  __u64 rip;
  __u64 rdp;
  __u32 mxcsr;
  __u32 mxcsr_mask;
  __u32 st_space[32U];
  __u32 xmm_space[64U];
  __u32 reserved2[12U];
# 153 "./arch/x86/include/uapi/asm/sigcontext.h"
  union
  {
# 150 "./arch/x86/include/uapi/asm/sigcontext.h"
    __u32 reserved3[12U];
    struct _fpx_sw_bytes sw_reserved;
  } ldv_2879;
};
struct _xsave_hdr
{
# 198 "./arch/x86/include/uapi/asm/sigcontext.h"
  __u64 xstate_bv;
  __u64 reserved1[2U];
  __u64 reserved2[5U];
};
struct _ymmh_state
{
# 205 "./arch/x86/include/uapi/asm/sigcontext.h"
  __u32 ymmh_space[64U];
};
struct _xstate
{
# 215 "./arch/x86/include/uapi/asm/sigcontext.h"
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
struct sigcontext
{
# 41 "./arch/x86/include/asm/sigcontext.h"
  long unsigned int r8;
  long unsigned int r9;
  long unsigned int r10;
  long unsigned int r11;
  long unsigned int r12;
  long unsigned int r13;
  long unsigned int r14;
  long unsigned int r15;
  long unsigned int di;
  long unsigned int si;
  long unsigned int bp;
  long unsigned int bx;
  long unsigned int dx;
  long unsigned int ax;
  long unsigned int cx;
  long unsigned int sp;
  long unsigned int ip;
  long unsigned int flags;
  short unsigned int cs;
  short unsigned int gs;
  short unsigned int fs;
  short unsigned int __pad0;
  long unsigned int err;
  long unsigned int trapno;
  long unsigned int oldmask;
  long unsigned int cr2;
# 75 "./arch/x86/include/asm/sigcontext.h"
  void *fpstate;
  long unsigned int reserved1[8U];
};
# 9 "./arch/x86/include/asm/page_64.h"
extern long unsigned int max_pfn;
extern long unsigned int phys_base;
# 12 "./arch/x86/include/asm/page_64.h"
static inline long unsigned int __phys_addr_nodebug(long unsigned int x)
{
  long unsigned int y = x - 18446744071562067968UL;
# 17 "./arch/x86/include/asm/page_64.h"
  x = ( x > y ? phys_base : 131939247849472UL ) + y;
# 19 "./arch/x86/include/asm/page_64.h"
  return x;
}
# 23 "./arch/x86/include/asm/page_64.h"
long unsigned int __phys_addr(long unsigned int);
long unsigned int __phys_addr_symbol(long unsigned int);
# 37 "./arch/x86/include/asm/page_64.h"
void clear_page(void *);
void copy_page(void *, void *);
struct range
{
# 5 "include/linux/range.h"
  u64 start;
  u64 end;
};
# 9 "include/linux/range.h"
int add_range(struct range *, int, int, u64, u64);
# 13 "include/linux/range.h"
int add_range_with_merge(struct range *, int, int, u64, u64);
# 16 "include/linux/range.h"
void subtract_range(struct range *, int, u64, u64);
# 18 "include/linux/range.h"
int clean_sort_range(struct range *, int);
# 20 "include/linux/range.h"
void sort_range(struct range *, int);
# 23 "include/linux/range.h"
static inline resource_size_t cap_resource(u64 val)
{
  if (0)
    return 18446744073709551615ULL;
# 28 "include/linux/range.h"
  return ( resource_size_t ) val;
}
# 21 "./arch/x86/include/asm/page.h"
extern struct range pfn_mapped[];
extern int nr_pfn_mapped;
# 24 "./arch/x86/include/asm/page.h"
static inline void clear_user_page(void *page, long unsigned int vaddr, struct page *pg)
{
# 27 "./arch/x86/include/asm/page.h"
  clear_page ( page );
}
# 30 "./arch/x86/include/asm/page.h"
static inline void copy_user_page(void *to, void *from, long unsigned int vaddr, struct page *topage)
{
# 33 "./arch/x86/include/asm/page.h"
  copy_page ( to , from );
}
# 65 "./arch/x86/include/asm/page.h"
bool __virt_addr_valid(long unsigned int);
# 13 "include/asm-generic/getorder.h"
static inline int __get_order(long unsigned int size)
{
  int order;
# 17 "include/asm-generic/getorder.h"
  size --;
  size >>= 12;
# 22 "include/asm-generic/getorder.h"
  order = fls64 ( ( __u64 ) size );
# 24 "include/asm-generic/getorder.h"
  return order;
}
# 10 "include/asm-generic/ioctl.h"
extern unsigned int __invalid_size_argument_for_IOC;
char *strndup_user(char const *, long int);
void *memdup_user(void const *, size_t);
# 9 "./arch/x86/include/asm/string_64.h"
static inline void *__inline_memcpy(void *to, void const *from, size_t n)
{
  long unsigned int d0;
# 11 "./arch/x86/include/asm/string_64.h"
  long unsigned int d1;
# 11 "./arch/x86/include/asm/string_64.h"
  long unsigned int d2;
  asm volatile ( "rep ; movsl\n\ttestb $2,%b4\n\tje 1f\n\tmovsw\n1:\ttestb $1,%b4\n\tje 2f\n\tmovsb\n2:" : "=&c" ( d0 ) , "=&D" ( d1 ) , "=&S" ( d2 ) : "0" ( n
# 21 "./arch/x86/include/asm/string_64.h"
  / 4UL ) , "q" ( n ) , "1" ( ( long int ) to ) , "2" ( ( long int ) from ) : "memory" ) ;
# 23 "./arch/x86/include/asm/string_64.h"
  return to;
}
# 34 "./arch/x86/include/asm/string_64.h"
void *__memcpy(void *, void const *, size_t);
# 55 "./arch/x86/include/asm/string_64.h"
void *memset(void *, int, size_t);
# 58 "./arch/x86/include/asm/string_64.h"
void *memmove(void *, void const *, size_t);
# 60 "./arch/x86/include/asm/string_64.h"
int memcmp(void const *, void const *, size_t);
size_t strlen(char const *);
char *strcpy(char *, char const *);
char *strcat(char *, char const *);
int strcmp(char const *, char const *);
# 20 "include/linux/string.h"
char *strcpy(char *, char const *);
# 23 "include/linux/string.h"
char *strncpy(char *, char const *, __kernel_size_t);
# 26 "include/linux/string.h"
size_t strlcpy(char *, char const *, size_t);
# 29 "include/linux/string.h"
char *strcat(char *, char const *);
# 32 "include/linux/string.h"
char *strncat(char *, char const *, __kernel_size_t);
# 35 "include/linux/string.h"
size_t strlcat(char *, char const *, __kernel_size_t);
# 38 "include/linux/string.h"
int strcmp(char const *, char const *);
# 41 "include/linux/string.h"
int strncmp(char const *, char const *, __kernel_size_t);
# 44 "include/linux/string.h"
int strnicmp(char const *, char const *, __kernel_size_t);
# 47 "include/linux/string.h"
int strcasecmp(char const *, char const *);
# 50 "include/linux/string.h"
int strncasecmp(char const *, char const *, size_t);
# 53 "include/linux/string.h"
char *strchr(char const *, int);
# 56 "include/linux/string.h"
char *strchrnul(char const *, int);
# 59 "include/linux/string.h"
char *strnchr(char const *, size_t, int);
# 62 "include/linux/string.h"
char *strrchr(char const *, int);
# 64 "include/linux/string.h"
char *skip_spaces(char const *);
# 66 "include/linux/string.h"
char *strim(char *);
# 68 "include/linux/string.h"
static inline char *strstrip(char *str)
{
  return strim ( str );
}
# 74 "include/linux/string.h"
char *strstr(char const *, char const *);
# 77 "include/linux/string.h"
char *strnstr(char const *, char const *, size_t);
# 80 "include/linux/string.h"
size_t strlen(char const *);
# 83 "include/linux/string.h"
__kernel_size_t strnlen(char const *, __kernel_size_t);
# 86 "include/linux/string.h"
char *strpbrk(char const *, char const *);
# 89 "include/linux/string.h"
char *strsep(char **, char const *);
# 92 "include/linux/string.h"
__kernel_size_t strspn(char const *, char const *);
# 95 "include/linux/string.h"
__kernel_size_t strcspn(char const *, char const *);
# 108 "include/linux/string.h"
void *memscan(void *, int, __kernel_size_t);
# 111 "include/linux/string.h"
int memcmp(void const *, void const *, size_t);
# 114 "include/linux/string.h"
void *memchr(void const *, int, __kernel_size_t);
# 116 "include/linux/string.h"
void *memchr_inv(void const *, int, size_t);
# 118 "include/linux/string.h"
char *kstrdup(char const *, gfp_t);
char *kstrndup(char const *, size_t, gfp_t);
void *kmemdup(void const *, size_t, gfp_t);
# 122 "include/linux/string.h"
char **argv_split(gfp_t, char const *, int *);
void argv_free(char **);
# 125 "include/linux/string.h"
bool sysfs_streq(char const *, char const *);
int strtobool(char const *, bool *);
# 129 "include/linux/string.h"
int vbin_printf(u32 *, size_t, char const *, __va_list_tag *);
int bstr_printf(char *, size_t, char const *, u32 const *);
int bprintf(u32 *, size_t, char const *, ...);
# 134 "include/linux/string.h"
ssize_t memory_read_from_buffer(void *, size_t, loff_t *, void const *, size_t);
# 142 "include/linux/string.h"
static inline bool strstarts(char const *str, char const *prefix)
{
  return strncmp ( str , prefix , strlen ( prefix ) ) == 0;
}
# 147 "include/linux/string.h"
size_t memweight(void const *, size_t);
# 154 "include/linux/string.h"
static inline char const *kbasename(char const *path)
{
  char const *tail = ( char const *) strrchr ( path , 47 );
  return tail != ( ( char const *) 0 ) ? tail + 1UL : path;
}
# 91 "include/linux/bitmap.h"
int __bitmap_empty(long unsigned int const *, unsigned int);
int __bitmap_full(long unsigned int const *, unsigned int);
int __bitmap_equal(long unsigned int const *, long unsigned int const *, unsigned int);
# 95 "include/linux/bitmap.h"
void __bitmap_complement(long unsigned int *, long unsigned int const *, unsigned int);
# 97 "include/linux/bitmap.h"
void __bitmap_shift_right(long unsigned int *, long unsigned int const *, int, int);
# 99 "include/linux/bitmap.h"
void __bitmap_shift_left(long unsigned int *, long unsigned int const *, int, int);
# 101 "include/linux/bitmap.h"
int __bitmap_and(long unsigned int *, long unsigned int const *, long unsigned int const *, unsigned int);
# 103 "include/linux/bitmap.h"
void __bitmap_or(long unsigned int *, long unsigned int const *, long unsigned int const *, unsigned int);
# 105 "include/linux/bitmap.h"
void __bitmap_xor(long unsigned int *, long unsigned int const *, long unsigned int const *, unsigned int);
# 107 "include/linux/bitmap.h"
int __bitmap_andnot(long unsigned int *, long unsigned int const *, long unsigned int const *, unsigned int);
# 109 "include/linux/bitmap.h"
int __bitmap_intersects(long unsigned int const *, long unsigned int const *, unsigned int);
# 111 "include/linux/bitmap.h"
int __bitmap_subset(long unsigned int const *, long unsigned int const *, unsigned int);
# 113 "include/linux/bitmap.h"
int __bitmap_weight(long unsigned int const *, unsigned int);
# 115 "include/linux/bitmap.h"
void bitmap_set(long unsigned int *, unsigned int, int);
void bitmap_clear(long unsigned int *, unsigned int, int);
long unsigned int bitmap_find_next_zero_area(long unsigned int *, long unsigned int, long unsigned int, unsigned int, long unsigned int);
# 123 "include/linux/bitmap.h"
int bitmap_scnprintf(char *, unsigned int, long unsigned int const *, int);
# 125 "include/linux/bitmap.h"
int __bitmap_parse(char const *, unsigned int, int, long unsigned int *, int);
# 127 "include/linux/bitmap.h"
int bitmap_parse_user(char const *, unsigned int, long unsigned int *, int);
# 129 "include/linux/bitmap.h"
int bitmap_scnlistprintf(char *, unsigned int, long unsigned int const *, int);
# 131 "include/linux/bitmap.h"
int bitmap_parselist(char const *, long unsigned int *, int);
# 133 "include/linux/bitmap.h"
int bitmap_parselist_user(char const *, unsigned int, long unsigned int *, int);
# 135 "include/linux/bitmap.h"
void bitmap_remap(long unsigned int *, long unsigned int const *, long unsigned int const *, long unsigned int const *, int);
# 137 "include/linux/bitmap.h"
int bitmap_bitremap(int, long unsigned int const *, long unsigned int const *, int);
# 139 "include/linux/bitmap.h"
void bitmap_onto(long unsigned int *, long unsigned int const *, long unsigned int const *, int);
# 141 "include/linux/bitmap.h"
void bitmap_fold(long unsigned int *, long unsigned int const *, int, int);
# 143 "include/linux/bitmap.h"
int bitmap_find_free_region(long unsigned int *, unsigned int, int);
void bitmap_release_region(long unsigned int *, unsigned int, int);
int bitmap_allocate_region(long unsigned int *, unsigned int, int);
void bitmap_copy_le(void *, long unsigned int const *, int);
int bitmap_ord_to_pos(long unsigned int const *, int, int);
# 159 "include/linux/bitmap.h"
static inline void bitmap_zero(long unsigned int *dst, int nbits)
{
  if (0)
  {
# 162 "include/linux/bitmap.h"
    * dst = 0UL;
  }
  else
  {
# 164 "include/linux/bitmap.h"
    int len = ( int ) ( ( unsigned int ) ( ( ( long unsigned int ) nbits + 63UL ) / 64UL ) * 8U );
    memset ( ( void *) dst , 0 , ( size_t ) len );
  }
}
# 169 "include/linux/bitmap.h"
static inline void bitmap_fill(long unsigned int *dst, int nbits)
{
  size_t nlongs = ( ( long unsigned int ) nbits + 63UL ) / 64UL;
  if (1)
  {
# 173 "include/linux/bitmap.h"
    int len = ( int ) ( ( ( unsigned int ) nlongs + 536870911U ) * 8U );
    memset ( ( void *) dst , 255 , ( size_t ) len );
  }
  * ( dst + ( ( long unsigned int ) nlongs + 18446744073709551615U ) ) = ( ( unsigned int ) nbits & 63U ) != 0U ? ( 1UL << nbits % 64 ) - 1UL : 18446744073709551615UL;
}
# 179 "include/linux/bitmap.h"
static inline void bitmap_copy(long unsigned int *dst, long unsigned int const *src, int nbits)
{
# 182 "include/linux/bitmap.h"
  if (0)
  {
# 183 "include/linux/bitmap.h"
    * dst = * src;
  }
  else
  {
# 185 "include/linux/bitmap.h"
    int len = ( int ) ( ( unsigned int ) ( ( ( long unsigned int ) nbits + 63UL ) / 64UL ) * 8U );
    ({
# 186 "include/linux/bitmap.h"
      size_t __len = ( size_t ) len;
# 186 "include/linux/bitmap.h"
      void *__ret;
      {
# 186 "include/linux/bitmap.h"
        if (0)
        {
# 186 "include/linux/bitmap.h"
          __ret = __memcpy ( ( void *) dst , ( void const *) src , __len );
        }
        else
# 186 "include/linux/bitmap.h"
          __ret = __builtin_memcpy ( ( void *) dst , ( void const *) src , __len );
      }
# 186 "include/linux/bitmap.h"
      __ret;
    } );
  }
}
static inline int bitmap_and(long unsigned int *dst, long unsigned int const *src1, long unsigned int const *src2, unsigned int nbits)
{
# 193 "include/linux/bitmap.h"
  if (0)
    return ( * dst = ( long unsigned int ) * src1 & ( long unsigned int ) * src2 & ( ( nbits & 63U ) != 0U ? ( 1UL << ( ( int ) nbits & 63 ) ) - 1UL : 18446744073709551615UL ) ) != 0UL;
  return __bitmap_and ( dst , src1 , src2 , nbits );
}
# 198 "include/linux/bitmap.h"
static inline void bitmap_or(long unsigned int *dst, long unsigned int const *src1, long unsigned int const *src2, unsigned int nbits)
{
# 201 "include/linux/bitmap.h"
  if (0)
  {
# 202 "include/linux/bitmap.h"
    * dst = ( long unsigned int ) * src1 | ( long unsigned int ) * src2;
  }
  else
# 204 "include/linux/bitmap.h"
    __bitmap_or ( dst , src1 , src2 , nbits );
}
# 207 "include/linux/bitmap.h"
static inline void bitmap_xor(long unsigned int *dst, long unsigned int const *src1, long unsigned int const *src2, unsigned int nbits)
{
# 210 "include/linux/bitmap.h"
  if (0)
  {
# 211 "include/linux/bitmap.h"
    * dst = ( long unsigned int ) * src1 ^ ( long unsigned int ) * src2;
  }
  else
# 213 "include/linux/bitmap.h"
    __bitmap_xor ( dst , src1 , src2 , nbits );
}
# 216 "include/linux/bitmap.h"
static inline int bitmap_andnot(long unsigned int *dst, long unsigned int const *src1, long unsigned int const *src2, unsigned int nbits)
{
# 219 "include/linux/bitmap.h"
  if (0)
    return ( * dst = ( long unsigned int ) * src1 & ( long unsigned int ) ~ * src2 & ( ( nbits & 63U ) != 0U ? ( 1UL << ( ( int ) nbits & 63 ) ) - 1UL : 18446744073709551615UL ) ) != 0UL;
  return __bitmap_andnot ( dst , src1 , src2 , nbits );
}
# 224 "include/linux/bitmap.h"
static inline void bitmap_complement(long unsigned int *dst, long unsigned int const *src, unsigned int nbits)
{
# 227 "include/linux/bitmap.h"
  if (0)
  {
# 228 "include/linux/bitmap.h"
    * dst = ~ * src;
  }
  else
# 230 "include/linux/bitmap.h"
    __bitmap_complement ( dst , src , nbits );
}
# 233 "include/linux/bitmap.h"
static inline int bitmap_equal(long unsigned int const *src1, long unsigned int const *src2, unsigned int nbits)
{
# 236 "include/linux/bitmap.h"
  if (0)
  {
# 237 "include/linux/bitmap.h"
    return ( ( ( long unsigned int ) * src1 ^ ( long unsigned int ) * src2 ) & ( ( nbits & 63U ) != 0U ? ( 1UL << ( ( int ) nbits & 63 ) ) - 1UL : 18446744073709551615UL ) ) == 0UL;
  }
  else
# 239 "include/linux/bitmap.h"
    return __bitmap_equal ( src1 , src2 , nbits );
}
# 242 "include/linux/bitmap.h"
static inline int bitmap_intersects(long unsigned int const *src1, long unsigned int const *src2, unsigned int nbits)
{
# 245 "include/linux/bitmap.h"
  if (0)
  {
# 246 "include/linux/bitmap.h"
    return ( ( long unsigned int ) * src1 & ( long unsigned int ) * src2 & ( ( nbits & 63U ) != 0U ? ( 1UL << ( ( int ) nbits & 63 ) ) - 1UL : 18446744073709551615UL ) ) != 0UL;
  }
  else
# 248 "include/linux/bitmap.h"
    return __bitmap_intersects ( src1 , src2 , nbits );
}
# 251 "include/linux/bitmap.h"
static inline int bitmap_subset(long unsigned int const *src1, long unsigned int const *src2, unsigned int nbits)
{
# 254 "include/linux/bitmap.h"
  if (0)
  {
# 255 "include/linux/bitmap.h"
    return ( ( long unsigned int ) * src1 & ( long unsigned int ) ~ * src2 & ( ( nbits & 63U ) != 0U ? ( 1UL << ( ( int ) nbits & 63 ) ) - 1UL : 18446744073709551615UL ) ) == 0UL;
  }
  else
# 257 "include/linux/bitmap.h"
    return __bitmap_subset ( src1 , src2 , nbits );
}
# 260 "include/linux/bitmap.h"
static inline int bitmap_empty(long unsigned int const *src, unsigned int nbits)
{
  if (0)
  {
# 263 "include/linux/bitmap.h"
    return ( ( long unsigned int ) * src & ( ( nbits & 63U ) != 0U ? ( 1UL << ( ( int ) nbits & 63 ) ) - 1UL : 18446744073709551615UL ) ) == 0UL;
  }
  else
# 265 "include/linux/bitmap.h"
    return __bitmap_empty ( src , nbits );
}
# 268 "include/linux/bitmap.h"
static inline int bitmap_full(long unsigned int const *src, unsigned int nbits)
{
  if (0)
  {
# 271 "include/linux/bitmap.h"
    return ( ( long unsigned int ) ~ * src & ( ( nbits & 63U ) != 0U ? ( 1UL << ( ( int ) nbits & 63 ) ) - 1UL : 18446744073709551615UL ) ) == 0UL;
  }
  else
# 273 "include/linux/bitmap.h"
    return __bitmap_full ( src , nbits );
}
# 276 "include/linux/bitmap.h"
static inline int bitmap_weight(long unsigned int const *src, unsigned int nbits)
{
  if (0)
    return ( int ) hweight_long ( ( long unsigned int ) * src & ( ( nbits & 63U ) != 0U ? ( 1UL << ( ( int ) nbits & 63 ) ) - 1UL : 18446744073709551615UL ) );
  return __bitmap_weight ( src , nbits );
}
# 283 "include/linux/bitmap.h"
static inline void bitmap_shift_right(long unsigned int *dst, long unsigned int const *src, int n, int nbits)
{
# 286 "include/linux/bitmap.h"
  if (0)
  {
# 287 "include/linux/bitmap.h"
    * dst = ( ( long unsigned int ) * src & ( ( ( unsigned int ) nbits & 63U ) != 0U ? ( 1UL << nbits % 64 ) - 1UL : 18446744073709551615UL ) ) >> n;
  }
  else
# 289 "include/linux/bitmap.h"
    __bitmap_shift_right ( dst , src , n , nbits );
}
# 292 "include/linux/bitmap.h"
static inline void bitmap_shift_left(long unsigned int *dst, long unsigned int const *src, int n, int nbits)
{
# 295 "include/linux/bitmap.h"
  if (0)
  {
# 296 "include/linux/bitmap.h"
    * dst = ( long unsigned int ) ( * src << n ) & ( ( ( unsigned int ) nbits & 63U ) != 0U ? ( 1UL << nbits % 64 ) - 1UL : 18446744073709551615UL );
  }
  else
# 298 "include/linux/bitmap.h"
    __bitmap_shift_left ( dst , src , n , nbits );
}
# 301 "include/linux/bitmap.h"
static inline int bitmap_parse(char const *buf, unsigned int buflen, long unsigned int *maskp, int nmaskbits)
{
# 304 "include/linux/bitmap.h"
  return __bitmap_parse ( buf , buflen , 0 , maskp , nmaskbits );
}
struct bug_entry
{
# 22 "include/asm-generic/bug.h"
  int bug_addr_disp;
# 28 "include/asm-generic/bug.h"
  int file_disp;
# 30 "include/asm-generic/bug.h"
  short unsigned int line;
# 32 "include/asm-generic/bug.h"
  short unsigned int flags;
};
# 66 "include/asm-generic/bug.h"
void warn_slowpath_fmt(char const *, int const, char const *, ...);
# 69 "include/asm-generic/bug.h"
void warn_slowpath_fmt_taint(char const *, int const, unsigned int, char const *, ...);
# 71 "include/asm-generic/bug.h"
void warn_slowpath_null(char const *, int const);
enum bug_trap_type
{
  BUG_TRAP_TYPE_NONE = 0,
  BUG_TRAP_TYPE_WARN = 1,
  BUG_TRAP_TYPE_BUG = 2
};
# 91 "include/linux/bug.h"
static inline int is_warning_bug(struct bug_entry const *bug)
{
  return ( int ) ( * bug ) . flags & 1;
}
# 96 "include/linux/bug.h"
struct bug_entry const *find_bug(long unsigned int);
# 98 "include/linux/bug.h"
enum bug_trap_type report_bug(long unsigned int, struct pt_regs *);
# 101 "include/linux/bug.h"
int is_valid_bugaddr(long unsigned int);
struct cpumask
{
# 14 "include/linux/cpumask.h"
  long unsigned int bits[128U];
};
# 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
# 28 "include/linux/cpumask.h"
extern int nr_cpu_ids;
# 79 "include/linux/cpumask.h"
extern struct cpumask const *const cpu_possible_mask;
extern struct cpumask const *const cpu_online_mask;
extern struct cpumask const *const cpu_present_mask;
extern struct cpumask const *const cpu_active_mask;
# 105 "include/linux/cpumask.h"
static inline unsigned int cpumask_check(unsigned int cpu)
{
# 108 "include/linux/cpumask.h"
  ({
# 108 "include/linux/cpumask.h"
    bool __warned;
# 108 "include/linux/cpumask.h"
    int __ret_warn_once = ( unsigned int ) nr_cpu_ids <= cpu;
    {
# 108 "include/linux/cpumask.h"
      if (__builtin_expect ( __ret_warn_once != 0 , 0L ) != 0L)
# 108 "include/linux/cpumask.h"
        if (({
# 108 "include/linux/cpumask.h"
          int __ret_warn_on = ( int ) ! ( _Bool ) __warned;
          {
# 108 "include/linux/cpumask.h"
            if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 108 "include/linux/cpumask.h"
              warn_slowpath_null ( ( char const *) "include/linux/cpumask.h" , 108 );
          }
# 108 "include/linux/cpumask.h"
          __builtin_expect ( __ret_warn_on != 0 , 0L );
        } )
# 108 "include/linux/cpumask.h"
        != 0L)
# 108 "include/linux/cpumask.h"
          __warned = 1;
    }
# 108 "include/linux/cpumask.h"
    __builtin_expect ( __ret_warn_once != 0 , 0L );
  } );
  return cpu;
}
# 165 "include/linux/cpumask.h"
static inline unsigned int cpumask_first(struct cpumask const *srcp)
{
  return ( unsigned int ) find_first_bit ( ( long unsigned int const *) & ( * srcp ) . bits , ( long unsigned int ) nr_cpu_ids );
}
# 177 "include/linux/cpumask.h"
static inline unsigned int cpumask_next(int n, struct cpumask const *srcp)
{
# 180 "include/linux/cpumask.h"
  if (n != -1)
    cpumask_check ( ( unsigned int ) n );
  return ( unsigned int ) find_next_bit ( ( long unsigned int const *) & ( * srcp ) . bits , ( long unsigned int ) nr_cpu_ids , ( long unsigned int ) ( n + 1 ) );
}
# 192 "include/linux/cpumask.h"
static inline unsigned int cpumask_next_zero(int n, struct cpumask const *srcp)
{
# 195 "include/linux/cpumask.h"
  if (n != -1)
    cpumask_check ( ( unsigned int ) n );
  return ( unsigned int ) find_next_zero_bit ( ( long unsigned int const *) & ( * srcp ) . bits , ( long unsigned int ) nr_cpu_ids , ( long unsigned int ) ( n + 1 ) );
}
# 200 "include/linux/cpumask.h"
int cpumask_next_and(int, struct cpumask const *, struct cpumask const *);
int cpumask_any_but(struct cpumask const *, unsigned int);
int cpumask_set_cpu_local_first(int, int, cpumask_t *);
# 263 "include/linux/cpumask.h"
static inline void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
{
  set_bit ( ( long int ) cpumask_check ( cpu ) , ( long unsigned int volatile *) & ( * dstp ) . bits );
}
# 273 "include/linux/cpumask.h"
static inline void cpumask_clear_cpu(int cpu, struct cpumask *dstp)
{
  clear_bit ( ( long int ) cpumask_check ( ( unsigned int ) cpu ) , ( long unsigned int volatile *) & ( * dstp ) . bits );
}
# 299 "include/linux/cpumask.h"
static inline int cpumask_test_and_set_cpu(int cpu, struct cpumask *cpumask)
{
  return test_and_set_bit ( ( long int ) cpumask_check ( ( unsigned int ) cpu ) , ( long unsigned int volatile *) & ( * cpumask ) . bits );
}
# 313 "include/linux/cpumask.h"
static inline int cpumask_test_and_clear_cpu(int cpu, struct cpumask *cpumask)
{
  return test_and_clear_bit ( ( long int ) cpumask_check ( ( unsigned int ) cpu ) , ( long unsigned int volatile *) & ( * cpumask ) . bits );
}
# 322 "include/linux/cpumask.h"
static inline void cpumask_setall(struct cpumask *dstp)
{
  bitmap_fill ( ( long unsigned int *) & ( * dstp ) . bits , nr_cpu_ids );
}
# 331 "include/linux/cpumask.h"
static inline void cpumask_clear(struct cpumask *dstp)
{
  bitmap_zero ( ( long unsigned int *) & ( * dstp ) . bits , nr_cpu_ids );
}
# 344 "include/linux/cpumask.h"
static inline int cpumask_and(struct cpumask *dstp, struct cpumask const *src1p, struct cpumask const *src2p)
{
# 348 "include/linux/cpumask.h"
  return bitmap_and ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * src1p ) . bits ,
# 349 "include/linux/cpumask.h"
  ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nr_cpu_ids );
}
# 358 "include/linux/cpumask.h"
static inline void cpumask_or(struct cpumask *dstp, struct cpumask const *src1p, struct cpumask const *src2p)
{
# 361 "include/linux/cpumask.h"
  bitmap_or ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * src1p ) . bits ,
# 362 "include/linux/cpumask.h"
  ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nr_cpu_ids );
}
# 371 "include/linux/cpumask.h"
static inline void cpumask_xor(struct cpumask *dstp, struct cpumask const *src1p, struct cpumask const *src2p)
{
# 375 "include/linux/cpumask.h"
  bitmap_xor ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * src1p ) . bits ,
# 376 "include/linux/cpumask.h"
  ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nr_cpu_ids );
}
# 387 "include/linux/cpumask.h"
static inline int cpumask_andnot(struct cpumask *dstp, struct cpumask const *src1p, struct cpumask const *src2p)
{
# 391 "include/linux/cpumask.h"
  return bitmap_andnot ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * src1p ) . bits ,
# 392 "include/linux/cpumask.h"
  ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nr_cpu_ids );
}
# 400 "include/linux/cpumask.h"
static inline void cpumask_complement(struct cpumask *dstp, struct cpumask const *srcp)
{
# 403 "include/linux/cpumask.h"
  bitmap_complement ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * srcp ) . bits , ( unsigned int ) nr_cpu_ids );
}
# 412 "include/linux/cpumask.h"
static inline bool cpumask_equal(struct cpumask const *src1p, struct cpumask const *src2p)
{
# 415 "include/linux/cpumask.h"
  return bitmap_equal ( ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nr_cpu_ids )
# 416 "include/linux/cpumask.h"
  != 0;
}
# 424 "include/linux/cpumask.h"
static inline bool cpumask_intersects(struct cpumask const *src1p, struct cpumask const *src2p)
{
# 427 "include/linux/cpumask.h"
  return bitmap_intersects ( ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nr_cpu_ids )
# 428 "include/linux/cpumask.h"
  != 0;
}
# 438 "include/linux/cpumask.h"
static inline int cpumask_subset(struct cpumask const *src1p, struct cpumask const *src2p)
{
# 441 "include/linux/cpumask.h"
  return bitmap_subset ( ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nr_cpu_ids );
}
# 449 "include/linux/cpumask.h"
static inline bool cpumask_empty(struct cpumask const *srcp)
{
  return bitmap_empty ( ( long unsigned int const *) & ( * srcp ) . bits , ( unsigned int ) nr_cpu_ids ) != 0;
}
# 458 "include/linux/cpumask.h"
static inline bool cpumask_full(struct cpumask const *srcp)
{
  return bitmap_full ( ( long unsigned int const *) & ( * srcp ) . bits , ( unsigned int ) nr_cpu_ids ) != 0;
}
# 467 "include/linux/cpumask.h"
static inline unsigned int cpumask_weight(struct cpumask const *srcp)
{
  return ( unsigned int ) bitmap_weight ( ( long unsigned int const *) & ( * srcp ) . bits , ( unsigned int ) nr_cpu_ids );
}
# 478 "include/linux/cpumask.h"
static inline void cpumask_shift_right(struct cpumask *dstp, struct cpumask const *srcp, int n)
{
# 481 "include/linux/cpumask.h"
  bitmap_shift_right ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * srcp ) . bits , n , nr_cpu_ids );
}
# 491 "include/linux/cpumask.h"
static inline void cpumask_shift_left(struct cpumask *dstp, struct cpumask const *srcp, int n)
{
# 494 "include/linux/cpumask.h"
  bitmap_shift_left ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * srcp ) . bits , n , nr_cpu_ids );
}
# 503 "include/linux/cpumask.h"
static inline void cpumask_copy(struct cpumask *dstp, struct cpumask const *srcp)
{
# 506 "include/linux/cpumask.h"
  bitmap_copy ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * srcp ) . bits , nr_cpu_ids );
}
# 550 "include/linux/cpumask.h"
static inline int cpumask_scnprintf(char *buf, int len, struct cpumask const *srcp)
{
# 553 "include/linux/cpumask.h"
  return bitmap_scnprintf ( buf , ( unsigned int ) len , ( long unsigned int const *) & ( * srcp ) . bits , nr_cpu_ids );
}
# 564 "include/linux/cpumask.h"
static inline int cpumask_parse_user(char const *buf, int len, struct cpumask *dstp)
{
# 567 "include/linux/cpumask.h"
  return bitmap_parse_user ( buf , ( unsigned int ) len , ( long unsigned int *) & ( * dstp ) . bits , nr_cpu_ids );
}
# 578 "include/linux/cpumask.h"
static inline int cpumask_parselist_user(char const *buf, int len, struct cpumask *dstp)
{
# 581 "include/linux/cpumask.h"
  return bitmap_parselist_user ( buf , ( unsigned int ) len , ( long unsigned int *) & ( * dstp ) . bits , nr_cpu_ids );
}
# 594 "include/linux/cpumask.h"
static inline int cpulist_scnprintf(char *buf, int len, struct cpumask const *srcp)
{
# 597 "include/linux/cpumask.h"
  return bitmap_scnlistprintf ( buf , ( unsigned int ) len , ( long unsigned int const *) & ( * srcp ) . bits , nr_cpu_ids );
}
# 608 "include/linux/cpumask.h"
static inline int cpumask_parse(char const *buf, struct cpumask *dstp)
{
  char *nl = strchr ( buf , 10 );
  unsigned int len = nl != ( ( char *) 0 ) ? ( unsigned int ) ( long int ) nl - ( unsigned int ) ( long int ) buf : ( unsigned int ) strlen ( buf );
# 613 "include/linux/cpumask.h"
  return bitmap_parse ( buf , len , ( long unsigned int *) & ( * dstp ) . bits , nr_cpu_ids );
}
# 623 "include/linux/cpumask.h"
static inline int cpulist_parse(char const *buf, struct cpumask *dstp)
{
  return bitmap_parselist ( buf , ( long unsigned int *) & ( * dstp ) . bits , nr_cpu_ids );
}
# 633 "include/linux/cpumask.h"
static inline size_t cpumask_size(void)
{
# 637 "include/linux/cpumask.h"
  return 1024UL;
}
# 671 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
# 673 "include/linux/cpumask.h"
bool alloc_cpumask_var_node(cpumask_var_t **, gfp_t, int);
bool alloc_cpumask_var(cpumask_var_t **, gfp_t);
bool zalloc_cpumask_var_node(cpumask_var_t **, gfp_t, int);
bool zalloc_cpumask_var(cpumask_var_t **, gfp_t);
void alloc_bootmem_cpumask_var(cpumask_var_t **);
void free_cpumask_var(cpumask_var_t);
void free_bootmem_cpumask_var(cpumask_var_t);
# 723 "include/linux/cpumask.h"
extern long unsigned int const cpu_all_bits[128U];
# 734 "include/linux/cpumask.h"
void set_cpu_possible(unsigned int, bool);
void set_cpu_present(unsigned int, bool);
void set_cpu_online(unsigned int, bool);
void set_cpu_active(unsigned int, bool);
void init_cpu_present(struct cpumask const *);
void init_cpu_possible(struct cpumask const *);
void init_cpu_online(struct cpumask const *);
# 756 "include/linux/cpumask.h"
static inline int __check_is_bitmap(long unsigned int const *bitmap)
{
  return 1;
}
# 769 "include/linux/cpumask.h"
extern long unsigned int const cpu_bit_bitmap[65U][128U];
# 771 "include/linux/cpumask.h"
static inline struct cpumask const *get_cpu_mask(unsigned int cpu)
{
  long unsigned int const *p = ( long unsigned int const *) & cpu_bit_bitmap + ( long unsigned int ) ( ( cpu & 63U ) + 1U );
  p += - ( long unsigned int ) ( cpu / 64U );
  return ( struct cpumask const *) p;
}
# 839 "include/linux/cpumask.h"
int __first_cpu(cpumask_t const *);
int __next_cpu(int, cpumask_t const *);
# 857 "include/linux/cpumask.h"
int __next_cpu_nr(int, cpumask_t const *);
# 868 "include/linux/cpumask.h"
static inline void __cpu_set(int cpu, cpumask_t volatile *dstp)
{
  set_bit ( ( long int ) cpu , ( long unsigned int volatile *) & ( * dstp ) . bits );
}
# 874 "include/linux/cpumask.h"
static inline void __cpu_clear(int cpu, cpumask_t volatile *dstp)
{
  clear_bit ( ( long int ) cpu , ( long unsigned int volatile *) & ( * dstp ) . bits );
}
# 880 "include/linux/cpumask.h"
static inline void __cpus_setall(cpumask_t *dstp, int nbits)
{
  bitmap_fill ( ( long unsigned int *) & ( * dstp ) . bits , nbits );
}
# 886 "include/linux/cpumask.h"
static inline void __cpus_clear(cpumask_t *dstp, int nbits)
{
  bitmap_zero ( ( long unsigned int *) & ( * dstp ) . bits , nbits );
}
# 895 "include/linux/cpumask.h"
static inline int __cpu_test_and_set(int cpu, cpumask_t *addr)
{
  return test_and_set_bit ( ( long int ) cpu , ( long unsigned int volatile *) & ( * addr ) . bits );
}
# 901 "include/linux/cpumask.h"
static inline int __cpus_and(cpumask_t *dstp, cpumask_t const *src1p, cpumask_t const *src2p, int nbits)
{
# 904 "include/linux/cpumask.h"
  return bitmap_and ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 908 "include/linux/cpumask.h"
static inline void __cpus_or(cpumask_t *dstp, cpumask_t const *src1p, cpumask_t const *src2p, int nbits)
{
# 911 "include/linux/cpumask.h"
  bitmap_or ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 915 "include/linux/cpumask.h"
static inline void __cpus_xor(cpumask_t *dstp, cpumask_t const *src1p, cpumask_t const *src2p, int nbits)
{
# 918 "include/linux/cpumask.h"
  bitmap_xor ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 923 "include/linux/cpumask.h"
static inline int __cpus_andnot(cpumask_t *dstp, cpumask_t const *src1p, cpumask_t const *src2p, int nbits)
{
# 926 "include/linux/cpumask.h"
  return bitmap_andnot ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 930 "include/linux/cpumask.h"
static inline int __cpus_equal(cpumask_t const *src1p, cpumask_t const *src2p, int nbits)
{
# 933 "include/linux/cpumask.h"
  return bitmap_equal ( ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 937 "include/linux/cpumask.h"
static inline int __cpus_intersects(cpumask_t const *src1p, cpumask_t const *src2p, int nbits)
{
# 940 "include/linux/cpumask.h"
  return bitmap_intersects ( ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 944 "include/linux/cpumask.h"
static inline int __cpus_subset(cpumask_t const *src1p, cpumask_t const *src2p, int nbits)
{
# 947 "include/linux/cpumask.h"
  return bitmap_subset ( ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 951 "include/linux/cpumask.h"
static inline int __cpus_empty(cpumask_t const *srcp, int nbits)
{
  return bitmap_empty ( ( long unsigned int const *) & ( * srcp ) . bits , ( unsigned int ) nbits );
}
# 957 "include/linux/cpumask.h"
static inline int __cpus_weight(cpumask_t const *srcp, int nbits)
{
  return bitmap_weight ( ( long unsigned int const *) & ( * srcp ) . bits , ( unsigned int ) nbits );
}
# 964 "include/linux/cpumask.h"
static inline void __cpus_shift_left(cpumask_t *dstp, cpumask_t const *srcp, int n, int nbits)
{
# 967 "include/linux/cpumask.h"
  bitmap_shift_left ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * srcp ) . bits , n , nbits );
}
# 6 "./arch/x86/include/asm/cpumask.h"
extern cpumask_var_t cpu_callin_mask;
extern cpumask_var_t cpu_callout_mask;
extern cpumask_var_t cpu_initialized_mask;
extern cpumask_var_t cpu_sibling_setup_mask;
# 11 "./arch/x86/include/asm/cpumask.h"
void setup_cpu_local_masks(void);
struct msr
{
# 19 "./arch/x86/include/asm/msr.h"
  union
  {
# 17 "./arch/x86/include/asm/msr.h"
    struct
    {
# 15 "./arch/x86/include/asm/msr.h"
      u32 l;
      u32 h;
    } ldv_3734;
    u64 q;
  } ldv_3736;
};
struct msr_info
{
  u32 msr_no;
  struct msr reg;
  struct msr *msrs;
  int err;
};
struct msr_regs_info
{
  u32 *regs;
  int err;
};
# 34 "./arch/x86/include/asm/msr.h"
static inline long long unsigned int native_read_tscp(unsigned int *aux)
{
  long unsigned int low;
# 36 "./arch/x86/include/asm/msr.h"
  long unsigned int high;
  asm volatile ( ".byte 0x0f,0x01,0xf9" : "=a" ( low ) , "=d" ( high ) , "=c" (
# 38 "./arch/x86/include/asm/msr.h"
  * aux ) ) ;
  return ( long long unsigned int ) high << 32 | ( long long unsigned int ) low;
}
# 60 "./arch/x86/include/asm/msr.h"
static inline long long unsigned int native_read_msr(unsigned int msr)
{
  unsigned int low;
# 62 "./arch/x86/include/asm/msr.h"
  unsigned int high;
# 64 "./arch/x86/include/asm/msr.h"
  asm volatile ( "rdmsr" : "=a" ( low ) , "=d" ( high ) : "c" ( msr ) ) ;
  return ( long long unsigned int ) low | ( long long unsigned int ) high << 32;
}
# 68 "./arch/x86/include/asm/msr.h"
static inline long long unsigned int native_read_msr_safe(unsigned int msr, int *err)
{
# 71 "./arch/x86/include/asm/msr.h"
  unsigned int low;
# 71 "./arch/x86/include/asm/msr.h"
  unsigned int high;
# 73 "./arch/x86/include/asm/msr.h"
  asm volatile ( "2: rdmsr ; xor %0,%0\n1:\n\t.section .fixup,\"ax\"\n\t3:  mov %4,%0 ; jmp 1b\n\t.previous\n\t .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (2b) - .\n .long (3b) - .\n .popsection\n" : [ err ] "=r" (
# 79 "./arch/x86/include/asm/msr.h"
  * err ) , "=a" ( low ) , "=d" ( high ) : "c" ( msr ) , [ fault ] "i" ( -5 ) ) ;
# 81 "./arch/x86/include/asm/msr.h"
  return ( long long unsigned int ) low | ( long long unsigned int ) high << 32;
}
# 84 "./arch/x86/include/asm/msr.h"
static inline void native_write_msr(unsigned int msr, unsigned int low, unsigned int high)
{
# 87 "./arch/x86/include/asm/msr.h"
  asm volatile ( "wrmsr" : : "c" ( msr ) , "a" ( low ) , "d" ( high ) : "memory" ) ;
}
# 91 "./arch/x86/include/asm/msr.h"
static inline int native_write_msr_safe(unsigned int msr, unsigned int low, unsigned int high)
{
# 94 "./arch/x86/include/asm/msr.h"
  int err;
  asm volatile ( "2: wrmsr ; xor %0,%0\n1:\n\t.section .fixup,\"ax\"\n\t3:  mov %4,%0 ; jmp 1b\n\t.previous\n\t .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (2b) - .\n .long (3b) - .\n .popsection\n" : [ err ] "=a" ( err ) : "c" ( msr ) , "0" ( low ) , "d" ( high ) , [ fault ] "i" ( -5 ) : "memory" ) ;
# 105 "./arch/x86/include/asm/msr.h"
  return err;
}
# 108 "./arch/x86/include/asm/msr.h"
long long unsigned int native_read_tsc(void);
# 110 "./arch/x86/include/asm/msr.h"
int rdmsr_safe_regs(u32 *);
int wrmsr_safe_regs(u32 *);
# 113 "./arch/x86/include/asm/msr.h"
static inline long long unsigned int __native_read_tsc(void)
{
  unsigned int low;
# 115 "./arch/x86/include/asm/msr.h"
  unsigned int high;
# 117 "./arch/x86/include/asm/msr.h"
  asm volatile ( "rdtsc" : "=a" ( low ) , "=d" ( high ) ) ;
# 119 "./arch/x86/include/asm/msr.h"
  return ( long long unsigned int ) low | ( long long unsigned int ) high << 32;
}
# 122 "./arch/x86/include/asm/msr.h"
static inline long long unsigned int native_read_pmc(int counter)
{
  unsigned int low;
# 124 "./arch/x86/include/asm/msr.h"
  unsigned int high;
# 126 "./arch/x86/include/asm/msr.h"
  asm volatile ( "rdpmc" : "=a" ( low ) , "=d" ( high ) : "c" ( counter ) ) ;
  return ( long long unsigned int ) low | ( long long unsigned int ) high << 32;
}
# 17 "./arch/x86/include/asm/paravirt.h"
static inline int paravirt_enabled(void)
{
  return pv_info . paravirt_enabled;
}
# 22 "./arch/x86/include/asm/paravirt.h"
static inline void load_sp0(struct tss_struct *tss, struct thread_struct *thread)
{
  {
    long unsigned int __edi = __edi;
# 25 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 25 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 25 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 25 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 25 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . load_sp0 == ( ( void (*)(struct tss_struct *, struct thread_struct *)) 0 ) , 0L ) != 0L)
      {
# 25 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 25 ) , "i" ( 12UL ) ) ;
        ldv_3800:;
# 25 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3800;
      }
    }
# 25 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 27UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . load_sp0 ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) tss ) , "S" ( ( long unsigned int ) thread ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 29 "./arch/x86/include/asm/paravirt.h"
static inline void __cpuid(unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx)
{
  {
    long unsigned int __edi = __edi;
# 32 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 32 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 32 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 32 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 32 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . cpuid == ( ( void (*)(unsigned int *, unsigned int *, unsigned int *, unsigned int *)) 0 ) , 0L ) != 0L)
      {
# 32 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 32 ) , "i" ( 12UL ) ) ;
        ldv_3812:;
# 32 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3812;
      }
    }
# 32 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 31UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . cpuid ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) eax ) , "S" ( ( long unsigned int ) ebx ) , "d" ( ( long unsigned int ) ecx ) , "c" ( ( long unsigned int ) edx ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 38 "./arch/x86/include/asm/paravirt.h"
static inline long unsigned int paravirt_get_debugreg(int reg)
{
  return ({
# 40 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ret;
# 40 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 40 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 40 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 40 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 40 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 40 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . get_debugreg == ( ( long unsigned int (*)(int)) 0 ) , 0L ) != 0L)
      {
# 40 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 40 ) , "i" ( 12UL ) ) ;
        ldv_3822:;
# 40 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3822;
      }
    }
    {
# 40 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 40 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 4UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . get_debugreg ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) reg ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 40 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
      }
      else
      {
# 40 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 4UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . get_debugreg ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) reg ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 40 "./arch/x86/include/asm/paravirt.h"
        __ret = __eax;
      }
    }
# 40 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
static inline void set_debugreg(long unsigned int val, int reg)
{
  {
# 45 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 45 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 45 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 45 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 45 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 45 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . set_debugreg == ( ( void (*)(int, long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 45 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 45 ) , "i" ( 12UL ) ) ;
        ldv_3833:;
# 45 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3833;
      }
    }
# 45 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 5UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . set_debugreg ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) reg ) , "S" ( val ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void clts(void)
{
  {
# 50 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 50 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 50 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 50 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 50 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 50 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . clts == ( ( void (*)(void)) 0 ) , 0L ) != 0L)
      {
# 50 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 50 ) , "i" ( 12UL ) ) ;
        ldv_3842:;
# 50 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3842;
      }
    }
# 50 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 6UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . clts ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline long unsigned int read_cr0(void)
{
  return ({
# 55 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ret;
# 55 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 55 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 55 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 55 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 55 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 55 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . read_cr0 == ( ( long unsigned int (*)(void)) 0 ) , 0L ) != 0L)
      {
# 55 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 55 ) , "i" ( 12UL ) ) ;
        ldv_3852:;
# 55 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3852;
      }
    }
    {
# 55 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 55 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 7UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_cr0 ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 55 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
      }
      else
      {
# 55 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 7UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_cr0 ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 55 "./arch/x86/include/asm/paravirt.h"
        __ret = __eax;
      }
    }
# 55 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
static inline void write_cr0(long unsigned int x)
{
  {
# 60 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 60 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 60 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 60 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 60 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 60 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . write_cr0 == ( ( void (*)(long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 60 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 60 ) , "i" ( 12UL ) ) ;
        ldv_3862:;
# 60 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3862;
      }
    }
# 60 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 8UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . write_cr0 ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( x ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline long unsigned int read_cr2(void)
{
  return ({
# 65 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ret;
# 65 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 65 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 65 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 65 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 65 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 65 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . read_cr2 == ( ( long unsigned int (*)(void)) 0 ) , 0L ) != 0L)
      {
# 65 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 65 ) , "i" ( 12UL ) ) ;
        ldv_3872:;
# 65 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3872;
      }
    }
    {
# 65 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 65 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 52UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . read_cr2 ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 65 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
      }
      else
      {
# 65 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 52UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . read_cr2 ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 65 "./arch/x86/include/asm/paravirt.h"
        __ret = __eax;
      }
    }
# 65 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
static inline void write_cr2(long unsigned int x)
{
  {
# 70 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 70 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 70 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 70 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 70 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 70 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . write_cr2 == ( ( void (*)(long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 70 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 70 ) , "i" ( 12UL ) ) ;
        ldv_3882:;
# 70 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3882;
      }
    }
# 70 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 53UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . write_cr2 ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( x ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline long unsigned int read_cr3(void)
{
  return ({
# 75 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ret;
# 75 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 75 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 75 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 75 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 75 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 75 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . read_cr3 == ( ( long unsigned int (*)(void)) 0 ) , 0L ) != 0L)
      {
# 75 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 75 ) , "i" ( 12UL ) ) ;
        ldv_3892:;
# 75 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3892;
      }
    }
    {
# 75 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 75 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 54UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . read_cr3 ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 75 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
      }
      else
      {
# 75 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 54UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . read_cr3 ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 75 "./arch/x86/include/asm/paravirt.h"
        __ret = __eax;
      }
    }
# 75 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
static inline void write_cr3(long unsigned int x)
{
  {
# 80 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 80 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 80 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 80 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 80 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 80 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . write_cr3 == ( ( void (*)(long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 80 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 80 ) , "i" ( 12UL ) ) ;
        ldv_3902:;
# 80 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3902;
      }
    }
# 80 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 55UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . write_cr3 ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( x ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline long unsigned int read_cr4(void)
{
  return ({
# 85 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ret;
# 85 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 85 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 85 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 85 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 85 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 85 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . read_cr4 == ( ( long unsigned int (*)(void)) 0 ) , 0L ) != 0L)
      {
# 85 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 85 ) , "i" ( 12UL ) ) ;
        ldv_3912:;
# 85 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3912;
      }
    }
    {
# 85 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 85 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 10UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_cr4 ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 85 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
      }
      else
      {
# 85 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 10UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_cr4 ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 85 "./arch/x86/include/asm/paravirt.h"
        __ret = __eax;
      }
    }
# 85 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
# 87 "./arch/x86/include/asm/paravirt.h"
static inline long unsigned int read_cr4_safe(void)
{
  return ({
# 89 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ret;
# 89 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 89 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 89 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 89 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 89 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 89 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . read_cr4_safe == ( ( long unsigned int (*)(void)) 0 ) , 0L ) != 0L)
      {
# 89 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 89 ) , "i" ( 12UL ) ) ;
        ldv_3923:;
# 89 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3923;
      }
    }
    {
# 89 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 89 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 9UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_cr4_safe ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 89 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
      }
      else
      {
# 89 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 9UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_cr4_safe ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 89 "./arch/x86/include/asm/paravirt.h"
        __ret = __eax;
      }
    }
# 89 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
static inline void write_cr4(long unsigned int x)
{
  {
# 94 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 94 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 94 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 94 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 94 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 94 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . write_cr4 == ( ( void (*)(long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 94 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 94 ) , "i" ( 12UL ) ) ;
        ldv_3933:;
# 94 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3933;
      }
    }
# 94 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 11UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . write_cr4 ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( x ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 98 "./arch/x86/include/asm/paravirt.h"
static inline long unsigned int read_cr8(void)
{
  return ({
# 100 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ret;
# 100 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 100 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 100 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 100 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 100 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 100 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . read_cr8 == ( ( long unsigned int (*)(void)) 0 ) , 0L ) != 0L)
      {
# 100 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 100 ) , "i" ( 12UL ) ) ;
        ldv_3943:;
# 100 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3943;
      }
    }
    {
# 100 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 100 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 12UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_cr8 ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 100 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
      }
      else
      {
# 100 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 12UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_cr8 ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 100 "./arch/x86/include/asm/paravirt.h"
        __ret = __eax;
      }
    }
# 100 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
static inline void write_cr8(long unsigned int x)
{
  {
# 105 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 105 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 105 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 105 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 105 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 105 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . write_cr8 == ( ( void (*)(long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 105 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 105 ) , "i" ( 12UL ) ) ;
        ldv_3953:;
# 105 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3953;
      }
    }
# 105 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 13UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . write_cr8 ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( x ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 109 "./arch/x86/include/asm/paravirt.h"
static inline void arch_safe_halt(void)
{
  {
# 111 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 111 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 111 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 111 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 111 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 111 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_irq_ops . safe_halt == ( ( void (*)(void)) 0 ) , 0L ) != 0L)
      {
# 111 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 111 ) , "i" ( 12UL ) ) ;
        ldv_3962:;
# 111 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3962;
      }
    }
# 111 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 48UL ) , [ paravirt_opptr ] "i" ( & pv_irq_ops . safe_halt ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void halt(void)
{
  {
# 116 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 116 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 116 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 116 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 116 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 116 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_irq_ops . halt == ( ( void (*)(void)) 0 ) , 0L ) != 0L)
      {
# 116 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 116 ) , "i" ( 12UL ) ) ;
        ldv_3971:;
# 116 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3971;
      }
    }
# 116 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 49UL ) , [ paravirt_opptr ] "i" ( & pv_irq_ops . halt ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void wbinvd(void)
{
  {
# 121 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 121 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 121 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 121 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 121 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 121 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . wbinvd == ( ( void (*)(void)) 0 ) , 0L ) != 0L)
      {
# 121 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 121 ) , "i" ( 12UL ) ) ;
        ldv_3980:;
# 121 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3980;
      }
    }
# 121 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 29UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . wbinvd ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 126 "./arch/x86/include/asm/paravirt.h"
static inline u64 paravirt_read_msr(unsigned int msr, int *err)
{
  return ({
# 128 "./arch/x86/include/asm/paravirt.h"
    u64 __ret;
# 128 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 128 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 128 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 128 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 128 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 128 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . read_msr == ( ( u64 (*)(unsigned int, int *)) 0 ) , 0L ) != 0L)
      {
# 128 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 128 ) , "i" ( 12UL ) ) ;
        ldv_3991:;
# 128 "./arch/x86/include/asm/paravirt.h"
        goto ldv_3991;
      }
    }
    {
# 128 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 128 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 32UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_msr ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) msr ) , "S" ( ( long unsigned int ) err ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 128 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax;
      }
      else
      {
# 128 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 32UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_msr ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) msr ) , "S" ( ( long unsigned int ) err ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 128 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long long unsigned int ) __eax;
      }
    }
# 128 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
static inline int paravirt_write_msr(unsigned int msr, unsigned int low, unsigned int high)
{
  return ({
# 133 "./arch/x86/include/asm/paravirt.h"
    int __ret;
# 133 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 133 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 133 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 133 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 133 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 133 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . write_msr == ( ( int (*)(unsigned int, unsigned int, unsigned int)) 0 ) , 0L ) != 0L)
      {
# 133 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 133 ) , "i" ( 12UL ) ) ;
        ldv_4004:;
# 133 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4004;
      }
    }
    {
# 133 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 133 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 33UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . write_msr ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) msr ) , "S" ( ( long unsigned int ) low ) , "d" ( ( long unsigned int ) high ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 133 "./arch/x86/include/asm/paravirt.h"
        __ret = ( int ) __eax;
      }
      else
      {
# 133 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 33UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . write_msr ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) msr ) , "S" ( ( long unsigned int ) low ) , "d" ( ( long unsigned int ) high ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 133 "./arch/x86/include/asm/paravirt.h"
        __ret = ( int ) __eax;
      }
    }
# 133 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
# 169 "./arch/x86/include/asm/paravirt.h"
static inline int rdmsrl_safe(unsigned int msr, long long unsigned int *p)
{
  int err;
# 173 "./arch/x86/include/asm/paravirt.h"
  * p = paravirt_read_msr ( msr , & err );
  return err;
}
# 177 "./arch/x86/include/asm/paravirt.h"
static inline u64 paravirt_read_tsc(void)
{
  return ({
# 179 "./arch/x86/include/asm/paravirt.h"
    u64 __ret;
# 179 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 179 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 179 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 179 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 179 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 179 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . read_tsc == ( ( u64 (*)(void)) 0 ) , 0L ) != 0L)
      {
# 179 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 179 ) , "i" ( 12UL ) ) ;
        ldv_4020:;
# 179 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4020;
      }
    }
    {
# 179 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 179 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 34UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_tsc ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 179 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax;
      }
      else
      {
# 179 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 34UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_tsc ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 179 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long long unsigned int ) __eax;
      }
    }
# 179 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
# 190 "./arch/x86/include/asm/paravirt.h"
static inline long long unsigned int paravirt_sched_clock(void)
{
  return ({
# 192 "./arch/x86/include/asm/paravirt.h"
    long long unsigned int __ret;
# 192 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 192 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 192 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 192 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 192 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 192 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_time_ops . sched_clock == ( ( long long unsigned int (*)(void)) 0 ) , 0L ) != 0L)
      {
# 192 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 192 ) , "i" ( 12UL ) ) ;
        ldv_4031:;
# 192 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4031;
      }
    }
    {
# 192 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 192 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 1UL ) , [ paravirt_opptr ] "i" ( & pv_time_ops . sched_clock ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 192 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax;
      }
      else
      {
# 192 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 1UL ) , [ paravirt_opptr ] "i" ( & pv_time_ops . sched_clock ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 192 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long long unsigned int ) __eax;
      }
    }
# 192 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
struct static_key;
extern struct static_key paravirt_steal_enabled;
extern struct static_key paravirt_steal_rq_enabled;
# 199 "./arch/x86/include/asm/paravirt.h"
static inline u64 paravirt_steal_clock(int cpu)
{
  return ({
# 201 "./arch/x86/include/asm/paravirt.h"
    u64 __ret;
# 201 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 201 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 201 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 201 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 201 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 201 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_time_ops . steal_clock == ( ( long long unsigned int (*)(int)) 0 ) , 0L ) != 0L)
      {
# 201 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 201 ) , "i" ( 12UL ) ) ;
        ldv_4045:;
# 201 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4045;
      }
    }
    {
# 201 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 201 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 2UL ) , [ paravirt_opptr ] "i" ( & pv_time_ops . steal_clock ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) cpu ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 201 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax;
      }
      else
      {
# 201 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 2UL ) , [ paravirt_opptr ] "i" ( & pv_time_ops . steal_clock ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) cpu ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 201 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long long unsigned int ) __eax;
      }
    }
# 201 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
static inline long long unsigned int paravirt_read_pmc(int counter)
{
  return ( long long unsigned int ) ({
# 206 "./arch/x86/include/asm/paravirt.h"
    u64 __ret;
# 206 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 206 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 206 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 206 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 206 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 206 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . read_pmc == ( ( u64 (*)(int)) 0 ) , 0L ) != 0L)
      {
# 206 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 206 ) , "i" ( 12UL ) ) ;
        ldv_4056:;
# 206 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4056;
      }
    }
    {
# 206 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 206 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 35UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_pmc ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) counter ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 206 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax;
      }
      else
      {
# 206 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 35UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_pmc ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) counter ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 206 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long long unsigned int ) __eax;
      }
    }
# 206 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
# 218 "./arch/x86/include/asm/paravirt.h"
static inline long long unsigned int paravirt_rdtscp(unsigned int *aux)
{
  return ( long long unsigned int ) ({
# 220 "./arch/x86/include/asm/paravirt.h"
    u64 __ret;
# 220 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 220 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 220 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 220 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 220 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 220 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . read_tscp == ( ( long long unsigned int (*)(unsigned int *)) 0 ) , 0L ) != 0L)
      {
# 220 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 220 ) , "i" ( 12UL ) ) ;
        ldv_4067:;
# 220 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4067;
      }
    }
    {
# 220 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 220 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 36UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_tscp ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) aux ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 220 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax;
      }
      else
      {
# 220 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 36UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . read_tscp ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) aux ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 220 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long long unsigned int ) __eax;
      }
    }
# 220 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
# 239 "./arch/x86/include/asm/paravirt.h"
static inline void paravirt_alloc_ldt(struct desc_struct *ldt, unsigned int entries)
{
  {
# 241 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 241 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 241 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 241 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 241 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 241 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . alloc_ldt == ( ( void (*)(struct desc_struct *, unsigned int)) 0 ) , 0L ) != 0L)
      {
# 241 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 241 ) , "i" ( 12UL ) ) ;
        ldv_4078:;
# 241 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4078;
      }
    }
# 241 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 25UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . alloc_ldt ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) ldt ) , "S" ( ( long unsigned int ) entries ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void paravirt_free_ldt(struct desc_struct *ldt, unsigned int entries)
{
  {
# 246 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 246 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 246 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 246 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 246 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 246 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . free_ldt == ( ( void (*)(struct desc_struct *, unsigned int)) 0 ) , 0L ) != 0L)
      {
# 246 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 246 ) , "i" ( 12UL ) ) ;
        ldv_4088:;
# 246 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4088;
      }
    }
# 246 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 26UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . free_ldt ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) ldt ) , "S" ( ( long unsigned int ) entries ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void load_TR_desc(void)
{
  {
# 251 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 251 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 251 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 251 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 251 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 251 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . load_tr_desc == ( ( void (*)(void)) 0 ) , 0L ) != 0L)
      {
# 251 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 251 ) , "i" ( 12UL ) ) ;
        ldv_4097:;
# 251 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4097;
      }
    }
# 251 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 14UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . load_tr_desc ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 253 "./arch/x86/include/asm/paravirt.h"
static inline void load_gdt(struct desc_ptr const *dtr)
{
  {
# 255 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 255 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 255 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 255 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 255 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 255 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . load_gdt == ( ( void (*)(struct desc_ptr const *)) 0 ) , 0L ) != 0L)
      {
# 255 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 255 ) , "i" ( 12UL ) ) ;
        ldv_4106:;
# 255 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4106;
      }
    }
# 255 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 15UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . load_gdt ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) dtr ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 257 "./arch/x86/include/asm/paravirt.h"
static inline void load_idt(struct desc_ptr const *dtr)
{
  {
# 259 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 259 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 259 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 259 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 259 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 259 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . load_idt == ( ( void (*)(struct desc_ptr const *)) 0 ) , 0L ) != 0L)
      {
# 259 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 259 ) , "i" ( 12UL ) ) ;
        ldv_4115:;
# 259 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4115;
      }
    }
# 259 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 16UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . load_idt ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) dtr ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 261 "./arch/x86/include/asm/paravirt.h"
static inline void set_ldt(void const *addr, unsigned int entries)
{
  {
# 263 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 263 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 263 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 263 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 263 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 263 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . set_ldt == ( ( void (*)(void const *, unsigned int)) 0 ) , 0L ) != 0L)
      {
# 263 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 263 ) , "i" ( 12UL ) ) ;
        ldv_4125:;
# 263 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4125;
      }
    }
# 263 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 18UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . set_ldt ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) addr ) , "S" ( ( long unsigned int ) entries ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 265 "./arch/x86/include/asm/paravirt.h"
static inline void store_idt(struct desc_ptr *dtr)
{
  {
# 267 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 267 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 267 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 267 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 267 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 267 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . store_idt == ( ( void (*)(struct desc_ptr *)) 0 ) , 0L ) != 0L)
      {
# 267 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 267 ) , "i" ( 12UL ) ) ;
        ldv_4134:;
# 267 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4134;
      }
    }
# 267 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 17UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . store_idt ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) dtr ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 269 "./arch/x86/include/asm/paravirt.h"
static inline long unsigned int paravirt_store_tr(void)
{
  return ({
# 271 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ret;
# 271 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 271 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 271 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 271 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 271 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 271 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . store_tr == ( ( long unsigned int (*)(void)) 0 ) , 0L ) != 0L)
      {
# 271 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 271 ) , "i" ( 12UL ) ) ;
        ldv_4144:;
# 271 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4144;
      }
    }
    {
# 271 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 271 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 19UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . store_tr ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 271 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
      }
      else
      {
# 271 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 19UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . store_tr ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 271 "./arch/x86/include/asm/paravirt.h"
        __ret = __eax;
      }
    }
# 271 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
static inline void load_TLS(struct thread_struct *t, unsigned int cpu)
{
  {
# 276 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 276 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 276 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 276 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 276 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 276 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . load_tls == ( ( void (*)(struct thread_struct *, unsigned int)) 0 ) , 0L ) != 0L)
      {
# 276 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 276 ) , "i" ( 12UL ) ) ;
        ldv_4155:;
# 276 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4155;
      }
    }
# 276 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 20UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . load_tls ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) t ) , "S" ( ( long unsigned int ) cpu ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 280 "./arch/x86/include/asm/paravirt.h"
static inline void load_gs_index(unsigned int gs)
{
  {
# 282 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 282 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 282 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 282 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 282 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 282 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . load_gs_index == ( ( void (*)(unsigned int)) 0 ) , 0L ) != 0L)
      {
# 282 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 282 ) , "i" ( 12UL ) ) ;
        ldv_4164:;
# 282 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4164;
      }
    }
# 282 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 21UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . load_gs_index ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) gs ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 286 "./arch/x86/include/asm/paravirt.h"
static inline void write_ldt_entry(struct desc_struct *dt, int entry, void const *desc)
{
  {
    long unsigned int __edi = __edi;
# 289 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 289 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 289 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 289 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 289 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . write_ldt_entry == ( ( void (*)(struct desc_struct *, int, void const *)) 0 ) , 0L ) != 0L)
      {
# 289 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 289 ) , "i" ( 12UL ) ) ;
        ldv_4175:;
# 289 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4175;
      }
    }
# 289 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 22UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . write_ldt_entry ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) dt ) , "S" ( ( long unsigned int ) entry ) , "d" ( ( long unsigned int ) desc ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void write_gdt_entry(struct desc_struct *dt, int entry, void *desc, int type)
{
  {
    long unsigned int __edi = __edi;
# 295 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 295 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 295 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 295 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 295 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . write_gdt_entry == ( ( void (*)(struct desc_struct *, int, void const *, int)) 0 ) , 0L ) != 0L)
      {
# 295 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 295 ) , "i" ( 12UL ) ) ;
        ldv_4187:;
# 295 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4187;
      }
    }
# 295 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 23UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . write_gdt_entry ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) dt ) , "S" ( ( long unsigned int ) entry ) , "d" ( ( long unsigned int ) desc ) , "c" ( ( long unsigned int ) type ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void write_idt_entry(gate_desc *dt, int entry, gate_desc const *g)
{
  {
# 300 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 300 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 300 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 300 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 300 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 300 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . write_idt_entry == ( ( void (*)(gate_desc *, int, gate_desc const *)) 0 ) , 0L ) != 0L)
      {
# 300 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 300 ) , "i" ( 12UL ) ) ;
        ldv_4198:;
# 300 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4198;
      }
    }
# 300 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 24UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . write_idt_entry ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) dt ) , "S" ( ( long unsigned int ) entry ) , "d" ( ( long unsigned int ) g ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 302 "./arch/x86/include/asm/paravirt.h"
static inline void set_iopl_mask(unsigned int mask)
{
  {
# 304 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 304 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 304 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 304 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 304 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 304 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . set_iopl_mask == ( ( void (*)(unsigned int)) 0 ) , 0L ) != 0L)
      {
# 304 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 304 ) , "i" ( 12UL ) ) ;
        ldv_4207:;
# 304 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4207;
      }
    }
# 304 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 28UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . set_iopl_mask ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mask ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 308 "./arch/x86/include/asm/paravirt.h"
static inline void slow_down_io(void)
{
  pv_cpu_ops . io_delay ( );
}
# 319 "./arch/x86/include/asm/paravirt.h"
static inline void startup_ipi_hook(int phys_apicid, long unsigned int start_eip, long unsigned int start_esp)
{
  {
    long unsigned int __edi = __edi;
# 322 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 322 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 322 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 322 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 322 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_apic_ops . startup_ipi_hook == ( ( void (*)(int, long unsigned int, long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 322 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 323 "./arch/x86/include/asm/paravirt.h"
        ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 323 ) , "i" ( 12UL ) ) ;
        ldv_4221:;
# 322 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4221;
      }
    }
# 322 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 51UL ) , [ paravirt_opptr ] "i" ( & pv_apic_ops . startup_ipi_hook ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) phys_apicid ) , "S" ( start_eip ) , "d" ( start_esp ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 327 "./arch/x86/include/asm/paravirt.h"
static inline void paravirt_activate_mm(struct mm_struct *prev, struct mm_struct *next)
{
  {
    long unsigned int __edi = __edi;
# 330 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 330 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 330 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 330 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 330 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . activate_mm == ( ( void (*)(struct mm_struct *, struct mm_struct *)) 0 ) , 0L ) != 0L)
      {
# 330 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 330 ) , "i" ( 12UL ) ) ;
        ldv_4231:;
# 330 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4231;
      }
    }
# 330 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 56UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . activate_mm ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) prev ) , "S" ( ( long unsigned int ) next ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void arch_dup_mmap(struct mm_struct *oldmm, struct mm_struct *mm)
{
  {
    long unsigned int __edi = __edi;
# 336 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 336 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 336 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 336 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 336 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . dup_mmap == ( ( void (*)(struct mm_struct *, struct mm_struct *)) 0 ) , 0L ) != 0L)
      {
# 336 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 336 ) , "i" ( 12UL ) ) ;
        ldv_4241:;
# 336 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4241;
      }
    }
# 336 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 57UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . dup_mmap ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) oldmm ) , "S" ( ( long unsigned int ) mm ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void arch_exit_mmap(struct mm_struct *mm)
{
  {
# 341 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 341 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 341 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 341 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 341 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 341 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . exit_mmap == ( ( void (*)(struct mm_struct *)) 0 ) , 0L ) != 0L)
      {
# 341 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 341 ) , "i" ( 12UL ) ) ;
        ldv_4250:;
# 341 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4250;
      }
    }
# 341 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 58UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . exit_mmap ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void __flush_tlb(void)
{
  {
# 346 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 346 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 346 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 346 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 346 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 346 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . flush_tlb_user == ( ( void (*)(void)) 0 ) , 0L ) != 0L)
      {
# 346 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 346 ) , "i" ( 12UL ) ) ;
        ldv_4259:;
# 346 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4259;
      }
    }
# 346 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 59UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . flush_tlb_user ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 348 "./arch/x86/include/asm/paravirt.h"
static inline void __flush_tlb_global(void)
{
  {
# 350 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 350 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 350 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 350 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 350 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 350 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . flush_tlb_kernel == ( ( void (*)(void)) 0 ) , 0L ) != 0L)
      {
# 350 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 350 ) , "i" ( 12UL ) ) ;
        ldv_4268:;
# 350 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4268;
      }
    }
# 350 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 60UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . flush_tlb_kernel ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 352 "./arch/x86/include/asm/paravirt.h"
static inline void __flush_tlb_single(long unsigned int addr)
{
  {
# 354 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 354 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 354 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 354 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 354 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 354 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . flush_tlb_single == ( ( void (*)(long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 354 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 354 ) , "i" ( 12UL ) ) ;
        ldv_4277:;
# 354 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4277;
      }
    }
# 354 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 61UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . flush_tlb_single ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( addr ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void flush_tlb_others(struct cpumask const *cpumask, struct mm_struct *mm, long unsigned int start, long unsigned int end)
{
  {
# 362 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 362 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 362 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 362 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 362 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 362 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . flush_tlb_others == ( ( void (*)(struct cpumask const *, struct mm_struct *, long unsigned int, long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 362 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 362 ) , "i" ( 12UL ) ) ;
        ldv_4289:;
# 362 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4289;
      }
    }
# 362 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 62UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . flush_tlb_others ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) cpumask ) , "S" ( ( long unsigned int ) mm ) , "d" ( start ) , "c" ( end ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline int paravirt_pgd_alloc(struct mm_struct *mm)
{
  return ({
# 367 "./arch/x86/include/asm/paravirt.h"
    int __ret;
# 367 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 367 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 367 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 367 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 367 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 367 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . pgd_alloc == ( ( int (*)(struct mm_struct *)) 0 ) , 0L ) != 0L)
      {
# 367 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 367 ) , "i" ( 12UL ) ) ;
        ldv_4299:;
# 367 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4299;
      }
    }
    {
# 367 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 367 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 63UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pgd_alloc ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 367 "./arch/x86/include/asm/paravirt.h"
        __ret = ( int ) __eax;
      }
      else
      {
# 367 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 63UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pgd_alloc ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 367 "./arch/x86/include/asm/paravirt.h"
        __ret = ( int ) __eax;
      }
    }
# 367 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
static inline void paravirt_pgd_free(struct mm_struct *mm, pgd_t *pgd)
{
  {
# 372 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 372 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 372 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 372 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 372 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 372 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . pgd_free == ( ( void (*)(struct mm_struct *, pgd_t *)) 0 ) , 0L ) != 0L)
      {
# 372 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 372 ) , "i" ( 12UL ) ) ;
        ldv_4310:;
# 372 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4310;
      }
    }
# 372 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 64UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pgd_free ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( ( long unsigned int ) pgd ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void paravirt_alloc_pte(struct mm_struct *mm, long unsigned int pfn)
{
  {
# 377 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 377 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 377 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 377 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 377 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 377 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . alloc_pte == ( ( void (*)(struct mm_struct *, long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 377 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 377 ) , "i" ( 12UL ) ) ;
        ldv_4320:;
# 377 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4320;
      }
    }
# 377 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 65UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . alloc_pte ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( pfn ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 379 "./arch/x86/include/asm/paravirt.h"
static inline void paravirt_release_pte(long unsigned int pfn)
{
  {
# 381 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 381 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 381 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 381 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 381 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 381 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . release_pte == ( ( void (*)(long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 381 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 381 ) , "i" ( 12UL ) ) ;
        ldv_4329:;
# 381 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4329;
      }
    }
# 381 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 68UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . release_pte ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( pfn ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void paravirt_alloc_pmd(struct mm_struct *mm, long unsigned int pfn)
{
  {
# 386 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 386 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 386 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 386 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 386 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 386 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . alloc_pmd == ( ( void (*)(struct mm_struct *, long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 386 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 386 ) , "i" ( 12UL ) ) ;
        ldv_4339:;
# 386 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4339;
      }
    }
# 386 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 66UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . alloc_pmd ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( pfn ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void paravirt_release_pmd(long unsigned int pfn)
{
  {
# 391 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 391 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 391 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 391 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 391 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 391 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . release_pmd == ( ( void (*)(long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 391 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 391 ) , "i" ( 12UL ) ) ;
        ldv_4348:;
# 391 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4348;
      }
    }
# 391 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 69UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . release_pmd ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( pfn ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void paravirt_alloc_pud(struct mm_struct *mm, long unsigned int pfn)
{
  {
# 396 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 396 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 396 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 396 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 396 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 396 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . alloc_pud == ( ( void (*)(struct mm_struct *, long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 396 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 396 ) , "i" ( 12UL ) ) ;
        ldv_4358:;
# 396 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4358;
      }
    }
# 396 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 67UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . alloc_pud ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( pfn ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 398 "./arch/x86/include/asm/paravirt.h"
static inline void paravirt_release_pud(long unsigned int pfn)
{
  {
# 400 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 400 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 400 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 400 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 400 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 400 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . release_pud == ( ( void (*)(long unsigned int)) 0 ) , 0L ) != 0L)
      {
# 400 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 400 ) , "i" ( 12UL ) ) ;
        ldv_4367:;
# 400 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4367;
      }
    }
# 400 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 70UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . release_pud ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( pfn ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void pte_update(struct mm_struct *mm, long unsigned int addr, pte_t *ptep)
{
  {
    long unsigned int __edi = __edi;
# 406 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 406 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 406 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 406 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 406 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . pte_update == ( ( void (*)(struct mm_struct *, long unsigned int, pte_t *)) 0 ) , 0L ) != 0L)
      {
# 406 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 406 ) , "i" ( 12UL ) ) ;
        ldv_4378:;
# 406 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4378;
      }
    }
# 406 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 75UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pte_update ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( addr ) , "d" ( ( long unsigned int ) ptep ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 408 "./arch/x86/include/asm/paravirt.h"
static inline void pmd_update(struct mm_struct *mm, long unsigned int addr, pmd_t *pmdp)
{
  {
    long unsigned int __edi = __edi;
# 411 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 411 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 411 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 411 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 411 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . pmd_update == ( ( void (*)(struct mm_struct *, long unsigned int, pmd_t *)) 0 ) , 0L ) != 0L)
      {
# 411 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 411 ) , "i" ( 12UL ) ) ;
        ldv_4389:;
# 411 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4389;
      }
    }
# 411 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 77UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pmd_update ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( addr ) , "d" ( ( long unsigned int ) pmdp ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void pte_update_defer(struct mm_struct *mm, long unsigned int addr, pte_t *ptep)
{
  {
    long unsigned int __edi = __edi;
# 417 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 417 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 417 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 417 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 417 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . pte_update_defer == ( ( void (*)(struct mm_struct *, long unsigned int, pte_t *)) 0 ) , 0L ) != 0L)
      {
# 417 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 417 ) , "i" ( 12UL ) ) ;
        ldv_4400:;
# 417 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4400;
      }
    }
# 417 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 76UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pte_update_defer ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( addr ) , "d" ( ( long unsigned int ) ptep ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void pmd_update_defer(struct mm_struct *mm, long unsigned int addr, pmd_t *pmdp)
{
  {
    long unsigned int __edi = __edi;
# 423 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 423 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 423 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 423 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 423 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . pmd_update_defer == ( ( void (*)(struct mm_struct *, long unsigned int, pmd_t *)) 0 ) , 0L ) != 0L)
      {
# 423 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 423 ) , "i" ( 12UL ) ) ;
        ldv_4411:;
# 423 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4411;
      }
    }
# 423 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 78UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pmd_update_defer ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( addr ) , "d" ( ( long unsigned int ) pmdp ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline pte_t __pte(pteval_t val)
{
  pteval_t ret;
# 430 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
# 431 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 431 "./arch/x86/include/asm/paravirt.h"
      pteval_t __ret;
# 431 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 431 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 431 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 431 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 431 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 431 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . make_pte . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 431 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 433 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 433 ) , "i" ( 12UL ) ) ;
          ldv_4422:;
# 431 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4422;
        }
      }
      {
# 431 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 431 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 82UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pte . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) val >> 32 ) ) : "memory" , "cc" ) ;
# 431 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 431 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 82UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pte . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) val >> 32 ) ) : "memory" , "cc" ) ;
# 431 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 431 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
  }
  else
    ret = ({
# 435 "./arch/x86/include/asm/paravirt.h"
      pteval_t __ret;
# 435 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 435 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 435 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 435 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 435 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 435 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . make_pte . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 435 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 437 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 437 ) , "i" ( 12UL ) ) ;
          ldv_4430:;
# 435 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4430;
        }
      }
      {
# 435 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 435 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 82UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pte . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) : "memory" , "cc" ) ;
# 435 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 435 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 82UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pte . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) : "memory" , "cc" ) ;
# 435 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 435 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
# 439 "./arch/x86/include/asm/paravirt.h"
  return ( pte_t ) { . pte = ret };
}
# 442 "./arch/x86/include/asm/paravirt.h"
static inline pteval_t pte_val(pte_t pte)
{
  pteval_t ret;
# 446 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
# 447 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 447 "./arch/x86/include/asm/paravirt.h"
      pteval_t __ret;
# 447 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 447 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 447 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 447 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 447 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 447 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . pte_val . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 447 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 448 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 448 ) , "i" ( 12UL ) ) ;
          ldv_4443:;
# 447 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4443;
        }
      }
      {
# 447 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 447 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 81UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pte_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pte . pte ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) pte . pte >> 32 ) ) : "memory" , "cc" ) ;
# 447 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 447 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 81UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pte_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pte . pte ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) pte . pte >> 32 ) ) : "memory" , "cc" ) ;
# 447 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 447 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
  }
  else
# 450 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 450 "./arch/x86/include/asm/paravirt.h"
      pteval_t __ret;
# 450 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 450 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 450 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 450 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 450 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 450 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . pte_val . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 450 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 451 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 451 ) , "i" ( 12UL ) ) ;
          ldv_4451:;
# 450 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4451;
        }
      }
      {
# 450 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 450 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 81UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pte_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pte . pte ) : "memory" , "cc" ) ;
# 450 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 450 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 81UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pte_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pte . pte ) : "memory" , "cc" ) ;
# 450 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 450 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
# 453 "./arch/x86/include/asm/paravirt.h"
  return ret;
}
# 456 "./arch/x86/include/asm/paravirt.h"
static inline pgd_t __pgd(pgdval_t val)
{
  pgdval_t ret;
# 460 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
# 461 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 461 "./arch/x86/include/asm/paravirt.h"
      pgdval_t __ret;
# 461 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 461 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 461 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 461 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 461 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 461 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . make_pgd . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 461 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 462 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 462 ) , "i" ( 12UL ) ) ;
          ldv_4463:;
# 461 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4463;
        }
      }
      {
# 461 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 461 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 84UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pgd . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) val >> 32 ) ) : "memory" , "cc" ) ;
# 461 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 461 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 84UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pgd . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) val >> 32 ) ) : "memory" , "cc" ) ;
# 461 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 461 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
  }
  else
# 464 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 464 "./arch/x86/include/asm/paravirt.h"
      pgdval_t __ret;
# 464 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 464 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 464 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 464 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 464 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 464 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . make_pgd . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 464 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 465 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 465 ) , "i" ( 12UL ) ) ;
          ldv_4471:;
# 464 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4471;
        }
      }
      {
# 464 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 464 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 84UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pgd . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) : "memory" , "cc" ) ;
# 464 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 464 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 84UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pgd . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) : "memory" , "cc" ) ;
# 464 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 464 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
# 467 "./arch/x86/include/asm/paravirt.h"
  return ( pgd_t ) { . pgd = ret };
}
# 470 "./arch/x86/include/asm/paravirt.h"
static inline pgdval_t pgd_val(pgd_t pgd)
{
  pgdval_t ret;
# 474 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
# 475 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 475 "./arch/x86/include/asm/paravirt.h"
      pgdval_t __ret;
# 475 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 475 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 475 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 475 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 475 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 475 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . pgd_val . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 475 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 476 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 476 ) , "i" ( 12UL ) ) ;
          ldv_4484:;
# 475 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4484;
        }
      }
      {
# 475 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 475 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 83UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pgd_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pgd . pgd ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) pgd . pgd >> 32 ) ) : "memory" , "cc" ) ;
# 475 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 475 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 83UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pgd_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pgd . pgd ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) pgd . pgd >> 32 ) ) : "memory" , "cc" ) ;
# 475 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 475 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
  }
  else
# 478 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 478 "./arch/x86/include/asm/paravirt.h"
      pgdval_t __ret;
# 478 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 478 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 478 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 478 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 478 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 478 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . pgd_val . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 478 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 479 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 479 ) , "i" ( 12UL ) ) ;
          ldv_4492:;
# 478 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4492;
        }
      }
      {
# 478 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 478 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 83UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pgd_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pgd . pgd ) : "memory" , "cc" ) ;
# 478 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 478 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 83UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pgd_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pgd . pgd ) : "memory" , "cc" ) ;
# 478 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 478 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
# 481 "./arch/x86/include/asm/paravirt.h"
  return ret;
}
# 485 "./arch/x86/include/asm/paravirt.h"
static inline pte_t ptep_modify_prot_start(struct mm_struct *mm, long unsigned int addr, pte_t *ptep)
{
# 488 "./arch/x86/include/asm/paravirt.h"
  pteval_t ret;
# 490 "./arch/x86/include/asm/paravirt.h"
  ret = ({
# 490 "./arch/x86/include/asm/paravirt.h"
    pteval_t __ret;
# 490 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 490 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 490 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 490 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 490 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 490 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . ptep_modify_prot_start == ( ( pte_t (*)(struct mm_struct *, long unsigned int, pte_t *)) 0 ) , 0L ) != 0L)
      {
# 490 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 491 "./arch/x86/include/asm/paravirt.h"
        ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 491 ) , "i" ( 12UL ) ) ;
        ldv_4506:;
# 490 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4506;
      }
    }
    {
# 490 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 490 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 79UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . ptep_modify_prot_start ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( addr ) , "d" ( ( long unsigned int ) ptep ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 490 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
      }
      else
      {
# 490 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) , "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 79UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . ptep_modify_prot_start ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( addr ) , "d" ( ( long unsigned int ) ptep ) : "memory" , "cc" , "r8" , "r9" , "r10" , "r11" ) ;
# 490 "./arch/x86/include/asm/paravirt.h"
        __ret = __eax;
      }
    }
# 490 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
# 493 "./arch/x86/include/asm/paravirt.h"
  return ( pte_t ) { . pte = ret };
}
# 496 "./arch/x86/include/asm/paravirt.h"
static inline void ptep_modify_prot_commit(struct mm_struct *mm, long unsigned int addr, pte_t *ptep, pte_t pte)
{
# 499 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
    pv_mmu_ops . ptep_modify_prot_commit ( mm , addr , ptep , pte );
  }
  else
  {
# 503 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 503 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 503 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 503 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 503 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 503 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . ptep_modify_prot_commit == ( ( void (*)(struct mm_struct *, long unsigned int, pte_t *, pte_t)) 0 ) , 0L ) != 0L)
      {
# 503 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 504 "./arch/x86/include/asm/paravirt.h"
        ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 504 ) , "i" ( 12UL ) ) ;
        ldv_4520:;
# 503 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4520;
      }
    }
# 503 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 80UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . ptep_modify_prot_commit ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( addr ) , "d" ( ( long unsigned int ) ptep ) , "c" ( pte . pte ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 507 "./arch/x86/include/asm/paravirt.h"
static inline void set_pte(pte_t *ptep, pte_t pte)
{
  if (0)
  {
# 510 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 510 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 510 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 510 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 510 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 510 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . set_pte == ( ( void (*)(pte_t *, pte_t)) 0 ) , 0L ) != 0L)
      {
# 510 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 511 "./arch/x86/include/asm/paravirt.h"
        ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 511 ) , "i" ( 12UL ) ) ;
        ldv_4530:;
# 510 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4530;
      }
    }
# 510 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 71UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . set_pte ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) ptep ) , "S" ( pte . pte ) , "d" ( ( long unsigned int ) ( ( long long unsigned int ) pte . pte >> 32 ) ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
  else
  {
# 513 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 513 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 513 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 513 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 513 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 513 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . set_pte == ( ( void (*)(pte_t *, pte_t)) 0 ) , 0L ) != 0L)
      {
# 513 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 514 "./arch/x86/include/asm/paravirt.h"
        ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 514 ) , "i" ( 12UL ) ) ;
        ldv_4536:;
# 513 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4536;
      }
    }
# 513 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 71UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . set_pte ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) ptep ) , "S" ( pte . pte ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 517 "./arch/x86/include/asm/paravirt.h"
static inline void set_pte_at(struct mm_struct *mm, long unsigned int addr, pte_t *ptep, pte_t pte)
{
# 520 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
    pv_mmu_ops . set_pte_at ( mm , addr , ptep , pte );
  }
  else
  {
# 524 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 524 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 524 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 524 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 524 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 524 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . set_pte_at == ( ( void (*)(struct mm_struct *, long unsigned int, pte_t *, pte_t)) 0 ) , 0L ) != 0L)
      {
# 524 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 524 ) , "i" ( 12UL ) ) ;
        ldv_4548:;
# 524 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4548;
      }
    }
# 524 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 72UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . set_pte_at ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( addr ) , "d" ( ( long unsigned int ) ptep ) , "c" ( pte . pte ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void set_pmd_at(struct mm_struct *mm, long unsigned int addr, pmd_t *pmdp, pmd_t pmd)
{
# 530 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
    pv_mmu_ops . set_pmd_at ( mm , addr , pmdp , pmd );
  }
  else
  {
# 534 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 534 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 534 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 534 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 534 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 534 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . set_pmd_at == ( ( void (*)(struct mm_struct *, long unsigned int, pmd_t *, pmd_t)) 0 ) , 0L ) != 0L)
      {
# 534 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 535 "./arch/x86/include/asm/paravirt.h"
        ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 535 ) , "i" ( 12UL ) ) ;
        ldv_4560:;
# 534 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4560;
      }
    }
# 534 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 74UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . set_pmd_at ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) mm ) , "S" ( addr ) , "d" ( ( long unsigned int ) pmdp ) , "c" ( native_pmd_val ( pmd ) ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 538 "./arch/x86/include/asm/paravirt.h"
static inline void set_pmd(pmd_t *pmdp, pmd_t pmd)
{
  pmdval_t val = native_pmd_val ( pmd );
# 542 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
# 543 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 543 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 543 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 543 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 543 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 543 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . set_pmd == ( ( void (*)(pmd_t *, pmd_t)) 0 ) , 0L ) != 0L)
      {
# 543 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 543 ) , "i" ( 12UL ) ) ;
        ldv_4571:;
# 543 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4571;
      }
    }
# 543 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 73UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . set_pmd ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) pmdp ) , "S" ( val ) , "d" ( ( long unsigned int ) ( ( long long unsigned int ) val >> 32 ) ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
  else
  {
# 545 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 545 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 545 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 545 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 545 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 545 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . set_pmd == ( ( void (*)(pmd_t *, pmd_t)) 0 ) , 0L ) != 0L)
      {
# 545 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 545 ) , "i" ( 12UL ) ) ;
        ldv_4577:;
# 545 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4577;
      }
    }
# 545 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 73UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . set_pmd ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) pmdp ) , "S" ( val ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 549 "./arch/x86/include/asm/paravirt.h"
static inline pmd_t __pmd(pmdval_t val)
{
  pmdval_t ret;
# 553 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
# 554 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 554 "./arch/x86/include/asm/paravirt.h"
      pmdval_t __ret;
# 554 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 554 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 554 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 554 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 554 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 554 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . make_pmd . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 554 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 555 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 555 ) , "i" ( 12UL ) ) ;
          ldv_4588:;
# 554 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4588;
        }
      }
      {
# 554 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 554 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 87UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pmd . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) val >> 32 ) ) : "memory" , "cc" ) ;
# 554 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 554 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 87UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pmd . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) val >> 32 ) ) : "memory" , "cc" ) ;
# 554 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 554 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
  }
  else
# 557 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 557 "./arch/x86/include/asm/paravirt.h"
      pmdval_t __ret;
# 557 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 557 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 557 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 557 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 557 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 557 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . make_pmd . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 557 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 558 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 558 ) , "i" ( 12UL ) ) ;
          ldv_4596:;
# 557 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4596;
        }
      }
      {
# 557 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 557 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 87UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pmd . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) : "memory" , "cc" ) ;
# 557 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 557 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 87UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pmd . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) : "memory" , "cc" ) ;
# 557 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 557 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
# 560 "./arch/x86/include/asm/paravirt.h"
  return ( pmd_t ) { . pmd = ret };
}
# 563 "./arch/x86/include/asm/paravirt.h"
static inline pmdval_t pmd_val(pmd_t pmd)
{
  pmdval_t ret;
# 567 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
# 568 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 568 "./arch/x86/include/asm/paravirt.h"
      pmdval_t __ret;
# 568 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 568 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 568 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 568 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 568 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 568 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . pmd_val . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 568 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 569 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 569 ) , "i" ( 12UL ) ) ;
          ldv_4609:;
# 568 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4609;
        }
      }
      {
# 568 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 568 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 86UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pmd_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pmd . pmd ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) pmd . pmd >> 32 ) ) : "memory" , "cc" ) ;
# 568 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 568 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 86UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pmd_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pmd . pmd ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) pmd . pmd >> 32 ) ) : "memory" , "cc" ) ;
# 568 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 568 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
  }
  else
# 571 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 571 "./arch/x86/include/asm/paravirt.h"
      pmdval_t __ret;
# 571 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 571 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 571 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 571 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 571 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 571 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . pmd_val . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 571 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 572 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 572 ) , "i" ( 12UL ) ) ;
          ldv_4617:;
# 571 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4617;
        }
      }
      {
# 571 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 571 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 86UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pmd_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pmd . pmd ) : "memory" , "cc" ) ;
# 571 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 571 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 86UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pmd_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pmd . pmd ) : "memory" , "cc" ) ;
# 571 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 571 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
# 574 "./arch/x86/include/asm/paravirt.h"
  return ret;
}
# 577 "./arch/x86/include/asm/paravirt.h"
static inline void set_pud(pud_t *pudp, pud_t pud)
{
  pudval_t val = native_pud_val ( pud );
# 581 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
# 582 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 582 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 582 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 582 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 582 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 582 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . set_pud == ( ( void (*)(pud_t *, pud_t)) 0 ) , 0L ) != 0L)
      {
# 582 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 583 "./arch/x86/include/asm/paravirt.h"
        ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 583 ) , "i" ( 12UL ) ) ;
        ldv_4629:;
# 582 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4629;
      }
    }
# 582 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 85UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . set_pud ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) pudp ) , "S" ( val ) , "d" ( ( long unsigned int ) ( ( long long unsigned int ) val >> 32 ) ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
  else
  {
# 585 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 585 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 585 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 585 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 585 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 585 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . set_pud == ( ( void (*)(pud_t *, pud_t)) 0 ) , 0L ) != 0L)
      {
# 585 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 586 "./arch/x86/include/asm/paravirt.h"
        ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 586 ) , "i" ( 12UL ) ) ;
        ldv_4635:;
# 585 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4635;
      }
    }
# 585 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 85UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . set_pud ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) pudp ) , "S" ( val ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 589 "./arch/x86/include/asm/paravirt.h"
static inline pud_t __pud(pudval_t val)
{
  pudval_t ret;
# 593 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
# 594 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 594 "./arch/x86/include/asm/paravirt.h"
      pudval_t __ret;
# 594 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 594 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 594 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 594 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 594 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 594 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . make_pud . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 594 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 595 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 595 ) , "i" ( 12UL ) ) ;
          ldv_4646:;
# 594 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4646;
        }
      }
      {
# 594 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 594 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 89UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pud . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) val >> 32 ) ) : "memory" , "cc" ) ;
# 594 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 594 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 89UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pud . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) val >> 32 ) ) : "memory" , "cc" ) ;
# 594 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 594 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
  }
  else
# 597 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 597 "./arch/x86/include/asm/paravirt.h"
      pudval_t __ret;
# 597 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 597 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 597 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 597 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 597 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 597 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . make_pud . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 597 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 598 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 598 ) , "i" ( 12UL ) ) ;
          ldv_4654:;
# 597 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4654;
        }
      }
      {
# 597 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 597 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 89UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pud . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) : "memory" , "cc" ) ;
# 597 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 597 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 89UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . make_pud . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( val ) : "memory" , "cc" ) ;
# 597 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 597 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
# 600 "./arch/x86/include/asm/paravirt.h"
  return ( pud_t ) { . pud = ret };
}
# 603 "./arch/x86/include/asm/paravirt.h"
static inline pudval_t pud_val(pud_t pud)
{
  pudval_t ret;
# 607 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
# 608 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 608 "./arch/x86/include/asm/paravirt.h"
      pudval_t __ret;
# 608 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 608 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 608 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 608 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 608 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 608 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . pud_val . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 608 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 609 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 609 ) , "i" ( 12UL ) ) ;
          ldv_4667:;
# 608 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4667;
        }
      }
      {
# 608 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 608 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 88UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pud_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pud . pud ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) pud . pud >> 32 ) ) : "memory" , "cc" ) ;
# 608 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 608 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 88UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pud_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pud . pud ) , "S" ( ( long unsigned int ) ( ( long long unsigned int ) pud . pud >> 32 ) ) : "memory" , "cc" ) ;
# 608 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 608 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
  }
  else
# 611 "./arch/x86/include/asm/paravirt.h"
    ret = ({
# 611 "./arch/x86/include/asm/paravirt.h"
      pudval_t __ret;
# 611 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edi = __edi;
# 611 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __esi = __esi;
# 611 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __edx = __edx;
# 611 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __ecx = __ecx;
# 611 "./arch/x86/include/asm/paravirt.h"
      long unsigned int __eax = __eax;
      {
# 611 "./arch/x86/include/asm/paravirt.h"
        if (__builtin_expect ( pv_mmu_ops . pud_val . func == ( ( void *) 0 ) , 0L ) != 0L)
        {
# 611 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 612 "./arch/x86/include/asm/paravirt.h"
          ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 612 ) , "i" ( 12UL ) ) ;
          ldv_4675:;
# 611 "./arch/x86/include/asm/paravirt.h"
          goto ldv_4675;
        }
      }
      {
# 611 "./arch/x86/include/asm/paravirt.h"
        if (0)
        {
# 611 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 88UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pud_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pud . pud ) : "memory" , "cc" ) ;
# 611 "./arch/x86/include/asm/paravirt.h"
          __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
        }
        else
        {
# 611 "./arch/x86/include/asm/paravirt.h"
          asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 88UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . pud_val . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( pud . pud ) : "memory" , "cc" ) ;
# 611 "./arch/x86/include/asm/paravirt.h"
          __ret = __eax;
        }
      }
# 611 "./arch/x86/include/asm/paravirt.h"
      __ret;
    } );
# 614 "./arch/x86/include/asm/paravirt.h"
  return ret;
}
# 617 "./arch/x86/include/asm/paravirt.h"
static inline void set_pgd(pgd_t *pgdp, pgd_t pgd)
{
  pgdval_t val = native_pgd_val ( pgd );
# 621 "./arch/x86/include/asm/paravirt.h"
  if (0)
  {
# 622 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 622 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 622 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 622 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 622 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 622 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . set_pgd == ( ( void (*)(pgd_t *, pgd_t)) 0 ) , 0L ) != 0L)
      {
# 622 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 623 "./arch/x86/include/asm/paravirt.h"
        ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 623 ) , "i" ( 12UL ) ) ;
        ldv_4687:;
# 622 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4687;
      }
    }
# 622 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 90UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . set_pgd ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) pgdp ) , "S" ( val ) , "d" ( ( long unsigned int ) ( ( long long unsigned int ) val >> 32 ) ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
  else
  {
# 625 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 625 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 625 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 625 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 625 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 625 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . set_pgd == ( ( void (*)(pgd_t *, pgd_t)) 0 ) , 0L ) != 0L)
      {
# 625 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 626 "./arch/x86/include/asm/paravirt.h"
        ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 626 ) , "i" ( 12UL ) ) ;
        ldv_4693:;
# 625 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4693;
      }
    }
# 625 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 90UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . set_pgd ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) pgdp ) , "S" ( val ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 629 "./arch/x86/include/asm/paravirt.h"
static inline void pgd_clear(pgd_t *pgdp)
{
  set_pgd ( pgdp , __pgd ( 0UL ) );
}
# 634 "./arch/x86/include/asm/paravirt.h"
static inline void pud_clear(pud_t *pudp)
{
  set_pud ( pudp , __pud ( 0UL ) );
}
# 663 "./arch/x86/include/asm/paravirt.h"
static inline void set_pte_atomic(pte_t *ptep, pte_t pte)
{
  set_pte ( ptep , pte );
}
# 668 "./arch/x86/include/asm/paravirt.h"
static inline void pte_clear(struct mm_struct *mm, long unsigned int addr, pte_t *ptep)
{
# 671 "./arch/x86/include/asm/paravirt.h"
  set_pte_at ( mm , addr , ptep , __pte ( 0UL ) );
}
# 674 "./arch/x86/include/asm/paravirt.h"
static inline void pmd_clear(pmd_t *pmdp)
{
  set_pmd ( pmdp , __pmd ( 0UL ) );
}
# 681 "./arch/x86/include/asm/paravirt.h"
static inline void arch_start_context_switch(struct task_struct *prev)
{
  {
# 683 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 683 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 683 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 683 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 683 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 683 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . start_context_switch == ( ( void (*)(struct task_struct *)) 0 ) , 0L ) != 0L)
      {
# 683 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 683 ) , "i" ( 12UL ) ) ;
        ldv_4720:;
# 683 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4720;
      }
    }
# 683 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 42UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . start_context_switch ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) prev ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void arch_end_context_switch(struct task_struct *next)
{
  {
# 688 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 688 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 688 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 688 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 688 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 688 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_cpu_ops . end_context_switch == ( ( void (*)(struct task_struct *)) 0 ) , 0L ) != 0L)
      {
# 688 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 688 ) , "i" ( 12UL ) ) ;
        ldv_4729:;
# 688 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4729;
      }
    }
# 688 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 43UL ) , [ paravirt_opptr ] "i" ( & pv_cpu_ops . end_context_switch ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) next ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 692 "./arch/x86/include/asm/paravirt.h"
static inline void arch_enter_lazy_mmu_mode(void)
{
  {
# 694 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 694 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 694 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 694 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 694 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 694 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . lazy_mode . enter == ( ( void (*)(void)) 0 ) , 0L ) != 0L)
      {
# 694 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 694 ) , "i" ( 12UL ) ) ;
        ldv_4738:;
# 694 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4738;
      }
    }
# 694 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 91UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . lazy_mode . enter ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void arch_leave_lazy_mmu_mode(void)
{
  {
# 699 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 699 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 699 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 699 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 699 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 699 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . lazy_mode . leave == ( ( void (*)(void)) 0 ) , 0L ) != 0L)
      {
# 699 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 699 ) , "i" ( 12UL ) ) ;
        ldv_4747:;
# 699 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4747;
      }
    }
# 699 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 92UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . lazy_mode . leave ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void arch_flush_lazy_mmu_mode(void)
{
  {
# 704 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 704 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 704 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 704 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 704 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 704 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_mmu_ops . lazy_mode . flush == ( ( void (*)(void)) 0 ) , 0L ) != 0L)
      {
# 704 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 704 ) , "i" ( 12UL ) ) ;
        ldv_4756:;
# 704 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4756;
      }
    }
# 704 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 93UL ) , [ paravirt_opptr ] "i" ( & pv_mmu_ops . lazy_mode . flush ) , [ paravirt_clobber ] "i" ( 511 ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
static inline void __set_fixmap(unsigned int idx, phys_addr_t phys, pgprot_t flags)
{
# 710 "./arch/x86/include/asm/paravirt.h"
  pv_mmu_ops . set_fixmap ( idx , phys , flags );
}
# 715 "./arch/x86/include/asm/paravirt.h"
static inline void __ticket_lock_spinning(struct arch_spinlock *lock, __ticket_t ticket)
{
  {
    long unsigned int __edi = __edi;
# 718 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 718 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 718 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 718 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 718 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_lock_ops . lock_spinning . func == ( ( void *) 0 ) , 0L ) != 0L)
      {
# 718 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 718 ) , "i" ( 12UL ) ) ;
        ldv_4771:;
# 718 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4771;
      }
    }
# 718 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 95UL ) , [ paravirt_opptr ] "i" ( & pv_lock_ops . lock_spinning . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( ( long unsigned int ) lock ) , "S" ( ( long unsigned int ) ticket ) : "memory" , "cc" ) ;
  }
}
static inline void __ticket_unlock_kick(struct arch_spinlock *lock, __ticket_t ticket)
{
  {
    long unsigned int __edi = __edi;
# 724 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 724 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 724 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 724 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 724 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_lock_ops . unlock_kick == ( ( void (*)(struct arch_spinlock *, __ticket_t)) 0 ) , 0L ) != 0L)
      {
# 724 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 724 ) , "i" ( 12UL ) ) ;
        ldv_4781:;
# 724 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4781;
      }
    }
# 724 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n" : "=D" ( __edi ) , "=S" ( __esi ) , "=d" ( __edx ) , "=c" ( __ecx ) : [ paravirt_typenum ] "i" ( 96UL ) , [ paravirt_opptr ] "i" ( & pv_lock_ops . unlock_kick ) , [ paravirt_clobber ] "i" ( 511 ) , "D" ( ( long unsigned int ) lock ) , "S" ( ( long unsigned int ) ticket ) : "memory" , "cc" , "rax" , "r8" , "r9" , "r10" , "r11" ) ;
  }
}
# 802 "./arch/x86/include/asm/paravirt.h"
static inline long unsigned int arch_local_save_flags(void)
{
  return ({
# 804 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ret;
# 804 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 804 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 804 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 804 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 804 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 804 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_irq_ops . save_fl . func == ( ( void *) 0 ) , 0L ) != 0L)
      {
# 804 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 804 ) , "i" ( 12UL ) ) ;
        ldv_4791:;
# 804 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4791;
      }
    }
    {
# 804 "./arch/x86/include/asm/paravirt.h"
      if (0)
      {
# 804 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 44UL ) , [ paravirt_opptr ] "i" ( & pv_irq_ops . save_fl . func ) , [ paravirt_clobber ] "i" ( 1 ) : "memory" , "cc" ) ;
# 804 "./arch/x86/include/asm/paravirt.h"
        __ret = ( long unsigned int ) ( ( long long unsigned int ) __edx << 32 | ( long long unsigned int ) __eax );
      }
      else
      {
# 804 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 44UL ) , [ paravirt_opptr ] "i" ( & pv_irq_ops . save_fl . func ) , [ paravirt_clobber ] "i" ( 1 ) : "memory" , "cc" ) ;
# 804 "./arch/x86/include/asm/paravirt.h"
        __ret = __eax;
      }
    }
# 804 "./arch/x86/include/asm/paravirt.h"
    __ret;
  } );
}
static inline void arch_local_irq_restore(long unsigned int f)
{
  {
# 809 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 809 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 809 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 809 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 809 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 809 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_irq_ops . restore_fl . func == ( ( void *) 0 ) , 0L ) != 0L)
      {
# 809 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 809 ) , "i" ( 12UL ) ) ;
        ldv_4801:;
# 809 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4801;
      }
    }
# 809 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 45UL ) , [ paravirt_opptr ] "i" ( & pv_irq_ops . restore_fl . func ) , [ paravirt_clobber ] "i" ( 1 ) , "D" ( f ) : "memory" , "cc" ) ;
  }
}
static inline void arch_local_irq_disable(void)
{
  {
# 814 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 814 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 814 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 814 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 814 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 814 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_irq_ops . irq_disable . func == ( ( void *) 0 ) , 0L ) != 0L)
      {
# 814 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 814 ) , "i" ( 12UL ) ) ;
        ldv_4810:;
# 814 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4810;
      }
    }
# 814 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 46UL ) , [ paravirt_opptr ] "i" ( & pv_irq_ops . irq_disable . func ) , [ paravirt_clobber ] "i" ( 1 ) : "memory" , "cc" ) ;
  }
}
static inline void arch_local_irq_enable(void)
{
  {
# 819 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edi = __edi;
# 819 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __esi = __esi;
# 819 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __edx = __edx;
# 819 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __ecx = __ecx;
# 819 "./arch/x86/include/asm/paravirt.h"
    long unsigned int __eax = __eax;
    {
# 819 "./arch/x86/include/asm/paravirt.h"
      if (__builtin_expect ( pv_irq_ops . irq_enable . func == ( ( void *) 0 ) , 0L ) != 0L)
      {
# 819 "./arch/x86/include/asm/paravirt.h"
        asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/paravirt.h" ) , "i" ( 819 ) , "i" ( 12UL ) ) ;
        ldv_4819:;
# 819 "./arch/x86/include/asm/paravirt.h"
        goto ldv_4819;
      }
    }
# 819 "./arch/x86/include/asm/paravirt.h"
    asm volatile ( "771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n" : "=a" ( __eax ) : [ paravirt_typenum ] "i" ( 47UL ) , [ paravirt_opptr ] "i" ( & pv_irq_ops . irq_enable . func ) , [ paravirt_clobber ] "i" ( 1 ) : "memory" , "cc" ) ;
  }
}
static inline long unsigned int arch_local_irq_save(void)
{
  long unsigned int f;
# 826 "./arch/x86/include/asm/paravirt.h"
  f = arch_local_save_flags ( );
  arch_local_irq_disable ( );
  return f;
}
# 847 "./arch/x86/include/asm/paravirt.h"
void default_banner(void);
# 215 "./arch/x86/include/asm/msr.h"
struct msr *msrs_alloc(void);
void msrs_free(struct msr *);
int msr_set_bit(u32, u8);
int msr_clear_bit(u32, u8);
# 221 "./arch/x86/include/asm/msr.h"
int rdmsr_on_cpu(unsigned int, u32, u32 *, u32 *);
int wrmsr_on_cpu(unsigned int, u32, u32, u32);
int rdmsrl_on_cpu(unsigned int, u32, u64 *);
int wrmsrl_on_cpu(unsigned int, u32, u64);
void rdmsr_on_cpus(struct cpumask const *, u32, struct msr *);
void wrmsr_on_cpus(struct cpumask const *, u32, struct msr *);
int rdmsr_safe_on_cpu(unsigned int, u32, u32 *, u32 *);
int wrmsr_safe_on_cpu(unsigned int, u32, u32, u32);
int rdmsrl_safe_on_cpu(unsigned int, u32, u64 *);
int wrmsrl_safe_on_cpu(unsigned int, u32, u64);
int rdmsr_safe_regs_on_cpu(unsigned int, u32 *);
int wrmsr_safe_regs_on_cpu(unsigned int, u32 *);
# 7 "./arch/x86/include/asm/special_insns.h"
static inline void native_clts(void)
{
  asm volatile ( "clts" ) ;
}
# 19 "./arch/x86/include/asm/special_insns.h"
extern long unsigned int __force_order;
# 21 "./arch/x86/include/asm/special_insns.h"
static inline long unsigned int native_read_cr0(void)
{
  long unsigned int val;
  asm volatile ( "mov %%cr0,%0\n\t" : "=r" ( val ) , "=m" ( __force_order ) ) ;
  return val;
}
# 28 "./arch/x86/include/asm/special_insns.h"
static inline void native_write_cr0(long unsigned int val)
{
  asm volatile ( "mov %0,%%cr0" : : "r" ( val ) , "m" ( __force_order ) ) ;
}
# 33 "./arch/x86/include/asm/special_insns.h"
static inline long unsigned int native_read_cr2(void)
{
  long unsigned int val;
  asm volatile ( "mov %%cr2,%0\n\t" : "=r" ( val ) , "=m" ( __force_order ) ) ;
  return val;
}
# 40 "./arch/x86/include/asm/special_insns.h"
static inline void native_write_cr2(long unsigned int val)
{
  asm volatile ( "mov %0,%%cr2" : : "r" ( val ) , "m" ( __force_order ) ) ;
}
# 45 "./arch/x86/include/asm/special_insns.h"
static inline long unsigned int native_read_cr3(void)
{
  long unsigned int val;
  asm volatile ( "mov %%cr3,%0\n\t" : "=r" ( val ) , "=m" ( __force_order ) ) ;
  return val;
}
# 52 "./arch/x86/include/asm/special_insns.h"
static inline void native_write_cr3(long unsigned int val)
{
  asm volatile ( "mov %0,%%cr3" : : "r" ( val ) , "m" ( __force_order ) ) ;
}
# 57 "./arch/x86/include/asm/special_insns.h"
static inline long unsigned int native_read_cr4(void)
{
  long unsigned int val;
  asm volatile ( "mov %%cr4,%0\n\t" : "=r" ( val ) , "=m" ( __force_order ) ) ;
  return val;
}
# 64 "./arch/x86/include/asm/special_insns.h"
static inline long unsigned int native_read_cr4_safe(void)
{
  long unsigned int val;
# 75 "./arch/x86/include/asm/special_insns.h"
  val = native_read_cr4 ( );
# 77 "./arch/x86/include/asm/special_insns.h"
  return val;
}
# 80 "./arch/x86/include/asm/special_insns.h"
static inline void native_write_cr4(long unsigned int val)
{
  asm volatile ( "mov %0,%%cr4" : : "r" ( val ) , "m" ( __force_order ) ) ;
}
# 86 "./arch/x86/include/asm/special_insns.h"
static inline long unsigned int native_read_cr8(void)
{
  long unsigned int cr8;
  asm volatile ( "movq %%cr8,%0" : "=r" ( cr8 ) ) ;
  return cr8;
}
# 93 "./arch/x86/include/asm/special_insns.h"
static inline void native_write_cr8(long unsigned int val)
{
  asm volatile ( "movq %0,%%cr8" : : "r" ( val ) : "memory" ) ;
}
# 99 "./arch/x86/include/asm/special_insns.h"
static inline void native_wbinvd(void)
{
  asm volatile ( "wbinvd" : : : "memory" ) ;
}
# 104 "./arch/x86/include/asm/special_insns.h"
void native_load_gs_index(unsigned int);
# 189 "./arch/x86/include/asm/special_insns.h"
static inline void clflush(void volatile *__p)
{
  asm volatile ( "clflush %0" : "+m" ( * ( char volatile *) __p ) ) ;
}
# 194 "./arch/x86/include/asm/special_insns.h"
static inline void clflushopt(void volatile *__p)
{
  asm volatile ( "661:\n\t.byte 0x3e; clflush %P0\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+23)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x66; clflush %P0\n6641:\n\t.popsection" : "+m" ( * ( char volatile *) __p ) : "i" ( 0 ) ) ;
}
enum ldv_7546
{
  UNAME26 = 131072,
  ADDR_NO_RANDOMIZE = 262144,
  FDPIC_FUNCPTRS = 524288,
  MMAP_PAGE_ZERO = 1048576,
  ADDR_COMPAT_LAYOUT = 2097152,
  READ_IMPLIES_EXEC = 4194304,
  ADDR_LIMIT_32BIT = 8388608,
  SHORT_INODE = 16777216,
  WHOLE_SECONDS = 33554432,
  STICKY_TIMEOUTS = 67108864,
  ADDR_LIMIT_3GB = 134217728
};
enum ldv_7547
{
  PER_LINUX = 0,
  PER_LINUX_32BIT = 8388608,
  PER_LINUX_FDPIC = 524288,
  PER_SVR4 = 68157441,
  PER_SVR3 = 83886082,
  PER_SCOSVR3 = 117440515,
  PER_OSR5 = 100663299,
  PER_WYSEV386 = 83886084,
  PER_ISCR4 = 67108869,
  PER_BSD = 6,
  PER_SUNOS = 67108870,
  PER_XENIX = 83886087,
  PER_LINUX32 = 8,
  PER_LINUX32_3GB = 134217736,
  PER_IRIX32 = 67108873,
  PER_IRIXN32 = 67108874,
  PER_IRIX64 = 67108875,
  PER_RISCOS = 12,
  PER_SOLARIS = 67108877,
  PER_UW7 = 68157454,
  PER_OSF4 = 15,
  PER_HPUX = 16,
  PER_MASK = 255
};
struct exec_domain;
# 14 "include/linux/personality.h"
int register_exec_domain(struct exec_domain *);
int unregister_exec_domain(struct exec_domain *);
int __set_personality(unsigned int);
# 25 "include/linux/personality.h"
typedef void (*handler_t)(int, struct pt_regs *);
struct exec_domain
{
  char const *name;
  handler_t handler;
  unsigned char pers_low;
  unsigned char pers_high;
  long unsigned int *signal_map;
  long unsigned int *signal_invmap;
  struct map_segment *err_map;
  struct map_segment *socktype_map;
  struct map_segment *sockopt_map;
  struct map_segment *af_map;
  struct module *module;
  struct exec_domain *next;
};
# 18 "include/linux/math64.h"
static inline u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)
{
  * remainder = ( u32 ) ( dividend % ( u64 ) divisor );
  return dividend / ( u64 ) divisor;
}
# 27 "include/linux/math64.h"
static inline s64 div_s64_rem(s64 dividend, s32 divisor, s32 *remainder)
{
  * remainder = ( s32 ) ( dividend % ( s64 ) divisor );
  return dividend / ( s64 ) divisor;
}
# 36 "include/linux/math64.h"
static inline u64 div64_u64_rem(u64 dividend, u64 divisor, u64 *remainder)
{
  * remainder = dividend % divisor;
  return dividend / divisor;
}
# 45 "include/linux/math64.h"
static inline u64 div64_u64(u64 dividend, u64 divisor)
{
  return dividend / divisor;
}
# 53 "include/linux/math64.h"
static inline s64 div64_s64(s64 dividend, s64 divisor)
{
  return dividend / divisor;
}
# 97 "include/linux/math64.h"
static inline u64 div_u64(u64 dividend, u32 divisor)
{
  u32 remainder;
  return div_u64_rem ( dividend , divisor , & remainder );
}
# 108 "include/linux/math64.h"
static inline s64 div_s64(s64 dividend, s32 divisor)
{
  s32 remainder;
  return div_s64_rem ( dividend , divisor , & remainder );
}
# 115 "include/linux/math64.h"
u32 iter_div_u64_rem(u64, u32, u64 *);
# 118 "include/linux/math64.h"
static inline u32 __iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder)
{
  u32 ret = 0U;
# 122 "include/linux/math64.h"
  goto ldv_5043;
  ldv_5042:;
# 125 "include/linux/math64.h"
  asm ( "" : "+rm" ( dividend ) ) ;
# 127 "include/linux/math64.h"
  dividend -= ( u64 ) divisor;
  ret ++;
  ldv_5043:;
# 122 "include/linux/math64.h"
  if (( u64 ) divisor <= dividend)
  {
    goto ldv_5042;
  }
  else
    goto ldv_5044;
  ldv_5044:;
# 131 "include/linux/math64.h"
  * remainder = dividend;
# 133 "include/linux/math64.h"
  return ret;
}
# 139 "include/linux/math64.h"
static inline u64 mul_u64_u32_shr(u64 a, u32 mul, unsigned int shift)
{
  return ( u64 ) ( ( unsigned int ) a * ( unsigned int ) mul >> ( int ) shift );
}
# 23 "include/linux/err.h"
static inline void *ERR_PTR(long int error)
{
  return ( void *) error;
}
# 28 "include/linux/err.h"
static inline long int PTR_ERR(void const *ptr)
{
  return ( long int ) ptr;
}
# 33 "include/linux/err.h"
static inline bool IS_ERR(void const *ptr)
{
  return __builtin_expect ( ( long unsigned int ) ptr > 18446744073709547520UL , 0L ) != 0L;
}
# 38 "include/linux/err.h"
static inline bool IS_ERR_OR_NULL(void const *ptr)
{
  return ( bool ) ( ptr == ( ( void const *) 0 ) || __builtin_expect ( ( long unsigned int ) ptr > 18446744073709547520UL , 0L ) != 0L );
}
# 50 "include/linux/err.h"
static inline void *ERR_CAST(void const *ptr)
{
# 53 "include/linux/err.h"
  return ( void *) ptr;
}
# 56 "include/linux/err.h"
static inline int PTR_ERR_OR_ZERO(void const *ptr)
{
  if (( int ) IS_ERR ( ptr ))
  {
# 59 "include/linux/err.h"
    return ( int ) PTR_ERR ( ptr );
  }
  else
# 61 "include/linux/err.h"
    return 0;
}
# 11 "./arch/x86/include/asm/irqflags.h"
static inline long unsigned int native_save_fl(void)
{
  long unsigned int flags;
# 20 "./arch/x86/include/asm/irqflags.h"
  asm volatile ( "# __raw_save_flags\n\tpushf ; pop %0" : "=rm" ( flags ) : : "memory" ) ;
# 26 "./arch/x86/include/asm/irqflags.h"
  return flags;
}
# 29 "./arch/x86/include/asm/irqflags.h"
static inline void native_restore_fl(long unsigned int flags)
{
  asm volatile ( "push %0 ; popf" : : "g" ( flags ) : "memory" , "cc" ) ;
}
# 37 "./arch/x86/include/asm/irqflags.h"
static inline void native_irq_disable(void)
{
  asm volatile ( "cli" : : : "memory" ) ;
}
# 42 "./arch/x86/include/asm/irqflags.h"
static inline void native_irq_enable(void)
{
  asm volatile ( "sti" : : : "memory" ) ;
}
# 47 "./arch/x86/include/asm/irqflags.h"
static inline void native_safe_halt(void)
{
  asm volatile ( "sti; hlt" : : : "memory" ) ;
}
# 52 "./arch/x86/include/asm/irqflags.h"
static inline void native_halt(void)
{
  asm volatile ( "hlt" : : : "memory" ) ;
}
# 155 "./arch/x86/include/asm/irqflags.h"
static inline int arch_irqs_disabled_flags(long unsigned int flags)
{
  return ( flags & 512UL ) == 0UL;
}
# 160 "./arch/x86/include/asm/irqflags.h"
static inline int arch_irqs_disabled(void)
{
  long unsigned int flags = arch_local_save_flags ( );
# 164 "./arch/x86/include/asm/irqflags.h"
  return arch_irqs_disabled_flags ( flags );
}
# 18 "include/linux/irqflags.h"
void trace_softirqs_on(long unsigned int);
void trace_softirqs_off(long unsigned int);
void trace_hardirqs_on(void);
void trace_hardirqs_off(void);
# 46 "./arch/x86/include/asm/processor.h"
static inline void *current_text_addr(void)
{
  void *pc;
# 50 "./arch/x86/include/asm/processor.h"
  asm volatile ( "mov $1f, %0; 1:" : "=r" ( pc ) ) ;
# 52 "./arch/x86/include/asm/processor.h"
  return pc;
}
enum tlb_infos
{
  ENTRIES = 0,
  NR_INFO = 1
};
# 68 "./arch/x86/include/asm/processor.h"
extern u16 tlb_lli_4k[1U];
extern u16 tlb_lli_2m[1U];
extern u16 tlb_lli_4m[1U];
extern u16 tlb_lld_4k[1U];
extern u16 tlb_lld_2m[1U];
extern u16 tlb_lld_4m[1U];
extern u16 tlb_lld_1g[1U];
struct cpuinfo_x86
{
# 83 "./arch/x86/include/asm/processor.h"
  __u8 x86;
  __u8 x86_vendor;
  __u8 x86_model;
  __u8 x86_mask;
# 96 "./arch/x86/include/asm/processor.h"
  int x86_tlbsize;
# 98 "./arch/x86/include/asm/processor.h"
  __u8 x86_virt_bits;
  __u8 x86_phys_bits;
# 101 "./arch/x86/include/asm/processor.h"
  __u8 x86_coreid_bits;
# 103 "./arch/x86/include/asm/processor.h"
  __u32 extended_cpuid_level;
# 105 "./arch/x86/include/asm/processor.h"
  int cpuid_level;
  __u32 x86_capability[12U];
  char x86_vendor_id[16U];
  char x86_model_id[64U];
# 110 "./arch/x86/include/asm/processor.h"
  int x86_cache_size;
  int x86_cache_alignment;
  int x86_power;
  long unsigned int loops_per_jiffy;
# 115 "./arch/x86/include/asm/processor.h"
  u16 x86_max_cores;
  u16 apicid;
  u16 initial_apicid;
  u16 x86_clflush_size;
# 120 "./arch/x86/include/asm/processor.h"
  u16 booted_cores;
# 122 "./arch/x86/include/asm/processor.h"
  u16 phys_proc_id;
# 124 "./arch/x86/include/asm/processor.h"
  u16 cpu_core_id;
# 126 "./arch/x86/include/asm/processor.h"
  u8 compute_unit_id;
# 128 "./arch/x86/include/asm/processor.h"
  u16 cpu_index;
  u32 microcode;
};
# 146 "./arch/x86/include/asm/processor.h"
extern struct cpuinfo_x86 boot_cpu_data;
extern struct cpuinfo_x86 new_cpu_data;
# 149 "./arch/x86/include/asm/processor.h"
extern struct tss_struct doublefault_tss;
extern __u32 cpu_caps_cleared[11U];
extern __u32 cpu_caps_set[11U];
# 154 "./arch/x86/include/asm/processor.h"
extern char __pcpu_scope_cpu_info;
# 154 "./arch/x86/include/asm/processor.h"
extern struct cpuinfo_x86 cpu_info;
# 161 "./arch/x86/include/asm/processor.h"
extern struct seq_operations const cpuinfo_op;
# 165 "./arch/x86/include/asm/processor.h"
void cpu_detect(struct cpuinfo_x86 *);
void fpu_detect(struct cpuinfo_x86 *);
# 168 "./arch/x86/include/asm/processor.h"
void early_cpu_init(void);
void identify_boot_cpu(void);
void identify_secondary_cpu(struct cpuinfo_x86 *);
void print_cpu_info(struct cpuinfo_x86 *);
void print_cpu_msr(struct cpuinfo_x86 *);
void init_scattered_cpuid_features(struct cpuinfo_x86 *);
unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *);
void init_amd_cacheinfo(struct cpuinfo_x86 *);
# 177 "./arch/x86/include/asm/processor.h"
void detect_extended_topology(struct cpuinfo_x86 *);
void detect_ht(struct cpuinfo_x86 *);
# 183 "./arch/x86/include/asm/processor.h"
static inline int have_cpuid_p(void)
{
  return 1;
}
# 188 "./arch/x86/include/asm/processor.h"
static inline void native_cpuid(unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx)
{
# 192 "./arch/x86/include/asm/processor.h"
  asm volatile ( "cpuid" : "=a" (
# 193 "./arch/x86/include/asm/processor.h"
  * eax ) , "=b" (
# 194 "./arch/x86/include/asm/processor.h"
  * ebx ) , "=c" (
# 195 "./arch/x86/include/asm/processor.h"
  * ecx ) , "=d" (
# 196 "./arch/x86/include/asm/processor.h"
  * edx ) : "0" (
# 197 "./arch/x86/include/asm/processor.h"
  * eax ) , "2" ( * ecx ) : "memory" ) ;
}
# 201 "./arch/x86/include/asm/processor.h"
static inline void load_cr3(pgd_t *pgdir)
{
  write_cr3 ( __phys_addr ( ( long unsigned int ) pgdir ) );
}
struct x86_hw_tss
{
# 241 "./arch/x86/include/asm/processor.h"
  u32 reserved1;
  u64 sp0;
  u64 sp1;
  u64 sp2;
  u64 reserved2;
  u64 ist[7U];
  u32 reserved3;
  u32 reserved4;
  u16 reserved5;
  u16 io_bitmap_base;
};
struct tss_struct
{
# 268 "./arch/x86/include/asm/processor.h"
  struct x86_hw_tss x86_tss;
# 276 "./arch/x86/include/asm/processor.h"
  long unsigned int io_bitmap[1025U];
# 281 "./arch/x86/include/asm/processor.h"
  long unsigned int stack[64U];
};
# 285 "./arch/x86/include/asm/processor.h"
extern char __pcpu_scope_init_tss;
# 285 "./arch/x86/include/asm/processor.h"
extern struct tss_struct init_tss;
struct orig_ist
{
# 291 "./arch/x86/include/asm/processor.h"
  long unsigned int ist[7U];
};
struct i387_fsave_struct
{
# 297 "./arch/x86/include/asm/processor.h"
  u32 cwd;
  u32 swd;
  u32 twd;
  u32 fip;
  u32 fcs;
  u32 foo;
  u32 fos;
# 306 "./arch/x86/include/asm/processor.h"
  u32 st_space[20U];
# 309 "./arch/x86/include/asm/processor.h"
  u32 status;
};
struct i387_fxsave_struct
{
  u16 cwd;
  u16 swd;
  u16 twd;
  u16 fop;
# 328 "./arch/x86/include/asm/processor.h"
  union
  {
# 321 "./arch/x86/include/asm/processor.h"
    struct
    {
# 319 "./arch/x86/include/asm/processor.h"
      u64 rip;
      u64 rdp;
    } ldv_5225;
# 327 "./arch/x86/include/asm/processor.h"
    struct
    {
# 323 "./arch/x86/include/asm/processor.h"
      u32 fip;
      u32 fcs;
      u32 foo;
      u32 fos;
    } ldv_5231;
  } ldv_5232;
  u32 mxcsr;
  u32 mxcsr_mask;
# 333 "./arch/x86/include/asm/processor.h"
  u32 st_space[32U];
# 336 "./arch/x86/include/asm/processor.h"
  u32 xmm_space[64U];
# 338 "./arch/x86/include/asm/processor.h"
  u32 padding[12U];
# 343 "./arch/x86/include/asm/processor.h"
  union
  {
# 341 "./arch/x86/include/asm/processor.h"
    u32 padding1[12U];
    u32 sw_reserved[12U];
  } ldv_5241;
};
struct i387_soft_struct
{
# 348 "./arch/x86/include/asm/processor.h"
  u32 cwd;
  u32 swd;
  u32 twd;
  u32 fip;
  u32 fcs;
  u32 foo;
  u32 fos;
# 356 "./arch/x86/include/asm/processor.h"
  u32 st_space[20U];
  u8 ftop;
  u8 changed;
  u8 lookahead;
  u8 no_update;
  u8 rm;
  u8 alimit;
  struct math_emu_info *info;
  u32 entry_eip;
};
struct ymmh_struct
{
# 369 "./arch/x86/include/asm/processor.h"
  u32 ymmh_space[64U];
};
struct lwp_struct
{
# 374 "./arch/x86/include/asm/processor.h"
  u8 reserved[128U];
};
struct bndregs_struct
{
  u64 bndregs[8U];
};
struct bndcsr_struct
{
  u64 cfg_reg_u;
  u64 status_reg;
};
struct xsave_hdr_struct
{
  u64 xstate_bv;
  u64 xcomp_bv;
  u64 reserved[6U];
};
struct xsave_struct
{
  struct i387_fxsave_struct i387;
  struct xsave_hdr_struct xsave_hdr;
  struct ymmh_struct ymmh;
  struct lwp_struct lwp;
  struct bndregs_struct bndregs;
  struct bndcsr_struct bndcsr;
};
union thread_xstate
{
# 403 "./arch/x86/include/asm/processor.h"
  struct i387_fsave_struct fsave;
  struct i387_fxsave_struct fxsave;
  struct i387_soft_struct soft;
  struct xsave_struct xsave;
};
struct fpu
{
  unsigned int last_cpu;
  unsigned int has_fpu;
  union thread_xstate *state;
};
# 416 "./arch/x86/include/asm/processor.h"
extern char __pcpu_scope_orig_ist;
# 416 "./arch/x86/include/asm/processor.h"
extern struct orig_ist orig_ist;
union irq_stack_union
{
  char irq_stack[16384U];
# 428 "./arch/x86/include/asm/processor.h"
  struct
  {
# 426 "./arch/x86/include/asm/processor.h"
    char gs_base[40U];
    long unsigned int stack_canary;
  } ldv_5295;
};
# 431 "./arch/x86/include/asm/processor.h"
extern char __pcpu_scope_irq_stack_union;
# 431 "./arch/x86/include/asm/processor.h"
extern union irq_stack_union irq_stack_union;
extern union irq_stack_union init_per_cpu__irq_stack_union;
# 434 "./arch/x86/include/asm/processor.h"
extern char __pcpu_scope_irq_stack_ptr;
# 434 "./arch/x86/include/asm/processor.h"
extern char *irq_stack_ptr;
extern char __pcpu_scope_irq_count;
# 435 "./arch/x86/include/asm/processor.h"
extern unsigned int irq_count;
void ignore_sysret(void);
# 462 "./arch/x86/include/asm/processor.h"
extern unsigned int xstate_size;
void free_thread_xstate(struct task_struct *);
extern struct kmem_cache *task_xstate_cachep;
struct perf_event;
struct thread_struct
{
# 470 "./arch/x86/include/asm/processor.h"
  struct desc_struct tls_array[3U];
  long unsigned int sp0;
  long unsigned int sp;
# 476 "./arch/x86/include/asm/processor.h"
  long unsigned int usersp;
  short unsigned int es;
  short unsigned int ds;
  short unsigned int fsindex;
  short unsigned int gsindex;
# 486 "./arch/x86/include/asm/processor.h"
  long unsigned int fs;
# 488 "./arch/x86/include/asm/processor.h"
  long unsigned int gs;
# 490 "./arch/x86/include/asm/processor.h"
  struct perf_event *ptrace_bps[4U];
# 492 "./arch/x86/include/asm/processor.h"
  long unsigned int debugreg6;
# 494 "./arch/x86/include/asm/processor.h"
  long unsigned int ptrace_dr7;
# 496 "./arch/x86/include/asm/processor.h"
  long unsigned int cr2;
  long unsigned int trap_nr;
  long unsigned int error_code;
# 500 "./arch/x86/include/asm/processor.h"
  struct fpu fpu;
# 512 "./arch/x86/include/asm/processor.h"
  long unsigned int *io_bitmap_ptr;
  long unsigned int iopl;
# 515 "./arch/x86/include/asm/processor.h"
  unsigned int io_bitmap_max;
# 524 "./arch/x86/include/asm/processor.h"
  unsigned char fpu_counter;
};
# 530 "./arch/x86/include/asm/processor.h"
static inline void native_set_iopl_mask(unsigned int mask)
{
}
# 547 "./arch/x86/include/asm/processor.h"
static inline void native_load_sp0(struct tss_struct *tss, struct thread_struct *thread)
{
  ( * tss ) . x86_tss . sp0 = ( u64 ) ( * thread ) . sp0;
}
# 559 "./arch/x86/include/asm/processor.h"
static inline void native_swapgs(void)
{
# 562 "./arch/x86/include/asm/processor.h"
  asm volatile ( "swapgs" : : : "memory" ) ;
}
# 587 "./arch/x86/include/asm/processor.h"
extern long unsigned int mmu_cr4_features;
extern u32 *trampoline_cr4_features;
# 590 "./arch/x86/include/asm/processor.h"
static inline void set_in_cr4(long unsigned int mask)
{
  long unsigned int cr4;
# 594 "./arch/x86/include/asm/processor.h"
  mmu_cr4_features |= mask;
  if (trampoline_cr4_features != ( ( u32 *) 0U ))
    * trampoline_cr4_features = ( u32 ) mmu_cr4_features;
  cr4 = read_cr4 ( );
  cr4 |= mask;
  write_cr4 ( cr4 );
}
# 602 "./arch/x86/include/asm/processor.h"
static inline void clear_in_cr4(long unsigned int mask)
{
  long unsigned int cr4;
# 606 "./arch/x86/include/asm/processor.h"
  mmu_cr4_features = ~ mask & mmu_cr4_features;
  if (trampoline_cr4_features != ( ( u32 *) 0U ))
    * trampoline_cr4_features = ( u32 ) mmu_cr4_features;
  cr4 = read_cr4 ( );
  cr4 = ~ mask & cr4;
  write_cr4 ( cr4 );
}
# 616 "./arch/x86/include/asm/processor.h"
typedef struct
{
# 615 "./arch/x86/include/asm/processor.h"
  long unsigned int seg;
} mm_segment_t;
# 620 "./arch/x86/include/asm/processor.h"
void release_thread(struct task_struct *);
# 622 "./arch/x86/include/asm/processor.h"
long unsigned int get_wchan(struct task_struct *);
# 629 "./arch/x86/include/asm/processor.h"
static inline void cpuid(unsigned int op, unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx)
{
# 633 "./arch/x86/include/asm/processor.h"
  * eax = op;
  * ecx = 0U;
  __cpuid ( eax , ebx , ecx , edx );
}
# 639 "./arch/x86/include/asm/processor.h"
static inline void cpuid_count(unsigned int op, int count, unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx)
{
# 643 "./arch/x86/include/asm/processor.h"
  * eax = op;
  * ecx = ( unsigned int ) count;
  __cpuid ( eax , ebx , ecx , edx );
}
# 651 "./arch/x86/include/asm/processor.h"
static inline unsigned int cpuid_eax(unsigned int op)
{
  unsigned int eax;
# 653 "./arch/x86/include/asm/processor.h"
  unsigned int ebx;
# 653 "./arch/x86/include/asm/processor.h"
  unsigned int ecx;
# 653 "./arch/x86/include/asm/processor.h"
  unsigned int edx;
# 655 "./arch/x86/include/asm/processor.h"
  cpuid ( op , & eax , & ebx , & ecx , & edx );
# 657 "./arch/x86/include/asm/processor.h"
  return eax;
}
# 660 "./arch/x86/include/asm/processor.h"
static inline unsigned int cpuid_ebx(unsigned int op)
{
  unsigned int eax;
# 662 "./arch/x86/include/asm/processor.h"
  unsigned int ebx;
# 662 "./arch/x86/include/asm/processor.h"
  unsigned int ecx;
# 662 "./arch/x86/include/asm/processor.h"
  unsigned int edx;
# 664 "./arch/x86/include/asm/processor.h"
  cpuid ( op , & eax , & ebx , & ecx , & edx );
# 666 "./arch/x86/include/asm/processor.h"
  return ebx;
}
# 669 "./arch/x86/include/asm/processor.h"
static inline unsigned int cpuid_ecx(unsigned int op)
{
  unsigned int eax;
# 671 "./arch/x86/include/asm/processor.h"
  unsigned int ebx;
# 671 "./arch/x86/include/asm/processor.h"
  unsigned int ecx;
# 671 "./arch/x86/include/asm/processor.h"
  unsigned int edx;
# 673 "./arch/x86/include/asm/processor.h"
  cpuid ( op , & eax , & ebx , & ecx , & edx );
# 675 "./arch/x86/include/asm/processor.h"
  return ecx;
}
# 678 "./arch/x86/include/asm/processor.h"
static inline unsigned int cpuid_edx(unsigned int op)
{
  unsigned int eax;
# 680 "./arch/x86/include/asm/processor.h"
  unsigned int ebx;
# 680 "./arch/x86/include/asm/processor.h"
  unsigned int ecx;
# 680 "./arch/x86/include/asm/processor.h"
  unsigned int edx;
# 682 "./arch/x86/include/asm/processor.h"
  cpuid ( op , & eax , & ebx , & ecx , & edx );
# 684 "./arch/x86/include/asm/processor.h"
  return edx;
}
# 688 "./arch/x86/include/asm/processor.h"
static inline void rep_nop(void)
{
  asm volatile ( "rep; nop" : : : "memory" ) ;
}
# 693 "./arch/x86/include/asm/processor.h"
static inline void cpu_relax(void)
{
  rep_nop ( );
}
# 701 "./arch/x86/include/asm/processor.h"
static inline void sync_core(void)
{
  int tmp;
# 723 "./arch/x86/include/asm/processor.h"
  asm volatile ( "cpuid" : "=a" ( tmp ) : "0" ( 1 ) : "ebx" , "ecx" , "edx" , "memory" ) ;
}
# 730 "./arch/x86/include/asm/processor.h"
void select_idle_routine(struct cpuinfo_x86 const *);
void init_amd_e400_c1e_mask(void);
# 733 "./arch/x86/include/asm/processor.h"
extern long unsigned int boot_option_idle_override;
extern bool amd_e400_c1e_detected;
enum idle_boot_override
{
  IDLE_NO_OVERRIDE = 0,
  IDLE_HALT = 1,
  IDLE_NOMWAIT = 2,
  IDLE_POLL = 3
};
# 739 "./arch/x86/include/asm/processor.h"
void enable_sep_cpu(void);
int sysenter_setup(void);
# 742 "./arch/x86/include/asm/processor.h"
void early_trap_init(void);
void early_trap_pf_init(void);
# 746 "./arch/x86/include/asm/processor.h"
extern struct desc_ptr early_gdt_descr;
# 748 "./arch/x86/include/asm/processor.h"
void cpu_set_gdt(int);
void switch_to_new_gdt(int);
void load_percpu_segment(int);
void cpu_init(void);
# 753 "./arch/x86/include/asm/processor.h"
static inline long unsigned int get_debugctlmsr(void)
{
  long unsigned int debugctlmsr = 0UL;
  {
# 761 "./arch/x86/include/asm/processor.h"
    int _err;
# 761 "./arch/x86/include/asm/processor.h"
    debugctlmsr = ( long unsigned int ) paravirt_read_msr ( 473U , & _err );
  }
  return debugctlmsr;
}
# 766 "./arch/x86/include/asm/processor.h"
static inline void update_debugctlmsr(long unsigned int debugctlmsr)
{
# 772 "./arch/x86/include/asm/processor.h"
  paravirt_write_msr ( 473U , ( unsigned int ) debugctlmsr , ( unsigned int ) ( ( long long unsigned int ) debugctlmsr >> 32 ) );
}
# 775 "./arch/x86/include/asm/processor.h"
void set_task_blockstep(struct task_struct *, bool);
# 781 "./arch/x86/include/asm/processor.h"
extern unsigned int machine_id;
extern unsigned int machine_submodel_id;
extern unsigned int BIOS_revision;
# 786 "./arch/x86/include/asm/processor.h"
extern int bootloader_type;
extern int bootloader_version;
# 789 "./arch/x86/include/asm/processor.h"
extern char ignore_fpu_irq;
# 808 "./arch/x86/include/asm/processor.h"
static inline void prefetch(void const *x)
{
  asm volatile ( "661:\n\tprefetcht0 (%1)\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 0*32+25)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\tprefetchnta (%1)\n6641:\n\t.popsection" : : "i" ( 0 ) , "r" ( x ) ) ;
}
# 821 "./arch/x86/include/asm/processor.h"
static inline void prefetchw(void const *x)
{
  asm volatile ( "661:\n\tprefetcht0 (%1)\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 1*32+31)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\tprefetchw (%1)\n6641:\n\t.popsection" : : "i" ( 0 ) , "r" ( x ) ) ;
}
# 829 "./arch/x86/include/asm/processor.h"
static inline void spin_lock_prefetch(void const *x)
{
  prefetchw ( x );
}
# 929 "./arch/x86/include/asm/processor.h"
long unsigned int KSTK_ESP(struct task_struct *);
# 934 "./arch/x86/include/asm/processor.h"
extern char __pcpu_scope_old_rsp;
# 934 "./arch/x86/include/asm/processor.h"
extern long unsigned int old_rsp;
# 938 "./arch/x86/include/asm/processor.h"
void start_thread(struct pt_regs *, long unsigned int, long unsigned int);
# 953 "./arch/x86/include/asm/processor.h"
int get_tsc_mode(long unsigned int);
int set_tsc_mode(unsigned int);
# 956 "./arch/x86/include/asm/processor.h"
u16 amd_get_nb_id(int);
# 958 "./arch/x86/include/asm/processor.h"
static inline uint32_t hypervisor_cpuid_base(char const *sig, uint32_t leaves)
{
  uint32_t base;
# 960 "./arch/x86/include/asm/processor.h"
  uint32_t eax;
# 960 "./arch/x86/include/asm/processor.h"
  uint32_t signature[3U];
# 962 "./arch/x86/include/asm/processor.h"
  base = 1073741824U;
# 962 "./arch/x86/include/asm/processor.h"
  goto ldv_5488;
  ldv_5487:;
# 963 "./arch/x86/include/asm/processor.h"
  cpuid ( base , ( unsigned int *) & eax , ( unsigned int *) & signature , ( unsigned int *) & signature + 1U , ( unsigned int *) & signature + 2U );
# 965 "./arch/x86/include/asm/processor.h"
  if (memcmp ( ( void const *) sig , ( void const *) & signature , 12UL ) == 0 && ( leaves
# 966 "./arch/x86/include/asm/processor.h"
  == 0U || eax - base >= leaves ))
    return base;
# 962 "./arch/x86/include/asm/processor.h"
  base += 256U;
  ldv_5488:;
# 962 "./arch/x86/include/asm/processor.h"
  if (base <= 1073807359U)
  {
    goto ldv_5487;
  }
  else
    goto ldv_5489;
  ldv_5489:;
# 970 "./arch/x86/include/asm/processor.h"
  return 0U;
}
# 973 "./arch/x86/include/asm/processor.h"
long unsigned int arch_align_stack(long unsigned int);
void free_init_pages(char *, long unsigned int, long unsigned int);
# 976 "./arch/x86/include/asm/processor.h"
void default_idle(void);
# 978 "./arch/x86/include/asm/processor.h"
bool xen_set_default_idle(void);
# 983 "./arch/x86/include/asm/processor.h"
void stop_this_cpu(void *);
void df_debug(struct pt_regs *, long int);
# 13 "./arch/x86/include/asm/cmpxchg.h"
void __xchg_wrong_size(void);
# 15 "./arch/x86/include/asm/cmpxchg.h"
void __cmpxchg_wrong_size(void);
# 17 "./arch/x86/include/asm/cmpxchg.h"
void __xadd_wrong_size(void);
# 19 "./arch/x86/include/asm/cmpxchg.h"
void __add_wrong_size(void);
# 4 "./arch/x86/include/asm/cmpxchg_64.h"
static inline void set_64bit(u64 volatile *ptr, u64 val)
{
  * ptr = val;
}
# 25 "./arch/x86/include/asm/atomic.h"
static inline int atomic_read(atomic_t const *v)
{
  return ( int ) * ( int volatile *) & ( * v ) . counter;
}
# 37 "./arch/x86/include/asm/atomic.h"
static inline void atomic_set(atomic_t *v, int i)
{
  ( * v ) . counter = i;
}
# 49 "./arch/x86/include/asm/atomic.h"
static inline void atomic_add(int i, atomic_t *v)
{
  asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addl %1,%0" : "+m" ( (
# 52 "./arch/x86/include/asm/atomic.h"
  * v ) . counter ) : "ir" ( i ) ) ;
}
# 63 "./arch/x86/include/asm/atomic.h"
static inline void atomic_sub(int i, atomic_t *v)
{
  asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %1,%0" : "+m" ( (
# 66 "./arch/x86/include/asm/atomic.h"
  * v ) . counter ) : "ir" ( i ) ) ;
}
# 79 "./arch/x86/include/asm/atomic.h"
static inline int atomic_sub_and_test(int i, atomic_t *v)
{
  {
# 81 "./arch/x86/include/asm/atomic.h"
    char c;
# 81 "./arch/x86/include/asm/atomic.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %2, %0; sete %1" : "+m" ( ( * v ) . counter ) , "=qm" ( c ) : "er" ( i ) : "memory" ) ;
# 81 "./arch/x86/include/asm/atomic.h"
    return ( signed char ) c != 0;
  }
}
# 90 "./arch/x86/include/asm/atomic.h"
static inline void atomic_inc(atomic_t *v)
{
  asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0" : "+m" ( (
# 93 "./arch/x86/include/asm/atomic.h"
  * v ) . counter ) ) ;
}
# 102 "./arch/x86/include/asm/atomic.h"
static inline void atomic_dec(atomic_t *v)
{
  asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0" : "+m" ( (
# 105 "./arch/x86/include/asm/atomic.h"
  * v ) . counter ) ) ;
}
# 116 "./arch/x86/include/asm/atomic.h"
static inline int atomic_dec_and_test(atomic_t *v)
{
  {
# 118 "./arch/x86/include/asm/atomic.h"
    char c;
# 118 "./arch/x86/include/asm/atomic.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1" : "+m" ( ( * v ) . counter ) , "=qm" ( c ) : : "memory" ) ;
# 118 "./arch/x86/include/asm/atomic.h"
    return ( signed char ) c != 0;
  }
}
# 129 "./arch/x86/include/asm/atomic.h"
static inline int atomic_inc_and_test(atomic_t *v)
{
  {
# 131 "./arch/x86/include/asm/atomic.h"
    char c;
# 131 "./arch/x86/include/asm/atomic.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0; sete %1" : "+m" ( ( * v ) . counter ) , "=qm" ( c ) : : "memory" ) ;
# 131 "./arch/x86/include/asm/atomic.h"
    return ( signed char ) c != 0;
  }
}
# 143 "./arch/x86/include/asm/atomic.h"
static inline int atomic_add_negative(int i, atomic_t *v)
{
  {
# 145 "./arch/x86/include/asm/atomic.h"
    char c;
# 145 "./arch/x86/include/asm/atomic.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addl %2, %0; sets %1" : "+m" ( ( * v ) . counter ) , "=qm" ( c ) : "er" ( i ) : "memory" ) ;
# 145 "./arch/x86/include/asm/atomic.h"
    return ( signed char ) c != 0;
  }
}
# 155 "./arch/x86/include/asm/atomic.h"
static inline int atomic_add_return(int i, atomic_t *v)
{
  return ({
# 157 "./arch/x86/include/asm/atomic.h"
    int __ret = i;
    {
# 157 "./arch/x86/include/asm/atomic.h"
      switch (4UL)
      {
# 157 "./arch/x86/include/asm/atomic.h"
        case 1:;
# 157 "./arch/x86/include/asm/atomic.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n" : "+q" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 157 "./arch/x86/include/asm/atomic.h"
        goto ldv_5562;
# 157 "./arch/x86/include/asm/atomic.h"
        case 2:;
# 157 "./arch/x86/include/asm/atomic.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n" : "+r" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 157 "./arch/x86/include/asm/atomic.h"
        goto ldv_5562;
# 157 "./arch/x86/include/asm/atomic.h"
        case 4:;
# 157 "./arch/x86/include/asm/atomic.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n" : "+r" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 157 "./arch/x86/include/asm/atomic.h"
        goto ldv_5562;
# 157 "./arch/x86/include/asm/atomic.h"
        case 8:;
# 157 "./arch/x86/include/asm/atomic.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n" : "+r" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 157 "./arch/x86/include/asm/atomic.h"
        goto ldv_5562;
# 157 "./arch/x86/include/asm/atomic.h"
        default:;
# 157 "./arch/x86/include/asm/atomic.h"
        __xadd_wrong_size ( );
      }
# 157 "./arch/x86/include/asm/atomic.h"
      ldv_5562:;
    }
# 157 "./arch/x86/include/asm/atomic.h"
    __ret;
  } )
# 157 "./arch/x86/include/asm/atomic.h"
  + i;
}
# 167 "./arch/x86/include/asm/atomic.h"
static inline int atomic_sub_return(int i, atomic_t *v)
{
  return atomic_add_return ( - i , v );
}
# 175 "./arch/x86/include/asm/atomic.h"
static inline int atomic_cmpxchg(atomic_t *v, int old, int new)
{
  return ({
# 177 "./arch/x86/include/asm/atomic.h"
    int __ret;
# 177 "./arch/x86/include/asm/atomic.h"
    int __old = old;
# 177 "./arch/x86/include/asm/atomic.h"
    int __new = new;
    {
# 177 "./arch/x86/include/asm/atomic.h"
      switch (4UL)
      {
# 177 "./arch/x86/include/asm/atomic.h"
        case 1:;
        {
# 177 "./arch/x86/include/asm/atomic.h"
          u8 volatile *__ptr = ( u8 volatile *) & ( * v ) . counter;
# 177 "./arch/x86/include/asm/atomic.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "q" ( __new ) , "0" ( __old ) : "memory" ) ;
# 177 "./arch/x86/include/asm/atomic.h"
          goto ldv_5582;
        }
# 177 "./arch/x86/include/asm/atomic.h"
        case 2:;
        {
# 177 "./arch/x86/include/asm/atomic.h"
          u16 volatile *__ptr = ( u16 volatile *) & ( * v ) . counter;
# 177 "./arch/x86/include/asm/atomic.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 177 "./arch/x86/include/asm/atomic.h"
          goto ldv_5582;
        }
# 177 "./arch/x86/include/asm/atomic.h"
        case 4:;
        {
# 177 "./arch/x86/include/asm/atomic.h"
          u32 volatile *__ptr = ( u32 volatile *) & ( * v ) . counter;
# 177 "./arch/x86/include/asm/atomic.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 177 "./arch/x86/include/asm/atomic.h"
          goto ldv_5582;
        }
# 177 "./arch/x86/include/asm/atomic.h"
        case 8:;
        {
# 177 "./arch/x86/include/asm/atomic.h"
          u64 volatile *__ptr = ( u64 volatile *) & ( * v ) . counter;
# 177 "./arch/x86/include/asm/atomic.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 177 "./arch/x86/include/asm/atomic.h"
          goto ldv_5582;
        }
# 177 "./arch/x86/include/asm/atomic.h"
        default:;
# 177 "./arch/x86/include/asm/atomic.h"
        __cmpxchg_wrong_size ( );
      }
# 177 "./arch/x86/include/asm/atomic.h"
      ldv_5582:;
    }
# 177 "./arch/x86/include/asm/atomic.h"
    __ret;
  } );
}
static inline int atomic_xchg(atomic_t *v, int new)
{
  return ({
# 182 "./arch/x86/include/asm/atomic.h"
    int __ret = new;
    {
# 182 "./arch/x86/include/asm/atomic.h"
      switch (4UL)
      {
# 182 "./arch/x86/include/asm/atomic.h"
        case 1:;
# 182 "./arch/x86/include/asm/atomic.h"
        asm volatile ( "xchgb %b0, %1\n" : "+q" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 182 "./arch/x86/include/asm/atomic.h"
        goto ldv_5597;
# 182 "./arch/x86/include/asm/atomic.h"
        case 2:;
# 182 "./arch/x86/include/asm/atomic.h"
        asm volatile ( "xchgw %w0, %1\n" : "+r" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 182 "./arch/x86/include/asm/atomic.h"
        goto ldv_5597;
# 182 "./arch/x86/include/asm/atomic.h"
        case 4:;
# 182 "./arch/x86/include/asm/atomic.h"
        asm volatile ( "xchgl %0, %1\n" : "+r" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 182 "./arch/x86/include/asm/atomic.h"
        goto ldv_5597;
# 182 "./arch/x86/include/asm/atomic.h"
        case 8:;
# 182 "./arch/x86/include/asm/atomic.h"
        asm volatile ( "xchgq %q0, %1\n" : "+r" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 182 "./arch/x86/include/asm/atomic.h"
        goto ldv_5597;
# 182 "./arch/x86/include/asm/atomic.h"
        default:;
# 182 "./arch/x86/include/asm/atomic.h"
        __xchg_wrong_size ( );
      }
# 182 "./arch/x86/include/asm/atomic.h"
      ldv_5597:;
    }
# 182 "./arch/x86/include/asm/atomic.h"
    __ret;
  } );
}
# 194 "./arch/x86/include/asm/atomic.h"
static inline int __atomic_add_unless(atomic_t *v, int a, int u)
{
  int c;
# 196 "./arch/x86/include/asm/atomic.h"
  int old;
  c = atomic_read ( ( atomic_t const *) v );
  ldv_5611:;
  if (__builtin_expect ( c == u , 0L ) != 0L)
    goto ldv_5610;
  old = atomic_cmpxchg ( v , c , c + a );
  if (__builtin_expect ( old == c , 1L ) != 0L)
    goto ldv_5610;
  c = old;
  goto ldv_5611;
  ldv_5610:;
# 206 "./arch/x86/include/asm/atomic.h"
  return c;
}
# 216 "./arch/x86/include/asm/atomic.h"
static inline short int atomic_inc_short(short int *v)
{
  asm ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addw $1, %0" : "+m" ( * v ) ) ;
  return * v;
}
# 231 "./arch/x86/include/asm/atomic.h"
static inline void atomic_or_long(long unsigned int *v1, long unsigned int v2)
{
  asm ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; orq %1, %0" : "+m" ( * v1 ) : "r" ( v2 ) ) ;
}
# 19 "./arch/x86/include/asm/atomic64_64.h"
static inline long int atomic64_read(atomic64_t const *v)
{
  return ( long int ) * ( long int volatile *) & ( * v ) . counter;
}
# 31 "./arch/x86/include/asm/atomic64_64.h"
static inline void atomic64_set(atomic64_t *v, long int i)
{
  ( * v ) . counter = i;
}
# 43 "./arch/x86/include/asm/atomic64_64.h"
static inline void atomic64_add(long int i, atomic64_t *v)
{
  asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addq %1,%0" : "=m" ( (
# 46 "./arch/x86/include/asm/atomic64_64.h"
  * v ) . counter ) : "er" ( i ) , "m" ( (
# 47 "./arch/x86/include/asm/atomic64_64.h"
  * v ) . counter ) ) ;
}
# 57 "./arch/x86/include/asm/atomic64_64.h"
static inline void atomic64_sub(long int i, atomic64_t *v)
{
  asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subq %1,%0" : "=m" ( (
# 60 "./arch/x86/include/asm/atomic64_64.h"
  * v ) . counter ) : "er" ( i ) , "m" ( (
# 61 "./arch/x86/include/asm/atomic64_64.h"
  * v ) . counter ) ) ;
}
# 73 "./arch/x86/include/asm/atomic64_64.h"
static inline int atomic64_sub_and_test(long int i, atomic64_t *v)
{
  {
# 75 "./arch/x86/include/asm/atomic64_64.h"
    char c;
# 75 "./arch/x86/include/asm/atomic64_64.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subq %2, %0; sete %1" : "+m" ( ( * v ) . counter ) , "=qm" ( c ) : "er" ( i ) : "memory" ) ;
# 75 "./arch/x86/include/asm/atomic64_64.h"
    return ( signed char ) c != 0;
  }
}
# 84 "./arch/x86/include/asm/atomic64_64.h"
static inline void atomic64_inc(atomic64_t *v)
{
  asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incq %0" : "=m" ( (
# 87 "./arch/x86/include/asm/atomic64_64.h"
  * v ) . counter ) : "m" ( (
# 88 "./arch/x86/include/asm/atomic64_64.h"
  * v ) . counter ) ) ;
}
# 97 "./arch/x86/include/asm/atomic64_64.h"
static inline void atomic64_dec(atomic64_t *v)
{
  asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decq %0" : "=m" ( (
# 100 "./arch/x86/include/asm/atomic64_64.h"
  * v ) . counter ) : "m" ( (
# 101 "./arch/x86/include/asm/atomic64_64.h"
  * v ) . counter ) ) ;
}
# 112 "./arch/x86/include/asm/atomic64_64.h"
static inline int atomic64_dec_and_test(atomic64_t *v)
{
  {
# 114 "./arch/x86/include/asm/atomic64_64.h"
    char c;
# 114 "./arch/x86/include/asm/atomic64_64.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decq %0; sete %1" : "+m" ( ( * v ) . counter ) , "=qm" ( c ) : : "memory" ) ;
# 114 "./arch/x86/include/asm/atomic64_64.h"
    return ( signed char ) c != 0;
  }
}
# 125 "./arch/x86/include/asm/atomic64_64.h"
static inline int atomic64_inc_and_test(atomic64_t *v)
{
  {
# 127 "./arch/x86/include/asm/atomic64_64.h"
    char c;
# 127 "./arch/x86/include/asm/atomic64_64.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incq %0; sete %1" : "+m" ( ( * v ) . counter ) , "=qm" ( c ) : : "memory" ) ;
# 127 "./arch/x86/include/asm/atomic64_64.h"
    return ( signed char ) c != 0;
  }
}
# 139 "./arch/x86/include/asm/atomic64_64.h"
static inline int atomic64_add_negative(long int i, atomic64_t *v)
{
  {
# 141 "./arch/x86/include/asm/atomic64_64.h"
    char c;
# 141 "./arch/x86/include/asm/atomic64_64.h"
    asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addq %2, %0; sets %1" : "+m" ( ( * v ) . counter ) , "=qm" ( c ) : "er" ( i ) : "memory" ) ;
# 141 "./arch/x86/include/asm/atomic64_64.h"
    return ( signed char ) c != 0;
  }
}
# 151 "./arch/x86/include/asm/atomic64_64.h"
static inline long int atomic64_add_return(long int i, atomic64_t *v)
{
  return ({
# 153 "./arch/x86/include/asm/atomic64_64.h"
    long int __ret = i;
    {
# 153 "./arch/x86/include/asm/atomic64_64.h"
      switch (8UL)
      {
# 153 "./arch/x86/include/asm/atomic64_64.h"
        case 1:;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n" : "+q" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        goto ldv_5664;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        case 2:;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n" : "+r" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        goto ldv_5664;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        case 4:;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n" : "+r" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        goto ldv_5664;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        case 8:;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n" : "+r" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        goto ldv_5664;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        default:;
# 153 "./arch/x86/include/asm/atomic64_64.h"
        __xadd_wrong_size ( );
      }
# 153 "./arch/x86/include/asm/atomic64_64.h"
      ldv_5664:;
    }
# 153 "./arch/x86/include/asm/atomic64_64.h"
    __ret;
  } )
# 153 "./arch/x86/include/asm/atomic64_64.h"
  + i;
}
# 156 "./arch/x86/include/asm/atomic64_64.h"
static inline long int atomic64_sub_return(long int i, atomic64_t *v)
{
  return atomic64_add_return ( - i , v );
}
# 164 "./arch/x86/include/asm/atomic64_64.h"
static inline long int atomic64_cmpxchg(atomic64_t *v, long int old, long int new)
{
  return ({
# 166 "./arch/x86/include/asm/atomic64_64.h"
    long int __ret;
# 166 "./arch/x86/include/asm/atomic64_64.h"
    long int __old = old;
# 166 "./arch/x86/include/asm/atomic64_64.h"
    long int __new = new;
    {
# 166 "./arch/x86/include/asm/atomic64_64.h"
      switch (8UL)
      {
# 166 "./arch/x86/include/asm/atomic64_64.h"
        case 1:;
        {
# 166 "./arch/x86/include/asm/atomic64_64.h"
          u8 volatile *__ptr = ( u8 volatile *) & ( * v ) . counter;
# 166 "./arch/x86/include/asm/atomic64_64.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "q" ( __new ) , "0" ( __old ) : "memory" ) ;
# 166 "./arch/x86/include/asm/atomic64_64.h"
          goto ldv_5684;
        }
# 166 "./arch/x86/include/asm/atomic64_64.h"
        case 2:;
        {
# 166 "./arch/x86/include/asm/atomic64_64.h"
          u16 volatile *__ptr = ( u16 volatile *) & ( * v ) . counter;
# 166 "./arch/x86/include/asm/atomic64_64.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 166 "./arch/x86/include/asm/atomic64_64.h"
          goto ldv_5684;
        }
# 166 "./arch/x86/include/asm/atomic64_64.h"
        case 4:;
        {
# 166 "./arch/x86/include/asm/atomic64_64.h"
          u32 volatile *__ptr = ( u32 volatile *) & ( * v ) . counter;
# 166 "./arch/x86/include/asm/atomic64_64.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 166 "./arch/x86/include/asm/atomic64_64.h"
          goto ldv_5684;
        }
# 166 "./arch/x86/include/asm/atomic64_64.h"
        case 8:;
        {
# 166 "./arch/x86/include/asm/atomic64_64.h"
          u64 volatile *__ptr = ( u64 volatile *) & ( * v ) . counter;
# 166 "./arch/x86/include/asm/atomic64_64.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 166 "./arch/x86/include/asm/atomic64_64.h"
          goto ldv_5684;
        }
# 166 "./arch/x86/include/asm/atomic64_64.h"
        default:;
# 166 "./arch/x86/include/asm/atomic64_64.h"
        __cmpxchg_wrong_size ( );
      }
# 166 "./arch/x86/include/asm/atomic64_64.h"
      ldv_5684:;
    }
# 166 "./arch/x86/include/asm/atomic64_64.h"
    __ret;
  } );
}
static inline long int atomic64_xchg(atomic64_t *v, long int new)
{
  return ({
# 171 "./arch/x86/include/asm/atomic64_64.h"
    long int __ret = new;
    {
# 171 "./arch/x86/include/asm/atomic64_64.h"
      switch (8UL)
      {
# 171 "./arch/x86/include/asm/atomic64_64.h"
        case 1:;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        asm volatile ( "xchgb %b0, %1\n" : "+q" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        goto ldv_5699;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        case 2:;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        asm volatile ( "xchgw %w0, %1\n" : "+r" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        goto ldv_5699;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        case 4:;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        asm volatile ( "xchgl %0, %1\n" : "+r" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        goto ldv_5699;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        case 8:;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        asm volatile ( "xchgq %q0, %1\n" : "+r" ( __ret ) , "+m" ( ( * v ) . counter ) : : "memory" , "cc" ) ;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        goto ldv_5699;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        default:;
# 171 "./arch/x86/include/asm/atomic64_64.h"
        __xchg_wrong_size ( );
      }
# 171 "./arch/x86/include/asm/atomic64_64.h"
      ldv_5699:;
    }
# 171 "./arch/x86/include/asm/atomic64_64.h"
    __ret;
  } );
}
# 183 "./arch/x86/include/asm/atomic64_64.h"
static inline int atomic64_add_unless(atomic64_t *v, long int a, long int u)
{
  long int c;
# 185 "./arch/x86/include/asm/atomic64_64.h"
  long int old;
  c = atomic64_read ( ( atomic64_t const *) v );
  ldv_5713:;
  if (__builtin_expect ( c == u , 0L ) != 0L)
    goto ldv_5712;
  old = atomic64_cmpxchg ( v , c , c + a );
  if (__builtin_expect ( old == c , 1L ) != 0L)
    goto ldv_5712;
  c = old;
  goto ldv_5713;
  ldv_5712:;
# 195 "./arch/x86/include/asm/atomic64_64.h"
  return c != u;
}
# 207 "./arch/x86/include/asm/atomic64_64.h"
static inline long int atomic64_dec_if_positive(atomic64_t *v)
{
  long int c;
# 209 "./arch/x86/include/asm/atomic64_64.h"
  long int old;
# 209 "./arch/x86/include/asm/atomic64_64.h"
  long int dec;
  c = atomic64_read ( ( atomic64_t const *) v );
  ldv_5721:;
  dec = c + -1L;
  if (__builtin_expect ( dec < 0L , 0L ) != 0L)
    goto ldv_5720;
  old = atomic64_cmpxchg ( v , c , dec );
  if (__builtin_expect ( old == c , 1L ) != 0L)
    goto ldv_5720;
  c = old;
  goto ldv_5721;
  ldv_5720:;
# 220 "./arch/x86/include/asm/atomic64_64.h"
  return dec;
}
# 13 "include/linux/atomic.h"
void __smp_mb__before_atomic(void);
# 11 "include/linux/atomic.h"
static inline void smp_mb__before_atomic_inc(void)
{
  void __smp_mb__before_atomic(void);
  __smp_mb__before_atomic ( );
}
# 21 "include/linux/atomic.h"
void __smp_mb__after_atomic(void);
# 19 "include/linux/atomic.h"
static inline void smp_mb__after_atomic_inc(void)
{
  void __smp_mb__after_atomic(void);
  __smp_mb__after_atomic ( );
}
# 29 "include/linux/atomic.h"
void __smp_mb__before_atomic(void);
# 27 "include/linux/atomic.h"
static inline void smp_mb__before_atomic_dec(void)
{
  void __smp_mb__before_atomic(void);
  __smp_mb__before_atomic ( );
}
# 37 "include/linux/atomic.h"
void __smp_mb__after_atomic(void);
# 35 "include/linux/atomic.h"
static inline void smp_mb__after_atomic_dec(void)
{
  void __smp_mb__after_atomic(void);
  __smp_mb__after_atomic ( );
}
# 51 "include/linux/atomic.h"
static inline int atomic_add_unless(atomic_t *v, int a, int u)
{
  return __atomic_add_unless ( v , a , u ) != u;
}
# 80 "include/linux/atomic.h"
static inline int atomic_inc_not_zero_hint(atomic_t *v, int hint)
{
  int val;
# 82 "include/linux/atomic.h"
  int c = hint;
# 85 "include/linux/atomic.h"
  if (hint == 0)
    return atomic_add_unless ( v , 1 , 0 );
  ldv_5757:;
# 89 "include/linux/atomic.h"
  val = atomic_cmpxchg ( v , c , c + 1 );
  if (val == c)
    return 1;
  c = val;
  if (c != 0)
  {
    goto ldv_5757;
  }
  else
    goto ldv_5758;
  ldv_5758:;
# 95 "include/linux/atomic.h"
  return 0;
}
# 100 "include/linux/atomic.h"
static inline int atomic_inc_unless_negative(atomic_t *p)
{
  int v;
# 102 "include/linux/atomic.h"
  int v1;
  v = 0;
# 103 "include/linux/atomic.h"
  goto ldv_5765;
  ldv_5764:;
# 104 "include/linux/atomic.h"
  v1 = atomic_cmpxchg ( p , v , v + 1 );
  if (__builtin_expect ( v1 == v , 1L ) != 0L)
    return 1;
# 103 "include/linux/atomic.h"
  v = v1;
  ldv_5765:;
# 103 "include/linux/atomic.h"
  if (v >= 0)
  {
    goto ldv_5764;
  }
  else
    goto ldv_5766;
  ldv_5766:;
# 108 "include/linux/atomic.h"
  return 0;
}
# 113 "include/linux/atomic.h"
static inline int atomic_dec_unless_positive(atomic_t *p)
{
  int v;
# 115 "include/linux/atomic.h"
  int v1;
  v = 0;
# 116 "include/linux/atomic.h"
  goto ldv_5773;
  ldv_5772:;
# 117 "include/linux/atomic.h"
  v1 = atomic_cmpxchg ( p , v , v + -1 );
  if (__builtin_expect ( v1 == v , 1L ) != 0L)
    return 1;
# 116 "include/linux/atomic.h"
  v = v1;
  ldv_5773:;
# 116 "include/linux/atomic.h"
  if (v <= 0)
  {
    goto ldv_5772;
  }
  else
    goto ldv_5774;
  ldv_5774:;
# 121 "include/linux/atomic.h"
  return 0;
}
# 133 "include/linux/atomic.h"
static inline int atomic_dec_if_positive(atomic_t *v)
{
  int c;
# 135 "include/linux/atomic.h"
  int old;
# 135 "include/linux/atomic.h"
  int dec;
  c = atomic_read ( ( atomic_t const *) v );
  ldv_5782:;
  dec = c + -1;
  if (__builtin_expect ( dec < 0 , 0L ) != 0L)
    goto ldv_5781;
  old = atomic_cmpxchg ( v , c , dec );
  if (__builtin_expect ( old == c , 1L ) != 0L)
    goto ldv_5781;
  c = old;
  goto ldv_5782;
  ldv_5781:;
# 146 "include/linux/atomic.h"
  return dec;
}
# 151 "include/linux/atomic.h"
static inline void atomic_or(int i, atomic_t *v)
{
  int old;
  int new;
  ldv_5789:;
# 157 "include/linux/atomic.h"
  old = atomic_read ( ( atomic_t const *) v );
  new = old | i;
  if (atomic_cmpxchg ( v , old , new ) != old)
  {
    goto ldv_5789;
  }
  else
    goto ldv_5790;
  ldv_5790:;
}
# 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
# 27 "include/asm-generic/atomic-long.h"
static inline long int atomic_long_read(atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 31 "include/asm-generic/atomic-long.h"
  return atomic64_read ( ( atomic64_t const *) v );
}
# 34 "include/asm-generic/atomic-long.h"
static inline void atomic_long_set(atomic_long_t *l, long int i)
{
  atomic64_t *v = ( atomic64_t *) l;
# 38 "include/asm-generic/atomic-long.h"
  atomic64_set ( v , i );
}
# 41 "include/asm-generic/atomic-long.h"
static inline void atomic_long_inc(atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 45 "include/asm-generic/atomic-long.h"
  atomic64_inc ( v );
}
# 48 "include/asm-generic/atomic-long.h"
static inline void atomic_long_dec(atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 52 "include/asm-generic/atomic-long.h"
  atomic64_dec ( v );
}
# 55 "include/asm-generic/atomic-long.h"
static inline void atomic_long_add(long int i, atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 59 "include/asm-generic/atomic-long.h"
  atomic64_add ( i , v );
}
# 62 "include/asm-generic/atomic-long.h"
static inline void atomic_long_sub(long int i, atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 66 "include/asm-generic/atomic-long.h"
  atomic64_sub ( i , v );
}
# 69 "include/asm-generic/atomic-long.h"
static inline int atomic_long_sub_and_test(long int i, atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 73 "include/asm-generic/atomic-long.h"
  return atomic64_sub_and_test ( i , v );
}
# 76 "include/asm-generic/atomic-long.h"
static inline int atomic_long_dec_and_test(atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 80 "include/asm-generic/atomic-long.h"
  return atomic64_dec_and_test ( v );
}
# 83 "include/asm-generic/atomic-long.h"
static inline int atomic_long_inc_and_test(atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 87 "include/asm-generic/atomic-long.h"
  return atomic64_inc_and_test ( v );
}
# 90 "include/asm-generic/atomic-long.h"
static inline int atomic_long_add_negative(long int i, atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 94 "include/asm-generic/atomic-long.h"
  return atomic64_add_negative ( i , v );
}
# 97 "include/asm-generic/atomic-long.h"
static inline long int atomic_long_add_return(long int i, atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 101 "include/asm-generic/atomic-long.h"
  return atomic64_add_return ( i , v );
}
# 104 "include/asm-generic/atomic-long.h"
static inline long int atomic_long_sub_return(long int i, atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 108 "include/asm-generic/atomic-long.h"
  return atomic64_sub_return ( i , v );
}
# 111 "include/asm-generic/atomic-long.h"
static inline long int atomic_long_inc_return(atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 115 "include/asm-generic/atomic-long.h"
  return atomic64_add_return ( 1L , v );
}
# 118 "include/asm-generic/atomic-long.h"
static inline long int atomic_long_dec_return(atomic_long_t *l)
{
  atomic64_t *v = ( atomic64_t *) l;
# 122 "include/asm-generic/atomic-long.h"
  return atomic64_sub_return ( 1L , v );
}
# 125 "include/asm-generic/atomic-long.h"
static inline long int atomic_long_add_unless(atomic_long_t *l, long int a, long int u)
{
  atomic64_t *v = ( atomic64_t *) l;
# 129 "include/asm-generic/atomic-long.h"
  return ( long int ) atomic64_add_unless ( v , a , u );
}
# 10 "include/linux/debug_locks.h"
extern int debug_locks;
extern int debug_locks_silent;
# 14 "include/linux/debug_locks.h"
static inline int __debug_locks_off(void)
{
  return ({
# 16 "include/linux/debug_locks.h"
    int __ret = 0;
    {
# 16 "include/linux/debug_locks.h"
      switch (4UL)
      {
# 16 "include/linux/debug_locks.h"
        case 1:;
# 16 "include/linux/debug_locks.h"
        asm volatile ( "xchgb %b0, %1\n" : "+q" ( __ret ) , "+m" ( debug_locks ) : : "memory" , "cc" ) ;
# 16 "include/linux/debug_locks.h"
        goto ldv_5868;
# 16 "include/linux/debug_locks.h"
        case 2:;
# 16 "include/linux/debug_locks.h"
        asm volatile ( "xchgw %w0, %1\n" : "+r" ( __ret ) , "+m" ( debug_locks ) : : "memory" , "cc" ) ;
# 16 "include/linux/debug_locks.h"
        goto ldv_5868;
# 16 "include/linux/debug_locks.h"
        case 4:;
# 16 "include/linux/debug_locks.h"
        asm volatile ( "xchgl %0, %1\n" : "+r" ( __ret ) , "+m" ( debug_locks ) : : "memory" , "cc" ) ;
# 16 "include/linux/debug_locks.h"
        goto ldv_5868;
# 16 "include/linux/debug_locks.h"
        case 8:;
# 16 "include/linux/debug_locks.h"
        asm volatile ( "xchgq %q0, %1\n" : "+r" ( __ret ) , "+m" ( debug_locks ) : : "memory" , "cc" ) ;
# 16 "include/linux/debug_locks.h"
        goto ldv_5868;
# 16 "include/linux/debug_locks.h"
        default:;
# 16 "include/linux/debug_locks.h"
        __xchg_wrong_size ( );
      }
# 16 "include/linux/debug_locks.h"
      ldv_5868:;
    }
# 16 "include/linux/debug_locks.h"
    __ret;
  } );
}
# 22 "include/linux/debug_locks.h"
int debug_locks_off(void);
# 43 "include/linux/debug_locks.h"
void locking_selftest(void);
# 51 "include/linux/debug_locks.h"
void debug_show_all_locks(void);
void debug_show_held_locks(struct task_struct *);
void debug_check_no_locks_freed(void const *, long unsigned int);
void debug_check_no_locks_held(void);
struct stack_trace
{
# 11 "include/linux/stacktrace.h"
  unsigned int nr_entries;
# 11 "include/linux/stacktrace.h"
  unsigned int max_entries;
  long unsigned int *entries;
  int skip;
};
# 16 "include/linux/stacktrace.h"
void save_stack_trace(struct stack_trace *);
void save_stack_trace_regs(struct pt_regs *, struct stack_trace *);
# 19 "include/linux/stacktrace.h"
void save_stack_trace_tsk(struct task_struct *, struct stack_trace *);
# 22 "include/linux/stacktrace.h"
void print_stack_trace(struct stack_trace *, int);
# 25 "include/linux/stacktrace.h"
void save_stack_trace_user(struct stack_trace *);
struct lockdep_subclass_key
{
# 51 "include/linux/lockdep.h"
  char __one_byte;
};
struct lock_class_key
{
  struct lockdep_subclass_key subkeys[8U];
};
# 58 "include/linux/lockdep.h"
extern struct lock_class_key __lockdep_no_validate__;
struct lock_class
{
# 69 "include/linux/lockdep.h"
  struct list_head hash_entry;
# 74 "include/linux/lockdep.h"
  struct list_head lock_entry;
# 76 "include/linux/lockdep.h"
  struct lockdep_subclass_key *key;
  unsigned int subclass;
  unsigned int dep_gen_id;
# 83 "include/linux/lockdep.h"
  long unsigned int usage_mask;
  struct stack_trace usage_traces[13U];
# 91 "include/linux/lockdep.h"
  struct list_head locks_after;
# 91 "include/linux/lockdep.h"
  struct list_head locks_before;
# 97 "include/linux/lockdep.h"
  unsigned int version;
# 102 "include/linux/lockdep.h"
  long unsigned int ops;
# 104 "include/linux/lockdep.h"
  char const *name;
  int name_version;
# 108 "include/linux/lockdep.h"
  long unsigned int contention_point[4U];
  long unsigned int contending_point[4U];
};
struct lock_time
{
# 115 "include/linux/lockdep.h"
  s64 min;
  s64 max;
  s64 total;
  long unsigned int nr;
};
enum bounce_type
{
  bounce_acquired_write = 0,
  bounce_acquired_read = 1,
  bounce_contended_write = 2,
  bounce_contended_read = 3,
  nr_bounce_types = 4,
  bounce_acquired = 0,
  bounce_contended = 2
};
struct lock_class_stats
{
# 133 "include/linux/lockdep.h"
  long unsigned int contention_point[4U];
  long unsigned int contending_point[4U];
  struct lock_time read_waittime;
  struct lock_time write_waittime;
  struct lock_time read_holdtime;
  struct lock_time write_holdtime;
  long unsigned int bounces[4U];
};
# 142 "include/linux/lockdep.h"
struct lock_class_stats lock_stats(struct lock_class *);
void clear_lock_stats(struct lock_class *);
struct lockdep_map
{
# 151 "include/linux/lockdep.h"
  struct lock_class_key *key;
  struct lock_class *class_cache[2U];
  char const *name;
# 155 "include/linux/lockdep.h"
  int cpu;
  long unsigned int ip;
};
# 160 "include/linux/lockdep.h"
static inline void lockdep_copy_map(struct lockdep_map *to, struct lockdep_map *from)
{
# 163 "include/linux/lockdep.h"
  int i;
# 165 "include/linux/lockdep.h"
  * to = * from;
# 174 "include/linux/lockdep.h"
  i = 0;
# 174 "include/linux/lockdep.h"
  goto ldv_5962;
  ldv_5961:;
# 175 "include/linux/lockdep.h"
  ( * to ) . class_cache [ i ] = ( ( struct lock_class *) 0 );
# 174 "include/linux/lockdep.h"
  i ++;
  ldv_5962:;
# 174 "include/linux/lockdep.h"
  if (i <= 1)
  {
    goto ldv_5961;
  }
  else
    goto ldv_5963;
  ldv_5963:;
}
struct lock_list
{
# 183 "include/linux/lockdep.h"
  struct list_head entry;
  struct lock_class *class;
  struct stack_trace trace;
  int distance;
# 192 "include/linux/lockdep.h"
  struct lock_list *parent;
};
struct lock_chain
{
# 199 "include/linux/lockdep.h"
  u8 irq_context;
  u8 depth;
  u16 base;
  struct list_head entry;
  u64 chain_key;
};
struct held_lock
{
# 229 "include/linux/lockdep.h"
  u64 prev_chain_key;
  long unsigned int acquire_ip;
  struct lockdep_map *instance;
  struct lockdep_map *nest_lock;
# 234 "include/linux/lockdep.h"
  u64 waittime_stamp;
  u64 holdtime_stamp;
# 237 "include/linux/lockdep.h"
  short unsigned int class_idx : 13;
# 251 "include/linux/lockdep.h"
  unsigned char irq_context : 2;
  unsigned char trylock : 1;
# 254 "include/linux/lockdep.h"
  unsigned char read : 2;
  unsigned char check : 1;
  unsigned char hardirqs_off : 1;
  short unsigned int references : 12;
};
# 263 "include/linux/lockdep.h"
void lockdep_init(void);
void lockdep_info(void);
void lockdep_reset(void);
void lockdep_reset_lock(struct lockdep_map *);
void lockdep_free_key_range(void *, long unsigned int);
void lockdep_sys_exit(void);
# 270 "include/linux/lockdep.h"
void lockdep_off(void);
void lockdep_on(void);
# 279 "include/linux/lockdep.h"
void lockdep_init_map(struct lockdep_map *, char const *, struct lock_class_key *, int);
# 312 "include/linux/lockdep.h"
static inline int lockdep_match_key(struct lockdep_map *lock, struct lock_class_key *key)
{
# 315 "include/linux/lockdep.h"
  return ( * lock ) . key == key;
}
# 332 "include/linux/lockdep.h"
void lock_acquire(struct lockdep_map *, unsigned int, int, int, int, struct lockdep_map *, long unsigned int);
# 336 "include/linux/lockdep.h"
void lock_release(struct lockdep_map *, int, long unsigned int);
# 341 "include/linux/lockdep.h"
int lock_is_held(struct lockdep_map *);
# 343 "include/linux/lockdep.h"
void lock_set_class(struct lockdep_map *, char const *, struct lock_class_key *, unsigned int, long unsigned int);
# 347 "include/linux/lockdep.h"
static inline void lock_set_subclass(struct lockdep_map *lock, unsigned int subclass, long unsigned int ip)
{
# 350 "include/linux/lockdep.h"
  lock_set_class ( lock , ( * lock ) . name , ( * lock ) . key , subclass , ip );
}
# 353 "include/linux/lockdep.h"
void lockdep_set_current_reclaim_state(gfp_t);
void lockdep_clear_current_reclaim_state(void);
void lockdep_trace_alloc(gfp_t);
# 422 "include/linux/lockdep.h"
void lock_contended(struct lockdep_map *, long unsigned int);
void lock_acquired(struct lockdep_map *, long unsigned int);
# 462 "include/linux/lockdep.h"
void print_irqtrace_events(struct task_struct *);
# 529 "include/linux/lockdep.h"
void lockdep_rcu_suspicious(char const *, int const, char const *);
struct raw_spinlock
{
# 21 "include/linux/spinlock_types.h"
  arch_spinlock_t raw_lock;
# 26 "include/linux/spinlock_types.h"
  unsigned int magic;
# 26 "include/linux/spinlock_types.h"
  unsigned int owner_cpu;
  void *owner;
# 30 "include/linux/spinlock_types.h"
  struct lockdep_map dep_map;
};
typedef struct raw_spinlock raw_spinlock_t;
struct spinlock
{
# 75 "include/linux/spinlock_types.h"
  union
  {
# 66 "include/linux/spinlock_types.h"
    struct raw_spinlock rlock;
# 73 "include/linux/spinlock_types.h"
    struct
    {
# 71 "include/linux/spinlock_types.h"
      u8 __padding[24U];
      struct lockdep_map dep_map;
    } ldv_6072;
  } ldv_6073;
};
typedef struct spinlock spinlock_t;
# 23 "include/linux/rwlock_types.h"
typedef struct
{
# 12 "include/linux/rwlock_types.h"
  arch_rwlock_t raw_lock;
# 17 "include/linux/rwlock_types.h"
  unsigned int magic;
# 17 "include/linux/rwlock_types.h"
  unsigned int owner_cpu;
  void *owner;
# 21 "include/linux/rwlock_types.h"
  struct lockdep_map dep_map;
} rwlock_t;
struct optimistic_spin_queue
{
# 16 "include/linux/osq_lock.h"
  atomic_t tail;
};
# 22 "include/linux/osq_lock.h"
static inline void osq_lock_init(struct optimistic_spin_queue *lock)
{
  atomic_set ( & ( * lock ) . tail , 0 );
}
struct mutex
{
# 52 "include/linux/mutex.h"
  atomic_t count;
  spinlock_t wait_lock;
  struct list_head wait_list;
# 56 "include/linux/mutex.h"
  struct task_struct *owner;
# 62 "include/linux/mutex.h"
  char const *name;
  void *magic;
# 66 "include/linux/mutex.h"
  struct lockdep_map dep_map;
};
struct mutex_waiter
{
# 75 "include/linux/mutex.h"
  struct list_head list;
  struct task_struct *task;
# 78 "include/linux/mutex.h"
  void *magic;
};
# 22 "include/linux/mutex-debug.h"
void mutex_destroy(struct mutex *);
# 120 "include/linux/mutex.h"
void __mutex_init(struct mutex *, char const *, struct lock_class_key *);
# 129 "include/linux/mutex.h"
static inline int mutex_is_locked(struct mutex *lock)
{
  return atomic_read ( ( atomic_t const *) & ( * lock ) . count ) != 1;
}
# 139 "include/linux/mutex.h"
void mutex_lock_nested(struct mutex *, unsigned int);
void _mutex_lock_nest_lock(struct mutex *, struct lockdep_map *);
# 142 "include/linux/mutex.h"
int mutex_lock_interruptible_nested(struct mutex *, unsigned int);
# 144 "include/linux/mutex.h"
int mutex_lock_killable_nested(struct mutex *, unsigned int);
# 174 "include/linux/mutex.h"
int mutex_trylock(struct mutex *);
int mutex_trylock(struct mutex *);
# 177 "include/linux/mutex.h"
int ldv_mutex_trylock_4(struct mutex *);
# 179 "include/linux/mutex.h"
void mutex_unlock(struct mutex *);
void mutex_unlock(struct mutex *);
# 182 "include/linux/mutex.h"
void ldv_mutex_unlock_2(struct mutex *);
# 184 "include/linux/mutex.h"
void mutex_unlock(struct mutex *);
# 186 "include/linux/mutex.h"
void ldv_mutex_unlock_5(struct mutex *);
# 188 "include/linux/mutex.h"
void mutex_unlock(struct mutex *);
# 190 "include/linux/mutex.h"
void ldv_mutex_unlock_6(struct mutex *);
# 192 "include/linux/mutex.h"
void mutex_unlock(struct mutex *);
# 194 "include/linux/mutex.h"
void ldv_mutex_unlock_9(struct mutex *);
# 196 "include/linux/mutex.h"
void mutex_unlock(struct mutex *);
# 198 "include/linux/mutex.h"
void ldv_mutex_unlock_11(struct mutex *);
# 200 "include/linux/mutex.h"
void mutex_unlock(struct mutex *);
# 202 "include/linux/mutex.h"
void ldv_mutex_unlock_13(struct mutex *);
# 204 "include/linux/mutex.h"
void mutex_unlock(struct mutex *);
# 206 "include/linux/mutex.h"
void ldv_mutex_unlock_15(struct mutex *);
# 208 "include/linux/mutex.h"
void mutex_unlock(struct mutex *);
# 210 "include/linux/mutex.h"
void ldv_mutex_unlock_17(struct mutex *);
# 212 "include/linux/mutex.h"
void mutex_unlock(struct mutex *);
# 214 "include/linux/mutex.h"
void ldv_mutex_unlock_19(struct mutex *);
# 217 "include/linux/mutex.h"
int atomic_dec_and_mutex_lock(atomic_t *, struct mutex *);
# 5 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
int mutex_lock_interruptible(struct mutex *);
int mutex_lock_killable(struct mutex *);
void mutex_lock(struct mutex *);
void mutex_lock(struct mutex *);
# 10 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_1(struct mutex *);
# 12 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void mutex_lock(struct mutex *);
# 14 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_3(struct mutex *);
# 16 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void mutex_lock(struct mutex *);
# 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_7(struct mutex *);
# 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void mutex_lock(struct mutex *);
# 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_8(struct mutex *);
# 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void mutex_lock(struct mutex *);
# 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_10(struct mutex *);
# 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void mutex_lock(struct mutex *);
# 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_12(struct mutex *);
# 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void mutex_lock(struct mutex *);
# 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_14(struct mutex *);
# 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void mutex_lock(struct mutex *);
# 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_16(struct mutex *);
# 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void mutex_lock(struct mutex *);
# 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_18(struct mutex *);
# 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
int ldv_mutex_lock_interruptible_i_mutex_of_inode(struct mutex *);
int ldv_mutex_lock_killable_i_mutex_of_inode(struct mutex *);
void ldv_mutex_lock_nested_i_mutex_of_inode(struct mutex *, unsigned int);
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *);
int ldv_mutex_trylock_i_mutex_of_inode(struct mutex *);
int ldv_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *, struct mutex *);
int ldv_mutex_is_locked_i_mutex_of_inode(struct mutex *);
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *);
int ldv_mutex_lock_interruptible_lock(struct mutex *);
int ldv_mutex_lock_killable_lock(struct mutex *);
void ldv_mutex_lock_nested_lock(struct mutex *, unsigned int);
void ldv_mutex_lock_lock(struct mutex *);
int ldv_mutex_trylock_lock(struct mutex *);
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *, struct mutex *);
int ldv_mutex_is_locked_lock(struct mutex *);
void ldv_mutex_unlock_lock(struct mutex *);
int ldv_mutex_lock_interruptible_lock_of_memstick_host(struct mutex *);
int ldv_mutex_lock_killable_lock_of_memstick_host(struct mutex *);
void ldv_mutex_lock_nested_lock_of_memstick_host(struct mutex *, unsigned int);
void ldv_mutex_lock_lock_of_memstick_host(struct mutex *);
int ldv_mutex_trylock_lock_of_memstick_host(struct mutex *);
int ldv_atomic_dec_and_mutex_lock_lock_of_memstick_host(atomic_t *, struct mutex *);
int ldv_mutex_is_locked_lock_of_memstick_host(struct mutex *);
void ldv_mutex_unlock_lock_of_memstick_host(struct mutex *);
int ldv_mutex_lock_interruptible_msb_disk_lock(struct mutex *);
int ldv_mutex_lock_killable_msb_disk_lock(struct mutex *);
void ldv_mutex_lock_nested_msb_disk_lock(struct mutex *, unsigned int);
void ldv_mutex_lock_msb_disk_lock(struct mutex *);
int ldv_mutex_trylock_msb_disk_lock(struct mutex *);
int ldv_atomic_dec_and_mutex_lock_msb_disk_lock(atomic_t *, struct mutex *);
int ldv_mutex_is_locked_msb_disk_lock(struct mutex *);
void ldv_mutex_unlock_msb_disk_lock(struct mutex *);
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *);
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *);
void ldv_mutex_lock_nested_mutex_of_device(struct mutex *, unsigned int);
void ldv_mutex_lock_mutex_of_device(struct mutex *);
int ldv_mutex_trylock_mutex_of_device(struct mutex *);
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *, struct mutex *);
int ldv_mutex_is_locked_mutex_of_device(struct mutex *);
void ldv_mutex_unlock_mutex_of_device(struct mutex *);
struct stat
{
# 83 "./arch/x86/include/uapi/asm/stat.h"
  __kernel_ulong_t st_dev;
  __kernel_ulong_t st_ino;
  __kernel_ulong_t st_nlink;
# 87 "./arch/x86/include/uapi/asm/stat.h"
  unsigned int st_mode;
  unsigned int st_uid;
  unsigned int st_gid;
  unsigned int __pad0;
  __kernel_ulong_t st_rdev;
  __kernel_long_t st_size;
  __kernel_long_t st_blksize;
  __kernel_long_t st_blocks;
# 96 "./arch/x86/include/uapi/asm/stat.h"
  __kernel_ulong_t st_atime;
  __kernel_ulong_t st_atime_nsec;
  __kernel_ulong_t st_mtime;
  __kernel_ulong_t st_mtime_nsec;
  __kernel_ulong_t st_ctime;
  __kernel_ulong_t st_ctime_nsec;
  __kernel_long_t __unused[3U];
};
struct __old_kernel_stat
{
# 117 "./arch/x86/include/uapi/asm/stat.h"
  short unsigned int st_dev;
  short unsigned int st_ino;
  short unsigned int st_mode;
  short unsigned int st_nlink;
  short unsigned int st_uid;
  short unsigned int st_gid;
  short unsigned int st_rdev;
# 130 "./arch/x86/include/uapi/asm/stat.h"
  unsigned int st_size;
  unsigned int st_atime;
  unsigned int st_mtime;
  unsigned int st_ctime;
};
struct timespec;
struct compat_timespec;
struct restart_block
{
# 20 "include/linux/thread_info.h"
  long int (*fn)(struct restart_block *);
# 48 "include/linux/thread_info.h"
  union
  {
# 30 "include/linux/thread_info.h"
    struct
    {
# 24 "include/linux/thread_info.h"
      u32 *uaddr;
      u32 val;
      u32 flags;
      u32 bitset;
      u64 time;
      u32 *uaddr2;
    } futex;
# 39 "include/linux/thread_info.h"
    struct
    {
# 33 "include/linux/thread_info.h"
      clockid_t clockid;
      struct timespec *rmtp;
# 36 "include/linux/thread_info.h"
      struct compat_timespec *compat_rmtp;
# 38 "include/linux/thread_info.h"
      u64 expires;
    } nanosleep;
# 47 "include/linux/thread_info.h"
    struct
    {
# 42 "include/linux/thread_info.h"
      struct pollfd *ufds;
      int nfds;
      int has_timeout;
      long unsigned int tv_sec;
      long unsigned int tv_nsec;
    } poll;
  } ldv_6358;
};
# 51 "include/linux/thread_info.h"
long int do_no_restart_syscall(struct restart_block *);
struct thread_info
{
# 27 "./arch/x86/include/asm/thread_info.h"
  struct task_struct *task;
  struct exec_domain *exec_domain;
  __u32 flags;
  __u32 status;
  __u32 cpu;
  int saved_preempt_count;
  mm_segment_t addr_limit;
  struct restart_block restart_block;
  void *sysenter_return;
  unsigned char sig_on_uaccess_error : 1;
  unsigned char uaccess_err : 1;
};
# 163 "./arch/x86/include/asm/thread_info.h"
extern char __pcpu_scope_kernel_stack;
# 163 "./arch/x86/include/asm/thread_info.h"
extern long unsigned int kernel_stack;
# 165 "./arch/x86/include/asm/thread_info.h"
static inline struct thread_info *current_thread_info(void)
{
  struct thread_info *ti;
  ti = ( struct thread_info *) ( ({
# 168 "./arch/x86/include/asm/thread_info.h"
    long unsigned int pfo_ret__;
    {
# 168 "./arch/x86/include/asm/thread_info.h"
      switch (8UL)
      {
# 168 "./arch/x86/include/asm/thread_info.h"
        case 1:;
# 168 "./arch/x86/include/asm/thread_info.h"
        asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "p" ( & kernel_stack ) ) ;
# 168 "./arch/x86/include/asm/thread_info.h"
        goto ldv_6381;
# 168 "./arch/x86/include/asm/thread_info.h"
        case 2:;
# 168 "./arch/x86/include/asm/thread_info.h"
        asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "p" ( & kernel_stack ) ) ;
# 168 "./arch/x86/include/asm/thread_info.h"
        goto ldv_6381;
# 168 "./arch/x86/include/asm/thread_info.h"
        case 4:;
# 168 "./arch/x86/include/asm/thread_info.h"
        asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "p" ( & kernel_stack ) ) ;
# 168 "./arch/x86/include/asm/thread_info.h"
        goto ldv_6381;
# 168 "./arch/x86/include/asm/thread_info.h"
        case 8:;
# 168 "./arch/x86/include/asm/thread_info.h"
        asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "p" ( & kernel_stack ) ) ;
# 168 "./arch/x86/include/asm/thread_info.h"
        goto ldv_6381;
# 168 "./arch/x86/include/asm/thread_info.h"
        default:;
# 168 "./arch/x86/include/asm/thread_info.h"
        __bad_percpu_size ( );
      }
# 168 "./arch/x86/include/asm/thread_info.h"
      ldv_6381:;
    }
# 168 "./arch/x86/include/asm/thread_info.h"
    pfo_ret__;
  } ) - 16344UL );
  return ti;
}
# 200 "./arch/x86/include/asm/thread_info.h"
static inline void set_restore_sigmask(void)
{
  struct thread_info *ti = current_thread_info ( );
  ( * ti ) . status |= 8U;
  ({
# 204 "./arch/x86/include/asm/thread_info.h"
    int __ret_warn_on = constant_test_bit ( 2L , ( long unsigned int const volatile *) & ( * ti ) . flags ) == 0;
    {
# 204 "./arch/x86/include/asm/thread_info.h"
      if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 204 "./arch/x86/include/asm/thread_info.h"
        warn_slowpath_null ( ( char const *) "./arch/x86/include/asm/thread_info.h" , 204 );
    }
# 204 "./arch/x86/include/asm/thread_info.h"
    __builtin_expect ( __ret_warn_on != 0 , 0L );
  } );
}
# 206 "./arch/x86/include/asm/thread_info.h"
static inline void clear_restore_sigmask(void)
{
  ( * ( current_thread_info ( ) ) ) . status &= 4294967287U;
}
static inline bool test_restore_sigmask(void)
{
  return ( ( * current_thread_info ( ) ) . status & 8U ) != 0U;
}
static inline bool test_and_clear_restore_sigmask(void)
{
  struct thread_info *ti = current_thread_info ( );
  if (( ( * ti ) . status & 8U ) == 0U)
    return 0;
  ( * ti ) . status &= 4294967287U;
  return 1;
}
# 223 "./arch/x86/include/asm/thread_info.h"
static inline bool is_ia32_task(void)
{
# 229 "./arch/x86/include/asm/thread_info.h"
  if (( ( * current_thread_info ( ) ) . status & 2U ) != 0U)
    return 1;
# 232 "./arch/x86/include/asm/thread_info.h"
  return 0;
}
# 237 "./arch/x86/include/asm/thread_info.h"
void arch_task_cache_init(void);
int arch_dup_task_struct(struct task_struct *, struct task_struct *);
void arch_release_task_struct(struct task_struct *);
# 69 "include/linux/thread_info.h"
static inline void set_ti_thread_flag(struct thread_info *ti, int flag)
{
  set_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * ti ) . flags );
}
# 74 "include/linux/thread_info.h"
static inline void clear_ti_thread_flag(struct thread_info *ti, int flag)
{
  clear_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * ti ) . flags );
}
# 79 "include/linux/thread_info.h"
static inline int test_and_set_ti_thread_flag(struct thread_info *ti, int flag)
{
  return test_and_set_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * ti ) . flags );
}
# 84 "include/linux/thread_info.h"
static inline int test_and_clear_ti_thread_flag(struct thread_info *ti, int flag)
{
  return test_and_clear_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * ti ) . flags );
}
# 89 "include/linux/thread_info.h"
static inline int test_ti_thread_flag(struct thread_info *ti, int flag)
{
  return variable_test_bit ( ( long int ) flag , ( long unsigned int const volatile *) & ( * ti ) . flags );
}
# 8 "./arch/x86/include/asm/preempt.h"
extern char __pcpu_scope___preempt_count;
# 8 "./arch/x86/include/asm/preempt.h"
extern int __preempt_count;
# 20 "./arch/x86/include/asm/preempt.h"
static inline int preempt_count(void)
{
  return ({
# 22 "./arch/x86/include/asm/preempt.h"
    int pfo_ret__;
    {
# 22 "./arch/x86/include/asm/preempt.h"
      switch (4UL)
      {
# 22 "./arch/x86/include/asm/preempt.h"
        case 1:;
# 22 "./arch/x86/include/asm/preempt.h"
        asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( __preempt_count ) ) ;
# 22 "./arch/x86/include/asm/preempt.h"
        goto ldv_6440;
# 22 "./arch/x86/include/asm/preempt.h"
        case 2:;
# 22 "./arch/x86/include/asm/preempt.h"
        asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( __preempt_count ) ) ;
# 22 "./arch/x86/include/asm/preempt.h"
        goto ldv_6440;
# 22 "./arch/x86/include/asm/preempt.h"
        case 4:;
# 22 "./arch/x86/include/asm/preempt.h"
        asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( __preempt_count ) ) ;
# 22 "./arch/x86/include/asm/preempt.h"
        goto ldv_6440;
# 22 "./arch/x86/include/asm/preempt.h"
        case 8:;
# 22 "./arch/x86/include/asm/preempt.h"
        asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( __preempt_count ) ) ;
# 22 "./arch/x86/include/asm/preempt.h"
        goto ldv_6440;
# 22 "./arch/x86/include/asm/preempt.h"
        default:;
# 22 "./arch/x86/include/asm/preempt.h"
        __bad_percpu_size ( );
      }
# 22 "./arch/x86/include/asm/preempt.h"
      ldv_6440:;
    }
# 22 "./arch/x86/include/asm/preempt.h"
    pfo_ret__;
  } ) & 2147483647;
}
static inline void preempt_count_set(int pc)
{
  {
# 27 "./arch/x86/include/asm/preempt.h"
    typedef int pto_T__;
# 27 "./arch/x86/include/asm/preempt.h"
    if (0)
    {
# 27 "./arch/x86/include/asm/preempt.h"
      pto_T__ pto_tmp__;
# 27 "./arch/x86/include/asm/preempt.h"
      pto_tmp__ = pc;
# 27 "./arch/x86/include/asm/preempt.h"
      ( void ) pto_tmp__;
    }
# 27 "./arch/x86/include/asm/preempt.h"
    switch (4UL)
    {
# 27 "./arch/x86/include/asm/preempt.h"
      case 1:;
# 27 "./arch/x86/include/asm/preempt.h"
      asm ( "movb %1,%%gs:%P0" : "+m" ( __preempt_count ) : "qi" ( pc ) ) ;
# 27 "./arch/x86/include/asm/preempt.h"
      goto ldv_6452;
# 27 "./arch/x86/include/asm/preempt.h"
      case 2:;
# 27 "./arch/x86/include/asm/preempt.h"
      asm ( "movw %1,%%gs:%P0" : "+m" ( __preempt_count ) : "ri" ( pc ) ) ;
# 27 "./arch/x86/include/asm/preempt.h"
      goto ldv_6452;
# 27 "./arch/x86/include/asm/preempt.h"
      case 4:;
# 27 "./arch/x86/include/asm/preempt.h"
      asm ( "movl %1,%%gs:%P0" : "+m" ( __preempt_count ) : "ri" ( pc ) ) ;
# 27 "./arch/x86/include/asm/preempt.h"
      goto ldv_6452;
# 27 "./arch/x86/include/asm/preempt.h"
      case 8:;
# 27 "./arch/x86/include/asm/preempt.h"
      asm ( "movq %1,%%gs:%P0" : "+m" ( __preempt_count ) : "re" ( pc ) ) ;
# 27 "./arch/x86/include/asm/preempt.h"
      goto ldv_6452;
# 27 "./arch/x86/include/asm/preempt.h"
      default:;
# 27 "./arch/x86/include/asm/preempt.h"
      __bad_percpu_size ( );
    }
# 27 "./arch/x86/include/asm/preempt.h"
    ldv_6452:;
  }
}
# 54 "./arch/x86/include/asm/preempt.h"
static inline void set_preempt_need_resched(void)
{
  {
# 56 "./arch/x86/include/asm/preempt.h"
    typedef int pto_T__;
# 56 "./arch/x86/include/asm/preempt.h"
    if (0)
    {
# 56 "./arch/x86/include/asm/preempt.h"
      pto_T__ pto_tmp__;
# 56 "./arch/x86/include/asm/preempt.h"
      pto_tmp__ = 2147483647;
# 56 "./arch/x86/include/asm/preempt.h"
      ( void ) pto_tmp__;
    }
# 56 "./arch/x86/include/asm/preempt.h"
    switch (4UL)
    {
# 56 "./arch/x86/include/asm/preempt.h"
      case 1:;
# 56 "./arch/x86/include/asm/preempt.h"
      asm ( "andb %1,%%gs:%P0" : "+m" ( __preempt_count ) : "qi" ( 2147483647 ) ) ;
# 56 "./arch/x86/include/asm/preempt.h"
      goto ldv_6463;
# 56 "./arch/x86/include/asm/preempt.h"
      case 2:;
# 56 "./arch/x86/include/asm/preempt.h"
      asm ( "andw %1,%%gs:%P0" : "+m" ( __preempt_count ) : "ri" ( 2147483647 ) ) ;
# 56 "./arch/x86/include/asm/preempt.h"
      goto ldv_6463;
# 56 "./arch/x86/include/asm/preempt.h"
      case 4:;
# 56 "./arch/x86/include/asm/preempt.h"
      asm ( "andl %1,%%gs:%P0" : "+m" ( __preempt_count ) : "ri" ( 2147483647 ) ) ;
# 56 "./arch/x86/include/asm/preempt.h"
      goto ldv_6463;
# 56 "./arch/x86/include/asm/preempt.h"
      case 8:;
# 56 "./arch/x86/include/asm/preempt.h"
      asm ( "andq %1,%%gs:%P0" : "+m" ( __preempt_count ) : "re" ( 2147483647 ) ) ;
# 56 "./arch/x86/include/asm/preempt.h"
      goto ldv_6463;
# 56 "./arch/x86/include/asm/preempt.h"
      default:;
# 56 "./arch/x86/include/asm/preempt.h"
      __bad_percpu_size ( );
    }
# 56 "./arch/x86/include/asm/preempt.h"
    ldv_6463:;
  }
}
static inline void clear_preempt_need_resched(void)
{
  {
# 61 "./arch/x86/include/asm/preempt.h"
    typedef int pto_T__;
# 61 "./arch/x86/include/asm/preempt.h"
    if (0)
    {
# 61 "./arch/x86/include/asm/preempt.h"
      pto_T__ pto_tmp__;
# 61 "./arch/x86/include/asm/preempt.h"
      pto_tmp__ = -2147483648;
# 61 "./arch/x86/include/asm/preempt.h"
      ( void ) pto_tmp__;
    }
# 61 "./arch/x86/include/asm/preempt.h"
    switch (4UL)
    {
# 61 "./arch/x86/include/asm/preempt.h"
      case 1:;
# 61 "./arch/x86/include/asm/preempt.h"
      asm ( "orb %1,%%gs:%P0" : "+m" ( __preempt_count ) : "qi" ( -2147483648 ) ) ;
# 61 "./arch/x86/include/asm/preempt.h"
      goto ldv_6474;
# 61 "./arch/x86/include/asm/preempt.h"
      case 2:;
# 61 "./arch/x86/include/asm/preempt.h"
      asm ( "orw %1,%%gs:%P0" : "+m" ( __preempt_count ) : "ri" ( -2147483648 ) ) ;
# 61 "./arch/x86/include/asm/preempt.h"
      goto ldv_6474;
# 61 "./arch/x86/include/asm/preempt.h"
      case 4:;
# 61 "./arch/x86/include/asm/preempt.h"
      asm ( "orl %1,%%gs:%P0" : "+m" ( __preempt_count ) : "ri" ( -2147483648 ) ) ;
# 61 "./arch/x86/include/asm/preempt.h"
      goto ldv_6474;
# 61 "./arch/x86/include/asm/preempt.h"
      case 8:;
# 61 "./arch/x86/include/asm/preempt.h"
      asm ( "orq %1,%%gs:%P0" : "+m" ( __preempt_count ) : "re" ( -2147483648 ) ) ;
# 61 "./arch/x86/include/asm/preempt.h"
      goto ldv_6474;
# 61 "./arch/x86/include/asm/preempt.h"
      default:;
# 61 "./arch/x86/include/asm/preempt.h"
      __bad_percpu_size ( );
    }
# 61 "./arch/x86/include/asm/preempt.h"
    ldv_6474:;
  }
}
static inline bool test_preempt_need_resched(void)
{
  return ({
# 66 "./arch/x86/include/asm/preempt.h"
    int pfo_ret__;
    {
# 66 "./arch/x86/include/asm/preempt.h"
      switch (4UL)
      {
# 66 "./arch/x86/include/asm/preempt.h"
        case 1:;
# 66 "./arch/x86/include/asm/preempt.h"
        asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( __preempt_count ) ) ;
# 66 "./arch/x86/include/asm/preempt.h"
        goto ldv_6484;
# 66 "./arch/x86/include/asm/preempt.h"
        case 2:;
# 66 "./arch/x86/include/asm/preempt.h"
        asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( __preempt_count ) ) ;
# 66 "./arch/x86/include/asm/preempt.h"
        goto ldv_6484;
# 66 "./arch/x86/include/asm/preempt.h"
        case 4:;
# 66 "./arch/x86/include/asm/preempt.h"
        asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( __preempt_count ) ) ;
# 66 "./arch/x86/include/asm/preempt.h"
        goto ldv_6484;
# 66 "./arch/x86/include/asm/preempt.h"
        case 8:;
# 66 "./arch/x86/include/asm/preempt.h"
        asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( __preempt_count ) ) ;
# 66 "./arch/x86/include/asm/preempt.h"
        goto ldv_6484;
# 66 "./arch/x86/include/asm/preempt.h"
        default:;
# 66 "./arch/x86/include/asm/preempt.h"
        __bad_percpu_size ( );
      }
# 66 "./arch/x86/include/asm/preempt.h"
      ldv_6484:;
    }
# 66 "./arch/x86/include/asm/preempt.h"
    pfo_ret__;
  } )
# 66 "./arch/x86/include/asm/preempt.h"
  >= 0;
}
# 73 "./arch/x86/include/asm/preempt.h"
static inline void __preempt_count_add(int val)
{
  {
# 75 "./arch/x86/include/asm/preempt.h"
    typedef int pao_T__;
# 75 "./arch/x86/include/asm/preempt.h"
    int const pao_ID__ = 0;
# 75 "./arch/x86/include/asm/preempt.h"
    if (0)
    {
# 75 "./arch/x86/include/asm/preempt.h"
      pao_T__ pao_tmp__;
# 75 "./arch/x86/include/asm/preempt.h"
      pao_tmp__ = val;
# 75 "./arch/x86/include/asm/preempt.h"
      ( void ) pao_tmp__;
    }
# 75 "./arch/x86/include/asm/preempt.h"
    switch (4UL)
    {
# 75 "./arch/x86/include/asm/preempt.h"
      case 1:;
# 75 "./arch/x86/include/asm/preempt.h"
      if (( int ) pao_ID__ == 1)
      {
# 75 "./arch/x86/include/asm/preempt.h"
        asm ( "incb %%gs:%P0" : "+m" ( __preempt_count ) ) ;
      }
      else
# 75 "./arch/x86/include/asm/preempt.h"
        if (( int ) pao_ID__ == -1)
        {
# 75 "./arch/x86/include/asm/preempt.h"
          asm ( "decb %%gs:%P0" : "+m" ( __preempt_count ) ) ;
        }
        else
# 75 "./arch/x86/include/asm/preempt.h"
          asm ( "addb %1, %%gs:%P0" : "+m" ( __preempt_count ) : "qi" ( val ) ) ;
# 75 "./arch/x86/include/asm/preempt.h"
      goto ldv_6497;
# 75 "./arch/x86/include/asm/preempt.h"
      case 2:;
# 75 "./arch/x86/include/asm/preempt.h"
      if (( int ) pao_ID__ == 1)
      {
# 75 "./arch/x86/include/asm/preempt.h"
        asm ( "incw %%gs:%P0" : "+m" ( __preempt_count ) ) ;
      }
      else
# 75 "./arch/x86/include/asm/preempt.h"
        if (( int ) pao_ID__ == -1)
        {
# 75 "./arch/x86/include/asm/preempt.h"
          asm ( "decw %%gs:%P0" : "+m" ( __preempt_count ) ) ;
        }
        else
# 75 "./arch/x86/include/asm/preempt.h"
          asm ( "addw %1, %%gs:%P0" : "+m" ( __preempt_count ) : "ri" ( val ) ) ;
# 75 "./arch/x86/include/asm/preempt.h"
      goto ldv_6497;
# 75 "./arch/x86/include/asm/preempt.h"
      case 4:;
# 75 "./arch/x86/include/asm/preempt.h"
      if (( int ) pao_ID__ == 1)
      {
# 75 "./arch/x86/include/asm/preempt.h"
        asm ( "incl %%gs:%P0" : "+m" ( __preempt_count ) ) ;
      }
      else
# 75 "./arch/x86/include/asm/preempt.h"
        if (( int ) pao_ID__ == -1)
        {
# 75 "./arch/x86/include/asm/preempt.h"
          asm ( "decl %%gs:%P0" : "+m" ( __preempt_count ) ) ;
        }
        else
# 75 "./arch/x86/include/asm/preempt.h"
          asm ( "addl %1, %%gs:%P0" : "+m" ( __preempt_count ) : "ri" ( val ) ) ;
# 75 "./arch/x86/include/asm/preempt.h"
      goto ldv_6497;
# 75 "./arch/x86/include/asm/preempt.h"
      case 8:;
# 75 "./arch/x86/include/asm/preempt.h"
      if (( int ) pao_ID__ == 1)
      {
# 75 "./arch/x86/include/asm/preempt.h"
        asm ( "incq %%gs:%P0" : "+m" ( __preempt_count ) ) ;
      }
      else
# 75 "./arch/x86/include/asm/preempt.h"
        if (( int ) pao_ID__ == -1)
        {
# 75 "./arch/x86/include/asm/preempt.h"
          asm ( "decq %%gs:%P0" : "+m" ( __preempt_count ) ) ;
        }
        else
# 75 "./arch/x86/include/asm/preempt.h"
          asm ( "addq %1, %%gs:%P0" : "+m" ( __preempt_count ) : "re" ( val ) ) ;
# 75 "./arch/x86/include/asm/preempt.h"
      goto ldv_6497;
# 75 "./arch/x86/include/asm/preempt.h"
      default:;
# 75 "./arch/x86/include/asm/preempt.h"
      __bad_percpu_size ( );
    }
# 75 "./arch/x86/include/asm/preempt.h"
    ldv_6497:;
  }
}
static inline void __preempt_count_sub(int val)
{
  {
# 80 "./arch/x86/include/asm/preempt.h"
    typedef int pao_T__;
# 80 "./arch/x86/include/asm/preempt.h"
    int const pao_ID__ = 0;
# 80 "./arch/x86/include/asm/preempt.h"
    if (0)
    {
# 80 "./arch/x86/include/asm/preempt.h"
      pao_T__ pao_tmp__;
# 80 "./arch/x86/include/asm/preempt.h"
      pao_tmp__ = - val;
# 80 "./arch/x86/include/asm/preempt.h"
      ( void ) pao_tmp__;
    }
# 80 "./arch/x86/include/asm/preempt.h"
    switch (4UL)
    {
# 80 "./arch/x86/include/asm/preempt.h"
      case 1:;
# 80 "./arch/x86/include/asm/preempt.h"
      if (( int ) pao_ID__ == 1)
      {
# 80 "./arch/x86/include/asm/preempt.h"
        asm ( "incb %%gs:%P0" : "+m" ( __preempt_count ) ) ;
      }
      else
# 80 "./arch/x86/include/asm/preempt.h"
        if (( int ) pao_ID__ == -1)
        {
# 80 "./arch/x86/include/asm/preempt.h"
          asm ( "decb %%gs:%P0" : "+m" ( __preempt_count ) ) ;
        }
        else
# 80 "./arch/x86/include/asm/preempt.h"
          asm ( "addb %1, %%gs:%P0" : "+m" ( __preempt_count ) : "qi" ( - val ) ) ;
# 80 "./arch/x86/include/asm/preempt.h"
      goto ldv_6509;
# 80 "./arch/x86/include/asm/preempt.h"
      case 2:;
# 80 "./arch/x86/include/asm/preempt.h"
      if (( int ) pao_ID__ == 1)
      {
# 80 "./arch/x86/include/asm/preempt.h"
        asm ( "incw %%gs:%P0" : "+m" ( __preempt_count ) ) ;
      }
      else
# 80 "./arch/x86/include/asm/preempt.h"
        if (( int ) pao_ID__ == -1)
        {
# 80 "./arch/x86/include/asm/preempt.h"
          asm ( "decw %%gs:%P0" : "+m" ( __preempt_count ) ) ;
        }
        else
# 80 "./arch/x86/include/asm/preempt.h"
          asm ( "addw %1, %%gs:%P0" : "+m" ( __preempt_count ) : "ri" ( - val ) ) ;
# 80 "./arch/x86/include/asm/preempt.h"
      goto ldv_6509;
# 80 "./arch/x86/include/asm/preempt.h"
      case 4:;
# 80 "./arch/x86/include/asm/preempt.h"
      if (( int ) pao_ID__ == 1)
      {
# 80 "./arch/x86/include/asm/preempt.h"
        asm ( "incl %%gs:%P0" : "+m" ( __preempt_count ) ) ;
      }
      else
# 80 "./arch/x86/include/asm/preempt.h"
        if (( int ) pao_ID__ == -1)
        {
# 80 "./arch/x86/include/asm/preempt.h"
          asm ( "decl %%gs:%P0" : "+m" ( __preempt_count ) ) ;
        }
        else
# 80 "./arch/x86/include/asm/preempt.h"
          asm ( "addl %1, %%gs:%P0" : "+m" ( __preempt_count ) : "ri" ( - val ) ) ;
# 80 "./arch/x86/include/asm/preempt.h"
      goto ldv_6509;
# 80 "./arch/x86/include/asm/preempt.h"
      case 8:;
# 80 "./arch/x86/include/asm/preempt.h"
      if (( int ) pao_ID__ == 1)
      {
# 80 "./arch/x86/include/asm/preempt.h"
        asm ( "incq %%gs:%P0" : "+m" ( __preempt_count ) ) ;
      }
      else
# 80 "./arch/x86/include/asm/preempt.h"
        if (( int ) pao_ID__ == -1)
        {
# 80 "./arch/x86/include/asm/preempt.h"
          asm ( "decq %%gs:%P0" : "+m" ( __preempt_count ) ) ;
        }
        else
# 80 "./arch/x86/include/asm/preempt.h"
          asm ( "addq %1, %%gs:%P0" : "+m" ( __preempt_count ) : "re" ( - val ) ) ;
# 80 "./arch/x86/include/asm/preempt.h"
      goto ldv_6509;
# 80 "./arch/x86/include/asm/preempt.h"
      default:;
# 80 "./arch/x86/include/asm/preempt.h"
      __bad_percpu_size ( );
    }
# 80 "./arch/x86/include/asm/preempt.h"
    ldv_6509:;
  }
}
# 88 "./arch/x86/include/asm/preempt.h"
static inline bool __preempt_count_dec_and_test(void)
{
  {
# 90 "./arch/x86/include/asm/preempt.h"
    char c;
# 90 "./arch/x86/include/asm/preempt.h"
    asm volatile ( "decl %%gs:%P0; sete %1" : "+m" ( __preempt_count ) , "=qm" ( c ) : : "memory" ) ;
# 90 "./arch/x86/include/asm/preempt.h"
    return ( signed char ) c != 0;
  }
}
# 96 "./arch/x86/include/asm/preempt.h"
static inline bool should_resched(void)
{
  return __builtin_expect ( ({
# 98 "./arch/x86/include/asm/preempt.h"
    int pfo_ret__;
    {
# 98 "./arch/x86/include/asm/preempt.h"
      switch (4UL)
      {
# 98 "./arch/x86/include/asm/preempt.h"
        case 1:;
# 98 "./arch/x86/include/asm/preempt.h"
        asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( __preempt_count ) ) ;
# 98 "./arch/x86/include/asm/preempt.h"
        goto ldv_6523;
# 98 "./arch/x86/include/asm/preempt.h"
        case 2:;
# 98 "./arch/x86/include/asm/preempt.h"
        asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( __preempt_count ) ) ;
# 98 "./arch/x86/include/asm/preempt.h"
        goto ldv_6523;
# 98 "./arch/x86/include/asm/preempt.h"
        case 4:;
# 98 "./arch/x86/include/asm/preempt.h"
        asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( __preempt_count ) ) ;
# 98 "./arch/x86/include/asm/preempt.h"
        goto ldv_6523;
# 98 "./arch/x86/include/asm/preempt.h"
        case 8:;
# 98 "./arch/x86/include/asm/preempt.h"
        asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( __preempt_count ) ) ;
# 98 "./arch/x86/include/asm/preempt.h"
        goto ldv_6523;
# 98 "./arch/x86/include/asm/preempt.h"
        default:;
# 98 "./arch/x86/include/asm/preempt.h"
        __bad_percpu_size ( );
      }
# 98 "./arch/x86/include/asm/preempt.h"
      ldv_6523:;
    }
# 98 "./arch/x86/include/asm/preempt.h"
    pfo_ret__;
  } )
# 98 "./arch/x86/include/asm/preempt.h"
  == 0 , 0L ) != 0L;
}
struct preempt_notifier;
struct preempt_ops
{
# 166 "include/linux/preempt.h"
  void (*sched_in)(struct preempt_notifier *, int);
  void (*sched_out)(struct preempt_notifier *, struct task_struct *);
};
struct preempt_notifier
{
# 179 "include/linux/preempt.h"
  struct hlist_node link;
  struct preempt_ops *ops;
};
# 183 "include/linux/preempt.h"
void preempt_notifier_register(struct preempt_notifier *);
void preempt_notifier_unregister(struct preempt_notifier *);
# 186 "include/linux/preempt.h"
static inline void preempt_notifier_init(struct preempt_notifier *notifier, struct preempt_ops *ops)
{
# 189 "include/linux/preempt.h"
  INIT_HLIST_NODE ( & ( * notifier ) . link );
  ( * notifier ) . ops = ops;
}
# 8 "include/linux/bottom_half.h"
void __local_bh_disable_ip(long unsigned int, unsigned int);
# 17 "include/linux/bottom_half.h"
static inline void local_bh_disable(void)
{
  __local_bh_disable_ip ( 0UL , 512U );
}
# 22 "include/linux/bottom_half.h"
void _local_bh_enable(void);
void __local_bh_enable_ip(long unsigned int, unsigned int);
# 25 "include/linux/bottom_half.h"
static inline void local_bh_enable_ip(long unsigned int ip)
{
  __local_bh_enable_ip ( ip , 512U );
}
# 30 "include/linux/bottom_half.h"
static inline void local_bh_enable(void)
{
  __local_bh_enable_ip ( 0UL , 512U );
}
# 53 "include/linux/jump_label.h"
extern bool static_key_initialized;
struct static_key
{
# 74 "include/linux/jump_label.h"
  atomic_t enabled;
};
enum jump_label_type
{
  JUMP_LABEL_DISABLE = 0,
  JUMP_LABEL_ENABLE = 1
};
# 87 "include/linux/jump_label.h"
static inline int static_key_count(struct static_key *key)
{
  return atomic_read ( ( atomic_t const *) & ( * key ) . enabled );
}
# 147 "include/linux/jump_label.h"
static inline void jump_label_init(void)
{
  static_key_initialized = 1;
}
# 152 "include/linux/jump_label.h"
static inline bool static_key_false(struct static_key *key)
{
  if (__builtin_expect ( static_key_count ( key ) > 0 , 0L ) != 0L)
    return 1;
  return 0;
}
# 159 "include/linux/jump_label.h"
static inline bool static_key_true(struct static_key *key)
{
  if (__builtin_expect ( static_key_count ( key ) > 0 , 1L ) != 0L)
    return 1;
  return 0;
}
# 166 "include/linux/jump_label.h"
static inline void static_key_slow_inc(struct static_key *key)
{
  ({
# 168 "include/linux/jump_label.h"
    int __ret_warn_on = ( int ) ! ( _Bool ) static_key_initialized;
    {
# 168 "include/linux/jump_label.h"
      if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 168 "include/linux/jump_label.h"
        warn_slowpath_fmt ( ( char const *) "include/linux/jump_label.h" , 168 , ( char const *) "%s used before call to jump_label_init" , ( char const *) __func__ );
    }
# 168 "include/linux/jump_label.h"
    __builtin_expect ( __ret_warn_on != 0 , 0L );
  } );
# 169 "include/linux/jump_label.h"
  atomic_inc ( & ( * key ) . enabled );
}
# 172 "include/linux/jump_label.h"
static inline void static_key_slow_dec(struct static_key *key)
{
  ({
# 174 "include/linux/jump_label.h"
    int __ret_warn_on = ( int ) ! ( _Bool ) static_key_initialized;
    {
# 174 "include/linux/jump_label.h"
      if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 174 "include/linux/jump_label.h"
        warn_slowpath_fmt ( ( char const *) "include/linux/jump_label.h" , 174 , ( char const *) "%s used before call to jump_label_init" , ( char const *) __func__ );
    }
# 174 "include/linux/jump_label.h"
    __builtin_expect ( __ret_warn_on != 0 , 0L );
  } );
# 175 "include/linux/jump_label.h"
  atomic_dec ( & ( * key ) . enabled );
}
# 178 "include/linux/jump_label.h"
static inline int jump_label_text_reserved(void *start, void *end)
{
  return 0;
}
# 183 "include/linux/jump_label.h"
static inline void jump_label_lock(void)
{
}
# 184 "include/linux/jump_label.h"
static inline void jump_label_unlock(void)
{
}
# 186 "include/linux/jump_label.h"
static inline int jump_label_apply_nops(struct module *mod)
{
  return 0;
}
# 201 "include/linux/jump_label.h"
static inline bool static_key_enabled(struct static_key *key)
{
  return static_key_count ( key ) > 0;
}
# 42 "./arch/x86/include/asm/spinlock.h"
extern struct static_key paravirt_ticketlocks_enabled;
# 152 "include/linux/jump_label.h"
static inline bool static_key_false(struct static_key *key);
# 47 "./arch/x86/include/asm/spinlock.h"
static inline void __ticket_enter_slowpath(arch_spinlock_t *lock)
{
  set_bit ( 0L , ( long unsigned int volatile *) & ( * lock ) . ldv_1452 . tickets . tail );
}
# 64 "./arch/x86/include/asm/spinlock.h"
static inline int arch_spin_value_unlocked(arch_spinlock_t lock)
{
  return ( short unsigned int ) lock . ldv_1452 . tickets . head == ( short unsigned int ) lock . ldv_1452 . tickets . tail;
}
# 82 "./arch/x86/include/asm/spinlock.h"
static inline void arch_spin_lock(arch_spinlock_t *lock)
{
  register struct __raw_tickets inc = { . tail = 2U };
# 86 "./arch/x86/include/asm/spinlock.h"
  inc = ({
# 86 "./arch/x86/include/asm/spinlock.h"
    struct __raw_tickets __ret = inc;
    {
# 86 "./arch/x86/include/asm/spinlock.h"
      switch (4UL)
      {
# 86 "./arch/x86/include/asm/spinlock.h"
        case 1:;
# 86 "./arch/x86/include/asm/spinlock.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n" : "+q" ( __ret ) , "+m" ( ( * lock ) . ldv_1452 . tickets ) : : "memory" , "cc" ) ;
# 86 "./arch/x86/include/asm/spinlock.h"
        goto ldv_6625;
# 86 "./arch/x86/include/asm/spinlock.h"
        case 2:;
# 86 "./arch/x86/include/asm/spinlock.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n" : "+r" ( __ret ) , "+m" ( ( * lock ) . ldv_1452 . tickets ) : : "memory" , "cc" ) ;
# 86 "./arch/x86/include/asm/spinlock.h"
        goto ldv_6625;
# 86 "./arch/x86/include/asm/spinlock.h"
        case 4:;
# 86 "./arch/x86/include/asm/spinlock.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n" : "+r" ( __ret ) , "+m" ( ( * lock ) . ldv_1452 . tickets ) : : "memory" , "cc" ) ;
# 86 "./arch/x86/include/asm/spinlock.h"
        goto ldv_6625;
# 86 "./arch/x86/include/asm/spinlock.h"
        case 8:;
# 86 "./arch/x86/include/asm/spinlock.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n" : "+r" ( __ret ) , "+m" ( ( * lock ) . ldv_1452 . tickets ) : : "memory" , "cc" ) ;
# 86 "./arch/x86/include/asm/spinlock.h"
        goto ldv_6625;
# 86 "./arch/x86/include/asm/spinlock.h"
        default:;
# 86 "./arch/x86/include/asm/spinlock.h"
        __xadd_wrong_size ( );
      }
# 86 "./arch/x86/include/asm/spinlock.h"
      ldv_6625:;
    }
# 86 "./arch/x86/include/asm/spinlock.h"
    __ret;
  } );
# 87 "./arch/x86/include/asm/spinlock.h"
  if (__builtin_expect ( ( short unsigned int ) inc . head == ( short unsigned int ) inc . tail , 1L ) != 0L)
    goto out;
# 90 "./arch/x86/include/asm/spinlock.h"
  inc . tail &= 65534U;
  ldv_6635:;
  {
# 92 "./arch/x86/include/asm/spinlock.h"
    unsigned int count = 32768U;
    ldv_6633:;
# 95 "./arch/x86/include/asm/spinlock.h"
    if (( short unsigned int ) * ( __ticket_t volatile *) & ( * lock ) . ldv_1452 . tickets . head == ( short unsigned int ) inc . tail)
      goto out;
    cpu_relax ( );
    if (-- count != 0U)
    {
      goto ldv_6633;
    }
    else
      goto ldv_6634;
    ldv_6634:;
# 99 "./arch/x86/include/asm/spinlock.h"
    __ticket_lock_spinning ( ( struct arch_spinlock *) lock , ( int ) inc . tail );
  }
# 100 "./arch/x86/include/asm/spinlock.h"
  goto ldv_6635;
  out:;
# 101 "./arch/x86/include/asm/spinlock.h"
  asm volatile ( "" : : : "memory" ) ;
}
# 104 "./arch/x86/include/asm/spinlock.h"
static inline int arch_spin_trylock(arch_spinlock_t *lock)
{
  arch_spinlock_t old;
# 106 "./arch/x86/include/asm/spinlock.h"
  arch_spinlock_t new;
# 108 "./arch/x86/include/asm/spinlock.h"
  old . ldv_1452 . tickets = * ( struct __raw_tickets volatile *) & ( * lock ) . ldv_1452 . tickets;
  if (( int ) old . ldv_1452 . tickets . head != ( ( int ) old . ldv_1452 . tickets . tail & -2 ))
    return 0;
# 112 "./arch/x86/include/asm/spinlock.h"
  new . ldv_1452 . head_tail = old . ldv_1452 . head_tail + 131072U;
# 115 "./arch/x86/include/asm/spinlock.h"
  return ({
# 115 "./arch/x86/include/asm/spinlock.h"
    __ticketpair_t __ret;
# 115 "./arch/x86/include/asm/spinlock.h"
    __ticketpair_t __old = old . ldv_1452 . head_tail;
# 115 "./arch/x86/include/asm/spinlock.h"
    __ticketpair_t __new = new . ldv_1452 . head_tail;
    {
# 115 "./arch/x86/include/asm/spinlock.h"
      switch (4UL)
      {
# 115 "./arch/x86/include/asm/spinlock.h"
        case 1:;
        {
# 115 "./arch/x86/include/asm/spinlock.h"
          u8 volatile *__ptr = ( u8 volatile *) & ( * lock ) . ldv_1452 . head_tail;
# 115 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "q" ( __new ) , "0" ( __old ) : "memory" ) ;
# 115 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6646;
        }
# 115 "./arch/x86/include/asm/spinlock.h"
        case 2:;
        {
# 115 "./arch/x86/include/asm/spinlock.h"
          u16 volatile *__ptr = ( u16 volatile *) & ( * lock ) . ldv_1452 . head_tail;
# 115 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 115 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6646;
        }
# 115 "./arch/x86/include/asm/spinlock.h"
        case 4:;
        {
# 115 "./arch/x86/include/asm/spinlock.h"
          u32 volatile *__ptr = ( u32 volatile *) & ( * lock ) . ldv_1452 . head_tail;
# 115 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 115 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6646;
        }
# 115 "./arch/x86/include/asm/spinlock.h"
        case 8:;
        {
# 115 "./arch/x86/include/asm/spinlock.h"
          u64 volatile *__ptr = ( u64 volatile *) & ( * lock ) . ldv_1452 . head_tail;
# 115 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 115 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6646;
        }
# 115 "./arch/x86/include/asm/spinlock.h"
        default:;
# 115 "./arch/x86/include/asm/spinlock.h"
        __cmpxchg_wrong_size ( );
      }
# 115 "./arch/x86/include/asm/spinlock.h"
      ldv_6646:;
    }
# 115 "./arch/x86/include/asm/spinlock.h"
    __ret;
  } )
# 115 "./arch/x86/include/asm/spinlock.h"
  == old . ldv_1452 . head_tail;
}
# 118 "./arch/x86/include/asm/spinlock.h"
static inline void __ticket_unlock_slowpath(arch_spinlock_t *lock, arch_spinlock_t old)
{
# 121 "./arch/x86/include/asm/spinlock.h"
  arch_spinlock_t new;
# 126 "./arch/x86/include/asm/spinlock.h"
  old . ldv_1452 . tickets . head += 2U;
# 129 "./arch/x86/include/asm/spinlock.h"
  new . ldv_1452 . head_tail = old . ldv_1452 . head_tail & 4294901759U;
# 135 "./arch/x86/include/asm/spinlock.h"
  if (( short unsigned int ) new . ldv_1452 . tickets . head != ( short unsigned int ) new . ldv_1452 . tickets . tail || ({
    __ticketpair_t __ret;
# 136 "./arch/x86/include/asm/spinlock.h"
    __ticketpair_t __old = old . ldv_1452 . head_tail;
# 136 "./arch/x86/include/asm/spinlock.h"
    __ticketpair_t __new = new . ldv_1452 . head_tail;
    {
# 136 "./arch/x86/include/asm/spinlock.h"
      switch (4UL)
      {
# 136 "./arch/x86/include/asm/spinlock.h"
        case 1:;
        {
# 136 "./arch/x86/include/asm/spinlock.h"
          u8 volatile *__ptr = ( u8 volatile *) & ( * lock ) . ldv_1452 . head_tail;
# 136 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "q" ( __new ) , "0" ( __old ) : "memory" ) ;
# 136 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6665;
        }
# 136 "./arch/x86/include/asm/spinlock.h"
        case 2:;
        {
# 136 "./arch/x86/include/asm/spinlock.h"
          u16 volatile *__ptr = ( u16 volatile *) & ( * lock ) . ldv_1452 . head_tail;
# 136 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 136 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6665;
        }
# 136 "./arch/x86/include/asm/spinlock.h"
        case 4:;
        {
# 136 "./arch/x86/include/asm/spinlock.h"
          u32 volatile *__ptr = ( u32 volatile *) & ( * lock ) . ldv_1452 . head_tail;
# 136 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 136 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6665;
        }
# 136 "./arch/x86/include/asm/spinlock.h"
        case 8:;
        {
# 136 "./arch/x86/include/asm/spinlock.h"
          u64 volatile *__ptr = ( u64 volatile *) & ( * lock ) . ldv_1452 . head_tail;
# 136 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 136 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6665;
        }
# 136 "./arch/x86/include/asm/spinlock.h"
        default:;
# 136 "./arch/x86/include/asm/spinlock.h"
        __cmpxchg_wrong_size ( );
      }
# 136 "./arch/x86/include/asm/spinlock.h"
      ldv_6665:;
    }
# 136 "./arch/x86/include/asm/spinlock.h"
    __ret;
  } ) != old . ldv_1452 . head_tail)
# 142 "./arch/x86/include/asm/spinlock.h"
    __ticket_unlock_kick ( ( struct arch_spinlock *) lock , ( int ) old . ldv_1452 . tickets . head );
}
# 146 "./arch/x86/include/asm/spinlock.h"
static inline void arch_spin_unlock(arch_spinlock_t *lock)
{
  if (( int ) static_key_false
# 149 "./arch/x86/include/asm/spinlock.h"
  ( & paravirt_ticketlocks_enabled ))
  {
# 150 "./arch/x86/include/asm/spinlock.h"
    arch_spinlock_t prev;
# 152 "./arch/x86/include/asm/spinlock.h"
    prev = * lock;
    ({
# 153 "./arch/x86/include/asm/spinlock.h"
      __ticket_t __ret = 2U;
      {
# 153 "./arch/x86/include/asm/spinlock.h"
        switch (2UL)
        {
# 153 "./arch/x86/include/asm/spinlock.h"
          case 1:;
# 153 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addb %b1, %0\n" : "+m" ( ( * lock ) . ldv_1452 . tickets . head ) : "qi" ( 2U ) : "memory" , "cc" ) ;
# 153 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6680;
# 153 "./arch/x86/include/asm/spinlock.h"
          case 2:;
# 153 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addw %w1, %0\n" : "+m" ( ( * lock ) . ldv_1452 . tickets . head ) : "ri" ( 2U ) : "memory" , "cc" ) ;
# 153 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6680;
# 153 "./arch/x86/include/asm/spinlock.h"
          case 4:;
# 153 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addl %1, %0\n" : "+m" ( ( * lock ) . ldv_1452 . tickets . head ) : "ri" ( 2U ) : "memory" , "cc" ) ;
# 153 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6680;
# 153 "./arch/x86/include/asm/spinlock.h"
          case 8:;
# 153 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addq %1, %0\n" : "+m" ( ( * lock ) . ldv_1452 . tickets . head ) : "ri" ( 2U ) : "memory" , "cc" ) ;
# 153 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6680;
# 153 "./arch/x86/include/asm/spinlock.h"
          default:;
# 153 "./arch/x86/include/asm/spinlock.h"
          __add_wrong_size ( );
        }
# 153 "./arch/x86/include/asm/spinlock.h"
        ldv_6680:;
      }
# 153 "./arch/x86/include/asm/spinlock.h"
      __ret;
    } );
# 157 "./arch/x86/include/asm/spinlock.h"
    if (__builtin_expect ( ( long int ) ( * lock ) . ldv_1452 . tickets . tail & 1L , 0L ) != 0L)
      __ticket_unlock_slowpath ( lock , prev );
  }
  else
# 160 "./arch/x86/include/asm/spinlock.h"
    ({
# 160 "./arch/x86/include/asm/spinlock.h"
      __ticket_t __ret = 2U;
      {
# 160 "./arch/x86/include/asm/spinlock.h"
        switch (2UL)
        {
# 160 "./arch/x86/include/asm/spinlock.h"
          case 1:;
# 160 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( "addb %b1, %0\n" : "+m" ( ( * lock ) . ldv_1452 . tickets . head ) : "qi" ( 2U ) : "memory" , "cc" ) ;
# 160 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6688;
# 160 "./arch/x86/include/asm/spinlock.h"
          case 2:;
# 160 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( "addw %w1, %0\n" : "+m" ( ( * lock ) . ldv_1452 . tickets . head ) : "ri" ( 2U ) : "memory" , "cc" ) ;
# 160 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6688;
# 160 "./arch/x86/include/asm/spinlock.h"
          case 4:;
# 160 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( "addl %1, %0\n" : "+m" ( ( * lock ) . ldv_1452 . tickets . head ) : "ri" ( 2U ) : "memory" , "cc" ) ;
# 160 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6688;
# 160 "./arch/x86/include/asm/spinlock.h"
          case 8:;
# 160 "./arch/x86/include/asm/spinlock.h"
          asm volatile ( "addq %1, %0\n" : "+m" ( ( * lock ) . ldv_1452 . tickets . head ) : "ri" ( 2U ) : "memory" , "cc" ) ;
# 160 "./arch/x86/include/asm/spinlock.h"
          goto ldv_6688;
# 160 "./arch/x86/include/asm/spinlock.h"
          default:;
# 160 "./arch/x86/include/asm/spinlock.h"
          __add_wrong_size ( );
        }
# 160 "./arch/x86/include/asm/spinlock.h"
        ldv_6688:;
      }
# 160 "./arch/x86/include/asm/spinlock.h"
      __ret;
    } );
}
static inline int arch_spin_is_locked(arch_spinlock_t *lock)
{
  struct __raw_tickets tmp = * ( struct __raw_tickets volatile *) & ( * lock ) . ldv_1452 . tickets;
# 167 "./arch/x86/include/asm/spinlock.h"
  return ( short unsigned int ) tmp . tail != ( short unsigned int ) tmp . head;
}
# 170 "./arch/x86/include/asm/spinlock.h"
static inline int arch_spin_is_contended(arch_spinlock_t *lock)
{
  struct __raw_tickets tmp = * ( struct __raw_tickets volatile *) & ( * lock ) . ldv_1452 . tickets;
# 174 "./arch/x86/include/asm/spinlock.h"
  return ( short unsigned int ) tmp . tail - ( short unsigned int ) tmp . head > 2U;
}
# 178 "./arch/x86/include/asm/spinlock.h"
static inline void arch_spin_lock_flags(arch_spinlock_t *lock, long unsigned int flags)
{
# 181 "./arch/x86/include/asm/spinlock.h"
  arch_spin_lock ( lock );
}
# 184 "./arch/x86/include/asm/spinlock.h"
static inline void arch_spin_unlock_wait(arch_spinlock_t *lock)
{
  goto ldv_6710;
  ldv_6709:;
# 187 "./arch/x86/include/asm/spinlock.h"
  cpu_relax ( );
  ldv_6710:;
# 186 "./arch/x86/include/asm/spinlock.h"
  if (arch_spin_is_locked ( lock ) != 0)
  {
    goto ldv_6709;
  }
  else
    goto ldv_6711;
  ldv_6711:;
}
# 8 "./arch/x86/include/asm/qrwlock.h"
static inline void queue_write_unlock(struct qrwlock *lock)
{
  asm volatile ( "" : : : "memory" ) ;
  * ( u8 volatile *) & ( * lock ) . cnts = 0U;
}
# 39 "include/asm-generic/qrwlock.h"
void queue_read_lock_slowpath(struct qrwlock *);
void queue_write_lock_slowpath(struct qrwlock *);
# 46 "include/asm-generic/qrwlock.h"
static inline int queue_read_can_lock(struct qrwlock *lock)
{
  return ( atomic_read ( ( atomic_t const *) & ( * lock ) . cnts ) & 255 ) == 0;
}
# 55 "include/asm-generic/qrwlock.h"
static inline int queue_write_can_lock(struct qrwlock *lock)
{
  return atomic_read ( ( atomic_t const *) & ( * lock ) . cnts ) == 0;
}
# 65 "include/asm-generic/qrwlock.h"
static inline int queue_read_trylock(struct qrwlock *lock)
{
  u32 cnts;
# 69 "include/asm-generic/qrwlock.h"
  cnts = ( u32 ) atomic_read ( ( atomic_t const *) & ( * lock ) . cnts );
  if (__builtin_expect ( ( cnts & 255U ) == 0U , 1L ) != 0L)
  {
# 71 "include/asm-generic/qrwlock.h"
    cnts = ( unsigned int ) atomic_add_return ( 256 , & ( * lock ) . cnts );
    if (__builtin_expect ( ( cnts & 255U ) == 0U , 1L ) != 0L)
      return 1;
    atomic_sub ( 256 , & ( * lock ) . cnts );
  }
  return 0;
}
# 84 "include/asm-generic/qrwlock.h"
static inline int queue_write_trylock(struct qrwlock *lock)
{
  u32 cnts;
# 88 "include/asm-generic/qrwlock.h"
  cnts = ( u32 ) atomic_read ( ( atomic_t const *) & ( * lock ) . cnts );
  if (__builtin_expect ( cnts != 0U , 0L ) != 0L)
    return 0;
# 92 "include/asm-generic/qrwlock.h"
  return ( int ) __builtin_expect ( ( u32 ) atomic_cmpxchg ( & ( * lock ) . cnts , ( int ) cnts , ( int ) ( cnts | 255U ) ) == cnts , 1L );
}
# 99 "include/asm-generic/qrwlock.h"
static inline void queue_read_lock(struct qrwlock *lock)
{
  u32 cnts;
# 103 "include/asm-generic/qrwlock.h"
  cnts = ( u32 ) atomic_add_return ( 256 , & ( * lock ) . cnts );
  if (__builtin_expect ( ( cnts & 255U ) == 0U , 1L ) != 0L)
    return;
# 108 "include/asm-generic/qrwlock.h"
  queue_read_lock_slowpath ( lock );
}
# 115 "include/asm-generic/qrwlock.h"
static inline void queue_write_lock(struct qrwlock *lock)
{
# 118 "include/asm-generic/qrwlock.h"
  if (atomic_cmpxchg ( & ( * lock ) . cnts , 0 , 255 ) == 0)
    return;
# 121 "include/asm-generic/qrwlock.h"
  queue_write_lock_slowpath ( lock );
}
# 128 "include/asm-generic/qrwlock.h"
static inline void queue_read_unlock(struct qrwlock *lock)
{
# 133 "include/asm-generic/qrwlock.h"
  asm volatile ( "" : : : "memory" ) ;
  atomic_sub ( 256 , & ( * lock ) . cnts );
}
# 93 "include/linux/spinlock.h"
void __raw_spin_lock_init(raw_spinlock_t *, char const *, struct lock_class_key *);
# 150 "include/linux/spinlock.h"
void do_raw_spin_lock(raw_spinlock_t *);
# 152 "include/linux/spinlock.h"
int do_raw_spin_trylock(raw_spinlock_t *);
void do_raw_spin_unlock(raw_spinlock_t *);
# 18 "include/linux/rwlock.h"
void __rwlock_init(rwlock_t *, char const *, struct lock_class_key *);
# 32 "include/linux/rwlock.h"
void do_raw_read_lock(rwlock_t *);
# 34 "include/linux/rwlock.h"
int do_raw_read_trylock(rwlock_t *);
void do_raw_read_unlock(rwlock_t *);
void do_raw_write_lock(rwlock_t *);
# 38 "include/linux/rwlock.h"
int do_raw_write_trylock(rwlock_t *);
void do_raw_write_unlock(rwlock_t *);
# 18 "include/linux/spinlock_api_smp.h"
int in_lock_functions(long unsigned int);
# 22 "include/linux/spinlock_api_smp.h"
void _raw_spin_lock(raw_spinlock_t *);
void _raw_spin_lock_nested(raw_spinlock_t *, int);
# 26 "include/linux/spinlock_api_smp.h"
void _raw_spin_lock_nest_lock(raw_spinlock_t *, struct lockdep_map *);
# 28 "include/linux/spinlock_api_smp.h"
void _raw_spin_lock_bh(raw_spinlock_t *);
void _raw_spin_lock_irq(raw_spinlock_t *);
# 32 "include/linux/spinlock_api_smp.h"
long unsigned int _raw_spin_lock_irqsave(raw_spinlock_t *);
# 35 "include/linux/spinlock_api_smp.h"
long unsigned int _raw_spin_lock_irqsave_nested(raw_spinlock_t *, int);
# 37 "include/linux/spinlock_api_smp.h"
int _raw_spin_trylock(raw_spinlock_t *);
int _raw_spin_trylock_bh(raw_spinlock_t *);
void _raw_spin_unlock(raw_spinlock_t *);
void _raw_spin_unlock_bh(raw_spinlock_t *);
void _raw_spin_unlock_irq(raw_spinlock_t *);
# 43 "include/linux/spinlock_api_smp.h"
void _raw_spin_unlock_irqrestore(raw_spinlock_t *, long unsigned int);
# 86 "include/linux/spinlock_api_smp.h"
static inline int __raw_spin_trylock(raw_spinlock_t *lock)
{
  __preempt_count_add ( 1 );
# 88 "include/linux/spinlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
  if (do_raw_spin_trylock ( lock ) != 0)
  {
# 90 "include/linux/spinlock_api_smp.h"
    lock_acquire ( & ( * lock ) . dep_map , 0U , 1 , 0 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
    return 1;
  }
  asm volatile ( "" : : : "memory" ) ;
# 93 "include/linux/spinlock_api_smp.h"
  __preempt_count_sub ( 1 );
  return 0;
}
# 104 "include/linux/spinlock_api_smp.h"
static inline long unsigned int __raw_spin_lock_irqsave(raw_spinlock_t *lock)
{
  long unsigned int flags;
# 108 "include/linux/spinlock_api_smp.h"
  ({
# 108 "include/linux/spinlock_api_smp.h"
    long unsigned int __dummy;
# 108 "include/linux/spinlock_api_smp.h"
    long unsigned int __dummy2;
# 108 "include/linux/spinlock_api_smp.h"
    ( void ) 0;
# 108 "include/linux/spinlock_api_smp.h"
    1;
  } );
# 108 "include/linux/spinlock_api_smp.h"
  flags = arch_local_irq_save ( );
# 108 "include/linux/spinlock_api_smp.h"
  trace_hardirqs_off ( );
  __preempt_count_add ( 1 );
# 109 "include/linux/spinlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
  lock_acquire ( & ( * lock ) . dep_map , 0U , 0 , 0 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 117 "include/linux/spinlock_api_smp.h"
  if (do_raw_spin_trylock ( lock ) == 0)
  {
# 117 "include/linux/spinlock_api_smp.h"
    lock_contended ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 117 "include/linux/spinlock_api_smp.h"
    do_raw_spin_lock ( lock );
  }
# 117 "include/linux/spinlock_api_smp.h"
  lock_acquired ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 121 "include/linux/spinlock_api_smp.h"
  return flags;
}
# 124 "include/linux/spinlock_api_smp.h"
static inline void __raw_spin_lock_irq(raw_spinlock_t *lock)
{
  arch_local_irq_disable ( );
# 126 "include/linux/spinlock_api_smp.h"
  trace_hardirqs_off ( );
  __preempt_count_add ( 1 );
# 127 "include/linux/spinlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
  lock_acquire ( & ( * lock ) . dep_map , 0U , 0 , 0 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
  if (do_raw_spin_trylock ( lock ) == 0)
  {
# 129 "include/linux/spinlock_api_smp.h"
    lock_contended ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 129 "include/linux/spinlock_api_smp.h"
    do_raw_spin_lock ( lock );
  }
# 129 "include/linux/spinlock_api_smp.h"
  lock_acquired ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
}
# 132 "include/linux/spinlock_api_smp.h"
static inline void __raw_spin_lock_bh(raw_spinlock_t *lock)
{
  __local_bh_disable_ip ( ( long unsigned int ) __builtin_return_address ( 0U ) , 513U );
  lock_acquire ( & ( * lock ) . dep_map , 0U , 0 , 0 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
  if (do_raw_spin_trylock ( lock ) == 0)
  {
# 136 "include/linux/spinlock_api_smp.h"
    lock_contended ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 136 "include/linux/spinlock_api_smp.h"
    do_raw_spin_lock ( lock );
  }
# 136 "include/linux/spinlock_api_smp.h"
  lock_acquired ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
}
# 139 "include/linux/spinlock_api_smp.h"
static inline void __raw_spin_lock(raw_spinlock_t *lock)
{
  __preempt_count_add ( 1 );
# 141 "include/linux/spinlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
  lock_acquire ( & ( * lock ) . dep_map , 0U , 0 , 0 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
  if (do_raw_spin_trylock ( lock ) == 0)
  {
# 143 "include/linux/spinlock_api_smp.h"
    lock_contended ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 143 "include/linux/spinlock_api_smp.h"
    do_raw_spin_lock ( lock );
  }
# 143 "include/linux/spinlock_api_smp.h"
  lock_acquired ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
}
# 148 "include/linux/spinlock_api_smp.h"
static inline void __raw_spin_unlock(raw_spinlock_t *lock)
{
  lock_release ( & ( * lock ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  do_raw_spin_unlock ( lock );
  asm volatile ( "" : : : "memory" ) ;
# 152 "include/linux/spinlock_api_smp.h"
  __preempt_count_sub ( 1 );
}
# 155 "include/linux/spinlock_api_smp.h"
static inline void __raw_spin_unlock_irqrestore(raw_spinlock_t *lock, long unsigned int flags)
{
# 158 "include/linux/spinlock_api_smp.h"
  lock_release ( & ( * lock ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  do_raw_spin_unlock ( lock );
  if (({
# 160 "include/linux/spinlock_api_smp.h"
    ({
# 160 "include/linux/spinlock_api_smp.h"
      long unsigned int __dummy;
# 160 "include/linux/spinlock_api_smp.h"
      long unsigned int __dummy2;
# 160 "include/linux/spinlock_api_smp.h"
      ( void ) 0;
# 160 "include/linux/spinlock_api_smp.h"
      1;
    } );
# 160 "include/linux/spinlock_api_smp.h"
    arch_irqs_disabled_flags ( flags );
  } )
# 160 "include/linux/spinlock_api_smp.h"
  != 0)
  {
# 160 "include/linux/spinlock_api_smp.h"
    ({
# 160 "include/linux/spinlock_api_smp.h"
      long unsigned int __dummy;
# 160 "include/linux/spinlock_api_smp.h"
      long unsigned int __dummy2;
# 160 "include/linux/spinlock_api_smp.h"
      ( void ) 0;
# 160 "include/linux/spinlock_api_smp.h"
      1;
    } );
# 160 "include/linux/spinlock_api_smp.h"
    arch_local_irq_restore ( flags );
# 160 "include/linux/spinlock_api_smp.h"
    trace_hardirqs_off ( );
  }
  else
  {
# 160 "include/linux/spinlock_api_smp.h"
    trace_hardirqs_on ( );
# 160 "include/linux/spinlock_api_smp.h"
    ({
# 160 "include/linux/spinlock_api_smp.h"
      long unsigned int __dummy;
# 160 "include/linux/spinlock_api_smp.h"
      long unsigned int __dummy2;
# 160 "include/linux/spinlock_api_smp.h"
      ( void ) 0;
# 160 "include/linux/spinlock_api_smp.h"
      1;
    } );
# 160 "include/linux/spinlock_api_smp.h"
    arch_local_irq_restore ( flags );
  }
# 161 "include/linux/spinlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
# 161 "include/linux/spinlock_api_smp.h"
  __preempt_count_sub ( 1 );
}
# 164 "include/linux/spinlock_api_smp.h"
static inline void __raw_spin_unlock_irq(raw_spinlock_t *lock)
{
  lock_release ( & ( * lock ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  do_raw_spin_unlock ( lock );
  trace_hardirqs_on ( );
# 168 "include/linux/spinlock_api_smp.h"
  arch_local_irq_enable ( );
  asm volatile ( "" : : : "memory" ) ;
# 169 "include/linux/spinlock_api_smp.h"
  __preempt_count_sub ( 1 );
}
# 172 "include/linux/spinlock_api_smp.h"
static inline void __raw_spin_unlock_bh(raw_spinlock_t *lock)
{
  lock_release ( & ( * lock ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  do_raw_spin_unlock ( lock );
  __local_bh_enable_ip ( ( long unsigned int ) __builtin_return_address ( 0U ) , 513U );
}
# 179 "include/linux/spinlock_api_smp.h"
static inline int __raw_spin_trylock_bh(raw_spinlock_t *lock)
{
  __local_bh_disable_ip ( ( long unsigned int ) __builtin_return_address ( 0U ) , 513U );
  if (do_raw_spin_trylock ( lock ) != 0)
  {
# 183 "include/linux/spinlock_api_smp.h"
    lock_acquire ( & ( * lock ) . dep_map , 0U , 1 , 0 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
    return 1;
  }
  __local_bh_enable_ip ( ( long unsigned int ) __builtin_return_address ( 0U ) , 513U );
  return 0;
}
# 18 "include/linux/rwlock_api_smp.h"
void _raw_read_lock(rwlock_t *);
void _raw_write_lock(rwlock_t *);
void _raw_read_lock_bh(rwlock_t *);
void _raw_write_lock_bh(rwlock_t *);
void _raw_read_lock_irq(rwlock_t *);
void _raw_write_lock_irq(rwlock_t *);
long unsigned int _raw_read_lock_irqsave(rwlock_t *);
# 26 "include/linux/rwlock_api_smp.h"
long unsigned int _raw_write_lock_irqsave(rwlock_t *);
# 28 "include/linux/rwlock_api_smp.h"
int _raw_read_trylock(rwlock_t *);
int _raw_write_trylock(rwlock_t *);
void _raw_read_unlock(rwlock_t *);
void _raw_write_unlock(rwlock_t *);
void _raw_read_unlock_bh(rwlock_t *);
void _raw_write_unlock_bh(rwlock_t *);
void _raw_read_unlock_irq(rwlock_t *);
void _raw_write_unlock_irq(rwlock_t *);
# 37 "include/linux/rwlock_api_smp.h"
void _raw_read_unlock_irqrestore(rwlock_t *, long unsigned int);
# 40 "include/linux/rwlock_api_smp.h"
void _raw_write_unlock_irqrestore(rwlock_t *, long unsigned int);
# 117 "include/linux/rwlock_api_smp.h"
static inline int __raw_read_trylock(rwlock_t *lock)
{
  __preempt_count_add ( 1 );
# 119 "include/linux/rwlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
  if (do_raw_read_trylock ( lock ) != 0)
  {
# 121 "include/linux/rwlock_api_smp.h"
    lock_acquire ( & ( * lock ) . dep_map , 0U , 1 , 2 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
    return 1;
  }
  asm volatile ( "" : : : "memory" ) ;
# 124 "include/linux/rwlock_api_smp.h"
  __preempt_count_sub ( 1 );
  return 0;
}
# 128 "include/linux/rwlock_api_smp.h"
static inline int __raw_write_trylock(rwlock_t *lock)
{
  __preempt_count_add ( 1 );
# 130 "include/linux/rwlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
  if (do_raw_write_trylock ( lock ) != 0)
  {
# 132 "include/linux/rwlock_api_smp.h"
    lock_acquire ( & ( * lock ) . dep_map , 0U , 1 , 0 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
    return 1;
  }
  asm volatile ( "" : : : "memory" ) ;
# 135 "include/linux/rwlock_api_smp.h"
  __preempt_count_sub ( 1 );
  return 0;
}
# 146 "include/linux/rwlock_api_smp.h"
static inline void __raw_read_lock(rwlock_t *lock)
{
  __preempt_count_add ( 1 );
# 148 "include/linux/rwlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
  lock_acquire ( & ( * lock ) . dep_map , 0U , 0 , 2 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
  if (do_raw_read_trylock ( lock ) == 0)
  {
# 150 "include/linux/rwlock_api_smp.h"
    lock_contended ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 150 "include/linux/rwlock_api_smp.h"
    do_raw_read_lock ( lock );
  }
# 150 "include/linux/rwlock_api_smp.h"
  lock_acquired ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
}
# 153 "include/linux/rwlock_api_smp.h"
static inline long unsigned int __raw_read_lock_irqsave(rwlock_t *lock)
{
  long unsigned int flags;
# 157 "include/linux/rwlock_api_smp.h"
  ({
# 157 "include/linux/rwlock_api_smp.h"
    long unsigned int __dummy;
# 157 "include/linux/rwlock_api_smp.h"
    long unsigned int __dummy2;
# 157 "include/linux/rwlock_api_smp.h"
    ( void ) 0;
# 157 "include/linux/rwlock_api_smp.h"
    1;
  } );
# 157 "include/linux/rwlock_api_smp.h"
  flags = arch_local_irq_save ( );
# 157 "include/linux/rwlock_api_smp.h"
  trace_hardirqs_off ( );
  __preempt_count_add ( 1 );
# 158 "include/linux/rwlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
  lock_acquire ( & ( * lock ) . dep_map , 0U , 0 , 2 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
  if (do_raw_read_trylock ( lock ) == 0)
  {
# 160 "include/linux/rwlock_api_smp.h"
    lock_contended ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 160 "include/linux/rwlock_api_smp.h"
    do_raw_read_lock ( lock );
  }
# 160 "include/linux/rwlock_api_smp.h"
  lock_acquired ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 162 "include/linux/rwlock_api_smp.h"
  return flags;
}
# 165 "include/linux/rwlock_api_smp.h"
static inline void __raw_read_lock_irq(rwlock_t *lock)
{
  arch_local_irq_disable ( );
# 167 "include/linux/rwlock_api_smp.h"
  trace_hardirqs_off ( );
  __preempt_count_add ( 1 );
# 168 "include/linux/rwlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
  lock_acquire ( & ( * lock ) . dep_map , 0U , 0 , 2 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
  if (do_raw_read_trylock ( lock ) == 0)
  {
# 170 "include/linux/rwlock_api_smp.h"
    lock_contended ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 170 "include/linux/rwlock_api_smp.h"
    do_raw_read_lock ( lock );
  }
# 170 "include/linux/rwlock_api_smp.h"
  lock_acquired ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
}
# 173 "include/linux/rwlock_api_smp.h"
static inline void __raw_read_lock_bh(rwlock_t *lock)
{
  __local_bh_disable_ip ( ( long unsigned int ) __builtin_return_address ( 0U ) , 513U );
  lock_acquire ( & ( * lock ) . dep_map , 0U , 0 , 2 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
  if (do_raw_read_trylock ( lock ) == 0)
  {
# 177 "include/linux/rwlock_api_smp.h"
    lock_contended ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 177 "include/linux/rwlock_api_smp.h"
    do_raw_read_lock ( lock );
  }
# 177 "include/linux/rwlock_api_smp.h"
  lock_acquired ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
}
# 180 "include/linux/rwlock_api_smp.h"
static inline long unsigned int __raw_write_lock_irqsave(rwlock_t *lock)
{
  long unsigned int flags;
# 184 "include/linux/rwlock_api_smp.h"
  ({
# 184 "include/linux/rwlock_api_smp.h"
    long unsigned int __dummy;
# 184 "include/linux/rwlock_api_smp.h"
    long unsigned int __dummy2;
# 184 "include/linux/rwlock_api_smp.h"
    ( void ) 0;
# 184 "include/linux/rwlock_api_smp.h"
    1;
  } );
# 184 "include/linux/rwlock_api_smp.h"
  flags = arch_local_irq_save ( );
# 184 "include/linux/rwlock_api_smp.h"
  trace_hardirqs_off ( );
  __preempt_count_add ( 1 );
# 185 "include/linux/rwlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
  lock_acquire ( & ( * lock ) . dep_map , 0U , 0 , 0 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
  if (do_raw_write_trylock ( lock ) == 0)
  {
# 187 "include/linux/rwlock_api_smp.h"
    lock_contended ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 187 "include/linux/rwlock_api_smp.h"
    do_raw_write_lock ( lock );
  }
# 187 "include/linux/rwlock_api_smp.h"
  lock_acquired ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 189 "include/linux/rwlock_api_smp.h"
  return flags;
}
# 192 "include/linux/rwlock_api_smp.h"
static inline void __raw_write_lock_irq(rwlock_t *lock)
{
  arch_local_irq_disable ( );
# 194 "include/linux/rwlock_api_smp.h"
  trace_hardirqs_off ( );
  __preempt_count_add ( 1 );
# 195 "include/linux/rwlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
  lock_acquire ( & ( * lock ) . dep_map , 0U , 0 , 0 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
  if (do_raw_write_trylock ( lock ) == 0)
  {
# 197 "include/linux/rwlock_api_smp.h"
    lock_contended ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 197 "include/linux/rwlock_api_smp.h"
    do_raw_write_lock ( lock );
  }
# 197 "include/linux/rwlock_api_smp.h"
  lock_acquired ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
}
# 200 "include/linux/rwlock_api_smp.h"
static inline void __raw_write_lock_bh(rwlock_t *lock)
{
  __local_bh_disable_ip ( ( long unsigned int ) __builtin_return_address ( 0U ) , 513U );
  lock_acquire ( & ( * lock ) . dep_map , 0U , 0 , 0 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
  if (do_raw_write_trylock ( lock ) == 0)
  {
# 204 "include/linux/rwlock_api_smp.h"
    lock_contended ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 204 "include/linux/rwlock_api_smp.h"
    do_raw_write_lock ( lock );
  }
# 204 "include/linux/rwlock_api_smp.h"
  lock_acquired ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
}
# 207 "include/linux/rwlock_api_smp.h"
static inline void __raw_write_lock(rwlock_t *lock)
{
  __preempt_count_add ( 1 );
# 209 "include/linux/rwlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
  lock_acquire ( & ( * lock ) . dep_map , 0U , 0 , 0 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
  if (do_raw_write_trylock ( lock ) == 0)
  {
# 211 "include/linux/rwlock_api_smp.h"
    lock_contended ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
# 211 "include/linux/rwlock_api_smp.h"
    do_raw_write_lock ( lock );
  }
# 211 "include/linux/rwlock_api_smp.h"
  lock_acquired ( & ( * lock ) . dep_map , ( long unsigned int ) __builtin_return_address ( 0U ) );
}
# 216 "include/linux/rwlock_api_smp.h"
static inline void __raw_write_unlock(rwlock_t *lock)
{
  lock_release ( & ( * lock ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  do_raw_write_unlock ( lock );
  asm volatile ( "" : : : "memory" ) ;
# 220 "include/linux/rwlock_api_smp.h"
  __preempt_count_sub ( 1 );
}
# 223 "include/linux/rwlock_api_smp.h"
static inline void __raw_read_unlock(rwlock_t *lock)
{
  lock_release ( & ( * lock ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  do_raw_read_unlock ( lock );
  asm volatile ( "" : : : "memory" ) ;
# 227 "include/linux/rwlock_api_smp.h"
  __preempt_count_sub ( 1 );
}
# 231 "include/linux/rwlock_api_smp.h"
static inline void __raw_read_unlock_irqrestore(rwlock_t *lock, long unsigned int flags)
{
  lock_release ( & ( * lock ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  do_raw_read_unlock ( lock );
  if (({
# 235 "include/linux/rwlock_api_smp.h"
    ({
# 235 "include/linux/rwlock_api_smp.h"
      long unsigned int __dummy;
# 235 "include/linux/rwlock_api_smp.h"
      long unsigned int __dummy2;
# 235 "include/linux/rwlock_api_smp.h"
      ( void ) 0;
# 235 "include/linux/rwlock_api_smp.h"
      1;
    } );
# 235 "include/linux/rwlock_api_smp.h"
    arch_irqs_disabled_flags ( flags );
  } )
# 235 "include/linux/rwlock_api_smp.h"
  != 0)
  {
# 235 "include/linux/rwlock_api_smp.h"
    ({
# 235 "include/linux/rwlock_api_smp.h"
      long unsigned int __dummy;
# 235 "include/linux/rwlock_api_smp.h"
      long unsigned int __dummy2;
# 235 "include/linux/rwlock_api_smp.h"
      ( void ) 0;
# 235 "include/linux/rwlock_api_smp.h"
      1;
    } );
# 235 "include/linux/rwlock_api_smp.h"
    arch_local_irq_restore ( flags );
# 235 "include/linux/rwlock_api_smp.h"
    trace_hardirqs_off ( );
  }
  else
  {
# 235 "include/linux/rwlock_api_smp.h"
    trace_hardirqs_on ( );
# 235 "include/linux/rwlock_api_smp.h"
    ({
# 235 "include/linux/rwlock_api_smp.h"
      long unsigned int __dummy;
# 235 "include/linux/rwlock_api_smp.h"
      long unsigned int __dummy2;
# 235 "include/linux/rwlock_api_smp.h"
      ( void ) 0;
# 235 "include/linux/rwlock_api_smp.h"
      1;
    } );
# 235 "include/linux/rwlock_api_smp.h"
    arch_local_irq_restore ( flags );
  }
# 236 "include/linux/rwlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
# 236 "include/linux/rwlock_api_smp.h"
  __preempt_count_sub ( 1 );
}
# 239 "include/linux/rwlock_api_smp.h"
static inline void __raw_read_unlock_irq(rwlock_t *lock)
{
  lock_release ( & ( * lock ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  do_raw_read_unlock ( lock );
  trace_hardirqs_on ( );
# 243 "include/linux/rwlock_api_smp.h"
  arch_local_irq_enable ( );
  asm volatile ( "" : : : "memory" ) ;
# 244 "include/linux/rwlock_api_smp.h"
  __preempt_count_sub ( 1 );
}
# 247 "include/linux/rwlock_api_smp.h"
static inline void __raw_read_unlock_bh(rwlock_t *lock)
{
  lock_release ( & ( * lock ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  do_raw_read_unlock ( lock );
  __local_bh_enable_ip ( ( long unsigned int ) __builtin_return_address ( 0U ) , 513U );
}
# 254 "include/linux/rwlock_api_smp.h"
static inline void __raw_write_unlock_irqrestore(rwlock_t *lock, long unsigned int flags)
{
# 257 "include/linux/rwlock_api_smp.h"
  lock_release ( & ( * lock ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  do_raw_write_unlock ( lock );
  if (({
# 259 "include/linux/rwlock_api_smp.h"
    ({
# 259 "include/linux/rwlock_api_smp.h"
      long unsigned int __dummy;
# 259 "include/linux/rwlock_api_smp.h"
      long unsigned int __dummy2;
# 259 "include/linux/rwlock_api_smp.h"
      ( void ) 0;
# 259 "include/linux/rwlock_api_smp.h"
      1;
    } );
# 259 "include/linux/rwlock_api_smp.h"
    arch_irqs_disabled_flags ( flags );
  } )
# 259 "include/linux/rwlock_api_smp.h"
  != 0)
  {
# 259 "include/linux/rwlock_api_smp.h"
    ({
# 259 "include/linux/rwlock_api_smp.h"
      long unsigned int __dummy;
# 259 "include/linux/rwlock_api_smp.h"
      long unsigned int __dummy2;
# 259 "include/linux/rwlock_api_smp.h"
      ( void ) 0;
# 259 "include/linux/rwlock_api_smp.h"
      1;
    } );
# 259 "include/linux/rwlock_api_smp.h"
    arch_local_irq_restore ( flags );
# 259 "include/linux/rwlock_api_smp.h"
    trace_hardirqs_off ( );
  }
  else
  {
# 259 "include/linux/rwlock_api_smp.h"
    trace_hardirqs_on ( );
# 259 "include/linux/rwlock_api_smp.h"
    ({
# 259 "include/linux/rwlock_api_smp.h"
      long unsigned int __dummy;
# 259 "include/linux/rwlock_api_smp.h"
      long unsigned int __dummy2;
# 259 "include/linux/rwlock_api_smp.h"
      ( void ) 0;
# 259 "include/linux/rwlock_api_smp.h"
      1;
    } );
# 259 "include/linux/rwlock_api_smp.h"
    arch_local_irq_restore ( flags );
  }
# 260 "include/linux/rwlock_api_smp.h"
  asm volatile ( "" : : : "memory" ) ;
# 260 "include/linux/rwlock_api_smp.h"
  __preempt_count_sub ( 1 );
}
# 263 "include/linux/rwlock_api_smp.h"
static inline void __raw_write_unlock_irq(rwlock_t *lock)
{
  lock_release ( & ( * lock ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  do_raw_write_unlock ( lock );
  trace_hardirqs_on ( );
# 267 "include/linux/rwlock_api_smp.h"
  arch_local_irq_enable ( );
  asm volatile ( "" : : : "memory" ) ;
# 268 "include/linux/rwlock_api_smp.h"
  __preempt_count_sub ( 1 );
}
# 271 "include/linux/rwlock_api_smp.h"
static inline void __raw_write_unlock_bh(rwlock_t *lock)
{
  lock_release ( & ( * lock ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  do_raw_write_unlock ( lock );
  __local_bh_enable_ip ( ( long unsigned int ) __builtin_return_address ( 0U ) , 513U );
}
# 290 "include/linux/spinlock.h"
static inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  return ( raw_spinlock_t *) & ( * lock ) . ldv_6073 . rlock;
}
# 301 "include/linux/spinlock.h"
static inline void spin_lock(spinlock_t *lock)
{
  _raw_spin_lock ( ( raw_spinlock_t *) & ( * lock ) . ldv_6073 . rlock );
}
# 306 "include/linux/spinlock.h"
static inline void spin_lock_bh(spinlock_t *lock)
{
  _raw_spin_lock_bh ( ( raw_spinlock_t *) & ( * lock ) . ldv_6073 . rlock );
}
# 311 "include/linux/spinlock.h"
static inline int spin_trylock(spinlock_t *lock)
{
  return _raw_spin_trylock ( ( raw_spinlock_t *) & ( * lock ) . ldv_6073 . rlock );
}
# 326 "include/linux/spinlock.h"
static inline void spin_lock_irq(spinlock_t *lock)
{
  _raw_spin_lock_irq ( ( raw_spinlock_t *) & ( * lock ) . ldv_6073 . rlock );
}
# 341 "include/linux/spinlock.h"
static inline void spin_unlock(spinlock_t *lock)
{
  _raw_spin_unlock ( ( raw_spinlock_t *) & ( * lock ) . ldv_6073 . rlock );
}
# 346 "include/linux/spinlock.h"
static inline void spin_unlock_bh(spinlock_t *lock)
{
  _raw_spin_unlock_bh ( ( raw_spinlock_t *) & ( * lock ) . ldv_6073 . rlock );
}
# 351 "include/linux/spinlock.h"
static inline void spin_unlock_irq(spinlock_t *lock)
{
  _raw_spin_unlock_irq ( ( raw_spinlock_t *) & ( * lock ) . ldv_6073 . rlock );
}
# 356 "include/linux/spinlock.h"
static inline void spin_unlock_irqrestore(spinlock_t *lock, long unsigned int flags)
{
  ({
# 358 "include/linux/spinlock.h"
    long unsigned int __dummy;
# 358 "include/linux/spinlock.h"
    long unsigned int __dummy2;
# 358 "include/linux/spinlock.h"
    ( void ) 0;
# 358 "include/linux/spinlock.h"
    1;
  } );
# 358 "include/linux/spinlock.h"
  _raw_spin_unlock_irqrestore ( ( raw_spinlock_t *) & ( * lock ) . ldv_6073 . rlock , flags );
}
# 361 "include/linux/spinlock.h"
static inline int spin_trylock_bh(spinlock_t *lock)
{
  return _raw_spin_trylock_bh ( ( raw_spinlock_t *) & ( * lock ) . ldv_6073 . rlock );
}
# 366 "include/linux/spinlock.h"
static inline int spin_trylock_irq(spinlock_t *lock)
{
  return ({
    {
# 368 "include/linux/spinlock.h"
      arch_local_irq_disable ( );
# 368 "include/linux/spinlock.h"
      trace_hardirqs_off ( );
    }
# 368 "include/linux/spinlock.h"
    _raw_spin_trylock ( ( raw_spinlock_t *) & ( * lock ) . ldv_6073 . rlock ) == 0 ? ({
      {
# 368 "include/linux/spinlock.h"
        trace_hardirqs_on ( );
# 368 "include/linux/spinlock.h"
        arch_local_irq_enable ( );
      }
# 368 "include/linux/spinlock.h"
      0;
    } )
# 368 "include/linux/spinlock.h"
    : 1;
  } );
}
# 376 "include/linux/spinlock.h"
static inline void spin_unlock_wait(spinlock_t *lock)
{
  arch_spin_unlock_wait ( & ( * lock ) . ldv_6073 . rlock . raw_lock );
}
# 381 "include/linux/spinlock.h"
static inline int spin_is_locked(spinlock_t *lock)
{
  return arch_spin_is_locked ( & ( * lock ) . ldv_6073 . rlock . raw_lock );
}
# 386 "include/linux/spinlock.h"
static inline int spin_is_contended(spinlock_t *lock)
{
  return arch_spin_is_contended ( & ( * lock ) . ldv_6073 . rlock . raw_lock );
}
# 391 "include/linux/spinlock.h"
static inline int spin_can_lock(spinlock_t *lock)
{
  return arch_spin_is_locked ( & ( * lock ) . ldv_6073 . rlock . raw_lock ) == 0;
}
# 411 "include/linux/spinlock.h"
int _atomic_dec_and_lock(atomic_t *, spinlock_t *);
struct seqcount
{
# 47 "include/linux/seqlock.h"
  unsigned int sequence;
# 49 "include/linux/seqlock.h"
  struct lockdep_map dep_map;
};
typedef struct seqcount seqcount_t;
# 53 "include/linux/seqlock.h"
static inline void __seqcount_init(seqcount_t *s, char const *name, struct lock_class_key *key)
{
# 59 "include/linux/seqlock.h"
  lockdep_init_map ( & ( * s ) . dep_map , name , key , 0 );
  ( * s ) . sequence = 0U;
}
# 73 "include/linux/seqlock.h"
static inline void seqcount_lockdep_reader_access(seqcount_t const *s)
{
  seqcount_t *l = ( seqcount_t *) s;
  long unsigned int flags;
# 78 "include/linux/seqlock.h"
  ({
# 78 "include/linux/seqlock.h"
    long unsigned int __dummy;
# 78 "include/linux/seqlock.h"
    long unsigned int __dummy2;
# 78 "include/linux/seqlock.h"
    ( void ) 0;
# 78 "include/linux/seqlock.h"
    1;
  } );
# 78 "include/linux/seqlock.h"
  flags = arch_local_irq_save ( );
# 78 "include/linux/seqlock.h"
  trace_hardirqs_off ( );
  lock_acquire ( & ( * l ) . dep_map , 0U , 0 , 2 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
  lock_release ( & ( * l ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  if (({
# 81 "include/linux/seqlock.h"
    ({
# 81 "include/linux/seqlock.h"
      long unsigned int __dummy;
# 81 "include/linux/seqlock.h"
      long unsigned int __dummy2;
# 81 "include/linux/seqlock.h"
      ( void ) 0;
# 81 "include/linux/seqlock.h"
      1;
    } );
# 81 "include/linux/seqlock.h"
    arch_irqs_disabled_flags ( flags );
  } )
# 81 "include/linux/seqlock.h"
  != 0)
  {
# 81 "include/linux/seqlock.h"
    ({
# 81 "include/linux/seqlock.h"
      long unsigned int __dummy;
# 81 "include/linux/seqlock.h"
      long unsigned int __dummy2;
# 81 "include/linux/seqlock.h"
      ( void ) 0;
# 81 "include/linux/seqlock.h"
      1;
    } );
# 81 "include/linux/seqlock.h"
    arch_local_irq_restore ( flags );
# 81 "include/linux/seqlock.h"
    trace_hardirqs_off ( );
  }
  else
  {
# 81 "include/linux/seqlock.h"
    trace_hardirqs_on ( );
# 81 "include/linux/seqlock.h"
    ({
# 81 "include/linux/seqlock.h"
      long unsigned int __dummy;
# 81 "include/linux/seqlock.h"
      long unsigned int __dummy2;
# 81 "include/linux/seqlock.h"
      ( void ) 0;
# 81 "include/linux/seqlock.h"
      1;
    } );
# 81 "include/linux/seqlock.h"
    arch_local_irq_restore ( flags );
  }
}
# 106 "include/linux/seqlock.h"
static inline unsigned int __read_seqcount_begin(seqcount_t const *s)
{
  unsigned int ret;
# 110 "include/linux/seqlock.h"
  repeat:;
  ret = * ( unsigned int const volatile *) & ( * s ) . sequence;
  if (__builtin_expect ( ( long int ) ( int ) ret & 1L , 0L ) != 0L)
  {
# 113 "include/linux/seqlock.h"
    cpu_relax ( );
    goto repeat;
  }
  return ret;
}
# 128 "include/linux/seqlock.h"
static inline unsigned int raw_read_seqcount(seqcount_t const *s)
{
  unsigned int ret = * ( unsigned int const volatile *) & ( * s ) . sequence;
  asm volatile ( "" : : : "memory" ) ;
  return ret;
}
# 144 "include/linux/seqlock.h"
static inline unsigned int raw_read_seqcount_begin(seqcount_t const *s)
{
  unsigned int ret = __read_seqcount_begin ( s );
  asm volatile ( "" : : : "memory" ) ;
  return ret;
}
# 160 "include/linux/seqlock.h"
static inline unsigned int read_seqcount_begin(seqcount_t const *s)
{
  seqcount_lockdep_reader_access ( s );
  return raw_read_seqcount_begin ( s );
}
# 180 "include/linux/seqlock.h"
static inline unsigned int raw_seqcount_begin(seqcount_t const *s)
{
  unsigned int ret = * ( unsigned int const volatile *) & ( * s ) . sequence;
  asm volatile ( "" : : : "memory" ) ;
  return ret & 4294967294U;
}
# 201 "include/linux/seqlock.h"
static inline int __read_seqcount_retry(seqcount_t const *s, unsigned int start)
{
  return ( int ) __builtin_expect ( ( unsigned int ) ( * s ) . sequence != start , 0L );
}
# 216 "include/linux/seqlock.h"
static inline int read_seqcount_retry(seqcount_t const *s, unsigned int start)
{
  asm volatile ( "" : : : "memory" ) ;
  return __read_seqcount_retry ( s , start );
}
# 224 "include/linux/seqlock.h"
static inline void raw_write_seqcount_begin(seqcount_t *s)
{
  ( * s ) . sequence ++;
  asm volatile ( "" : : : "memory" ) ;
}
# 230 "include/linux/seqlock.h"
static inline void raw_write_seqcount_end(seqcount_t *s)
{
  asm volatile ( "" : : : "memory" ) ;
  ( * s ) . sequence ++;
}
# 240 "include/linux/seqlock.h"
static inline void raw_write_seqcount_latch(seqcount_t *s)
{
  asm volatile ( "" : : : "memory" ) ;
  ( * s ) . sequence ++;
  asm volatile ( "" : : : "memory" ) ;
}
# 251 "include/linux/seqlock.h"
static inline void write_seqcount_begin_nested(seqcount_t *s, int subclass)
{
  raw_write_seqcount_begin ( s );
  lock_acquire ( & ( * s ) . dep_map , ( unsigned int ) subclass , 0 , 0 , 1 , ( ( struct lockdep_map *) 0 ) , ( long unsigned int ) __builtin_return_address ( 0U ) );
}
# 257 "include/linux/seqlock.h"
static inline void write_seqcount_begin(seqcount_t *s)
{
  write_seqcount_begin_nested ( s , 0 );
}
# 262 "include/linux/seqlock.h"
static inline void write_seqcount_end(seqcount_t *s)
{
  lock_release ( & ( * s ) . dep_map , 1 , ( long unsigned int ) __builtin_return_address ( 0U ) );
  raw_write_seqcount_end ( s );
}
# 275 "include/linux/seqlock.h"
static inline void write_seqcount_barrier(seqcount_t *s)
{
  asm volatile ( "" : : : "memory" ) ;
  ( * s ) . sequence += 2U;
}
# 284 "include/linux/seqlock.h"
typedef struct
{
# 282 "include/linux/seqlock.h"
  struct seqcount seqcount;
  spinlock_t lock;
} seqlock_t;
# 308 "include/linux/seqlock.h"
static inline unsigned int read_seqbegin(seqlock_t const *sl)
{
  return read_seqcount_begin ( ( seqcount_t const *) & ( * sl ) . seqcount );
}
# 313 "include/linux/seqlock.h"
static inline unsigned int read_seqretry(seqlock_t const *sl, unsigned int start)
{
  return ( unsigned int ) read_seqcount_retry ( ( seqcount_t const *) & ( * sl ) . seqcount , start );
}
# 323 "include/linux/seqlock.h"
static inline void write_seqlock(seqlock_t *sl)
{
  spin_lock ( & ( * sl ) . lock );
  write_seqcount_begin ( ( seqcount_t *) & ( * sl ) . seqcount );
}
# 329 "include/linux/seqlock.h"
static inline void write_sequnlock(seqlock_t *sl)
{
  write_seqcount_end ( ( seqcount_t *) & ( * sl ) . seqcount );
  spin_unlock ( & ( * sl ) . lock );
}
# 335 "include/linux/seqlock.h"
static inline void write_seqlock_bh(seqlock_t *sl)
{
  spin_lock_bh ( & ( * sl ) . lock );
  write_seqcount_begin ( ( seqcount_t *) & ( * sl ) . seqcount );
}
# 341 "include/linux/seqlock.h"
static inline void write_sequnlock_bh(seqlock_t *sl)
{
  write_seqcount_end ( ( seqcount_t *) & ( * sl ) . seqcount );
  spin_unlock_bh ( & ( * sl ) . lock );
}
# 347 "include/linux/seqlock.h"
static inline void write_seqlock_irq(seqlock_t *sl)
{
  spin_lock_irq ( & ( * sl ) . lock );
  write_seqcount_begin ( ( seqcount_t *) & ( * sl ) . seqcount );
}
# 353 "include/linux/seqlock.h"
static inline void write_sequnlock_irq(seqlock_t *sl)
{
  write_seqcount_end ( ( seqcount_t *) & ( * sl ) . seqcount );
  spin_unlock_irq ( & ( * sl ) . lock );
}
# 359 "include/linux/seqlock.h"
static inline long unsigned int __write_seqlock_irqsave(seqlock_t *sl)
{
  long unsigned int flags;
# 363 "include/linux/seqlock.h"
  ({
# 363 "include/linux/seqlock.h"
    long unsigned int __dummy;
# 363 "include/linux/seqlock.h"
    long unsigned int __dummy2;
# 363 "include/linux/seqlock.h"
    ( void ) 0;
# 363 "include/linux/seqlock.h"
    1;
  } );
# 363 "include/linux/seqlock.h"
  flags = _raw_spin_lock_irqsave ( spinlock_check ( & ( * sl ) . lock ) );
  write_seqcount_begin ( ( seqcount_t *) & ( * sl ) . seqcount );
  return flags;
}
# 372 "include/linux/seqlock.h"
static inline void write_sequnlock_irqrestore(seqlock_t *sl, long unsigned int flags)
{
  write_seqcount_end ( ( seqcount_t *) & ( * sl ) . seqcount );
  spin_unlock_irqrestore ( & ( * sl ) . lock , flags );
}
# 383 "include/linux/seqlock.h"
static inline void read_seqlock_excl(seqlock_t *sl)
{
  spin_lock ( & ( * sl ) . lock );
}
# 388 "include/linux/seqlock.h"
static inline void read_sequnlock_excl(seqlock_t *sl)
{
  spin_unlock ( & ( * sl ) . lock );
}
# 403 "include/linux/seqlock.h"
static inline void read_seqbegin_or_lock(seqlock_t *lock, int *seq)
{
  if (( * seq & 1 ) == 0)
  {
# 406 "include/linux/seqlock.h"
    * seq = ( int ) read_seqbegin ( ( seqlock_t const *) lock );
  }
  else
# 408 "include/linux/seqlock.h"
    read_seqlock_excl ( lock );
}
# 411 "include/linux/seqlock.h"
static inline int need_seqretry(seqlock_t *lock, int seq)
{
  return ( seq & 1 ) == 0 && read_seqretry ( ( seqlock_t const *) lock , ( unsigned int ) seq ) != 0U;
}
# 416 "include/linux/seqlock.h"
static inline void done_seqretry(seqlock_t *lock, int seq)
{
  if (seq & 1)
    read_sequnlock_excl ( lock );
}
# 422 "include/linux/seqlock.h"
static inline void read_seqlock_excl_bh(seqlock_t *sl)
{
  spin_lock_bh ( & ( * sl ) . lock );
}
# 427 "include/linux/seqlock.h"
static inline void read_sequnlock_excl_bh(seqlock_t *sl)
{
  spin_unlock_bh ( & ( * sl ) . lock );
}
# 432 "include/linux/seqlock.h"
static inline void read_seqlock_excl_irq(seqlock_t *sl)
{
  spin_lock_irq ( & ( * sl ) . lock );
}
# 437 "include/linux/seqlock.h"
static inline void read_sequnlock_excl_irq(seqlock_t *sl)
{
  spin_unlock_irq ( & ( * sl ) . lock );
}
# 442 "include/linux/seqlock.h"
static inline long unsigned int __read_seqlock_excl_irqsave(seqlock_t *sl)
{
  long unsigned int flags;
# 446 "include/linux/seqlock.h"
  ({
# 446 "include/linux/seqlock.h"
    long unsigned int __dummy;
# 446 "include/linux/seqlock.h"
    long unsigned int __dummy2;
# 446 "include/linux/seqlock.h"
    ( void ) 0;
# 446 "include/linux/seqlock.h"
    1;
  } );
# 446 "include/linux/seqlock.h"
  flags = _raw_spin_lock_irqsave ( spinlock_check ( & ( * sl ) . lock ) );
  return flags;
}
# 454 "include/linux/seqlock.h"
static inline void read_sequnlock_excl_irqrestore(seqlock_t *sl, long unsigned int flags)
{
  spin_unlock_irqrestore ( & ( * sl ) . lock , flags );
}
struct timespec
{
# 10 "include/uapi/linux/time.h"
  __kernel_time_t tv_sec;
  long int tv_nsec;
};
struct timeval
{
# 16 "include/uapi/linux/time.h"
  __kernel_time_t tv_sec;
  __kernel_suseconds_t tv_usec;
};
struct timezone
{
  int tz_minuteswest;
  int tz_dsttime;
};
struct itimerspec
{
# 35 "include/uapi/linux/time.h"
  struct timespec it_interval;
  struct timespec it_value;
};
struct itimerval
{
  struct timeval it_interval;
  struct timeval it_value;
};
# 6 "include/linux/time64.h"
typedef __s64 time64_t;
# 36 "include/linux/time64.h"
static inline struct timespec timespec64_to_timespec(struct timespec const ts64)
{
  return ( struct timespec ) ts64;
}
# 41 "include/linux/time64.h"
static inline struct timespec timespec_to_timespec64(struct timespec const ts)
{
  return ( struct timespec ) ts;
}
# 9 "include/linux/time.h"
extern struct timezone sys_tz;
# 13 "include/linux/time.h"
static inline int timespec_equal(struct timespec const *a, struct timespec const *b)
{
# 16 "include/linux/time.h"
  return ( long int ) ( * a ) . tv_sec == ( long int ) ( * b ) . tv_sec && ( long int ) ( * a ) . tv_nsec == ( long int ) ( * b ) . tv_nsec;
}
# 24 "include/linux/time.h"
static inline int timespec_compare(struct timespec const *lhs, struct timespec const *rhs)
{
  if (( long int ) ( * lhs ) . tv_sec < ( long int ) ( * rhs ) . tv_sec)
    return -1;
  if (( long int ) ( * lhs ) . tv_sec > ( long int ) ( * rhs ) . tv_sec)
    return 1;
  return ( int ) ( ( unsigned int ) ( * lhs ) . tv_nsec - ( unsigned int ) ( * rhs ) . tv_nsec );
}
# 33 "include/linux/time.h"
static inline int timeval_compare(struct timeval const *lhs, struct timeval const *rhs)
{
  if (( long int ) ( * lhs ) . tv_sec < ( long int ) ( * rhs ) . tv_sec)
    return -1;
  if (( long int ) ( * lhs ) . tv_sec > ( long int ) ( * rhs ) . tv_sec)
    return 1;
  return ( int ) ( ( unsigned int ) ( * lhs ) . tv_usec - ( unsigned int ) ( * rhs ) . tv_usec );
}
# 42 "include/linux/time.h"
long unsigned int mktime(unsigned int const, unsigned int const, unsigned int const, unsigned int const, unsigned int const, unsigned int const);
# 46 "include/linux/time.h"
void set_normalized_timespec(struct timespec *, time_t, s64);
# 53 "include/linux/time.h"
struct timespec timespec_add_safe(struct timespec const, struct timespec const);
# 57 "include/linux/time.h"
static inline struct timespec timespec_add(struct timespec lhs, struct timespec rhs)
{
# 60 "include/linux/time.h"
  struct timespec ts_delta;
  set_normalized_timespec ( & ts_delta , lhs . tv_sec + rhs . tv_sec , ( s64 ) ( lhs
# 62 "include/linux/time.h"
  . tv_nsec + rhs . tv_nsec ) );
  return ts_delta;
}
# 69 "include/linux/time.h"
static inline struct timespec timespec_sub(struct timespec lhs, struct timespec rhs)
{
# 72 "include/linux/time.h"
  struct timespec ts_delta;
  set_normalized_timespec ( & ts_delta , lhs . tv_sec - rhs . tv_sec , ( s64 ) ( lhs
# 74 "include/linux/time.h"
  . tv_nsec - rhs . tv_nsec ) );
  return ts_delta;
}
# 81 "include/linux/time.h"
static inline bool timespec_valid(struct timespec const *ts)
{
# 84 "include/linux/time.h"
  if (( long int ) ( * ts ) . tv_sec < 0L)
    return 0;
# 87 "include/linux/time.h"
  if (( long unsigned int ) ( * ts ) . tv_nsec > 999999999UL)
    return 0;
  return 1;
}
# 92 "include/linux/time.h"
static inline bool timespec_valid_strict(struct timespec const *ts)
{
  if (( int ) ! ( _Bool ) timespec_valid ( ts ))
    return 0;
# 97 "include/linux/time.h"
  if (( long long unsigned int ) ( * ts ) . tv_sec > 9223372035ULL)
    return 0;
  return 1;
}
# 102 "include/linux/time.h"
struct timespec timespec_trunc(struct timespec, unsigned int);
# 121 "include/linux/time.h"
int do_setitimer(int, struct itimerval *, struct itimerval *);
# 123 "include/linux/time.h"
int do_getitimer(int, struct itimerval *);
# 125 "include/linux/time.h"
unsigned int alarm_setitimer(unsigned int);
# 127 "include/linux/time.h"
long int do_utimes(int, char const *, struct timespec *, int);
struct tms;
# 130 "include/linux/time.h"
void do_sys_times(struct tms *);
struct tm
{
# 141 "include/linux/time.h"
  int tm_sec;
# 143 "include/linux/time.h"
  int tm_min;
# 145 "include/linux/time.h"
  int tm_hour;
# 147 "include/linux/time.h"
  int tm_mday;
# 149 "include/linux/time.h"
  int tm_mon;
# 151 "include/linux/time.h"
  long int tm_year;
# 153 "include/linux/time.h"
  int tm_wday;
# 155 "include/linux/time.h"
  int tm_yday;
};
# 158 "include/linux/time.h"
void time_to_tm(time_t, int, struct tm *);
# 167 "include/linux/time.h"
static inline s64 timespec_to_ns(struct timespec const *ts)
{
  return ( s64 ) ( ( long long int ) ( * ts ) . tv_sec * 1000000000LL + ( long long int ) ( * ts ) . tv_nsec );
}
# 179 "include/linux/time.h"
static inline s64 timeval_to_ns(struct timeval const *tv)
{
  return ( s64 ) ( ( long long int ) ( * tv ) . tv_sec * 1000000000LL + ( long long int ) (
# 182 "include/linux/time.h"
  ( long int ) ( * tv ) . tv_usec * 1000L ) );
}
# 191 "include/linux/time.h"
struct timespec ns_to_timespec(s64 const);
# 199 "include/linux/time.h"
struct timeval ns_to_timeval(s64 const);
# 209 "include/linux/time.h"
static inline void timespec_add_ns(struct timespec *a, u64 ns)
{
  ( * a ) . tv_sec += ( __kernel_time_t ) __iter_div_u64_rem ( ( long long unsigned int ) ( * a ) . tv_nsec + ( long long unsigned int ) ns , 1000000000U , & ns );
  ( * a ) . tv_nsec = ( long int ) ns;
}
# 34 "include/linux/highuid.h"
extern int overflowuid;
extern int overflowgid;
# 37 "include/linux/highuid.h"
void __bad_uid(void);
void __bad_gid(void);
# 81 "include/linux/highuid.h"
extern int fs_overflowuid;
extern int fs_overflowgid;
struct user_namespace;
# 18 "include/linux/uidgid.h"
extern struct user_namespace init_user_ns;
# 22 "include/linux/uidgid.h"
typedef struct
{
# 21 "include/linux/uidgid.h"
  uid_t val;
} kuid_t;
# 27 "include/linux/uidgid.h"
typedef struct
{
# 26 "include/linux/uidgid.h"
  gid_t val;
} kgid_t;
# 32 "include/linux/uidgid.h"
static inline uid_t __kuid_val(kuid_t uid)
{
  return uid . val;
}
# 37 "include/linux/uidgid.h"
static inline gid_t __kgid_val(kgid_t gid)
{
  return gid . val;
}
# 48 "include/linux/uidgid.h"
static inline bool uid_eq(kuid_t left, kuid_t right)
{
  return __kuid_val ( left ) == __kuid_val ( right );
}
# 53 "include/linux/uidgid.h"
static inline bool gid_eq(kgid_t left, kgid_t right)
{
  return __kgid_val ( left ) == __kgid_val ( right );
}
# 58 "include/linux/uidgid.h"
static inline bool uid_gt(kuid_t left, kuid_t right)
{
  return __kuid_val ( left ) > __kuid_val ( right );
}
# 63 "include/linux/uidgid.h"
static inline bool gid_gt(kgid_t left, kgid_t right)
{
  return __kgid_val ( left ) > __kgid_val ( right );
}
# 68 "include/linux/uidgid.h"
static inline bool uid_gte(kuid_t left, kuid_t right)
{
  return __kuid_val ( left ) >= __kuid_val ( right );
}
# 73 "include/linux/uidgid.h"
static inline bool gid_gte(kgid_t left, kgid_t right)
{
  return __kgid_val ( left ) >= __kgid_val ( right );
}
# 78 "include/linux/uidgid.h"
static inline bool uid_lt(kuid_t left, kuid_t right)
{
  return __kuid_val ( left ) < __kuid_val ( right );
}
# 83 "include/linux/uidgid.h"
static inline bool gid_lt(kgid_t left, kgid_t right)
{
  return __kgid_val ( left ) < __kgid_val ( right );
}
# 88 "include/linux/uidgid.h"
static inline bool uid_lte(kuid_t left, kuid_t right)
{
  return __kuid_val ( left ) <= __kuid_val ( right );
}
# 93 "include/linux/uidgid.h"
static inline bool gid_lte(kgid_t left, kgid_t right)
{
  return __kgid_val ( left ) <= __kgid_val ( right );
}
# 98 "include/linux/uidgid.h"
static inline bool uid_valid(kuid_t uid)
{
  return ( bool ) ! ( ( int ) uid_eq ( uid , ( kuid_t ) { . val = 4294967295U } ) != 0 );
}
# 103 "include/linux/uidgid.h"
static inline bool gid_valid(kgid_t gid)
{
  return ( bool ) ! ( ( int ) gid_eq ( gid , ( kgid_t ) { . val = 4294967295U } ) != 0 );
}
# 110 "include/linux/uidgid.h"
kuid_t make_kuid(struct user_namespace *, uid_t);
kgid_t make_kgid(struct user_namespace *, gid_t);
# 113 "include/linux/uidgid.h"
uid_t from_kuid(struct user_namespace *, kuid_t);
gid_t from_kgid(struct user_namespace *, kgid_t);
uid_t from_kuid_munged(struct user_namespace *, kuid_t);
gid_t from_kgid_munged(struct user_namespace *, kgid_t);
# 118 "include/linux/uidgid.h"
static inline bool kuid_has_mapping(struct user_namespace *ns, kuid_t uid)
{
  return from_kuid ( ns , uid ) != 4294967295U;
}
# 123 "include/linux/uidgid.h"
static inline bool kgid_has_mapping(struct user_namespace *ns, kgid_t gid)
{
  return from_kgid ( ns , gid ) != 4294967295U;
}
struct kstat
{
# 22 "include/linux/stat.h"
  u64 ino;
  dev_t dev;
  umode_t mode;
  unsigned int nlink;
  kuid_t uid;
  kgid_t gid;
  dev_t rdev;
  loff_t size;
  struct timespec atime;
  struct timespec mtime;
  struct timespec ctime;
  long unsigned int blksize;
  long long unsigned int blocks;
};
# 8 "include/linux/mmdebug.h"
void dump_page(struct page *, char const *);
void dump_page_badflags(struct page *, char const *, long unsigned int);
# 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
typedef int (*wait_queue_func_t)(wait_queue_t *, unsigned int, int, void *);
int default_wake_function(wait_queue_t *, unsigned int, int, void *);
struct __wait_queue
{
  unsigned int flags;
# 19 "include/linux/wait.h"
  void *private;
  wait_queue_func_t func;
  struct list_head task_list;
};
struct wait_bit_key
{
  void *flags;
  int bit_nr;
# 28 "include/linux/wait.h"
  long unsigned int private;
};
struct wait_bit_queue
{
  struct wait_bit_key key;
  wait_queue_t wait;
};
struct __wait_queue_head
{
  spinlock_t lock;
  struct list_head task_list;
};
typedef struct __wait_queue_head wait_queue_head_t;
# 69 "include/linux/wait.h"
void __init_waitqueue_head(wait_queue_head_t *, char const *, struct lock_class_key *);
# 87 "include/linux/wait.h"
static inline void init_waitqueue_entry(wait_queue_t *q, struct task_struct *p)
{
  ( * q ) . flags = 0U;
  ( * q ) . private = ( void *) p;
  ( * q ) . func = & default_wake_function;
}
# 95 "include/linux/wait.h"
static inline void init_waitqueue_func_entry(wait_queue_t *q, wait_queue_func_t func)
{
  ( * q ) . flags = 0U;
  ( * q ) . private = ( ( void *) 0 );
  ( * q ) . func = func;
}
# 102 "include/linux/wait.h"
static inline int waitqueue_active(wait_queue_head_t *q)
{
  return list_empty ( ( struct list_head const *) & ( * q ) . task_list ) == 0;
}
# 107 "include/linux/wait.h"
void add_wait_queue(wait_queue_head_t *, wait_queue_t *);
void add_wait_queue_exclusive(wait_queue_head_t *, wait_queue_t *);
void remove_wait_queue(wait_queue_head_t *, wait_queue_t *);
# 111 "include/linux/wait.h"
static inline void __add_wait_queue(wait_queue_head_t *head, wait_queue_t *new)
{
  list_add ( & ( * new ) . task_list , & ( * head ) . task_list );
}
# 120 "include/linux/wait.h"
static inline void __add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t *wait)
{
  ( * wait ) . flags |= 1U;
  __add_wait_queue ( q , wait );
}
# 126 "include/linux/wait.h"
static inline void __add_wait_queue_tail(wait_queue_head_t *head, wait_queue_t *new)
{
# 129 "include/linux/wait.h"
  list_add_tail ( & ( * new ) . task_list , & ( * head ) . task_list );
}
# 133 "include/linux/wait.h"
static inline void __add_wait_queue_tail_exclusive(wait_queue_head_t *q, wait_queue_t *wait)
{
  ( * wait ) . flags |= 1U;
  __add_wait_queue_tail ( q , wait );
}
# 140 "include/linux/wait.h"
static inline void __remove_wait_queue(wait_queue_head_t *head, wait_queue_t *old)
{
  list_del ( & ( * old ) . task_list );
}
# 145 "include/linux/wait.h"
typedef int wait_bit_action_f(struct wait_bit_key *);
void __wake_up(wait_queue_head_t *, unsigned int, int, void *);
void __wake_up_locked_key(wait_queue_head_t *, unsigned int, void *);
void __wake_up_sync_key(wait_queue_head_t *, unsigned int, int, void *);
void __wake_up_locked(wait_queue_head_t *, unsigned int, int);
void __wake_up_sync(wait_queue_head_t *, unsigned int, int);
void __wake_up_bit(wait_queue_head_t *, void *, int);
int __wait_on_bit(wait_queue_head_t *, struct wait_bit_queue *, wait_bit_action_f *, unsigned int);
int __wait_on_bit_lock(wait_queue_head_t *, struct wait_bit_queue *, wait_bit_action_f *, unsigned int);
void wake_up_bit(void *, int);
void wake_up_atomic_t(atomic_t *);
int out_of_line_wait_on_bit(void *, int, wait_bit_action_f *, unsigned int);
int out_of_line_wait_on_bit_lock(void *, int, wait_bit_action_f *, unsigned int);
int out_of_line_wait_on_atomic_t(atomic_t *, int (*)(atomic_t *), unsigned int);
wait_queue_head_t *bit_waitqueue(void *, int);
# 823 "include/linux/wait.h"
void prepare_to_wait(wait_queue_head_t *, wait_queue_t *, int);
void prepare_to_wait_exclusive(wait_queue_head_t *, wait_queue_t *, int);
long int prepare_to_wait_event(wait_queue_head_t *, wait_queue_t *, int);
void finish_wait(wait_queue_head_t *, wait_queue_t *);
void abort_exclusive_wait(wait_queue_head_t *, wait_queue_t *, unsigned int, void *);
int autoremove_wake_function(wait_queue_t *, unsigned int, int, void *);
int wake_bit_function(wait_queue_t *, unsigned int, int, void *);
# 860 "include/linux/wait.h"
int bit_wait(struct wait_bit_key *);
int bit_wait_io(struct wait_bit_key *);
# 880 "include/linux/wait.h"
static inline int wait_on_bit(void *word, int bit, unsigned int mode)
{
  if (variable_test_bit ( ( long int ) bit , ( long unsigned int const volatile *) word ) == 0)
    return 0;
  return out_of_line_wait_on_bit ( word , bit ,
# 885 "include/linux/wait.h"
  ( wait_bit_action_f *) & bit_wait , mode );
}
# 904 "include/linux/wait.h"
static inline int wait_on_bit_io(void *word, int bit, unsigned int mode)
{
  if (variable_test_bit ( ( long int ) bit , ( long unsigned int const volatile *) word ) == 0)
    return 0;
  return out_of_line_wait_on_bit ( word , bit ,
# 909 "include/linux/wait.h"
  ( wait_bit_action_f *) & bit_wait_io , mode );
}
# 930 "include/linux/wait.h"
static inline int wait_on_bit_action(void *word, int bit, wait_bit_action_f *action, unsigned int mode)
{
  if (variable_test_bit ( ( long int ) bit , ( long unsigned int const volatile *) word ) == 0)
    return 0;
  return out_of_line_wait_on_bit ( word , bit , action , mode );
}
# 957 "include/linux/wait.h"
static inline int wait_on_bit_lock(void *word, int bit, unsigned int mode)
{
  if (test_and_set_bit ( ( long int ) bit , ( long unsigned int volatile *) word ) == 0)
    return 0;
  return out_of_line_wait_on_bit_lock ( word , bit , ( wait_bit_action_f *) & bit_wait , mode );
}
# 980 "include/linux/wait.h"
static inline int wait_on_bit_lock_io(void *word, int bit, unsigned int mode)
{
  if (test_and_set_bit ( ( long int ) bit , ( long unsigned int volatile *) word ) == 0)
    return 0;
  return out_of_line_wait_on_bit_lock ( word , bit , ( wait_bit_action_f *) & bit_wait_io , mode );
}
# 1005 "include/linux/wait.h"
static inline int wait_on_bit_lock_action(void *word, int bit, wait_bit_action_f *action, unsigned int mode)
{
  if (test_and_set_bit ( ( long int ) bit , ( long unsigned int volatile *) word ) == 0)
    return 0;
  return out_of_line_wait_on_bit_lock ( word , bit , action , mode );
}
# 1023 "include/linux/wait.h"
static inline int wait_on_atomic_t(atomic_t *val, int (*action)(atomic_t *), unsigned int mode)
{
  if (atomic_read ( ( atomic_t const *) val ) == 0)
    return 0;
  return out_of_line_wait_on_atomic_t ( val , action , mode );
}
# 98 "include/linux/nodemask.h"
typedef struct
{
# 98 "include/linux/nodemask.h"
  long unsigned int bits[16U];
} nodemask_t;
# 99 "include/linux/nodemask.h"
extern nodemask_t _unused_nodemask_arg_;
# 111 "include/linux/nodemask.h"
static inline void __node_set(int node, nodemask_t volatile *dstp)
{
  set_bit ( ( long int ) node , ( long unsigned int volatile *) & ( * dstp ) . bits );
}
# 117 "include/linux/nodemask.h"
static inline void __node_clear(int node, nodemask_t volatile *dstp)
{
  clear_bit ( ( long int ) node , ( long unsigned int volatile *) & ( * dstp ) . bits );
}
# 123 "include/linux/nodemask.h"
static inline void __nodes_setall(nodemask_t *dstp, int nbits)
{
  bitmap_fill ( ( long unsigned int *) & ( * dstp ) . bits , nbits );
}
# 129 "include/linux/nodemask.h"
static inline void __nodes_clear(nodemask_t *dstp, int nbits)
{
  bitmap_zero ( ( long unsigned int *) & ( * dstp ) . bits , nbits );
}
# 139 "include/linux/nodemask.h"
static inline int __node_test_and_set(int node, nodemask_t *addr)
{
  return test_and_set_bit ( ( long int ) node , ( long unsigned int volatile *) & ( * addr ) . bits );
}
# 146 "include/linux/nodemask.h"
static inline void __nodes_and(nodemask_t *dstp, nodemask_t const *src1p, nodemask_t const *src2p, int nbits)
{
# 149 "include/linux/nodemask.h"
  bitmap_and ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 154 "include/linux/nodemask.h"
static inline void __nodes_or(nodemask_t *dstp, nodemask_t const *src1p, nodemask_t const *src2p, int nbits)
{
# 157 "include/linux/nodemask.h"
  bitmap_or ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 162 "include/linux/nodemask.h"
static inline void __nodes_xor(nodemask_t *dstp, nodemask_t const *src1p, nodemask_t const *src2p, int nbits)
{
# 165 "include/linux/nodemask.h"
  bitmap_xor ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 170 "include/linux/nodemask.h"
static inline void __nodes_andnot(nodemask_t *dstp, nodemask_t const *src1p, nodemask_t const *src2p, int nbits)
{
# 173 "include/linux/nodemask.h"
  bitmap_andnot ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 178 "include/linux/nodemask.h"
static inline void __nodes_complement(nodemask_t *dstp, nodemask_t const *srcp, int nbits)
{
# 181 "include/linux/nodemask.h"
  bitmap_complement ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * srcp ) . bits , ( unsigned int ) nbits );
}
# 186 "include/linux/nodemask.h"
static inline int __nodes_equal(nodemask_t const *src1p, nodemask_t const *src2p, int nbits)
{
# 189 "include/linux/nodemask.h"
  return bitmap_equal ( ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 194 "include/linux/nodemask.h"
static inline int __nodes_intersects(nodemask_t const *src1p, nodemask_t const *src2p, int nbits)
{
# 197 "include/linux/nodemask.h"
  return bitmap_intersects ( ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 202 "include/linux/nodemask.h"
static inline int __nodes_subset(nodemask_t const *src1p, nodemask_t const *src2p, int nbits)
{
# 205 "include/linux/nodemask.h"
  return bitmap_subset ( ( long unsigned int const *) & ( * src1p ) . bits , ( long unsigned int const *) & ( * src2p ) . bits , ( unsigned int ) nbits );
}
# 209 "include/linux/nodemask.h"
static inline int __nodes_empty(nodemask_t const *srcp, int nbits)
{
  return bitmap_empty ( ( long unsigned int const *) & ( * srcp ) . bits , ( unsigned int ) nbits );
}
# 215 "include/linux/nodemask.h"
static inline int __nodes_full(nodemask_t const *srcp, int nbits)
{
  return bitmap_full ( ( long unsigned int const *) & ( * srcp ) . bits , ( unsigned int ) nbits );
}
# 221 "include/linux/nodemask.h"
static inline int __nodes_weight(nodemask_t const *srcp, int nbits)
{
  return bitmap_weight ( ( long unsigned int const *) & ( * srcp ) . bits , ( unsigned int ) nbits );
}
# 228 "include/linux/nodemask.h"
static inline void __nodes_shift_right(nodemask_t *dstp, nodemask_t const *srcp, int n, int nbits)
{
# 231 "include/linux/nodemask.h"
  bitmap_shift_right ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * srcp ) . bits , n , nbits );
}
# 236 "include/linux/nodemask.h"
static inline void __nodes_shift_left(nodemask_t *dstp, nodemask_t const *srcp, int n, int nbits)
{
# 239 "include/linux/nodemask.h"
  bitmap_shift_left ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * srcp ) . bits , n , nbits );
}
# 246 "include/linux/nodemask.h"
static inline int __first_node(nodemask_t const *srcp)
{
  return ({
# 248 "include/linux/nodemask.h"
    int __min1 = 1024;
# 248 "include/linux/nodemask.h"
    int __min2 = ( int ) find_first_bit ( ( long unsigned int const *) & ( * srcp ) . bits , 1024UL );
# 248 "include/linux/nodemask.h"
    ((__min1) < (__min2) ? (__min1) : (__min2));
  } );
}
# 252 "include/linux/nodemask.h"
static inline int __next_node(int n, nodemask_t const *srcp)
{
  return ({
# 254 "include/linux/nodemask.h"
    int __min1 = 1024;
# 254 "include/linux/nodemask.h"
    int __min2 = ( int ) find_next_bit ( ( long unsigned int const *) & ( * srcp ) . bits , 1024UL , ( long unsigned int ) ( n + 1 ) );
# 254 "include/linux/nodemask.h"
    ((__min1) < (__min2) ? (__min1) : (__min2));
  } );
}
static inline void init_nodemask_of_node(nodemask_t *mask, int node)
{
  __nodes_clear ( mask , 1024 );
  __node_set ( node , ( nodemask_t volatile *) mask );
}
# 275 "include/linux/nodemask.h"
static inline int __first_unset_node(nodemask_t const *maskp)
{
  return ({
# 277 "include/linux/nodemask.h"
    int __min1 = 1024;
# 277 "include/linux/nodemask.h"
    int __min2 = ( int ) find_first_zero_bit ( ( long unsigned int const *) & ( * maskp ) . bits , 1024UL );
# 277 "include/linux/nodemask.h"
    ((__min1) < (__min2) ? (__min1) : (__min2));
  } );
}
# 309 "include/linux/nodemask.h"
static inline int __nodemask_scnprintf(char *buf, int len, nodemask_t const *srcp, int nbits)
{
# 312 "include/linux/nodemask.h"
  return bitmap_scnprintf ( buf , ( unsigned int ) len , ( long unsigned int const *) & ( * srcp ) . bits , nbits );
}
# 317 "include/linux/nodemask.h"
static inline int __nodemask_parse_user(char const *buf, int len, nodemask_t *dstp, int nbits)
{
# 320 "include/linux/nodemask.h"
  return bitmap_parse_user ( buf , ( unsigned int ) len , ( long unsigned int *) & ( * dstp ) . bits , nbits );
}
# 325 "include/linux/nodemask.h"
static inline int __nodelist_scnprintf(char *buf, int len, nodemask_t const *srcp, int nbits)
{
# 328 "include/linux/nodemask.h"
  return bitmap_scnlistprintf ( buf , ( unsigned int ) len , ( long unsigned int const *) & ( * srcp ) . bits , nbits );
}
# 332 "include/linux/nodemask.h"
static inline int __nodelist_parse(char const *buf, nodemask_t *dstp, int nbits)
{
  return bitmap_parselist ( buf , ( long unsigned int *) & ( * dstp ) . bits , nbits );
}
# 339 "include/linux/nodemask.h"
static inline int __node_remap(int oldbit, nodemask_t const *oldp, nodemask_t const *newp, int nbits)
{
# 342 "include/linux/nodemask.h"
  return bitmap_bitremap ( oldbit , ( long unsigned int const *) & ( * oldp ) . bits , ( long unsigned int const *) & ( * newp ) . bits , nbits );
}
# 347 "include/linux/nodemask.h"
static inline void __nodes_remap(nodemask_t *dstp, nodemask_t const *srcp, nodemask_t const *oldp, nodemask_t const *newp, int nbits)
{
# 350 "include/linux/nodemask.h"
  bitmap_remap ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * srcp ) . bits , ( long unsigned int const *) & ( * oldp ) . bits , ( long unsigned int const *) & ( * newp ) . bits , nbits );
}
# 355 "include/linux/nodemask.h"
static inline void __nodes_onto(nodemask_t *dstp, nodemask_t const *origp, nodemask_t const *relmapp, int nbits)
{
# 358 "include/linux/nodemask.h"
  bitmap_onto ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * origp ) . bits , ( long unsigned int const *) & ( * relmapp ) . bits , nbits );
}
# 363 "include/linux/nodemask.h"
static inline void __nodes_fold(nodemask_t *dstp, nodemask_t const *origp, int sz, int nbits)
{
# 366 "include/linux/nodemask.h"
  bitmap_fold ( ( long unsigned int *) & ( * dstp ) . bits , ( long unsigned int const *) & ( * origp ) . bits , sz , nbits );
}
enum node_states
{
  N_POSSIBLE = 0,
  N_ONLINE = 1,
  N_NORMAL_MEMORY = 2,
  N_HIGH_MEMORY = 2,
  N_MEMORY = 3,
  N_CPU = 4,
  NR_NODE_STATES = 5
};
# 406 "include/linux/nodemask.h"
extern nodemask_t node_states[5U];
# 409 "include/linux/nodemask.h"
static inline int node_state(int node, enum node_states state)
{
  return variable_test_bit ( ( long int ) node , ( long unsigned int const volatile *) & node_states [ ( unsigned int ) state ] . bits );
}
# 414 "include/linux/nodemask.h"
static inline void node_set_state(int node, enum node_states state)
{
  __node_set ( node , ( nodemask_t volatile *) & node_states + ( long unsigned int ) state );
}
# 419 "include/linux/nodemask.h"
static inline void node_clear_state(int node, enum node_states state)
{
  __node_clear ( node , ( nodemask_t volatile *) & node_states + ( long unsigned int ) state );
}
# 424 "include/linux/nodemask.h"
static inline int num_node_state(enum node_states state)
{
  return __nodes_weight ( ( nodemask_t const *) & node_states + ( long unsigned int ) state , 1024 );
}
# 434 "include/linux/nodemask.h"
static inline int next_online_node(int nid)
{
  return __next_node ( nid , ( nodemask_t const *) & node_states + 1U );
}
static inline int next_memory_node(int nid)
{
  return __next_node ( nid , ( nodemask_t const *) & node_states + 3U );
}
# 443 "include/linux/nodemask.h"
extern int nr_node_ids;
extern int nr_online_nodes;
# 446 "include/linux/nodemask.h"
static inline void node_set_online(int nid)
{
  node_set_state ( nid , N_ONLINE );
  nr_online_nodes = num_node_state ( N_ONLINE );
}
# 452 "include/linux/nodemask.h"
static inline void node_set_offline(int nid)
{
  node_clear_state ( nid , N_ONLINE );
  nr_online_nodes = num_node_state ( N_ONLINE );
}
# 493 "include/linux/nodemask.h"
int node_random(nodemask_t const *);
struct nodemask_scratch
{
# 528 "include/linux/nodemask.h"
  nodemask_t mask1;
  nodemask_t mask2;
};
enum pageblock_bits
{
  PB_migrate = 0,
  PB_migrate_end = 2,
  PB_migrate_skip = 3,
  NR_PAGEBLOCK_BITS = 4
};
# 68 "include/linux/pageblock-flags.h"
long unsigned int get_pfnblock_flags_mask(struct page *, long unsigned int, long unsigned int, long unsigned int);
# 73 "include/linux/pageblock-flags.h"
void set_pfnblock_flags_mask(struct page *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
enum ldv_10269
{
  MIGRATE_UNMOVABLE = 0,
  MIGRATE_RECLAIMABLE = 1,
  MIGRATE_MOVABLE = 2,
  MIGRATE_PCPTYPES = 3,
  MIGRATE_RESERVE = 3,
  MIGRATE_CMA = 4,
  MIGRATE_ISOLATE = 5,
  MIGRATE_TYPES = 6
};
# 76 "include/linux/mmzone.h"
extern int page_group_by_mobility_disabled;
# 85 "include/linux/mmzone.h"
static inline int get_pfnblock_migratetype(struct page *page, long unsigned int pfn)
{
# 88 "include/linux/mmzone.h"
  return ( int ) get_pfnblock_flags_mask ( page , pfn , 2UL , 7UL );
}
struct free_area
{
# 93 "include/linux/mmzone.h"
  struct list_head free_list[6U];
  long unsigned int nr_free;
};
struct pglist_data;
struct zone_padding
{
# 107 "include/linux/mmzone.h"
  char x[0U];
};
enum zone_stat_item
{
  NR_FREE_PAGES = 0,
  NR_ALLOC_BATCH = 1,
  NR_LRU_BASE = 2,
  NR_INACTIVE_ANON = 2,
  NR_ACTIVE_ANON = 3,
  NR_INACTIVE_FILE = 4,
  NR_ACTIVE_FILE = 5,
  NR_UNEVICTABLE = 6,
  NR_MLOCK = 7,
  NR_ANON_PAGES = 8,
  NR_FILE_MAPPED = 9,
  NR_FILE_PAGES = 10,
  NR_FILE_DIRTY = 11,
  NR_WRITEBACK = 12,
  NR_SLAB_RECLAIMABLE = 13,
  NR_SLAB_UNRECLAIMABLE = 14,
  NR_PAGETABLE = 15,
  NR_KERNEL_STACK = 16,
  NR_UNSTABLE_NFS = 17,
  NR_BOUNCE = 18,
  NR_VMSCAN_WRITE = 19,
  NR_VMSCAN_IMMEDIATE = 20,
  NR_WRITEBACK_TEMP = 21,
  NR_ISOLATED_ANON = 22,
  NR_ISOLATED_FILE = 23,
  NR_SHMEM = 24,
  NR_DIRTIED = 25,
  NR_WRITTEN = 26,
  NR_PAGES_SCANNED = 27,
  NUMA_HIT = 28,
  NUMA_MISS = 29,
  NUMA_FOREIGN = 30,
  NUMA_INTERLEAVE_HIT = 31,
  NUMA_LOCAL = 32,
  NUMA_OTHER = 33,
  WORKINGSET_REFAULT = 34,
  WORKINGSET_ACTIVATE = 35,
  WORKINGSET_NODERECLAIM = 36,
  NR_ANON_TRANSPARENT_HUGEPAGES = 37,
  NR_FREE_CMA_PAGES = 38,
  NR_VM_ZONE_STAT_ITEMS = 39
};
enum lru_list
{
  LRU_INACTIVE_ANON = 0,
  LRU_ACTIVE_ANON = 1,
  LRU_INACTIVE_FILE = 2,
  LRU_ACTIVE_FILE = 3,
  LRU_UNEVICTABLE = 4,
  NR_LRU_LISTS = 5
};
# 188 "include/linux/mmzone.h"
static inline int is_file_lru(enum lru_list lru)
{
  return ( unsigned int ) lru == 2U || ( unsigned int ) lru == 3U;
}
# 193 "include/linux/mmzone.h"
static inline int is_active_lru(enum lru_list lru)
{
  return ( unsigned int ) lru == 1U || ( unsigned int ) lru == 3U;
}
# 198 "include/linux/mmzone.h"
static inline int is_unevictable_lru(enum lru_list lru)
{
  return ( unsigned int ) lru == 4U;
}
struct zone_reclaim_stat
{
# 212 "include/linux/mmzone.h"
  long unsigned int recent_rotated[2U];
  long unsigned int recent_scanned[2U];
};
struct lruvec
{
  struct list_head lists[5U];
  struct zone_reclaim_stat reclaim_stat;
# 220 "include/linux/mmzone.h"
  struct zone *zone;
};
# 239 "include/linux/mmzone.h"
typedef unsigned int isolate_mode_t;
enum zone_watermarks
{
  WMARK_MIN = 0,
  WMARK_LOW = 1,
  WMARK_HIGH = 2,
  NR_WMARK = 3
};
struct per_cpu_pages
{
# 253 "include/linux/mmzone.h"
  int count;
  int high;
  int batch;
# 258 "include/linux/mmzone.h"
  struct list_head lists[3U];
};
struct per_cpu_pageset
{
  struct per_cpu_pages pcp;
# 264 "include/linux/mmzone.h"
  s8 expire;
# 267 "include/linux/mmzone.h"
  s8 stat_threshold;
  s8 vm_stat_diff[39U];
};
enum zone_type
{
  ZONE_DMA = 0,
  ZONE_DMA32 = 1,
  ZONE_NORMAL = 2,
  ZONE_MOVABLE = 3,
  __MAX_NR_ZONES = 4
};
struct zone
{
# 331 "include/linux/mmzone.h"
  long unsigned int watermark[3U];
# 341 "include/linux/mmzone.h"
  long int lowmem_reserve[4U];
# 344 "include/linux/mmzone.h"
  int node;
# 351 "include/linux/mmzone.h"
  unsigned int inactive_ratio;
# 353 "include/linux/mmzone.h"
  struct pglist_data *zone_pgdat;
  struct per_cpu_pageset *pageset;
# 360 "include/linux/mmzone.h"
  long unsigned int dirty_balance_reserve;
# 374 "include/linux/mmzone.h"
  long unsigned int min_unmapped_pages;
  long unsigned int min_slab_pages;
# 379 "include/linux/mmzone.h"
  long unsigned int zone_start_pfn;
# 422 "include/linux/mmzone.h"
  long unsigned int managed_pages;
  long unsigned int spanned_pages;
  long unsigned int present_pages;
# 426 "include/linux/mmzone.h"
  char const *name;
# 432 "include/linux/mmzone.h"
  int nr_migrate_reserve_block;
# 436 "include/linux/mmzone.h"
  seqlock_t span_seqlock;
# 463 "include/linux/mmzone.h"
  wait_queue_head_t *wait_table;
  long unsigned int wait_table_hash_nr_entries;
  long unsigned int wait_table_bits;
# 467 "include/linux/mmzone.h"
  struct zone_padding _pad1_;
# 470 "include/linux/mmzone.h"
  spinlock_t lock;
# 473 "include/linux/mmzone.h"
  struct free_area free_area[11U];
# 476 "include/linux/mmzone.h"
  long unsigned int flags;
# 478 "include/linux/mmzone.h"
  struct zone_padding _pad2_;
# 483 "include/linux/mmzone.h"
  spinlock_t lru_lock;
  struct lruvec lruvec;
# 487 "include/linux/mmzone.h"
  atomic_long_t inactive_age;
# 494 "include/linux/mmzone.h"
  long unsigned int percpu_drift_mark;
# 498 "include/linux/mmzone.h"
  long unsigned int compact_cached_free_pfn;
# 500 "include/linux/mmzone.h"
  long unsigned int compact_cached_migrate_pfn[2U];
# 509 "include/linux/mmzone.h"
  unsigned int compact_considered;
  unsigned int compact_defer_shift;
  int compact_order_failed;
# 516 "include/linux/mmzone.h"
  bool compact_blockskip_flush;
# 519 "include/linux/mmzone.h"
  struct zone_padding _pad3_;
# 521 "include/linux/mmzone.h"
  atomic_long_t vm_stat[39U];
};
enum ldv_10319
{
  ZONE_RECLAIM_LOCKED = 0,
  ZONE_OOM_LOCKED = 1,
  ZONE_CONGESTED = 2,
  ZONE_TAIL_LRU_DIRTY = 3,
  ZONE_WRITEBACK = 4,
  ZONE_FAIR_DEPLETED = 5
};
# 538 "include/linux/mmzone.h"
typedef enum ldv_10319 zone_flags_t;
# 540 "include/linux/mmzone.h"
static inline void zone_set_flag(struct zone *zone, zone_flags_t flag)
{
  set_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * zone ) . flags );
}
# 545 "include/linux/mmzone.h"
static inline int zone_test_and_set_flag(struct zone *zone, zone_flags_t flag)
{
  return test_and_set_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * zone ) . flags );
}
# 550 "include/linux/mmzone.h"
static inline void zone_clear_flag(struct zone *zone, zone_flags_t flag)
{
  clear_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * zone ) . flags );
}
# 555 "include/linux/mmzone.h"
static inline int zone_is_reclaim_congested(struct zone const *zone)
{
  return constant_test_bit ( 2L , ( long unsigned int const volatile *) & ( * zone ) . flags );
}
# 560 "include/linux/mmzone.h"
static inline int zone_is_reclaim_dirty(struct zone const *zone)
{
  return constant_test_bit ( 3L , ( long unsigned int const volatile *) & ( * zone ) . flags );
}
# 565 "include/linux/mmzone.h"
static inline int zone_is_reclaim_writeback(struct zone const *zone)
{
  return constant_test_bit ( 4L , ( long unsigned int const volatile *) & ( * zone ) . flags );
}
# 570 "include/linux/mmzone.h"
static inline int zone_is_reclaim_locked(struct zone const *zone)
{
  return constant_test_bit ( 0L , ( long unsigned int const volatile *) & ( * zone ) . flags );
}
# 575 "include/linux/mmzone.h"
static inline int zone_is_fair_depleted(struct zone const *zone)
{
  return constant_test_bit ( 5L , ( long unsigned int const volatile *) & ( * zone ) . flags );
}
# 580 "include/linux/mmzone.h"
static inline int zone_is_oom_locked(struct zone const *zone)
{
  return constant_test_bit ( 1L , ( long unsigned int const volatile *) & ( * zone ) . flags );
}
# 585 "include/linux/mmzone.h"
static inline long unsigned int zone_end_pfn(struct zone const *zone)
{
  return ( long unsigned int ) ( * zone ) . zone_start_pfn + ( long unsigned int ) ( * zone ) . spanned_pages;
}
# 590 "include/linux/mmzone.h"
static inline bool zone_spans_pfn(struct zone const *zone, long unsigned int pfn)
{
  return ( bool ) ( ( long unsigned int ) ( * zone ) . zone_start_pfn <= pfn && zone_end_pfn ( zone ) > pfn );
}
# 595 "include/linux/mmzone.h"
static inline bool zone_is_initialized(struct zone *zone)
{
  return ( * zone ) . wait_table != ( ( wait_queue_head_t *) 0 );
}
# 600 "include/linux/mmzone.h"
static inline bool zone_is_empty(struct zone *zone)
{
  return ( * zone ) . spanned_pages == 0UL;
}
struct zonelist_cache
{
# 687 "include/linux/mmzone.h"
  short unsigned int z_to_n[4096U];
  long unsigned int fullzones[64U];
  long unsigned int last_full_zap;
};
struct zoneref
{
# 701 "include/linux/mmzone.h"
  struct zone *zone;
  int zone_idx;
};
struct zonelist
{
# 723 "include/linux/mmzone.h"
  struct zonelist_cache *zlcache_ptr;
  struct zoneref _zonerefs[4097U];
# 726 "include/linux/mmzone.h"
  struct zonelist_cache zlcache;
};
struct node_active_region
{
# 732 "include/linux/mmzone.h"
  long unsigned int start_pfn;
  long unsigned int end_pfn;
  int nid;
};
# 740 "include/linux/mmzone.h"
extern struct page *mem_map;
struct bootmem_data;
struct pglist_data
{
# 756 "include/linux/mmzone.h"
  struct zone node_zones[4U];
  struct zonelist node_zonelists[2U];
  int nr_zones;
# 779 "include/linux/mmzone.h"
  spinlock_t node_size_lock;
# 781 "include/linux/mmzone.h"
  long unsigned int node_start_pfn;
  long unsigned int node_present_pages;
  long unsigned int node_spanned_pages;
# 785 "include/linux/mmzone.h"
  int node_id;
  wait_queue_head_t kswapd_wait;
  wait_queue_head_t pfmemalloc_wait;
  struct task_struct *kswapd;
# 790 "include/linux/mmzone.h"
  int kswapd_max_order;
  enum zone_type classzone_idx;
# 794 "include/linux/mmzone.h"
  spinlock_t numabalancing_migrate_lock;
# 797 "include/linux/mmzone.h"
  long unsigned int numabalancing_migrate_next_window;
# 800 "include/linux/mmzone.h"
  long unsigned int numabalancing_migrate_nr_pages;
};
typedef struct pglist_data pg_data_t;
# 816 "include/linux/mmzone.h"
static inline long unsigned int pgdat_end_pfn(pg_data_t *pgdat)
{
  return ( * pgdat ) . node_start_pfn + ( * pgdat ) . node_spanned_pages;
}
# 821 "include/linux/mmzone.h"
static inline bool pgdat_is_empty(pg_data_t *pgdat)
{
  return ( bool ) ( ( * pgdat ) . node_start_pfn == 0UL && ( * pgdat ) . node_spanned_pages == 0UL );
}
struct rw_semaphore;
struct rw_semaphore
{
# 28 "include/linux/rwsem.h"
  long int count;
  struct list_head wait_list;
  raw_spinlock_t wait_lock;
# 32 "include/linux/rwsem.h"
  struct optimistic_spin_queue osq;
# 37 "include/linux/rwsem.h"
  struct task_struct *owner;
# 40 "include/linux/rwsem.h"
  struct lockdep_map dep_map;
};
# 44 "include/linux/rwsem.h"
struct rw_semaphore *rwsem_down_read_failed(struct rw_semaphore *);
struct rw_semaphore *rwsem_down_write_failed(struct rw_semaphore *);
struct rw_semaphore *rwsem_wake(struct rw_semaphore *);
struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *);
# 63 "./arch/x86/include/asm/rwsem.h"
static inline void __down_read(struct rw_semaphore *sem)
{
  asm volatile ( "# beginning down_read\n\t.pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock;  incq (%1)\n\t  jns        1f\n  call call_rwsem_down_read_failed\n1:\n\t# ending down_read\n\t" : "+m" ( (
# 72 "./arch/x86/include/asm/rwsem.h"
  * sem ) . count ) : "a" ( sem ) : "memory" , "cc" ) ;
}
# 80 "./arch/x86/include/asm/rwsem.h"
static inline int __down_read_trylock(struct rw_semaphore *sem)
{
  long int result;
# 82 "./arch/x86/include/asm/rwsem.h"
  long int tmp;
  asm volatile ( "# beginning __down_read_trylock\n\t  mov          %0,%1\n\t1:\n\t  mov          %1,%2\n\t  add          %3,%2\n\t  jle\t     2f\n\t.pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock;   cmpxchg  %2,%0\n\t  jnz\t     1b\n\t2:\n\t# ending __down_read_trylock\n\t" : "+m" ( (
# 93 "./arch/x86/include/asm/rwsem.h"
  * sem ) . count ) , "=&a" ( result ) , "=&r" ( tmp ) : "i" ( 1L ) : "memory" , "cc" ) ;
# 96 "./arch/x86/include/asm/rwsem.h"
  return result >= 0L;
}
# 102 "./arch/x86/include/asm/rwsem.h"
static inline void __down_write_nested(struct rw_semaphore *sem, int subclass)
{
  long int tmp;
  asm volatile ( "# beginning down_write\n\t.pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock;   xadd      %1,(%2)\n\t  test  %k1 , %k1 \n\t  jz        1f\n  call call_rwsem_down_write_failed\n1:\n# ending down_write" : "+m" ( (
# 114 "./arch/x86/include/asm/rwsem.h"
  * sem ) . count ) , "=d" ( tmp ) : "a" ( sem ) , "1" ( -4294967295L ) : "memory" , "cc" ) ;
}
# 119 "./arch/x86/include/asm/rwsem.h"
static inline void __down_write(struct rw_semaphore *sem)
{
  __down_write_nested ( sem , 0 );
}
# 127 "./arch/x86/include/asm/rwsem.h"
static inline int __down_write_trylock(struct rw_semaphore *sem)
{
  long int result;
# 129 "./arch/x86/include/asm/rwsem.h"
  long int tmp;
  asm volatile ( "# beginning __down_write_trylock\n\t  mov          %0,%1\n\t1:\n\t  test  %k1 , %k1 \n\t  jnz          2f\n\t  mov          %1,%2\n\t  add          %3,%2\n\t.pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock;   cmpxchg  %2,%0\n\t  jnz\t     1b\n\t2:\n\t  sete         %b1\n\t  movzbl       %b1, %k1\n\t# ending __down_write_trylock\n\t" : "+m" ( (
# 144 "./arch/x86/include/asm/rwsem.h"
  * sem ) . count ) , "=&a" ( result ) , "=&r" ( tmp ) : "er" ( -4294967295L ) : "memory" , "cc" ) ;
# 147 "./arch/x86/include/asm/rwsem.h"
  return ( int ) result;
}
# 153 "./arch/x86/include/asm/rwsem.h"
static inline void __up_read(struct rw_semaphore *sem)
{
  long int tmp;
  asm volatile ( "# beginning __up_read\n\t.pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock;   xadd      %1,(%2)\n\t  jns        1f\n\t  call call_rwsem_wake\n1:\n# ending __up_read\n" : "+m" ( (
# 163 "./arch/x86/include/asm/rwsem.h"
  * sem ) . count ) , "=d" ( tmp ) : "a" ( sem ) , "1" ( -1L ) : "memory" , "cc" ) ;
}
# 171 "./arch/x86/include/asm/rwsem.h"
static inline void __up_write(struct rw_semaphore *sem)
{
  long int tmp;
  asm volatile ( "# beginning __up_write\n\t.pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock;   xadd      %1,(%2)\n\t  jns        1f\n\t  call call_rwsem_wake\n1:\n\t# ending __up_write\n" : "+m" ( (
# 181 "./arch/x86/include/asm/rwsem.h"
  * sem ) . count ) , "=d" ( tmp ) : "a" ( sem ) , "1" ( 4294967295L ) : "memory" , "cc" ) ;
}
# 189 "./arch/x86/include/asm/rwsem.h"
static inline void __downgrade_write(struct rw_semaphore *sem)
{
  asm volatile ( "# beginning __downgrade_write\n\t.pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock;  addq %2,(%1)\n\t  jns       1f\n\t  call call_rwsem_downgrade_wake\n1:\n\t# ending __downgrade_write\n" : "+m" ( (
# 201 "./arch/x86/include/asm/rwsem.h"
  * sem ) . count ) : "a" ( sem ) , "er" ( 4294967296L ) : "memory" , "cc" ) ;
}
# 209 "./arch/x86/include/asm/rwsem.h"
static inline void rwsem_atomic_add(long int delta, struct rw_semaphore *sem)
{
  asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock;  addq %1,%0" : "+m" ( (
# 212 "./arch/x86/include/asm/rwsem.h"
  * sem ) . count ) : "er" ( delta ) ) ;
}
# 219 "./arch/x86/include/asm/rwsem.h"
static inline long int rwsem_atomic_update(long int delta, struct rw_semaphore *sem)
{
  return ({
# 221 "./arch/x86/include/asm/rwsem.h"
    long int __ret = delta;
    {
# 221 "./arch/x86/include/asm/rwsem.h"
      switch (8UL)
      {
# 221 "./arch/x86/include/asm/rwsem.h"
        case 1:;
# 221 "./arch/x86/include/asm/rwsem.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n" : "+q" ( __ret ) , "+m" ( ( * sem ) . count ) : : "memory" , "cc" ) ;
# 221 "./arch/x86/include/asm/rwsem.h"
        goto ldv_8126;
# 221 "./arch/x86/include/asm/rwsem.h"
        case 2:;
# 221 "./arch/x86/include/asm/rwsem.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n" : "+r" ( __ret ) , "+m" ( ( * sem ) . count ) : : "memory" , "cc" ) ;
# 221 "./arch/x86/include/asm/rwsem.h"
        goto ldv_8126;
# 221 "./arch/x86/include/asm/rwsem.h"
        case 4:;
# 221 "./arch/x86/include/asm/rwsem.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n" : "+r" ( __ret ) , "+m" ( ( * sem ) . count ) : : "memory" , "cc" ) ;
# 221 "./arch/x86/include/asm/rwsem.h"
        goto ldv_8126;
# 221 "./arch/x86/include/asm/rwsem.h"
        case 8:;
# 221 "./arch/x86/include/asm/rwsem.h"
        asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n" : "+r" ( __ret ) , "+m" ( ( * sem ) . count ) : : "memory" , "cc" ) ;
# 221 "./arch/x86/include/asm/rwsem.h"
        goto ldv_8126;
# 221 "./arch/x86/include/asm/rwsem.h"
        default:;
# 221 "./arch/x86/include/asm/rwsem.h"
        __xadd_wrong_size ( );
      }
# 221 "./arch/x86/include/asm/rwsem.h"
      ldv_8126:;
    }
# 221 "./arch/x86/include/asm/rwsem.h"
    __ret;
  } )
# 221 "./arch/x86/include/asm/rwsem.h"
  + delta;
}
# 53 "include/linux/rwsem.h"
static inline int rwsem_is_locked(struct rw_semaphore *sem)
{
  return ( * sem ) . count != 0L;
}
# 84 "include/linux/rwsem.h"
void __init_rwsem(struct rw_semaphore *, char const *, struct lock_class_key *);
# 100 "include/linux/rwsem.h"
static inline int rwsem_is_contended(struct rw_semaphore *sem)
{
  return list_empty ( ( struct list_head const *) & ( * sem ) . wait_list ) == 0;
}
# 108 "include/linux/rwsem.h"
void down_read(struct rw_semaphore *);
# 113 "include/linux/rwsem.h"
int down_read_trylock(struct rw_semaphore *);
# 118 "include/linux/rwsem.h"
void down_write(struct rw_semaphore *);
# 123 "include/linux/rwsem.h"
int down_write_trylock(struct rw_semaphore *);
# 128 "include/linux/rwsem.h"
void up_read(struct rw_semaphore *);
# 133 "include/linux/rwsem.h"
void up_write(struct rw_semaphore *);
# 138 "include/linux/rwsem.h"
void downgrade_write(struct rw_semaphore *);
# 154 "include/linux/rwsem.h"
void down_read_nested(struct rw_semaphore *, int);
void down_write_nested(struct rw_semaphore *, int);
void _down_write_nest_lock(struct rw_semaphore *, struct lockdep_map *);
# 170 "include/linux/rwsem.h"
void down_read_non_owner(struct rw_semaphore *);
void up_read_non_owner(struct rw_semaphore *);
struct completion
{
# 26 "include/linux/completion.h"
  unsigned int done;
  wait_queue_head_t wait;
};
# 73 "include/linux/completion.h"
static inline void init_completion(struct completion *x)
{
  ( * x ) . done = 0U;
  {
# 76 "include/linux/completion.h"
    struct lock_class_key __key;
# 76 "include/linux/completion.h"
    __init_waitqueue_head ( & ( * x ) . wait , ( char const *) "&x->wait" , & __key );
  }
}
# 86 "include/linux/completion.h"
static inline void reinit_completion(struct completion *x)
{
  ( * x ) . done = 0U;
}
# 91 "include/linux/completion.h"
void wait_for_completion(struct completion *);
void wait_for_completion_io(struct completion *);
int wait_for_completion_interruptible(struct completion *);
int wait_for_completion_killable(struct completion *);
long unsigned int wait_for_completion_timeout(struct completion *, long unsigned int);
# 97 "include/linux/completion.h"
long unsigned int wait_for_completion_io_timeout(struct completion *, long unsigned int);
# 99 "include/linux/completion.h"
long int wait_for_completion_interruptible_timeout(struct completion *, long unsigned int);
# 101 "include/linux/completion.h"
long int wait_for_completion_killable_timeout(struct completion *, long unsigned int);
# 103 "include/linux/completion.h"
bool try_wait_for_completion(struct completion *);
bool completion_done(struct completion *);
# 106 "include/linux/completion.h"
void complete(struct completion *);
void complete_all(struct completion *);
enum debug_obj_state
{
  ODEBUG_STATE_NONE = 0,
  ODEBUG_STATE_INIT = 1,
  ODEBUG_STATE_INACTIVE = 2,
  ODEBUG_STATE_ACTIVE = 3,
  ODEBUG_STATE_DESTROYED = 4,
  ODEBUG_STATE_NOTAVAILABLE = 5,
  ODEBUG_STATE_MAX = 6
};
struct debug_obj_descr;
struct debug_obj
{
# 28 "include/linux/debugobjects.h"
  struct hlist_node node;
  enum debug_obj_state state;
  unsigned int astate;
  void *object;
  struct debug_obj_descr *descr;
};
struct debug_obj_descr
{
# 53 "include/linux/debugobjects.h"
  char const *name;
  void *(*debug_hint)(void *);
  int (*fixup_init)(void *, enum debug_obj_state);
  int (*fixup_activate)(void *, enum debug_obj_state);
  int (*fixup_destroy)(void *, enum debug_obj_state);
  int (*fixup_free)(void *, enum debug_obj_state);
  int (*fixup_assert_init)(void *, enum debug_obj_state);
};
# 63 "include/linux/debugobjects.h"
void debug_object_init(void *, struct debug_obj_descr *);
# 65 "include/linux/debugobjects.h"
void debug_object_init_on_stack(void *, struct debug_obj_descr *);
int debug_object_activate(void *, struct debug_obj_descr *);
void debug_object_deactivate(void *, struct debug_obj_descr *);
void debug_object_destroy(void *, struct debug_obj_descr *);
void debug_object_free(void *, struct debug_obj_descr *);
void debug_object_assert_init(void *, struct debug_obj_descr *);
# 78 "include/linux/debugobjects.h"
void debug_object_active_state(void *, struct debug_obj_descr *, unsigned int, unsigned int);
# 81 "include/linux/debugobjects.h"
void debug_objects_early_init(void);
void debug_objects_mem_init(void);
# 104 "include/linux/debugobjects.h"
void debug_check_no_obj_freed(void const *, long unsigned int);
# 49 "include/linux/rcupdate.h"
extern int rcu_expedited;
enum rcutorture_type
{
  RCU_FLAVOR = 0,
  RCU_BH_FLAVOR = 1,
  RCU_SCHED_FLAVOR = 2,
  SRCU_FLAVOR = 3,
  INVALID_RCU_FLAVOR = 4
};
# 63 "include/linux/rcupdate.h"
void rcutorture_get_gp_data(enum rcutorture_type, int *, long unsigned int *, long unsigned int *);
# 65 "include/linux/rcupdate.h"
void rcutorture_record_test_transition(void);
void rcutorture_record_progress(long unsigned int);
void do_trace_rcu_torture_read(char const *, struct callback_head *, long unsigned int, long unsigned int, long unsigned int);
# 173 "include/linux/rcupdate.h"
void call_rcu_bh(struct callback_head *, void (*)(struct callback_head *));
# 195 "include/linux/rcupdate.h"
void call_rcu_sched(struct callback_head *, void (*)(struct callback_head *));
# 198 "include/linux/rcupdate.h"
void synchronize_sched(void);
# 217 "include/linux/rcupdate.h"
static inline void __rcu_read_lock(void)
{
  __preempt_count_add ( 1 );
# 219 "include/linux/rcupdate.h"
  asm volatile ( "" : : : "memory" ) ;
}
# 222 "include/linux/rcupdate.h"
static inline void __rcu_read_unlock(void)
{
  asm volatile ( "" : : : "memory" ) ;
# 224 "include/linux/rcupdate.h"
  __preempt_count_sub ( 1 );
}
# 227 "include/linux/rcupdate.h"
static inline void synchronize_rcu(void)
{
  synchronize_sched ( );
}
# 232 "include/linux/rcupdate.h"
static inline int rcu_preempt_depth(void)
{
  return 0;
}
# 240 "include/linux/rcupdate.h"
void rcu_init(void);
void rcu_sched_qs(int);
void rcu_bh_qs(int);
void rcu_check_callbacks(int, int);
struct notifier_block;
void rcu_idle_enter(void);
void rcu_idle_exit(void);
void rcu_irq_enter(void);
void rcu_irq_exit(void);
# 251 "include/linux/rcupdate.h"
void rcu_sysrq_start(void);
void rcu_sysrq_end(void);
# 263 "include/linux/rcupdate.h"
void rcu_user_enter(void);
void rcu_user_exit(void);
# 298 "include/linux/rcupdate.h"
bool __rcu_is_watching(void);
# 306 "include/linux/rcupdate.h"
typedef void call_rcu_func_t(struct callback_head *, void (*)(struct callback_head *));
# 308 "include/linux/rcupdate.h"
void wait_rcu_gp(call_rcu_func_t *);
# 33 "include/linux/rcutree.h"
void rcu_note_context_switch(int);
# 35 "include/linux/rcutree.h"
int rcu_needs_cpu(int, long unsigned int *);
# 37 "include/linux/rcutree.h"
void rcu_cpu_stall_reset(void);
# 44 "include/linux/rcutree.h"
static inline void rcu_virt_note_context_switch(int cpu)
{
  rcu_note_context_switch ( cpu );
}
# 49 "include/linux/rcutree.h"
void synchronize_rcu_bh(void);
void synchronize_sched_expedited(void);
void synchronize_rcu_expedited(void);
# 53 "include/linux/rcutree.h"
void kfree_call_rcu(struct callback_head *, void (*)(struct callback_head *));
# 71 "include/linux/rcutree.h"
static inline void synchronize_rcu_bh_expedited(void)
{
  synchronize_sched_expedited ( );
}
# 76 "include/linux/rcutree.h"
void rcu_barrier(void);
void rcu_barrier_bh(void);
void rcu_barrier_sched(void);
long unsigned int get_state_synchronize_rcu(void);
void cond_synchronize_rcu(long unsigned int);
# 82 "include/linux/rcutree.h"
extern long unsigned int rcutorture_testseq;
extern long unsigned int rcutorture_vernum;
long int rcu_batches_completed(void);
long int rcu_batches_completed_bh(void);
long int rcu_batches_completed_sched(void);
void show_rcu_gp_kthreads(void);
# 89 "include/linux/rcutree.h"
void rcu_force_quiescent_state(void);
void rcu_bh_force_quiescent_state(void);
void rcu_sched_force_quiescent_state(void);
# 93 "include/linux/rcutree.h"
void exit_rcu(void);
# 95 "include/linux/rcutree.h"
void rcu_scheduler_starting(void);
extern int rcu_scheduler_active;
# 98 "include/linux/rcutree.h"
bool rcu_is_watching(void);
# 325 "include/linux/rcupdate.h"
void init_rcu_head(struct callback_head *);
void destroy_rcu_head(struct callback_head *);
void init_rcu_head_on_stack(struct callback_head *);
void destroy_rcu_head_on_stack(struct callback_head *);
# 348 "include/linux/rcupdate.h"
bool rcu_lockdep_current_cpu_online(void);
# 358 "include/linux/rcupdate.h"
static inline void rcu_lock_acquire(struct lockdep_map *map)
{
  lock_acquire ( map , 0U , 0 , 2 , 0 , ( ( struct lockdep_map *) 0 ) , 0UL );
}
# 363 "include/linux/rcupdate.h"
static inline void rcu_lock_release(struct lockdep_map *map)
{
  lock_release ( map , 1 , 0UL );
}
# 368 "include/linux/rcupdate.h"
extern struct lockdep_map rcu_lock_map;
extern struct lockdep_map rcu_bh_lock_map;
extern struct lockdep_map rcu_sched_lock_map;
extern struct lockdep_map rcu_callback_map;
int debug_lockdep_rcu_enabled(void);
# 394 "include/linux/rcupdate.h"
static inline int rcu_read_lock_held(void)
{
  if (debug_lockdep_rcu_enabled ( ) == 0)
    return 1;
  if (( int ) ! ( _Bool ) rcu_is_watching ( ))
    return 0;
  if (( int ) ! ( _Bool ) rcu_lockdep_current_cpu_online ( ))
    return 0;
  return lock_is_held ( & rcu_lock_map );
}
# 409 "include/linux/rcupdate.h"
int rcu_read_lock_bh_held(void);
# 443 "include/linux/rcupdate.h"
static inline int rcu_read_lock_sched_held(void)
{
  int lockdep_opinion = 0;
# 447 "include/linux/rcupdate.h"
  if (debug_lockdep_rcu_enabled ( ) == 0)
    return 1;
  if (( int ) ! ( _Bool ) rcu_is_watching ( ))
    return 0;
  if (( int ) ! ( _Bool ) rcu_lockdep_current_cpu_online ( ))
    return 0;
  if (debug_locks != 0)
    lockdep_opinion = lock_is_held ( & rcu_sched_lock_map );
  return lockdep_opinion != 0 || preempt_count ( ) != 0 || ({
# 455 "include/linux/rcupdate.h"
    long unsigned int _flags;
    {
# 455 "include/linux/rcupdate.h"
      ({
# 455 "include/linux/rcupdate.h"
        long unsigned int __dummy;
# 455 "include/linux/rcupdate.h"
        long unsigned int __dummy2;
# 455 "include/linux/rcupdate.h"
        ( void ) 0;
# 455 "include/linux/rcupdate.h"
        1;
      } );
# 455 "include/linux/rcupdate.h"
      _flags = arch_local_save_flags ( );
    }
# 455 "include/linux/rcupdate.h"
    ({
# 455 "include/linux/rcupdate.h"
      ({
# 455 "include/linux/rcupdate.h"
        long unsigned int __dummy;
# 455 "include/linux/rcupdate.h"
        long unsigned int __dummy2;
# 455 "include/linux/rcupdate.h"
        ( void ) 0;
# 455 "include/linux/rcupdate.h"
        1;
      } );
# 455 "include/linux/rcupdate.h"
      arch_irqs_disabled_flags ( _flags );
    } );
  } )
# 455 "include/linux/rcupdate.h"
  != 0;
}
# 510 "include/linux/rcupdate.h"
static inline void rcu_preempt_sleep_check(void)
{
  {
# 512 "include/linux/rcupdate.h"
    bool __warned;
# 512 "include/linux/rcupdate.h"
    if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && lock_is_held ( & rcu_lock_map ) != 0)
    {
# 512 "include/linux/rcupdate.h"
      __warned = 1;
# 512 "include/linux/rcupdate.h"
      lockdep_rcu_suspicious (
# 513 "include/linux/rcupdate.h"
      ( char const *) "include/linux/rcupdate.h" , 513 ,
# 512 "include/linux/rcupdate.h"
      ( char const *) "Illegal context switch in RCU read-side critical section" );
    }
  }
}
# 838 "include/linux/rcupdate.h"
static inline void rcu_read_lock(void)
{
  __rcu_read_lock ( );
  ( void ) 0;
  rcu_lock_acquire ( & rcu_lock_map );
  {
# 843 "include/linux/rcupdate.h"
    bool __warned;
# 843 "include/linux/rcupdate.h"
    if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && ( int ) ! ( _Bool ) rcu_is_watching ( ))
    {
# 843 "include/linux/rcupdate.h"
      __warned = 1;
# 843 "include/linux/rcupdate.h"
      lockdep_rcu_suspicious (
# 844 "include/linux/rcupdate.h"
      ( char const *) "include/linux/rcupdate.h" , 844 ,
# 843 "include/linux/rcupdate.h"
      ( char const *) "rcu_read_lock() used illegally while idle" );
    }
  }
}
# 890 "include/linux/rcupdate.h"
static inline void rcu_read_unlock(void)
{
  {
# 892 "include/linux/rcupdate.h"
    bool __warned;
# 892 "include/linux/rcupdate.h"
    if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && ( int ) ! ( _Bool ) rcu_is_watching ( ))
    {
# 892 "include/linux/rcupdate.h"
      __warned = 1;
# 892 "include/linux/rcupdate.h"
      lockdep_rcu_suspicious (
# 893 "include/linux/rcupdate.h"
      ( char const *) "include/linux/rcupdate.h" , 893 ,
# 892 "include/linux/rcupdate.h"
      ( char const *) "rcu_read_unlock() used illegally while idle" );
    }
  }
# 894 "include/linux/rcupdate.h"
  rcu_lock_release ( & rcu_lock_map );
  ( void ) 0;
  __rcu_read_unlock ( );
}
# 916 "include/linux/rcupdate.h"
static inline void rcu_read_lock_bh(void)
{
  local_bh_disable ( );
  ( void ) 0;
  rcu_lock_acquire ( & rcu_bh_lock_map );
  {
# 921 "include/linux/rcupdate.h"
    bool __warned;
# 921 "include/linux/rcupdate.h"
    if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && ( int ) ! ( _Bool ) rcu_is_watching ( ))
    {
# 921 "include/linux/rcupdate.h"
      __warned = 1;
# 921 "include/linux/rcupdate.h"
      lockdep_rcu_suspicious (
# 922 "include/linux/rcupdate.h"
      ( char const *) "include/linux/rcupdate.h" , 922 ,
# 921 "include/linux/rcupdate.h"
      ( char const *) "rcu_read_lock_bh() used illegally while idle" );
    }
  }
}
# 930 "include/linux/rcupdate.h"
static inline void rcu_read_unlock_bh(void)
{
  {
# 932 "include/linux/rcupdate.h"
    bool __warned;
# 932 "include/linux/rcupdate.h"
    if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && ( int ) ! ( _Bool ) rcu_is_watching ( ))
    {
# 932 "include/linux/rcupdate.h"
      __warned = 1;
# 932 "include/linux/rcupdate.h"
      lockdep_rcu_suspicious (
# 933 "include/linux/rcupdate.h"
      ( char const *) "include/linux/rcupdate.h" , 933 ,
# 932 "include/linux/rcupdate.h"
      ( char const *) "rcu_read_unlock_bh() used illegally while idle" );
    }
  }
# 934 "include/linux/rcupdate.h"
  rcu_lock_release ( & rcu_bh_lock_map );
  ( void ) 0;
  local_bh_enable ( );
}
# 952 "include/linux/rcupdate.h"
static inline void rcu_read_lock_sched(void)
{
  __preempt_count_add ( 1 );
# 954 "include/linux/rcupdate.h"
  asm volatile ( "" : : : "memory" ) ;
  ( void ) 0;
  rcu_lock_acquire ( & rcu_sched_lock_map );
  {
# 957 "include/linux/rcupdate.h"
    bool __warned;
# 957 "include/linux/rcupdate.h"
    if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && ( int ) ! ( _Bool ) rcu_is_watching ( ))
    {
# 957 "include/linux/rcupdate.h"
      __warned = 1;
# 957 "include/linux/rcupdate.h"
      lockdep_rcu_suspicious (
# 958 "include/linux/rcupdate.h"
      ( char const *) "include/linux/rcupdate.h" , 958 ,
# 957 "include/linux/rcupdate.h"
      ( char const *) "rcu_read_lock_sched() used illegally while idle" );
    }
  }
}
# 962 "include/linux/rcupdate.h"
static inline void rcu_read_lock_sched_notrace(void)
{
  __preempt_count_add ( 1 );
# 964 "include/linux/rcupdate.h"
  asm volatile ( "" : : : "memory" ) ;
  ( void ) 0;
}
# 973 "include/linux/rcupdate.h"
static inline void rcu_read_unlock_sched(void)
{
  {
# 975 "include/linux/rcupdate.h"
    bool __warned;
# 975 "include/linux/rcupdate.h"
    if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && ( int ) ! ( _Bool ) rcu_is_watching ( ))
    {
# 975 "include/linux/rcupdate.h"
      __warned = 1;
# 975 "include/linux/rcupdate.h"
      lockdep_rcu_suspicious (
# 976 "include/linux/rcupdate.h"
      ( char const *) "include/linux/rcupdate.h" , 976 ,
# 975 "include/linux/rcupdate.h"
      ( char const *) "rcu_read_unlock_sched() used illegally while idle" );
    }
  }
# 977 "include/linux/rcupdate.h"
  rcu_lock_release ( & rcu_sched_lock_map );
  ( void ) 0;
  asm volatile ( "" : : : "memory" ) ;
# 979 "include/linux/rcupdate.h"
  __preempt_count_sub ( 1 );
}
# 983 "include/linux/rcupdate.h"
static inline void rcu_read_unlock_sched_notrace(void)
{
  ( void ) 0;
  asm volatile ( "" : : : "memory" ) ;
# 986 "include/linux/rcupdate.h"
  __preempt_count_sub ( 1 );
}
# 1092 "include/linux/rcupdate.h"
bool rcu_is_nocb_cpu(int);
# 1104 "include/linux/rcupdate.h"
static inline bool rcu_sys_is_idle(void)
{
  return 0;
}
# 1109 "include/linux/rcupdate.h"
static inline void rcu_sysidle_force_exit(void)
{
}
struct timex
{
# 65 "include/uapi/linux/timex.h"
  unsigned int modes;
  __kernel_long_t offset;
  __kernel_long_t freq;
  __kernel_long_t maxerror;
  __kernel_long_t esterror;
  int status;
  __kernel_long_t constant;
  __kernel_long_t precision;
  __kernel_long_t tolerance;
# 76 "include/uapi/linux/timex.h"
  struct timeval time;
  __kernel_long_t tick;
# 79 "include/uapi/linux/timex.h"
  __kernel_long_t ppsfreq;
  __kernel_long_t jitter;
  int shift;
  __kernel_long_t stabil;
  __kernel_long_t jitcnt;
  __kernel_long_t calcnt;
  __kernel_long_t errcnt;
  __kernel_long_t stbcnt;
# 88 "include/uapi/linux/timex.h"
  int tai;
# 90 "include/uapi/linux/timex.h"
  int ldv_8509;
# 90 "include/uapi/linux/timex.h"
  int ldv_8510;
# 90 "include/uapi/linux/timex.h"
  int ldv_8511;
# 90 "include/uapi/linux/timex.h"
  int ldv_8512;
  int ldv_8513;
# 91 "include/uapi/linux/timex.h"
  int ldv_8514;
# 91 "include/uapi/linux/timex.h"
  int ldv_8515;
# 91 "include/uapi/linux/timex.h"
  int ldv_8516;
  int ldv_8517;
# 92 "include/uapi/linux/timex.h"
  int ldv_8518;
# 92 "include/uapi/linux/timex.h"
  int ldv_8519;
};
# 15 "./arch/x86/include/asm/tsc.h"
typedef long long unsigned int cycles_t;
# 17 "./arch/x86/include/asm/tsc.h"
extern unsigned int cpu_khz;
extern unsigned int tsc_khz;
# 20 "./arch/x86/include/asm/tsc.h"
void disable_TSC(void);
# 22 "./arch/x86/include/asm/tsc.h"
static inline cycles_t get_cycles(void)
{
  long long unsigned int ret = 0ULL;
# 30 "./arch/x86/include/asm/tsc.h"
  ret = paravirt_read_tsc ( );
# 32 "./arch/x86/include/asm/tsc.h"
  return ( cycles_t ) ret;
}
# 35 "./arch/x86/include/asm/tsc.h"
static inline cycles_t vget_cycles(void)
{
# 45 "./arch/x86/include/asm/tsc.h"
  return ( cycles_t ) __native_read_tsc ( );
}
# 48 "./arch/x86/include/asm/tsc.h"
void tsc_init(void);
void mark_tsc_unstable(char *);
int unsynchronized_tsc(void);
int check_tsc_unstable(void);
int check_tsc_disabled(void);
long unsigned int native_calibrate_tsc(void);
# 55 "./arch/x86/include/asm/tsc.h"
extern int tsc_clocksource_reliable;
# 61 "./arch/x86/include/asm/tsc.h"
void check_tsc_sync_source(int);
void check_tsc_sync_target(void);
# 64 "./arch/x86/include/asm/tsc.h"
int notsc_setup(char *);
void tsc_save_sched_clock_state(void);
void tsc_restore_sched_clock_state(void);
# 69 "./arch/x86/include/asm/tsc.h"
long unsigned int try_msr_calibrate_tsc(void);
# 139 "include/linux/timex.h"
extern long unsigned int tick_usec;
extern long unsigned int tick_nsec;
# 154 "include/linux/timex.h"
int do_adjtimex(struct timex *);
void hardpps(struct timespec const *, struct timespec const *);
# 157 "include/linux/timex.h"
int read_current_timer(long unsigned int *);
void ntp_notify_cmos_timer(void);
# 57 "include/linux/jiffies.h"
int register_refined_jiffies(long int);
# 76 "include/linux/jiffies.h"
extern u64 jiffies_64;
extern long unsigned int volatile jiffies;
# 82 "include/linux/jiffies.h"
static inline u64 get_jiffies_64(void)
{
  return ( u64 ) jiffies;
}
# 182 "include/linux/jiffies.h"
extern long unsigned int preset_lpj;
# 295 "include/linux/jiffies.h"
unsigned int jiffies_to_msecs(long unsigned int const);
unsigned int jiffies_to_usecs(long unsigned int const);
# 298 "include/linux/jiffies.h"
static inline u64 jiffies_to_nsecs(long unsigned int const j)
{
  return ( u64 ) ( ( long long unsigned int ) jiffies_to_usecs ( j ) * 1000ULL );
}
# 303 "include/linux/jiffies.h"
long unsigned int msecs_to_jiffies(unsigned int const);
long unsigned int usecs_to_jiffies(unsigned int const);
long unsigned int timespec_to_jiffies(struct timespec const *);
void jiffies_to_timespec(long unsigned int const, struct timespec *);
# 308 "include/linux/jiffies.h"
long unsigned int timeval_to_jiffies(struct timeval const *);
void jiffies_to_timeval(long unsigned int const, struct timeval *);
# 312 "include/linux/jiffies.h"
clock_t jiffies_to_clock_t(long unsigned int);
static inline clock_t jiffies_delta_to_clock_t(long int delta)
{
  return jiffies_to_clock_t ( ( long unsigned int ) ({
# 315 "include/linux/jiffies.h"
    long int _max1 = 0L;
# 315 "include/linux/jiffies.h"
    long int _max2 = delta;
# 315 "include/linux/jiffies.h"
    ( void ) 0;
# 315 "include/linux/jiffies.h"
    ((_max1) > (_max2) ? (_max1) : (_max2));
  } ) );
}
long unsigned int clock_t_to_jiffies(long unsigned int);
u64 jiffies_64_to_clock_t(u64);
u64 nsec_to_clock_t(u64);
u64 nsecs_to_jiffies64(u64);
long unsigned int nsecs_to_jiffies(u64);
union ktime
{
# 38 "include/linux/ktime.h"
  s64 tv64;
};
# 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
# 50 "include/linux/ktime.h"
static inline ktime_t ktime_set(s64 const secs, long unsigned int const nsecs)
{
  if (__builtin_expect ( ( long long int ) secs > 9223372035LL , 0L ) != 0L)
    return ( ktime_t ) { . tv64 = 9223372036854775807LL };
# 55 "include/linux/ktime.h"
  return ( ktime_t ) { . tv64 = ( long long int ) secs * 1000000000LL + ( long long int ) nsecs };
}
# 81 "include/linux/ktime.h"
static inline ktime_t timespec_to_ktime(struct timespec ts)
{
  return ktime_set ( ( s64 const ) ts . tv_sec , ( long unsigned int const ) ts . tv_nsec );
}
# 87 "include/linux/ktime.h"
static inline ktime_t timespec64_to_ktime(struct timespec ts)
{
  return ktime_set ( ( s64 const ) ts . tv_sec , ( long unsigned int const ) ts . tv_nsec );
}
# 93 "include/linux/ktime.h"
static inline ktime_t timeval_to_ktime(struct timeval tv)
{
  return ktime_set ( ( s64 const ) tv . tv_sec , ( long unsigned int const ) ( ( long int ) tv . tv_usec * 1000L ) );
}
# 120 "include/linux/ktime.h"
static inline int ktime_equal(ktime_t const cmp1, ktime_t const cmp2)
{
  return ( long long int ) cmp1 . tv64 == ( long long int ) cmp2 . tv64;
}
# 135 "include/linux/ktime.h"
static inline int ktime_compare(ktime_t const cmp1, ktime_t const cmp2)
{
  if (( long long int ) cmp1 . tv64 < ( long long int ) cmp2 . tv64)
    return -1;
  if (( long long int ) cmp1 . tv64 > ( long long int ) cmp2 . tv64)
    return 1;
  return 0;
}
# 151 "include/linux/ktime.h"
static inline bool ktime_after(ktime_t const cmp1, ktime_t const cmp2)
{
  return ktime_compare ( cmp1 , cmp2 ) > 0;
}
# 163 "include/linux/ktime.h"
static inline bool ktime_before(ktime_t const cmp1, ktime_t const cmp2)
{
  return ktime_compare ( cmp1 , cmp2 ) < 0;
}
# 174 "include/linux/ktime.h"
static inline s64 ktime_to_us(ktime_t const kt)
{
  return ( s64 ) ( ( long long int ) kt . tv64 / 1000LL );
}
# 179 "include/linux/ktime.h"
static inline s64 ktime_to_ms(ktime_t const kt)
{
  return ( s64 ) ( ( long long int ) kt . tv64 / 1000000LL );
}
# 184 "include/linux/ktime.h"
static inline s64 ktime_us_delta(ktime_t const later, ktime_t const earlier)
{
  return ktime_to_us ( ( ktime_t ) { . tv64 = ( long long int ) later . tv64 - ( long long int ) earlier . tv64 } );
}
# 189 "include/linux/ktime.h"
static inline ktime_t ktime_add_us(ktime_t const kt, u64 const usec)
{
  return ( ktime_t ) { . tv64 = ( long long int ) ( ( long long unsigned int ) kt . tv64 + ( long long unsigned int ) usec * 1000ULL ) };
}
# 194 "include/linux/ktime.h"
static inline ktime_t ktime_add_ms(ktime_t const kt, u64 const msec)
{
  return ( ktime_t ) { . tv64 = ( long long int ) ( ( long long unsigned int ) kt . tv64 + ( long long unsigned int ) msec * 1000000ULL ) };
}
# 199 "include/linux/ktime.h"
static inline ktime_t ktime_sub_us(ktime_t const kt, u64 const usec)
{
  return ( ktime_t ) { . tv64 = ( long long int ) ( ( long long unsigned int ) kt . tv64 - ( long long unsigned int ) usec * 1000ULL ) };
}
# 204 "include/linux/ktime.h"
ktime_t ktime_add_safe(ktime_t const, ktime_t const);
# 214 "include/linux/ktime.h"
static inline bool ktime_to_timespec_cond(ktime_t const kt, struct timespec *ts)
{
# 217 "include/linux/ktime.h"
  if (( long long int ) kt . tv64 != 0LL)
  {
# 218 "include/linux/ktime.h"
    * ts = ns_to_timespec ( kt . tv64 );
    return 1;
  }
  else
# 221 "include/linux/ktime.h"
    return 0;
}
# 233 "include/linux/ktime.h"
static inline bool ktime_to_timespec64_cond(ktime_t const kt, struct timespec *ts)
{
# 236 "include/linux/ktime.h"
  if (( long long int ) kt . tv64 != 0LL)
  {
# 237 "include/linux/ktime.h"
    * ts = ns_to_timespec ( kt . tv64 );
    return 1;
  }
  else
# 240 "include/linux/ktime.h"
    return 0;
}
# 253 "include/linux/ktime.h"
static inline ktime_t ns_to_ktime(u64 ns)
{
  ktime_t const ktime_zero = { . tv64 = 0LL };
# 257 "include/linux/ktime.h"
  return ( ktime_t ) { . tv64 = ( long long int ) ( ( long long unsigned int ) ktime_zero . tv64 + ( long long unsigned int ) ns ) };
}
# 260 "include/linux/ktime.h"
static inline ktime_t ms_to_ktime(u64 ms)
{
  ktime_t const ktime_zero = { . tv64 = 0LL };
# 264 "include/linux/ktime.h"
  return ktime_add_ms ( ktime_zero , ms );
}
# 6 "include/linux/timekeeping.h"
void timekeeping_init(void);
extern int timekeeping_suspended;
# 12 "include/linux/timekeeping.h"
void do_gettimeofday(struct timeval *);
int do_settimeofday(struct timespec const *);
int do_sys_settimeofday(struct timespec const *, struct timezone const *);
# 20 "include/linux/timekeeping.h"
long unsigned int get_seconds(void);
struct timespec current_kernel_time(void);
# 23 "include/linux/timekeeping.h"
struct timespec __current_kernel_time(void);
# 28 "include/linux/timekeeping.h"
struct timespec get_monotonic_coarse(void);
void getrawmonotonic(struct timespec *);
void ktime_get_ts64(struct timespec *);
# 32 "include/linux/timekeeping.h"
int __getnstimeofday64(struct timespec *);
void getnstimeofday64(struct timespec *);
# 36 "include/linux/timekeeping.h"
static inline int __getnstimeofday(struct timespec *ts)
{
  return __getnstimeofday64 ( ts );
}
# 41 "include/linux/timekeeping.h"
static inline void getnstimeofday(struct timespec *ts)
{
  getnstimeofday64 ( ts );
}
# 46 "include/linux/timekeeping.h"
static inline void ktime_get_ts(struct timespec *ts)
{
  ktime_get_ts64 ( ts );
}
# 51 "include/linux/timekeeping.h"
static inline void ktime_get_real_ts(struct timespec *ts)
{
  getnstimeofday64 ( ts );
}
# 91 "include/linux/timekeeping.h"
void getboottime(struct timespec *);
enum tk_offsets
{
  TK_OFFS_REAL = 0,
  TK_OFFS_BOOT = 1,
  TK_OFFS_TAI = 2,
  TK_OFFS_MAX = 3
};
# 107 "include/linux/timekeeping.h"
ktime_t ktime_get(void);
ktime_t ktime_get_with_offset(enum tk_offsets);
ktime_t ktime_mono_to_any(ktime_t, enum tk_offsets);
ktime_t ktime_get_raw(void);
# 115 "include/linux/timekeeping.h"
static inline ktime_t ktime_get_real(void)
{
  return ktime_get_with_offset ( TK_OFFS_REAL );
}
# 126 "include/linux/timekeeping.h"
static inline ktime_t ktime_get_boottime(void)
{
  return ktime_get_with_offset ( TK_OFFS_BOOT );
}
# 134 "include/linux/timekeeping.h"
static inline ktime_t ktime_get_clocktai(void)
{
  return ktime_get_with_offset ( TK_OFFS_TAI );
}
# 142 "include/linux/timekeeping.h"
static inline ktime_t ktime_mono_to_real(ktime_t mono)
{
  return ktime_mono_to_any ( mono , TK_OFFS_REAL );
}
# 147 "include/linux/timekeeping.h"
static inline u64 ktime_get_ns(void)
{
  return ( u64 ) ktime_get ( ) . tv64;
}
# 152 "include/linux/timekeeping.h"
static inline u64 ktime_get_real_ns(void)
{
  return ( u64 ) ktime_get_real ( ) . tv64;
}
# 157 "include/linux/timekeeping.h"
static inline u64 ktime_get_boot_ns(void)
{
  return ( u64 ) ktime_get_boottime ( ) . tv64;
}
# 162 "include/linux/timekeeping.h"
static inline u64 ktime_get_raw_ns(void)
{
  return ( u64 ) ktime_get_raw ( ) . tv64;
}
# 167 "include/linux/timekeeping.h"
u64 ktime_get_mono_fast_ns(void);
# 172 "include/linux/timekeeping.h"
static inline void get_monotonic_boottime(struct timespec *ts)
{
  * ts = ns_to_timespec ( ktime_get_boottime ( ) . tv64 );
}
# 177 "include/linux/timekeeping.h"
static inline void timekeeping_clocktai(struct timespec *ts)
{
  * ts = ns_to_timespec ( ktime_get_clocktai ( ) . tv64 );
}
# 185 "include/linux/timekeeping.h"
void timekeeping_inject_sleeptime(struct timespec *);
# 190 "include/linux/timekeeping.h"
void getnstime_raw_and_real(struct timespec *, struct timespec *);
# 196 "include/linux/timekeeping.h"
extern bool persistent_clock_exist;
extern int persistent_clock_is_local;
# 199 "include/linux/timekeeping.h"
static inline bool has_persistent_clock(void)
{
  return persistent_clock_exist;
}
# 204 "include/linux/timekeeping.h"
void read_persistent_clock(struct timespec *);
void read_boot_clock(struct timespec *);
int update_persistent_clock(struct timespec);
struct tvec_base;
struct timer_list
{
# 17 "include/linux/timer.h"
  struct list_head entry;
  long unsigned int expires;
  struct tvec_base *base;
# 21 "include/linux/timer.h"
  void (*function)(long unsigned int);
  long unsigned int data;
# 24 "include/linux/timer.h"
  int slack;
# 27 "include/linux/timer.h"
  int start_pid;
  void *start_site;
  char start_comm[16U];
# 32 "include/linux/timer.h"
  struct lockdep_map lockdep_map;
};
# 36 "include/linux/timer.h"
extern struct tvec_base boot_tvec_bases;
# 94 "include/linux/timer.h"
void init_timer_key(struct timer_list *, unsigned int, char const *, struct lock_class_key *);
# 98 "include/linux/timer.h"
void init_timer_on_stack_key(struct timer_list *, unsigned int, char const *, struct lock_class_key *);
# 101 "include/linux/timer.h"
void destroy_timer_on_stack(struct timer_list *);
# 169 "include/linux/timer.h"
static inline int timer_pending(struct timer_list const *timer)
{
  return ( * timer ) . entry . next != ( ( struct list_head *const ) 0 );
}
# 174 "include/linux/timer.h"
void add_timer_on(struct timer_list *, int);
int del_timer(struct timer_list *);
int mod_timer(struct timer_list *, long unsigned int);
int mod_timer_pending(struct timer_list *, long unsigned int);
int mod_timer_pinned(struct timer_list *, long unsigned int);
# 180 "include/linux/timer.h"
void set_timer_slack(struct timer_list *, int);
# 195 "include/linux/timer.h"
long unsigned int get_next_timer_interrupt(long unsigned int);
# 202 "include/linux/timer.h"
extern int timer_stats_active;
# 206 "include/linux/timer.h"
void init_timer_stats(void);
# 208 "include/linux/timer.h"
void timer_stats_update_stats(void *, pid_t, void *, void *, char *, unsigned int);
# 212 "include/linux/timer.h"
void __timer_stats_timer_set_start_info(struct timer_list *, void *);
# 215 "include/linux/timer.h"
static inline void timer_stats_timer_set_start_info(struct timer_list *timer)
{
  if (__builtin_expect ( timer_stats_active == 0 , 1L ) != 0L)
    return;
  __timer_stats_timer_set_start_info ( timer , __builtin_return_address ( 0U ) );
}
# 222 "include/linux/timer.h"
static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
  ( * timer ) . start_site = ( ( void *) 0 );
}
# 240 "include/linux/timer.h"
void add_timer(struct timer_list *);
# 242 "include/linux/timer.h"
int try_to_del_timer_sync(struct timer_list *);
# 245 "include/linux/timer.h"
int del_timer_sync(struct timer_list *);
# 252 "include/linux/timer.h"
void init_timers(void);
void run_local_timers(void);
struct hrtimer;
enum hrtimer_restart it_real_fn(struct hrtimer *);
# 257 "include/linux/timer.h"
long unsigned int __round_jiffies(long unsigned int, int);
long unsigned int __round_jiffies_relative(long unsigned int, int);
long unsigned int round_jiffies(long unsigned int);
long unsigned int round_jiffies_relative(long unsigned int);
# 262 "include/linux/timer.h"
long unsigned int __round_jiffies_up(long unsigned int, int);
long unsigned int __round_jiffies_up_relative(long unsigned int, int);
long unsigned int round_jiffies_up(long unsigned int);
long unsigned int round_jiffies_up_relative(long unsigned int);
struct workqueue_struct;
struct work_struct;
# 19 "include/linux/workqueue.h"
typedef void (*work_func_t)(struct work_struct *);
void delayed_work_timer_fn(long unsigned int);
enum ldv_10976
{
  WORK_STRUCT_PENDING_BIT = 0,
  WORK_STRUCT_DELAYED_BIT = 1,
  WORK_STRUCT_PWQ_BIT = 2,
  WORK_STRUCT_LINKED_BIT = 3,
  WORK_STRUCT_STATIC_BIT = 4,
  WORK_STRUCT_COLOR_SHIFT = 5,
  WORK_STRUCT_COLOR_BITS = 4,
  WORK_STRUCT_PENDING = 1,
  WORK_STRUCT_DELAYED = 2,
  WORK_STRUCT_PWQ = 4,
  WORK_STRUCT_LINKED = 8,
  WORK_STRUCT_STATIC = 16,
  WORK_NR_COLORS = 15,
  WORK_NO_COLOR = 15,
  WORK_CPU_UNBOUND = 8192,
  WORK_STRUCT_FLAG_BITS = 9,
  WORK_OFFQ_FLAG_BASE = 5,
  WORK_OFFQ_CANCELING = 32,
  WORK_OFFQ_FLAG_BITS = 1,
  WORK_OFFQ_POOL_SHIFT = 6,
  WORK_OFFQ_LEFT = 58,
  WORK_OFFQ_POOL_BITS = 31,
  WORK_OFFQ_POOL_NONE = 2147483647,
  WORK_STRUCT_FLAG_MASK = 511,
  WORK_STRUCT_WQ_DATA_MASK = -512,
  WORK_STRUCT_NO_POOL = 137438953408,
  WORK_BUSY_PENDING = 1,
  WORK_BUSY_RUNNING = 2,
  WORKER_DESC_LEN = 24
};
struct work_struct
{
# 100 "include/linux/workqueue.h"
  atomic_long_t data;
  struct list_head entry;
  work_func_t func;
# 104 "include/linux/workqueue.h"
  struct lockdep_map lockdep_map;
};
struct delayed_work
{
# 113 "include/linux/workqueue.h"
  struct work_struct work;
  struct timer_list timer;
# 117 "include/linux/workqueue.h"
  struct workqueue_struct *wq;
  int cpu;
};
struct workqueue_attrs
{
# 130 "include/linux/workqueue.h"
  int nice;
  cpumask_var_t cpumask;
  bool no_numa;
};
# 135 "include/linux/workqueue.h"
static inline struct delayed_work *to_delayed_work(struct work_struct *work)
{
  return ({
# 137 "include/linux/workqueue.h"
    struct work_struct const *__mptr = ( struct work_struct const *) work;
# 137 "include/linux/workqueue.h"
    ( struct delayed_work *) __mptr;
  } );
}
struct execute_work
{
# 141 "include/linux/workqueue.h"
  struct work_struct work;
};
# 180 "include/linux/workqueue.h"
void __init_work(struct work_struct *, int);
void destroy_work_on_stack(struct work_struct *);
void destroy_delayed_work_on_stack(struct delayed_work *);
static inline unsigned int work_static(struct work_struct *work)
{
  return ( unsigned int ) * ( long unsigned int *) & ( * work ) . data & 16U;
}
enum ldv_10989
{
  WQ_UNBOUND = 2,
  WQ_FREEZABLE = 4,
  WQ_MEM_RECLAIM = 8,
  WQ_HIGHPRI = 16,
  WQ_CPU_INTENSIVE = 32,
  WQ_SYSFS = 64,
  WQ_POWER_EFFICIENT = 128,
  __WQ_DRAINING = 65536,
  __WQ_ORDERED = 131072,
  WQ_MAX_ACTIVE = 512,
  WQ_MAX_UNBOUND_PER_CPU = 4,
  WQ_DFL_ACTIVE = 256
};
# 355 "include/linux/workqueue.h"
extern struct workqueue_struct *system_wq;
extern struct workqueue_struct *system_highpri_wq;
extern struct workqueue_struct *system_long_wq;
extern struct workqueue_struct *system_unbound_wq;
extern struct workqueue_struct *system_freezable_wq;
extern struct workqueue_struct *system_power_efficient_wq;
extern struct workqueue_struct *system_freezable_power_efficient_wq;
# 364 "include/linux/workqueue.h"
struct workqueue_struct *__alloc_workqueue_key(char const *, unsigned int, int, struct lock_class_key *, char const *, ...);
# 424 "include/linux/workqueue.h"
void destroy_workqueue(struct workqueue_struct *);
# 426 "include/linux/workqueue.h"
struct workqueue_attrs *alloc_workqueue_attrs(gfp_t);
void free_workqueue_attrs(struct workqueue_attrs *);
int apply_workqueue_attrs(struct workqueue_struct *, struct workqueue_attrs const *);
# 431 "include/linux/workqueue.h"
bool queue_work_on(int, struct workqueue_struct *, struct work_struct *);
# 433 "include/linux/workqueue.h"
bool queue_delayed_work_on(int, struct workqueue_struct *, struct delayed_work *, long unsigned int);
# 435 "include/linux/workqueue.h"
bool mod_delayed_work_on(int, struct workqueue_struct *, struct delayed_work *, long unsigned int);
# 438 "include/linux/workqueue.h"
void flush_workqueue(struct workqueue_struct *);
void drain_workqueue(struct workqueue_struct *);
void flush_scheduled_work(void);
# 442 "include/linux/workqueue.h"
int schedule_on_each_cpu(work_func_t);
# 444 "include/linux/workqueue.h"
int execute_in_process_context(work_func_t, struct execute_work *);
# 446 "include/linux/workqueue.h"
bool flush_work(struct work_struct *);
bool cancel_work_sync(struct work_struct *);
# 449 "include/linux/workqueue.h"
bool flush_delayed_work(struct delayed_work *);
bool cancel_delayed_work(struct delayed_work *);
bool cancel_delayed_work_sync(struct delayed_work *);
# 453 "include/linux/workqueue.h"
void workqueue_set_max_active(struct workqueue_struct *, int);
# 455 "include/linux/workqueue.h"
bool current_is_workqueue_rescuer(void);
bool workqueue_congested(int, struct workqueue_struct *);
unsigned int work_busy(struct work_struct *);
void set_worker_desc(char const *, ...);
void print_worker_info(char const *, struct task_struct *);
# 471 "include/linux/workqueue.h"
static inline bool queue_work(struct workqueue_struct *wq, struct work_struct *work)
{
# 474 "include/linux/workqueue.h"
  return queue_work_on ( 8192 , wq , work );
}
# 485 "include/linux/workqueue.h"
static inline bool queue_delayed_work(struct workqueue_struct *wq, struct delayed_work *dwork, long unsigned int delay)
{
# 489 "include/linux/workqueue.h"
  return queue_delayed_work_on ( 8192 , wq , dwork , delay );
}
# 500 "include/linux/workqueue.h"
static inline bool mod_delayed_work(struct workqueue_struct *wq, struct delayed_work *dwork, long unsigned int delay)
{
# 504 "include/linux/workqueue.h"
  return mod_delayed_work_on ( 8192 , wq , dwork , delay );
}
# 514 "include/linux/workqueue.h"
static inline bool schedule_work_on(int cpu, struct work_struct *work)
{
  return queue_work_on ( cpu , system_wq , work );
}
# 530 "include/linux/workqueue.h"
static inline bool schedule_work(struct work_struct *work)
{
  return queue_work ( system_wq , work );
}
# 544 "include/linux/workqueue.h"
static inline bool schedule_delayed_work_on(int cpu, struct delayed_work *dwork, long unsigned int delay)
{
# 547 "include/linux/workqueue.h"
  return queue_delayed_work_on ( cpu , system_wq , dwork , delay );
}
# 558 "include/linux/workqueue.h"
static inline bool schedule_delayed_work(struct delayed_work *dwork, long unsigned int delay)
{
# 561 "include/linux/workqueue.h"
  return queue_delayed_work ( system_wq , dwork , delay );
}
# 567 "include/linux/workqueue.h"
static inline bool keventd_up(void)
{
  return system_wq != ( ( struct workqueue_struct *) 0 );
}
# 578 "include/linux/workqueue.h"
long int work_on_cpu(int, long int (*)(void *), void *);
# 582 "include/linux/workqueue.h"
void freeze_workqueues_begin(void);
bool freeze_workqueues_busy(void);
void thaw_workqueues(void);
# 588 "include/linux/workqueue.h"
int workqueue_sysfs_register(struct workqueue_struct *);
struct srcu_struct_array
{
# 37 "include/linux/srcu.h"
  long unsigned int c[2U];
  long unsigned int seq[2U];
};
struct rcu_batch
{
  struct callback_head *head;
# 42 "include/linux/srcu.h"
  struct callback_head **tail;
};
struct srcu_struct
{
# 48 "include/linux/srcu.h"
  unsigned int completed;
  struct srcu_struct_array *per_cpu_ref;
  spinlock_t queue_lock;
  bool running;
# 53 "include/linux/srcu.h"
  struct rcu_batch batch_queue;
# 55 "include/linux/srcu.h"
  struct rcu_batch batch_check0;
# 57 "include/linux/srcu.h"
  struct rcu_batch batch_check1;
  struct rcu_batch batch_done;
  struct delayed_work work;
# 61 "include/linux/srcu.h"
  struct lockdep_map dep_map;
};
# 67 "include/linux/srcu.h"
int __init_srcu_struct(struct srcu_struct *, char const *, struct lock_class_key *);
# 85 "include/linux/srcu.h"
void process_srcu(struct work_struct *);
# 130 "include/linux/srcu.h"
void call_srcu(struct srcu_struct *, struct callback_head *, void (*)(struct callback_head *));
# 133 "include/linux/srcu.h"
void cleanup_srcu_struct(struct srcu_struct *);
int __srcu_read_lock(struct srcu_struct *);
void __srcu_read_unlock(struct srcu_struct *, int);
void synchronize_srcu(struct srcu_struct *);
void synchronize_srcu_expedited(struct srcu_struct *);
long int srcu_batches_completed(struct srcu_struct *);
void srcu_barrier(struct srcu_struct *);
# 158 "include/linux/srcu.h"
static inline int srcu_read_lock_held(struct srcu_struct *sp)
{
  if (debug_lockdep_rcu_enabled ( ) == 0)
    return 1;
  return lock_is_held ( & ( * sp ) . dep_map );
}
# 218 "include/linux/srcu.h"
static inline int srcu_read_lock(struct srcu_struct *sp)
{
  int retval = __srcu_read_lock ( sp );
# 222 "include/linux/srcu.h"
  rcu_lock_acquire ( & ( * sp ) . dep_map );
  return retval;
}
# 233 "include/linux/srcu.h"
static inline void srcu_read_unlock(struct srcu_struct *sp, int idx)
{
# 236 "include/linux/srcu.h"
  rcu_lock_release ( & ( * sp ) . dep_map );
  __srcu_read_unlock ( sp , idx );
}
# 249 "include/linux/srcu.h"
static inline void smp_mb__after_srcu_read_unlock(void)
{
}
# 50 "include/linux/notifier.h"
typedef int (*notifier_fn_t)(struct notifier_block *, long unsigned int, void *);
struct notifier_block
{
# 54 "include/linux/notifier.h"
  notifier_fn_t notifier_call;
  struct notifier_block *next;
  int priority;
};
struct atomic_notifier_head
{
  spinlock_t lock;
  struct notifier_block *head;
};
struct blocking_notifier_head
{
  struct rw_semaphore rwsem;
  struct notifier_block *head;
};
struct raw_notifier_head
{
  struct notifier_block *head;
};
struct srcu_notifier_head
{
  struct mutex mutex;
  struct srcu_struct srcu;
  struct notifier_block *head;
};
# 92 "include/linux/notifier.h"
void srcu_init_notifier_head(struct srcu_notifier_head *);
# 118 "include/linux/notifier.h"
int atomic_notifier_chain_register(struct atomic_notifier_head *, struct notifier_block *);
# 120 "include/linux/notifier.h"
int blocking_notifier_chain_register(struct blocking_notifier_head *, struct notifier_block *);
# 122 "include/linux/notifier.h"
int raw_notifier_chain_register(struct raw_notifier_head *, struct notifier_block *);
# 124 "include/linux/notifier.h"
int srcu_notifier_chain_register(struct srcu_notifier_head *, struct notifier_block *);
# 127 "include/linux/notifier.h"
int blocking_notifier_chain_cond_register(struct blocking_notifier_head *, struct notifier_block *);
# 131 "include/linux/notifier.h"
int atomic_notifier_chain_unregister(struct atomic_notifier_head *, struct notifier_block *);
# 133 "include/linux/notifier.h"
int blocking_notifier_chain_unregister(struct blocking_notifier_head *, struct notifier_block *);
# 135 "include/linux/notifier.h"
int raw_notifier_chain_unregister(struct raw_notifier_head *, struct notifier_block *);
# 137 "include/linux/notifier.h"
int srcu_notifier_chain_unregister(struct srcu_notifier_head *, struct notifier_block *);
# 140 "include/linux/notifier.h"
int atomic_notifier_call_chain(struct atomic_notifier_head *, long unsigned int, void *);
# 142 "include/linux/notifier.h"
int __atomic_notifier_call_chain(struct atomic_notifier_head *, long unsigned int, void *, int, int *);
# 144 "include/linux/notifier.h"
int blocking_notifier_call_chain(struct blocking_notifier_head *, long unsigned int, void *);
# 146 "include/linux/notifier.h"
int __blocking_notifier_call_chain(struct blocking_notifier_head *, long unsigned int, void *, int, int *);
# 148 "include/linux/notifier.h"
int raw_notifier_call_chain(struct raw_notifier_head *, long unsigned int, void *);
# 150 "include/linux/notifier.h"
int __raw_notifier_call_chain(struct raw_notifier_head *, long unsigned int, void *, int, int *);
# 152 "include/linux/notifier.h"
int srcu_notifier_call_chain(struct srcu_notifier_head *, long unsigned int, void *);
# 154 "include/linux/notifier.h"
int __srcu_notifier_call_chain(struct srcu_notifier_head *, long unsigned int, void *, int, int *);
# 168 "include/linux/notifier.h"
static inline int notifier_from_errno(int err)
{
  if (err != 0)
    return 1 - err | 32768;
# 173 "include/linux/notifier.h"
  return 1;
}
# 177 "include/linux/notifier.h"
static inline int notifier_to_errno(int ret)
{
  ret &= -32769;
  return ret > 1 ? 1 - ret : 0;
}
# 212 "include/linux/notifier.h"
extern struct blocking_notifier_head reboot_notifier_list;
struct mem_section;
struct memory_block;
enum ldv_11125
{
  MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE = 12,
  SECTION_INFO = 12,
  MIX_SECTION_INFO = 13,
  NODE_INFO = 14,
  MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE = 14
};
enum ldv_11126
{
  MMOP_OFFLINE = -1,
  MMOP_ONLINE_KEEP = 0,
  MMOP_ONLINE_KERNEL = 1,
  MMOP_ONLINE_MOVABLE = 2
};
# 41 "include/linux/memory_hotplug.h"
static inline void pgdat_resize_lock(struct pglist_data *pgdat, long unsigned int *flags)
{
  ({
# 43 "include/linux/memory_hotplug.h"
    long unsigned int __dummy;
# 43 "include/linux/memory_hotplug.h"
    long unsigned int __dummy2;
# 43 "include/linux/memory_hotplug.h"
    ( void ) 0;
# 43 "include/linux/memory_hotplug.h"
    1;
  } );
# 43 "include/linux/memory_hotplug.h"
  * flags = _raw_spin_lock_irqsave ( spinlock_check ( & ( * pgdat ) . node_size_lock ) );
}
# 46 "include/linux/memory_hotplug.h"
static inline void pgdat_resize_unlock(struct pglist_data *pgdat, long unsigned int *flags)
{
  spin_unlock_irqrestore ( & ( * pgdat ) . node_size_lock , * flags );
}
# 51 "include/linux/memory_hotplug.h"
static inline void pgdat_resize_init(struct pglist_data *pgdat)
{
  spinlock_check ( & ( * pgdat ) . node_size_lock );
  {
# 53 "include/linux/memory_hotplug.h"
    struct lock_class_key __key;
# 53 "include/linux/memory_hotplug.h"
    __raw_spin_lock_init ( ( raw_spinlock_t *) & ( * pgdat ) . node_size_lock . ldv_6073 . rlock , ( char const *) "&(&pgdat->node_size_lock)->rlock" , & __key );
  }
}
# 62 "include/linux/memory_hotplug.h"
static inline unsigned int zone_span_seqbegin(struct zone *zone)
{
  return read_seqbegin ( ( seqlock_t const *) & ( * zone ) . span_seqlock );
}
static inline int zone_span_seqretry(struct zone *zone, unsigned int iv)
{
  return ( int ) read_seqretry ( ( seqlock_t const *) & ( * zone ) . span_seqlock , iv );
}
static inline void zone_span_writelock(struct zone *zone)
{
  write_seqlock ( & ( * zone ) . span_seqlock );
}
static inline void zone_span_writeunlock(struct zone *zone)
{
  write_sequnlock ( & ( * zone ) . span_seqlock );
}
static inline void zone_seqlock_init(struct zone *zone)
{
  {
# 80 "include/linux/memory_hotplug.h"
    struct lock_class_key __key;
# 80 "include/linux/memory_hotplug.h"
    __seqcount_init ( ( seqcount_t *) & ( * zone ) . span_seqlock . seqcount , ( char const *) "&(&zone->span_seqlock)->seqcount" , & __key );
  }
# 80 "include/linux/memory_hotplug.h"
  spinlock_check ( & ( * zone ) . span_seqlock . lock );
  {
# 80 "include/linux/memory_hotplug.h"
    struct lock_class_key __key;
# 80 "include/linux/memory_hotplug.h"
    __raw_spin_lock_init ( ( raw_spinlock_t *) & ( * zone ) . span_seqlock . lock . ldv_6073 . rlock , ( char const *) "&(&(&zone->span_seqlock)->lock)->rlock" , & __key );
  }
}
# 82 "include/linux/memory_hotplug.h"
int zone_grow_free_lists(struct zone *, long unsigned int);
int zone_grow_waitqueues(struct zone *, long unsigned int);
int add_one_highpage(struct page *, int, int);
# 86 "include/linux/memory_hotplug.h"
int online_pages(long unsigned int, long unsigned int, int);
void __offline_isolated_pages(long unsigned int, long unsigned int);
# 89 "include/linux/memory_hotplug.h"
typedef void (*online_page_callback_t)(struct page *);
# 91 "include/linux/memory_hotplug.h"
int set_online_page_callback(online_page_callback_t);
int restore_online_page_callback(online_page_callback_t);
# 94 "include/linux/memory_hotplug.h"
void __online_page_set_limits(struct page *);
void __online_page_increment_counters(struct page *);
void __online_page_free(struct page *);
# 98 "include/linux/memory_hotplug.h"
int try_online_node(int);
# 101 "include/linux/memory_hotplug.h"
bool is_pageblock_removable_nolock(struct page *);
int arch_remove_memory(u64, u64);
int __remove_pages(struct zone *, long unsigned int, long unsigned int);
# 108 "include/linux/memory_hotplug.h"
int __add_pages(int, struct zone *, long unsigned int, long unsigned int);
# 112 "include/linux/memory_hotplug.h"
int memory_add_physaddr_to_nid(u64);
# 157 "include/linux/memory_hotplug.h"
extern pg_data_t *node_data[];
static inline void arch_refresh_nodedata(int nid, pg_data_t *pgdat)
{
  node_data [ nid ] = pgdat;
}
# 181 "include/linux/memory_hotplug.h"
void register_page_bootmem_info_node(struct pglist_data *);
# 187 "include/linux/memory_hotplug.h"
void put_page_bootmem(struct page *);
void get_page_bootmem(long unsigned int, struct page *, long unsigned int);
# 191 "include/linux/memory_hotplug.h"
void get_online_mems(void);
void put_online_mems(void);
# 237 "include/linux/memory_hotplug.h"
int is_mem_section_removable(long unsigned int, long unsigned int);
void try_offline_node(int);
int offline_pages(long unsigned int, long unsigned int);
void remove_memory(int, u64, u64);
# 259 "include/linux/memory_hotplug.h"
int walk_memory_range(long unsigned int, long unsigned int, void *, int (*)(struct memory_block *, void *));
# 261 "include/linux/memory_hotplug.h"
int add_memory(int, u64, u64);
int zone_for_memory(int, u64, u64, int);
int arch_add_memory(int, u64, u64);
int offline_pages(long unsigned int, long unsigned int);
bool is_memblock_offlined(struct memory_block *);
void remove_memory(int, u64, u64);
int sparse_add_one_section(struct zone *, long unsigned int);
void sparse_remove_one_section(struct zone *, struct mem_section *);
struct page *sparse_decode_mem_map(long unsigned int, long unsigned int);
# 828 "include/linux/mmzone.h"
extern struct mutex zonelists_mutex;
void build_all_zonelists(pg_data_t *, struct zone *);
void wakeup_kswapd(struct zone *, int, enum zone_type);
bool zone_watermark_ok(struct zone *, unsigned int, long unsigned int, int, int);
# 833 "include/linux/mmzone.h"
bool zone_watermark_ok_safe(struct zone *, unsigned int, long unsigned int, int, int);
enum memmap_context
{
  MEMMAP_EARLY = 0,
  MEMMAP_HOTPLUG = 1
};
int init_currently_empty_zone(struct zone *, long unsigned int, long unsigned int, enum memmap_context);
# 843 "include/linux/mmzone.h"
void lruvec_init(struct lruvec *);
# 845 "include/linux/mmzone.h"
static inline struct zone *lruvec_zone(struct lruvec *lruvec)
{
# 848 "include/linux/mmzone.h"
  return ( * lruvec ) . zone;
}
# 855 "include/linux/mmzone.h"
void memory_present(int, long unsigned int, long unsigned int);
# 863 "include/linux/mmzone.h"
static inline int local_memory_node(int node_id)
{
# 863 "include/linux/mmzone.h"
  return node_id;
}
# 875 "include/linux/mmzone.h"
static inline int populated_zone(struct zone *zone)
{
  return ( * zone ) . present_pages != 0UL;
}
# 880 "include/linux/mmzone.h"
extern int movable_zone;
# 882 "include/linux/mmzone.h"
static inline int zone_movable_is_highmem(void)
{
# 889 "include/linux/mmzone.h"
  return 0;
}
# 893 "include/linux/mmzone.h"
static inline int is_highmem_idx(enum zone_type idx)
{
# 899 "include/linux/mmzone.h"
  return 0;
}
# 909 "include/linux/mmzone.h"
static inline int is_highmem(struct zone *zone)
{
# 917 "include/linux/mmzone.h"
  return 0;
}
struct ctl_table;
# 923 "include/linux/mmzone.h"
int min_free_kbytes_sysctl_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 925 "include/linux/mmzone.h"
extern int sysctl_lowmem_reserve_ratio[3U];
int lowmem_reserve_ratio_sysctl_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 928 "include/linux/mmzone.h"
int percpu_pagelist_fraction_sysctl_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 930 "include/linux/mmzone.h"
int sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 932 "include/linux/mmzone.h"
int sysctl_min_slab_ratio_sysctl_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 935 "include/linux/mmzone.h"
int numa_zonelist_order_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 937 "include/linux/mmzone.h"
extern char numa_zonelist_order[];
struct mpf_intel
{
# 22 "./arch/x86/include/asm/mpspec_def.h"
  char signature[4U];
  unsigned int physptr;
  unsigned char length;
  unsigned char specification;
  unsigned char checksum;
  unsigned char feature1;
  unsigned char feature2;
  unsigned char feature3;
  unsigned char feature4;
  unsigned char feature5;
};
struct mpc_table
{
# 37 "./arch/x86/include/asm/mpspec_def.h"
  char signature[4U];
  short unsigned int length;
  char spec;
  char checksum;
  char oem[8U];
  char productid[12U];
  unsigned int oemptr;
  short unsigned int oemsize;
  short unsigned int oemcount;
  unsigned int lapic;
  unsigned int reserved;
};
struct mpc_cpu
{
# 68 "./arch/x86/include/asm/mpspec_def.h"
  unsigned char type;
  unsigned char apicid;
  unsigned char apicver;
  unsigned char cpuflag;
  unsigned int cpufeature;
  unsigned int featureflag;
  unsigned int reserved[2U];
};
struct mpc_bus
{
  unsigned char type;
  unsigned char busid;
  unsigned char bustype[6U];
};
struct mpc_ioapic
{
# 106 "./arch/x86/include/asm/mpspec_def.h"
  unsigned char type;
  unsigned char apicid;
  unsigned char apicver;
  unsigned char flags;
  unsigned int apicaddr;
};
struct mpc_intsrc
{
  unsigned char type;
  unsigned char irqtype;
  short unsigned int irqflag;
  unsigned char srcbus;
  unsigned char srcbusirq;
  unsigned char dstapic;
  unsigned char dstirq;
};
enum mp_irq_source_types
{
  mp_INT = 0,
  mp_NMI = 1,
  mp_SMI = 2,
  mp_ExtINT = 3
};
struct mpc_lintsrc
{
# 137 "./arch/x86/include/asm/mpspec_def.h"
  unsigned char type;
  unsigned char irqtype;
  short unsigned int irqflag;
  unsigned char srcbusid;
  unsigned char srcbusirq;
  unsigned char destapic;
  unsigned char destapiclint;
};
struct mpc_oemtable
{
# 149 "./arch/x86/include/asm/mpspec_def.h"
  char signature[4U];
  short unsigned int length;
  char rev;
  char checksum;
  char mpc[8U];
};
enum mp_bustype
{
  MP_BUS_ISA = 1,
  MP_BUS_EISA = 2,
  MP_BUS_PCI = 3
};
struct screen_info
{
# 11 "include/uapi/linux/screen_info.h"
  __u8 orig_x;
  __u8 orig_y;
  __u16 ext_mem_k;
  __u16 orig_video_page;
  __u8 orig_video_mode;
  __u8 orig_video_cols;
  __u8 flags;
  __u8 unused2;
  __u16 orig_video_ega_bx;
  __u16 unused3;
  __u8 orig_video_lines;
  __u8 orig_video_isVGA;
  __u16 orig_video_points;
# 26 "include/uapi/linux/screen_info.h"
  __u16 lfb_width;
  __u16 lfb_height;
  __u16 lfb_depth;
  __u32 lfb_base;
  __u32 lfb_size;
  __u16 cl_magic;
# 31 "include/uapi/linux/screen_info.h"
  __u16 cl_offset;
  __u16 lfb_linelength;
  __u8 red_size;
  __u8 red_pos;
  __u8 green_size;
  __u8 green_pos;
  __u8 blue_size;
  __u8 blue_pos;
  __u8 rsvd_size;
  __u8 rsvd_pos;
  __u16 vesapm_seg;
  __u16 vesapm_off;
  __u16 pages;
  __u16 vesa_attributes;
  __u32 capabilities;
  __u8 _reserved[6U];
};
# 6 "include/linux/screen_info.h"
extern struct screen_info screen_info;
# 21 "include/uapi/linux/apm_bios.h"
typedef short unsigned int apm_event_t;
typedef short unsigned int apm_eventinfo_t;
struct apm_bios_info
{
  __u16 version;
  __u16 cseg;
  __u32 offset;
  __u16 cseg_16;
  __u16 dseg;
  __u16 flags;
  __u16 cseg_len;
  __u16 cseg_16_len;
  __u16 dseg_len;
};
struct apm_info
{
# 36 "include/linux/apm_bios.h"
  struct apm_bios_info bios;
  short unsigned int connection_version;
  int get_power_status_broken;
  int get_power_status_swabinminutes;
  int allow_ints;
  int forbid_idle;
  int realmode_power_off;
  int disabled;
};
# 94 "include/linux/apm_bios.h"
extern struct apm_info apm_info;
struct edd_device_params
{
# 72 "include/uapi/linux/edd.h"
  __u16 length;
  __u16 info_flags;
  __u32 num_default_cylinders;
  __u32 num_default_heads;
  __u32 sectors_per_track;
  __u64 number_of_sectors;
  __u16 bytes_per_sector;
  __u32 dpte_ptr;
  __u16 key;
  __u8 device_path_info_length;
  __u8 reserved2;
  __u16 reserved3;
  __u8 host_bus_type[4U];
  __u8 interface_type[8U];
# 112 "include/uapi/linux/edd.h"
  union
  {
# 91 "include/uapi/linux/edd.h"
    struct
    {
# 88 "include/uapi/linux/edd.h"
      __u16 base_address;
      __u16 reserved1;
      __u32 reserved2;
    } isa;
# 98 "include/uapi/linux/edd.h"
    struct
    {
# 93 "include/uapi/linux/edd.h"
      __u8 bus;
      __u8 slot;
      __u8 function;
      __u8 channel;
      __u32 reserved;
    } pci;
# 102 "include/uapi/linux/edd.h"
    struct
    {
# 101 "include/uapi/linux/edd.h"
      __u64 reserved;
    } ibnd;
# 105 "include/uapi/linux/edd.h"
    struct
    {
# 104 "include/uapi/linux/edd.h"
      __u64 reserved;
    } xprs;
# 108 "include/uapi/linux/edd.h"
    struct
    {
# 107 "include/uapi/linux/edd.h"
      __u64 reserved;
    } htpt;
# 111 "include/uapi/linux/edd.h"
    struct
    {
# 110 "include/uapi/linux/edd.h"
      __u64 reserved;
    } unknown;
  } interface_path;
# 167 "include/uapi/linux/edd.h"
  union
  {
# 120 "include/uapi/linux/edd.h"
    struct
    {
# 115 "include/uapi/linux/edd.h"
      __u8 device;
      __u8 reserved1;
      __u16 reserved2;
      __u32 reserved3;
      __u64 reserved4;
    } ata;
# 128 "include/uapi/linux/edd.h"
    struct
    {
# 122 "include/uapi/linux/edd.h"
      __u8 device;
      __u8 lun;
      __u8 reserved1;
      __u8 reserved2;
      __u32 reserved3;
      __u64 reserved4;
    } atapi;
# 134 "include/uapi/linux/edd.h"
    struct
    {
# 130 "include/uapi/linux/edd.h"
      __u16 id;
      __u64 lun;
      __u16 reserved1;
      __u32 reserved2;
    } scsi;
# 138 "include/uapi/linux/edd.h"
    struct
    {
# 136 "include/uapi/linux/edd.h"
      __u64 serial_number;
      __u64 reserved;
    } usb;
# 142 "include/uapi/linux/edd.h"
    struct
    {
# 140 "include/uapi/linux/edd.h"
      __u64 eui;
      __u64 reserved;
    } i1394;
# 146 "include/uapi/linux/edd.h"
    struct
    {
# 144 "include/uapi/linux/edd.h"
      __u64 wwid;
      __u64 lun;
    } fibre;
# 150 "include/uapi/linux/edd.h"
    struct
    {
# 148 "include/uapi/linux/edd.h"
      __u64 identity_tag;
      __u64 reserved;
    } i2o;
# 155 "include/uapi/linux/edd.h"
    struct
    {
# 152 "include/uapi/linux/edd.h"
      __u32 array_number;
      __u32 reserved1;
      __u64 reserved2;
    } raid;
# 162 "include/uapi/linux/edd.h"
    struct
    {
# 157 "include/uapi/linux/edd.h"
      __u8 device;
      __u8 reserved1;
      __u16 reserved2;
      __u32 reserved3;
      __u64 reserved4;
    } sata;
# 166 "include/uapi/linux/edd.h"
    struct
    {
# 164 "include/uapi/linux/edd.h"
      __u64 reserved1;
      __u64 reserved2;
    } unknown;
  } device_path;
  __u8 reserved4;
  __u8 checksum;
};
struct edd_info
{
  __u8 device;
  __u8 version;
  __u16 interface_support;
  __u16 legacy_max_cylinder;
  __u8 legacy_max_head;
  __u8 legacy_sectors_per_track;
  struct edd_device_params params;
};
struct edd
{
  unsigned int mbr_signature[16U];
  struct edd_info edd_info[6U];
  unsigned char mbr_signature_nr;
  unsigned char edd_info_nr;
};
# 36 "include/linux/edd.h"
extern struct edd edd;
struct e820entry
{
# 53 "./arch/x86/include/uapi/asm/e820.h"
  __u64 addr;
  __u64 size;
  __u32 type;
};
struct e820map
{
  __u32 nr_map;
  struct e820entry map[3200U];
};
# 13 "./arch/x86/include/asm/e820.h"
extern struct e820map e820;
extern struct e820map e820_saved;
# 16 "./arch/x86/include/asm/e820.h"
extern long unsigned int pci_mem_start;
int e820_any_mapped(u64, u64, unsigned int);
int e820_all_mapped(u64, u64, unsigned int);
void e820_add_region(u64, u64, int);
void e820_print_map(char *);
# 22 "./arch/x86/include/asm/e820.h"
int sanitize_e820_map(struct e820entry *, int, u32 *);
u64 e820_update_range(u64, u64, unsigned int, unsigned int);
# 25 "./arch/x86/include/asm/e820.h"
u64 e820_remove_range(u64, u64, unsigned int, int);
# 27 "./arch/x86/include/asm/e820.h"
void update_e820(void);
void e820_setup_gap(void);
int e820_search_gap(long unsigned int *, long unsigned int *, long unsigned int, long long unsigned int);
struct setup_data;
# 32 "./arch/x86/include/asm/e820.h"
void parse_e820_ext(u64, u32);
# 36 "./arch/x86/include/asm/e820.h"
void e820_mark_nosave_regions(long unsigned int);
# 44 "./arch/x86/include/asm/e820.h"
void early_memtest(long unsigned int, long unsigned int);
# 51 "./arch/x86/include/asm/e820.h"
long unsigned int e820_end_of_ram_pfn(void);
long unsigned int e820_end_of_low_ram_pfn(void);
u64 early_reserve_e820(u64, u64);
# 55 "./arch/x86/include/asm/e820.h"
void memblock_x86_fill(void);
void memblock_find_dma_reserve(void);
# 58 "./arch/x86/include/asm/e820.h"
void finish_e820_parsing(void);
void e820_reserve_resources(void);
void e820_reserve_resources_late(void);
void setup_memory_map(void);
char *default_machine_specific_memory_setup(void);
# 68 "./arch/x86/include/asm/e820.h"
static inline bool is_ISA_range(u64 s, u64 e)
{
  return ( bool ) ( s > 655359ULL && e <= 1048576ULL );
}
struct resource
{
# 19 "include/linux/ioport.h"
  resource_size_t start;
  resource_size_t end;
  char const *name;
  long unsigned int flags;
  struct resource *parent;
# 23 "include/linux/ioport.h"
  struct resource *sibling;
# 23 "include/linux/ioport.h"
  struct resource *child;
};
# 138 "include/linux/ioport.h"
extern struct resource ioport_resource;
extern struct resource iomem_resource;
# 141 "include/linux/ioport.h"
struct resource *request_resource_conflict(struct resource *, struct resource *);
int request_resource(struct resource *, struct resource *);
int release_resource(struct resource *);
void release_child_resources(struct resource *);
void reserve_region_with_split(struct resource *, resource_size_t, resource_size_t, char const *);
# 148 "include/linux/ioport.h"
struct resource *insert_resource_conflict(struct resource *, struct resource *);
int insert_resource(struct resource *, struct resource *);
void insert_resource_expand_to_fit(struct resource *, struct resource *);
void arch_remove_reservations(struct resource *);
int allocate_resource(struct resource *, struct resource *, resource_size_t, resource_size_t, resource_size_t, resource_size_t, resource_size_t (*)(void *, struct resource const *, resource_size_t, resource_size_t), void *);
# 160 "include/linux/ioport.h"
struct resource *lookup_resource(struct resource *, resource_size_t);
int adjust_resource(struct resource *, resource_size_t, resource_size_t);
# 163 "include/linux/ioport.h"
resource_size_t resource_alignment(struct resource *);
static inline resource_size_t resource_size(struct resource const *res)
{
  return ( resource_size_t ) ( ( long long unsigned int ) ( * res ) . end - ( long long unsigned int ) ( * res ) . start + 1ULL );
}
static inline long unsigned int resource_type(struct resource const *res)
{
  return ( long unsigned int ) ( * res ) . flags & 7936UL;
}
# 173 "include/linux/ioport.h"
static inline bool resource_contains(struct resource *r1, struct resource *r2)
{
  if (resource_type ( ( struct resource const *) r1 ) != resource_type ( ( struct resource const *) r2 ))
    return 0;
  if (( ( * r1 ) . flags & 536870912UL ) != 0UL || ( ( * r2 ) . flags & 536870912UL ) != 0UL)
    return 0;
  return ( bool ) ( ( * r1 ) . start <= ( * r2 ) . start && ( * r1 ) . end >= ( * r2 ) . end );
}
# 192 "include/linux/ioport.h"
struct resource *__request_region(struct resource *, resource_size_t, resource_size_t, char const *, int);
# 202 "include/linux/ioport.h"
int __check_region(struct resource *, resource_size_t, resource_size_t);
void __release_region(struct resource *, resource_size_t, resource_size_t);
# 206 "include/linux/ioport.h"
int release_mem_region_adjustable(struct resource *, resource_size_t, resource_size_t);
# 210 "include/linux/ioport.h"
static inline int check_region(resource_size_t s, resource_size_t n)
{
# 213 "include/linux/ioport.h"
  return __check_region ( & ioport_resource , s , n );
}
# 223 "include/linux/ioport.h"
struct resource *__devm_request_region(struct device *, struct resource *, resource_size_t, resource_size_t, char const *);
# 232 "include/linux/ioport.h"
void __devm_release_region(struct device *, struct resource *, resource_size_t, resource_size_t);
# 234 "include/linux/ioport.h"
int iomem_map_sanity_check(resource_size_t, long unsigned int);
int iomem_is_exclusive(u64);
# 238 "include/linux/ioport.h"
int walk_system_ram_range(long unsigned int, long unsigned int, void *, int (*)(long unsigned int, long unsigned int, void *));
# 241 "include/linux/ioport.h"
int walk_system_ram_res(u64, u64, void *, int (*)(u64, u64, void *));
# 244 "include/linux/ioport.h"
int walk_iomem_res(char *, long unsigned int, u64, u64, void *, int (*)(u64, u64, void *));
# 248 "include/linux/ioport.h"
static inline bool resource_overlaps(struct resource *r1, struct resource *r2)
{
  return ( bool ) ( ( * r1 ) . start <= ( * r2 ) . end && ( * r1 ) . end >= ( * r2 ) . start );
}
struct ist_info
{
# 23 "./arch/x86/include/uapi/asm/ist.h"
  __u32 signature;
  __u32 command;
  __u32 event;
  __u32 perf_level;
};
# 21 "./arch/x86/include/asm/ist.h"
extern struct ist_info ist_info;
struct edid_info
{
# 5 "include/uapi/video/edid.h"
  unsigned char dummy[128U];
};
extern struct edid_info edid_info;
struct setup_data
{
# 41 "./arch/x86/include/uapi/asm/bootparam.h"
  __u64 next;
  __u32 type;
  __u32 len;
  __u8 data[0U];
};
struct setup_header
{
  __u8 setup_sects;
  __u16 root_flags;
  __u32 syssize;
  __u16 ram_size;
  __u16 vid_mode;
  __u16 root_dev;
  __u16 boot_flag;
  __u16 jump;
  __u32 header;
  __u16 version;
  __u32 realmode_swtch;
  __u16 start_sys;
  __u16 kernel_version;
  __u8 type_of_loader;
  __u8 loadflags;
  __u16 setup_move_size;
  __u32 code32_start;
  __u32 ramdisk_image;
  __u32 ramdisk_size;
  __u32 bootsect_kludge;
  __u16 heap_end_ptr;
  __u8 ext_loader_ver;
  __u8 ext_loader_type;
  __u32 cmd_line_ptr;
  __u32 initrd_addr_max;
  __u32 kernel_alignment;
  __u8 relocatable_kernel;
  __u8 min_alignment;
  __u16 xloadflags;
  __u32 cmdline_size;
  __u32 hardware_subarch;
  __u64 hardware_subarch_data;
  __u32 payload_offset;
  __u32 payload_length;
  __u64 setup_data;
  __u64 pref_address;
  __u32 init_size;
  __u32 handover_offset;
};
struct sys_desc_table
{
  __u16 length;
  __u8 table[14U];
};
struct olpc_ofw_header
{
# 95 "./arch/x86/include/uapi/asm/bootparam.h"
  __u32 ofw_magic;
  __u32 ofw_version;
  __u32 cif_handler;
  __u32 irq_desc_table;
};
struct efi_info
{
  __u32 efi_loader_signature;
  __u32 efi_systab;
  __u32 efi_memdesc_size;
  __u32 efi_memdesc_version;
  __u32 efi_memmap;
  __u32 efi_memmap_size;
  __u32 efi_systab_hi;
  __u32 efi_memmap_hi;
};
struct boot_params
{
# 114 "./arch/x86/include/uapi/asm/bootparam.h"
  struct screen_info screen_info;
  struct apm_bios_info apm_bios_info;
  __u8 _pad2[4U];
  __u64 tboot_addr;
  struct ist_info ist_info;
  __u8 _pad3[16U];
  __u8 hd0_info[16U];
  __u8 hd1_info[16U];
  struct sys_desc_table sys_desc_table;
  struct olpc_ofw_header olpc_ofw_header;
  __u32 ext_ramdisk_image;
  __u32 ext_ramdisk_size;
  __u32 ext_cmd_line_ptr;
  __u8 _pad4[116U];
  struct edid_info edid_info;
  struct efi_info efi_info;
  __u32 alt_mem_k;
  __u32 scratch;
  __u8 e820_entries;
  __u8 eddbuf_entries;
  __u8 edd_mbr_sig_buf_entries;
  __u8 kbd_status;
  __u8 _pad5[3U];
# 148 "./arch/x86/include/uapi/asm/bootparam.h"
  __u8 sentinel;
  __u8 _pad6[1U];
  struct setup_header hdr;
  __u8 _pad7[40U];
  __u32 edd_mbr_sig_buffer[16U];
  struct e820entry e820_map[128U];
  __u8 _pad8[48U];
  struct edd_info eddbuf[6U];
  __u8 _pad9[276U];
};
enum ldv_11466
{
  X86_SUBARCH_PC = 0,
  X86_SUBARCH_LGUEST = 1,
  X86_SUBARCH_XEN = 2,
  X86_SUBARCH_INTEL_MID = 3,
  X86_SUBARCH_CE4100 = 4,
  X86_NR_SUBARCHS = 5
};
struct x86_init_mpparse
{
# 24 "./arch/x86/include/asm/x86_init.h"
  void (*mpc_record)(unsigned int);
  void (*setup_ioapic_ids)(void);
  int (*mpc_apic_id)(struct mpc_cpu *);
  void (*smp_read_mpc_oem)(struct mpc_table *);
  void (*mpc_oem_pci_bus)(struct mpc_bus *);
  void (*mpc_oem_bus_info)(struct mpc_bus *, char *);
  void (*find_smp_config)(void);
  void (*get_smp_config)(unsigned int);
};
struct x86_init_resources
{
# 43 "./arch/x86/include/asm/x86_init.h"
  void (*probe_roms)(void);
  void (*reserve_resources)(void);
  char *(*memory_setup)(void);
};
struct x86_init_irqs
{
# 56 "./arch/x86/include/asm/x86_init.h"
  void (*pre_vector_init)(void);
  void (*intr_init)(void);
  void (*trap_init)(void);
};
struct x86_init_oem
{
# 67 "./arch/x86/include/asm/x86_init.h"
  void (*arch_setup)(void);
  void (*banner)(void);
};
struct x86_init_paging
{
# 79 "./arch/x86/include/asm/x86_init.h"
  void (*pagetable_init)(void);
};
struct x86_init_timers
{
# 91 "./arch/x86/include/asm/x86_init.h"
  void (*setup_percpu_clockev)(void);
  void (*tsc_pre_init)(void);
  void (*timer_init)(void);
  void (*wallclock_init)(void);
};
struct x86_init_iommu
{
# 102 "./arch/x86/include/asm/x86_init.h"
  int (*iommu_init)(void);
};
struct x86_init_pci
{
# 113 "./arch/x86/include/asm/x86_init.h"
  int (*arch_init)(void);
  int (*init)(void);
  void (*init_irq)(void);
  void (*fixup_irqs)(void);
};
struct x86_init_ops
{
# 124 "./arch/x86/include/asm/x86_init.h"
  struct x86_init_resources resources;
  struct x86_init_mpparse mpparse;
  struct x86_init_irqs irqs;
  struct x86_init_oem oem;
  struct x86_init_paging paging;
  struct x86_init_timers timers;
  struct x86_init_iommu iommu;
  struct x86_init_pci pci;
};
struct x86_cpuinit_ops
{
# 140 "./arch/x86/include/asm/x86_init.h"
  void (*setup_percpu_clockev)(void);
  void (*early_percpu_clock_init)(void);
  void (*fixup_cpu_id)(struct cpuinfo_x86 *, int);
};
struct x86_platform_ops
{
# 160 "./arch/x86/include/asm/x86_init.h"
  long unsigned int (*calibrate_tsc)(void);
  void (*get_wallclock)(struct timespec *);
  int (*set_wallclock)(struct timespec const *);
  void (*iommu_shutdown)(void);
  bool (*is_untracked_pat_range)(u64, u64);
  void (*nmi_init)(void);
  unsigned char (*get_nmi_reason)(void);
  int (*i8042_detect)(void);
  void (*save_sched_clock_state)(void);
  void (*restore_sched_clock_state)(void);
  void (*apic_post_init)(void);
};
struct pci_dev;
struct msi_msg;
struct msi_desc;
struct x86_msi_ops
{
# 178 "./arch/x86/include/asm/x86_init.h"
  int (*setup_msi_irqs)(struct pci_dev *, int, int);
  void (*compose_msi_msg)(struct pci_dev *, unsigned int, unsigned int, struct msi_msg *, u8);
# 182 "./arch/x86/include/asm/x86_init.h"
  void (*teardown_msi_irq)(unsigned int);
  void (*teardown_msi_irqs)(struct pci_dev *);
  void (*restore_msi_irqs)(struct pci_dev *);
  int (*setup_hpet_msi)(unsigned int, unsigned int);
  u32 (*msi_mask_irq)(struct msi_desc *, u32, u32);
  u32 (*msix_mask_irq)(struct msi_desc *, u32);
};
struct IO_APIC_route_entry;
struct io_apic_irq_attr;
struct irq_data;
struct x86_io_apic_ops
{
# 196 "./arch/x86/include/asm/x86_init.h"
  void (*init)(void);
  unsigned int (*read)(unsigned int, unsigned int);
  void (*write)(unsigned int, unsigned int, unsigned int);
  void (*modify)(unsigned int, unsigned int, unsigned int);
  void (*disable)(void);
  void (*print_entries)(unsigned int, unsigned int);
  int (*set_affinity)(struct irq_data *, struct cpumask const *, bool);
# 205 "./arch/x86/include/asm/x86_init.h"
  int (*setup_entry)(int, struct IO_APIC_route_entry *, unsigned int, int, struct io_apic_irq_attr *);
# 208 "./arch/x86/include/asm/x86_init.h"
  void (*eoi_ioapic_pin)(int, int, int);
};
# 211 "./arch/x86/include/asm/x86_init.h"
extern struct x86_init_ops x86_init;
extern struct x86_cpuinit_ops x86_cpuinit;
extern struct x86_platform_ops x86_platform;
extern struct x86_msi_ops x86_msi;
extern struct x86_io_apic_ops x86_io_apic_ops;
void x86_init_noop(void);
void x86_init_uint_noop(unsigned int);
struct local_apic
{
# 180 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 180 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_01;
  struct
  {
# 182 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_02;
# 189 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 185 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved_1 : 24;
    unsigned char phys_apic_id : 4;
    unsigned char __reserved_2 : 4;
    unsigned int __reserved[3U];
  } id;
# 198 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 193 "./arch/x86/include/asm/apicdef.h"
    unsigned char version;
    unsigned char __reserved_1;
    unsigned char max_lvt;
    unsigned char __reserved_2;
    unsigned int __reserved[3U];
  } const version;
# 200 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 200 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_03;
  struct
  {
# 202 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_04;
  struct
  {
# 204 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_05;
  struct
  {
# 206 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_06;
# 212 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 209 "./arch/x86/include/asm/apicdef.h"
    unsigned char priority;
    unsigned int __reserved_1 : 24;
    unsigned int __reserved_2[3U];
  } tpr;
# 219 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 216 "./arch/x86/include/asm/apicdef.h"
    unsigned char priority;
    unsigned int __reserved_1 : 24;
    unsigned int __reserved_2[3U];
  } const apr;
# 226 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 223 "./arch/x86/include/asm/apicdef.h"
    unsigned char priority;
    unsigned int __reserved_1 : 24;
    unsigned int __reserved_2[3U];
  } const ppr;
# 231 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 229 "./arch/x86/include/asm/apicdef.h"
    unsigned int eoi;
    unsigned int __reserved[3U];
  } eoi;
# 233 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 233 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_07;
# 239 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 236 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved_1 : 24;
    unsigned char logical_dest;
    unsigned int __reserved_2[3U];
  } ldr;
# 245 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 242 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved_1 : 28;
    unsigned char model : 4;
    unsigned int __reserved_2[3U];
  } dfr;
# 253 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 248 "./arch/x86/include/asm/apicdef.h"
    unsigned char spurious_vector;
    unsigned char apic_enabled : 1;
    unsigned char focus_cpu : 1;
    unsigned int __reserved_2 : 22;
    unsigned int __reserved_3[3U];
  } svr;
# 258 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 256 "./arch/x86/include/asm/apicdef.h"
    unsigned int bitfield;
    unsigned int __reserved[3U];
  } isr[8U];
# 263 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 261 "./arch/x86/include/asm/apicdef.h"
    unsigned int bitfield;
    unsigned int __reserved[3U];
  } tmr[8U];
# 268 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 266 "./arch/x86/include/asm/apicdef.h"
    unsigned int bitfield;
    unsigned int __reserved[3U];
  } irr[8U];
# 287 "./arch/x86/include/asm/apicdef.h"
  union
  {
# 282 "./arch/x86/include/asm/apicdef.h"
    struct
    {
# 272 "./arch/x86/include/asm/apicdef.h"
      unsigned char send_cs_error : 1;
      unsigned char receive_cs_error : 1;
      unsigned char send_accept_error : 1;
      unsigned char receive_accept_error : 1;
      unsigned char __reserved_1 : 1;
      unsigned char send_illegal_vector : 1;
      unsigned char receive_illegal_vector : 1;
      unsigned char illegal_register_address : 1;
      unsigned int __reserved_2 : 24;
      unsigned int __reserved_3[3U];
    } error_bits;
# 286 "./arch/x86/include/asm/apicdef.h"
    struct
    {
# 284 "./arch/x86/include/asm/apicdef.h"
      unsigned int errors;
      unsigned int __reserved_3[3U];
    } all_errors;
  } esr;
# 289 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 289 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_08;
  struct
  {
# 291 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_09;
  struct
  {
# 293 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_10;
  struct
  {
# 295 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_11;
  struct
  {
# 297 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_12;
  struct
  {
# 299 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_13;
  struct
  {
# 301 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_14;
# 315 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 304 "./arch/x86/include/asm/apicdef.h"
    unsigned char vector;
    unsigned char delivery_mode : 3;
    unsigned char destination_mode : 1;
    unsigned char delivery_status : 1;
    unsigned char __reserved_1 : 1;
    unsigned char level : 1;
    unsigned char trigger : 1;
    unsigned char __reserved_2 : 2;
    unsigned char shorthand : 2;
    short unsigned int __reserved_3 : 12;
    unsigned int __reserved_4[3U];
  } icr1;
# 326 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 324 "./arch/x86/include/asm/apicdef.h"
    union
    {
# 319 "./arch/x86/include/asm/apicdef.h"
      unsigned int __reserved_1 : 24;
      unsigned char phys_dest : 4;
      unsigned char __reserved_2 : 4;
      unsigned int __reserved_3 : 24;
      unsigned char logical_dest;
    } dest;
    unsigned int __reserved_4[3U];
  } icr2;
# 337 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 329 "./arch/x86/include/asm/apicdef.h"
    unsigned char vector;
    unsigned char __reserved_1 : 4;
    unsigned char delivery_status : 1;
    unsigned char __reserved_2 : 3;
    unsigned char mask : 1;
    unsigned char timer_mode : 1;
    short unsigned int __reserved_3 : 14;
    unsigned int __reserved_4[3U];
  } lvt_timer;
# 348 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 340 "./arch/x86/include/asm/apicdef.h"
    unsigned char vector;
    unsigned char delivery_mode : 3;
    unsigned char __reserved_1 : 1;
    unsigned char delivery_status : 1;
    unsigned char __reserved_2 : 3;
    unsigned char mask : 1;
    short unsigned int __reserved_3 : 15;
    unsigned int __reserved_4[3U];
  } lvt_thermal;
# 359 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 351 "./arch/x86/include/asm/apicdef.h"
    unsigned char vector;
    unsigned char delivery_mode : 3;
    unsigned char __reserved_1 : 1;
    unsigned char delivery_status : 1;
    unsigned char __reserved_2 : 3;
    unsigned char mask : 1;
    short unsigned int __reserved_3 : 15;
    unsigned int __reserved_4[3U];
  } lvt_pc;
# 372 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 362 "./arch/x86/include/asm/apicdef.h"
    unsigned char vector;
    unsigned char delivery_mode : 3;
    unsigned char __reserved_1 : 1;
    unsigned char delivery_status : 1;
    unsigned char polarity : 1;
    unsigned char remote_irr : 1;
    unsigned char trigger : 1;
    unsigned char mask : 1;
    short unsigned int __reserved_2 : 15;
    unsigned int __reserved_3[3U];
  } lvt_lint0;
# 385 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 375 "./arch/x86/include/asm/apicdef.h"
    unsigned char vector;
    unsigned char delivery_mode : 3;
    unsigned char __reserved_1 : 1;
    unsigned char delivery_status : 1;
    unsigned char polarity : 1;
    unsigned char remote_irr : 1;
    unsigned char trigger : 1;
    unsigned char mask : 1;
    short unsigned int __reserved_2 : 15;
    unsigned int __reserved_3[3U];
  } lvt_lint1;
# 395 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 388 "./arch/x86/include/asm/apicdef.h"
    unsigned char vector;
    unsigned char __reserved_1 : 4;
    unsigned char delivery_status : 1;
    unsigned char __reserved_2 : 3;
    unsigned char mask : 1;
    short unsigned int __reserved_3 : 15;
    unsigned int __reserved_4[3U];
  } lvt_error;
# 400 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 398 "./arch/x86/include/asm/apicdef.h"
    unsigned int initial_count;
    unsigned int __reserved_2[3U];
  } timer_icr;
# 406 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 404 "./arch/x86/include/asm/apicdef.h"
    unsigned int curr_count;
    unsigned int __reserved_2[3U];
  } const timer_ccr;
# 408 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 408 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_16;
  struct
  {
# 410 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_17;
  struct
  {
# 412 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_18;
  struct
  {
# 414 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_19;
# 420 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 417 "./arch/x86/include/asm/apicdef.h"
    unsigned char divisor : 4;
    unsigned int __reserved_1 : 28;
    unsigned int __reserved_2[3U];
  } timer_dcr;
# 422 "./arch/x86/include/asm/apicdef.h"
  struct
  {
# 422 "./arch/x86/include/asm/apicdef.h"
    unsigned int __reserved[4U];
  } __reserved_20;
};
enum ioapic_irq_destination_types
{
  dest_Fixed = 0,
  dest_LowestPrio = 1,
  dest_SMI = 2,
  dest__reserved_1 = 3,
  dest_NMI = 4,
  dest_INIT = 5,
  dest__reserved_2 = 6,
  dest_ExtINT = 7
};
# 9 "./arch/x86/include/asm/mpspec.h"
extern int apic_version[];
extern int pic_mode;
# 40 "./arch/x86/include/asm/mpspec.h"
extern long unsigned int mp_bus_not_pci[4U];
# 42 "./arch/x86/include/asm/mpspec.h"
extern unsigned int boot_cpu_physical_apicid;
extern long unsigned int mp_lapic_addr;
# 46 "./arch/x86/include/asm/mpspec.h"
extern int smp_found_config;
# 51 "./arch/x86/include/asm/mpspec.h"
static inline void get_smp_config(void)
{
  x86_init . mpparse . get_smp_config ( 0U );
}
# 56 "./arch/x86/include/asm/mpspec.h"
static inline void early_get_smp_config(void)
{
  x86_init . mpparse . get_smp_config ( 1U );
}
# 61 "./arch/x86/include/asm/mpspec.h"
static inline void find_smp_config(void)
{
  x86_init . mpparse . find_smp_config ( );
}
# 67 "./arch/x86/include/asm/mpspec.h"
void early_reserve_e820_mpc_new(void);
extern int enable_update_mptable;
int default_mpc_apic_id(struct mpc_cpu *);
void default_smp_read_mpc_oem(struct mpc_table *);
# 72 "./arch/x86/include/asm/mpspec.h"
void default_mpc_oem_bus_info(struct mpc_bus *, char *);
# 76 "./arch/x86/include/asm/mpspec.h"
void default_find_smp_config(void);
void default_get_smp_config(unsigned int);
# 88 "./arch/x86/include/asm/mpspec.h"
int generic_processor_info(int, int);
struct physid_mask
{
# 93 "./arch/x86/include/asm/mpspec.h"
  long unsigned int mask[512U];
};
# 96 "./arch/x86/include/asm/mpspec.h"
typedef struct physid_mask physid_mask_t;
# 131 "./arch/x86/include/asm/mpspec.h"
static inline long unsigned int physids_coerce(physid_mask_t *map)
{
  return ( * map ) . mask [ 0 ];
}
# 136 "./arch/x86/include/asm/mpspec.h"
static inline void physids_promote(long unsigned int physids, physid_mask_t *map)
{
  bitmap_zero ( ( long unsigned int *) & ( * map ) . mask , 32768 );
  ( * map ) . mask [ 0 ] = physids;
}
# 142 "./arch/x86/include/asm/mpspec.h"
static inline void physid_set_mask_of_physid(int physid, physid_mask_t *map)
{
  bitmap_zero ( ( long unsigned int *) & ( * map ) . mask , 32768 );
  set_bit ( ( long int ) physid , ( long unsigned int volatile *) & ( * map ) . mask );
}
# 151 "./arch/x86/include/asm/mpspec.h"
extern physid_mask_t phys_cpu_present_map;
# 34 "include/linux/pm.h"
extern void (*pm_power_off)(void);
extern void (*pm_power_off_prepare)(void);
# 39 "include/linux/pm.h"
void pm_vt_switch_required(struct device *, bool);
void pm_vt_switch_unregister(struct device *);
# 57 "include/linux/pm.h"
extern char const power_group_name[];
struct pm_message
{
# 63 "include/linux/pm.h"
  int event;
};
# 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
struct dev_pm_ops
{
# 296 "include/linux/pm.h"
  int (*prepare)(struct device *);
  void (*complete)(struct device *);
  int (*suspend)(struct device *);
  int (*resume)(struct device *);
  int (*freeze)(struct device *);
  int (*thaw)(struct device *);
  int (*poweroff)(struct device *);
  int (*restore)(struct device *);
  int (*suspend_late)(struct device *);
  int (*resume_early)(struct device *);
  int (*freeze_late)(struct device *);
  int (*thaw_early)(struct device *);
  int (*poweroff_late)(struct device *);
  int (*restore_early)(struct device *);
  int (*suspend_noirq)(struct device *);
  int (*resume_noirq)(struct device *);
  int (*freeze_noirq)(struct device *);
  int (*thaw_noirq)(struct device *);
  int (*poweroff_noirq)(struct device *);
  int (*restore_noirq)(struct device *);
  int (*runtime_suspend)(struct device *);
  int (*runtime_resume)(struct device *);
  int (*runtime_idle)(struct device *);
};
enum rpm_status
{
  RPM_ACTIVE = 0,
  RPM_RESUMING = 1,
  RPM_SUSPENDED = 2,
  RPM_SUSPENDING = 3
};
enum rpm_request
{
  RPM_REQ_NONE = 0,
  RPM_REQ_IDLE = 1,
  RPM_REQ_SUSPEND = 2,
  RPM_REQ_AUTOSUSPEND = 3,
  RPM_REQ_RESUME = 4
};
struct wakeup_source;
struct pm_domain_data
{
# 543 "include/linux/pm.h"
  struct list_head list_node;
  struct device *dev;
};
struct pm_subsys_data
{
  spinlock_t lock;
  unsigned int refcount;
# 551 "include/linux/pm.h"
  struct list_head clock_list;
};
struct dev_pm_info
{
# 559 "include/linux/pm.h"
  pm_message_t power_state;
  unsigned char can_wakeup : 1;
  unsigned char async_suspend : 1;
  bool is_prepared;
  bool is_suspended;
  bool is_noirq_suspended;
  bool is_late_suspended;
  bool ignore_children;
  bool early_init;
  bool direct_complete;
  spinlock_t lock;
# 571 "include/linux/pm.h"
  struct list_head entry;
  struct completion completion;
  struct wakeup_source *wakeup;
  bool wakeup_path;
  bool syscore;
# 580 "include/linux/pm.h"
  struct timer_list suspend_timer;
  long unsigned int timer_expires;
  struct work_struct work;
  wait_queue_head_t wait_queue;
  atomic_t usage_count;
  atomic_t child_count;
  unsigned char disable_depth : 3;
  unsigned char idle_notification : 1;
  unsigned char request_pending : 1;
  unsigned char deferred_resume : 1;
  unsigned char run_wake : 1;
  unsigned char runtime_auto : 1;
  unsigned char no_callbacks : 1;
  unsigned char irq_safe : 1;
  unsigned char use_autosuspend : 1;
  unsigned char timer_autosuspends : 1;
  unsigned char memalloc_noio : 1;
  enum rpm_request request;
  enum rpm_status runtime_status;
  int runtime_error;
  int autosuspend_delay;
  long unsigned int last_busy;
  long unsigned int active_jiffies;
  long unsigned int suspended_jiffies;
  long unsigned int accounting_timestamp;
# 606 "include/linux/pm.h"
  struct pm_subsys_data *subsys_data;
  void (*set_latency_tolerance)(struct device *, s32);
  struct dev_pm_qos *qos;
};
# 611 "include/linux/pm.h"
void update_pm_runtime_accounting(struct device *);
int dev_pm_get_subsys_data(struct device *);
int dev_pm_put_subsys_data(struct device *);
struct dev_pm_domain
{
# 621 "include/linux/pm.h"
  struct dev_pm_ops ops;
};
# 679 "include/linux/pm.h"
void device_pm_lock(void);
void dpm_resume_start(pm_message_t);
void dpm_resume_end(pm_message_t);
void dpm_resume(pm_message_t);
void dpm_complete(pm_message_t);
# 685 "include/linux/pm.h"
void device_pm_unlock(void);
int dpm_suspend_end(pm_message_t);
int dpm_suspend_start(pm_message_t);
int dpm_suspend(pm_message_t);
int dpm_prepare(pm_message_t);
# 691 "include/linux/pm.h"
void __suspend_report_result(char const *, void *, int);
# 698 "include/linux/pm.h"
int device_pm_wait_for_dev(struct device *, struct device *);
void dpm_for_each_dev(void *, void (*)(struct device *, void *));
# 701 "include/linux/pm.h"
int pm_generic_prepare(struct device *);
int pm_generic_suspend_late(struct device *);
int pm_generic_suspend_noirq(struct device *);
int pm_generic_suspend(struct device *);
int pm_generic_resume_early(struct device *);
int pm_generic_resume_noirq(struct device *);
int pm_generic_resume(struct device *);
int pm_generic_freeze_noirq(struct device *);
int pm_generic_freeze_late(struct device *);
int pm_generic_freeze(struct device *);
int pm_generic_thaw_noirq(struct device *);
int pm_generic_thaw_early(struct device *);
int pm_generic_thaw(struct device *);
int pm_generic_restore_noirq(struct device *);
int pm_generic_restore_early(struct device *);
int pm_generic_restore(struct device *);
int pm_generic_poweroff_noirq(struct device *);
int pm_generic_poweroff_late(struct device *);
int pm_generic_poweroff(struct device *);
void pm_generic_complete(struct device *);
enum dpm_order
{
  DPM_ORDER_NONE = 0,
  DPM_ORDER_DEV_AFTER_PARENT = 1,
  DPM_ORDER_PARENT_BEFORE_DEV = 2,
  DPM_ORDER_DEV_LAST = 3
};
# 51 "./arch/x86/include/asm/topology.h"
extern char __pcpu_scope_x86_cpu_to_node_map;
# 51 "./arch/x86/include/asm/topology.h"
extern int x86_cpu_to_node_map;
# 51 "./arch/x86/include/asm/topology.h"
extern int *x86_cpu_to_node_map_early_ptr;
# 51 "./arch/x86/include/asm/topology.h"
extern int x86_cpu_to_node_map_early_map[];
# 57 "./arch/x86/include/asm/topology.h"
int __cpu_to_node(int);
# 60 "./arch/x86/include/asm/topology.h"
int early_cpu_to_node(int);
# 73 "./arch/x86/include/asm/topology.h"
extern cpumask_var_t node_to_cpumask_map[1024U];
# 76 "./arch/x86/include/asm/topology.h"
struct cpumask const *cpumask_of_node(int);
# 85 "./arch/x86/include/asm/topology.h"
void setup_node_to_cpumask_map(void);
# 95 "./arch/x86/include/asm/topology.h"
int __node_distance(int, int);
# 120 "./arch/x86/include/asm/topology.h"
struct cpumask const *cpu_coregroup_mask(int);
# 130 "./arch/x86/include/asm/topology.h"
static inline void arch_fix_phys_package_id(int num, u32 slot)
{
}
struct pci_bus;
# 135 "./arch/x86/include/asm/topology.h"
int x86_pci_root_bus_node(int);
void x86_pci_root_bus_resources(int, struct list_head *);
# 21 "./arch/x86/include/asm/numa.h"
extern int numa_off;
# 31 "./arch/x86/include/asm/numa.h"
extern s16 __apicid_to_node[32768U];
extern nodemask_t numa_nodes_parsed;
# 34 "./arch/x86/include/asm/numa.h"
int numa_add_memblk(int, u64, u64);
void numa_set_distance(int, int, int);
# 37 "./arch/x86/include/asm/numa.h"
static inline void set_apicid_to_node(int apicid, s16 node)
{
  __apicid_to_node [ apicid ] = node;
}
# 42 "./arch/x86/include/asm/numa.h"
int numa_cpu_node(int);
# 60 "./arch/x86/include/asm/numa.h"
void numa_set_node(int, int);
void numa_clear_node(int);
void init_cpu_to_node(void);
void numa_add_cpu(int);
void numa_remove_cpu(int);
# 74 "./arch/x86/include/asm/numa.h"
void debug_cpumask_set_cpu(int, int, bool);
# 80 "./arch/x86/include/asm/numa.h"
void numa_emu_cmdline(char *);
# 22 "./arch/x86/include/asm/mmu.h"
typedef struct
{
# 12 "./arch/x86/include/asm/mmu.h"
  void *ldt;
  int size;
# 17 "./arch/x86/include/asm/mmu.h"
  short unsigned int ia32_compat;
# 20 "./arch/x86/include/asm/mmu.h"
  struct mutex lock;
  void *vdso;
} mm_context_t;
# 25 "./arch/x86/include/asm/mmu.h"
void leave_mm(int);
# 10 "include/asm-generic/early_ioremap.h"
void *early_ioremap(resource_size_t, long unsigned int);
# 12 "include/asm-generic/early_ioremap.h"
void *early_memremap(resource_size_t, long unsigned int);
# 14 "include/asm-generic/early_ioremap.h"
void early_iounmap(void *, long unsigned int);
void early_memunmap(void *, long unsigned int);
# 21 "include/asm-generic/early_ioremap.h"
void early_ioremap_shutdown(void);
# 25 "include/asm-generic/early_ioremap.h"
void early_ioremap_init(void);
# 28 "include/asm-generic/early_ioremap.h"
void early_ioremap_setup(void);
# 34 "include/asm-generic/early_ioremap.h"
void early_ioremap_reset(void);
# 54 "./arch/x86/include/asm/io.h"
static inline unsigned char readb(void const volatile *addr)
{
# 54 "./arch/x86/include/asm/io.h"
  unsigned char ret;
# 54 "./arch/x86/include/asm/io.h"
  asm volatile ( "movb %1,%0" : "=q" ( ret ) : "m" ( * ( unsigned char volatile *) addr ) : "memory" ) ;
# 54 "./arch/x86/include/asm/io.h"
  return ret;
}
# 55 "./arch/x86/include/asm/io.h"
static inline short unsigned int readw(void const volatile *addr)
{
# 55 "./arch/x86/include/asm/io.h"
  short unsigned int ret;
# 55 "./arch/x86/include/asm/io.h"
  asm volatile ( "movw %1,%0" : "=r" ( ret ) : "m" ( * ( short unsigned int volatile *) addr ) : "memory" ) ;
# 55 "./arch/x86/include/asm/io.h"
  return ret;
}
# 56 "./arch/x86/include/asm/io.h"
static inline unsigned int readl(void const volatile *addr)
{
# 56 "./arch/x86/include/asm/io.h"
  unsigned int ret;
# 56 "./arch/x86/include/asm/io.h"
  asm volatile ( "movl %1,%0" : "=r" ( ret ) : "m" ( * ( unsigned int volatile *) addr ) : "memory" ) ;
# 56 "./arch/x86/include/asm/io.h"
  return ret;
}
static inline unsigned char __readb(void const volatile *addr)
{
# 58 "./arch/x86/include/asm/io.h"
  unsigned char ret;
# 58 "./arch/x86/include/asm/io.h"
  asm volatile ( "movb %1,%0" : "=q" ( ret ) : "m" ( * ( unsigned char volatile *) addr ) ) ;
# 58 "./arch/x86/include/asm/io.h"
  return ret;
}
# 59 "./arch/x86/include/asm/io.h"
static inline short unsigned int __readw(void const volatile *addr)
{
# 59 "./arch/x86/include/asm/io.h"
  short unsigned int ret;
# 59 "./arch/x86/include/asm/io.h"
  asm volatile ( "movw %1,%0" : "=r" ( ret ) : "m" ( * ( short unsigned int volatile *) addr ) ) ;
# 59 "./arch/x86/include/asm/io.h"
  return ret;
}
# 60 "./arch/x86/include/asm/io.h"
static inline unsigned int __readl(void const volatile *addr)
{
# 60 "./arch/x86/include/asm/io.h"
  unsigned int ret;
# 60 "./arch/x86/include/asm/io.h"
  asm volatile ( "movl %1,%0" : "=r" ( ret ) : "m" ( * ( unsigned int volatile *) addr ) ) ;
# 60 "./arch/x86/include/asm/io.h"
  return ret;
}
static inline void writeb(unsigned char val, void volatile *addr)
{
# 62 "./arch/x86/include/asm/io.h"
  asm volatile ( "movb %0,%1" : : "q" ( val ) , "m" ( * ( unsigned char volatile *) addr ) : "memory" ) ;
}
# 63 "./arch/x86/include/asm/io.h"
static inline void writew(short unsigned int val, void volatile *addr)
{
# 63 "./arch/x86/include/asm/io.h"
  asm volatile ( "movw %0,%1" : : "r" ( val ) , "m" ( * ( short unsigned int volatile *) addr ) : "memory" ) ;
}
# 64 "./arch/x86/include/asm/io.h"
static inline void writel(unsigned int val, void volatile *addr)
{
# 64 "./arch/x86/include/asm/io.h"
  asm volatile ( "movl %0,%1" : : "r" ( val ) , "m" ( * ( unsigned int volatile *) addr ) : "memory" ) ;
}
static inline void __writeb(unsigned char val, void volatile *addr)
{
# 66 "./arch/x86/include/asm/io.h"
  asm volatile ( "movb %0,%1" : : "q" ( val ) , "m" ( * ( unsigned char volatile *) addr ) ) ;
}
# 67 "./arch/x86/include/asm/io.h"
static inline void __writew(short unsigned int val, void volatile *addr)
{
# 67 "./arch/x86/include/asm/io.h"
  asm volatile ( "movw %0,%1" : : "r" ( val ) , "m" ( * ( short unsigned int volatile *) addr ) ) ;
}
# 68 "./arch/x86/include/asm/io.h"
static inline void __writel(unsigned int val, void volatile *addr)
{
# 68 "./arch/x86/include/asm/io.h"
  asm volatile ( "movl %0,%1" : : "r" ( val ) , "m" ( * ( unsigned int volatile *) addr ) ) ;
}
# 85 "./arch/x86/include/asm/io.h"
static inline long unsigned int readq(void const volatile *addr)
{
# 85 "./arch/x86/include/asm/io.h"
  long unsigned int ret;
# 85 "./arch/x86/include/asm/io.h"
  asm volatile ( "movq %1,%0" : "=r" ( ret ) : "m" ( * ( long unsigned int volatile *) addr ) : "memory" ) ;
# 85 "./arch/x86/include/asm/io.h"
  return ret;
}
# 86 "./arch/x86/include/asm/io.h"
static inline void writeq(long unsigned int val, void volatile *addr)
{
# 86 "./arch/x86/include/asm/io.h"
  asm volatile ( "movq %0,%1" : : "r" ( val ) , "m" ( * ( long unsigned int volatile *) addr ) : "memory" ) ;
}
# 112 "./arch/x86/include/asm/io.h"
static inline phys_addr_t virt_to_phys(void volatile *address)
{
  return ( phys_addr_t ) __phys_addr ( ( long unsigned int ) address );
}
# 130 "./arch/x86/include/asm/io.h"
static inline void *phys_to_virt(phys_addr_t address)
{
  return ( void *) ( ( long unsigned int ) address + 18446612132314218496UL );
}
# 145 "./arch/x86/include/asm/io.h"
static inline unsigned int isa_virt_to_bus(void volatile *address)
{
  return ( unsigned int ) virt_to_phys ( address );
}
# 175 "./arch/x86/include/asm/io.h"
void *ioremap_nocache(resource_size_t, long unsigned int);
void *ioremap_cache(resource_size_t, long unsigned int);
void *ioremap_prot(resource_size_t, long unsigned int, long unsigned int);
# 183 "./arch/x86/include/asm/io.h"
static inline void *ioremap(resource_size_t offset, long unsigned int size)
{
  return ioremap_nocache ( offset , size );
}
# 188 "./arch/x86/include/asm/io.h"
void iounmap(void volatile *);
# 190 "./arch/x86/include/asm/io.h"
void set_iounmap_nonlazy(void);
# 28 "include/asm-generic/iomap.h"
unsigned int ioread8(void *);
unsigned int ioread16(void *);
unsigned int ioread16be(void *);
unsigned int ioread32(void *);
unsigned int ioread32be(void *);
# 34 "include/asm-generic/iomap.h"
void iowrite8(u8, void *);
void iowrite16(u16, void *);
void iowrite16be(u16, void *);
void iowrite32(u32, void *);
void iowrite32be(u32, void *);
# 51 "include/asm-generic/iomap.h"
void ioread8_rep(void *, void *, long unsigned int);
void ioread16_rep(void *, void *, long unsigned int);
void ioread32_rep(void *, void *, long unsigned int);
# 55 "include/asm-generic/iomap.h"
void iowrite8_rep(void *, void const *, long unsigned int);
void iowrite16_rep(void *, void const *, long unsigned int);
void iowrite32_rep(void *, void const *, long unsigned int);
# 61 "include/asm-generic/iomap.h"
void *ioport_map(long unsigned int, unsigned int);
void ioport_unmap(void *);
# 72 "include/asm-generic/iomap.h"
void pci_iounmap(struct pci_dev *, void *);
# 17 "include/asm-generic/pci_iomap.h"
void *pci_iomap(struct pci_dev *, int, long unsigned int);
struct rb_node
{
# 36 "include/linux/rbtree.h"
  long unsigned int __rb_parent_color;
  struct rb_node *rb_right;
  struct rb_node *rb_left;
};
struct rb_root
{
# 43 "include/linux/rbtree.h"
  struct rb_node *rb_node;
};
# 61 "include/linux/rbtree.h"
void rb_insert_color(struct rb_node *, struct rb_root *);
void rb_erase(struct rb_node *, struct rb_root *);
# 66 "include/linux/rbtree.h"
struct rb_node *rb_next(struct rb_node const *);
struct rb_node *rb_prev(struct rb_node const *);
struct rb_node *rb_first(struct rb_root const *);
struct rb_node *rb_last(struct rb_root const *);
# 72 "include/linux/rbtree.h"
struct rb_node *rb_first_postorder(struct rb_root const *);
struct rb_node *rb_next_postorder(struct rb_node const *);
# 76 "include/linux/rbtree.h"
void rb_replace_node(struct rb_node *, struct rb_node *, struct rb_root *);
# 79 "include/linux/rbtree.h"
static inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link)
{
# 82 "include/linux/rbtree.h"
  ( * node ) . __rb_parent_color = ( long unsigned int ) parent;
  ( * node ) . rb_left = ( * node ) . rb_right = ( ( struct rb_node *) 0 );
# 85 "include/linux/rbtree.h"
  * rb_link = node;
}
struct vm_area_struct;
struct vm_struct
{
# 30 "include/linux/vmalloc.h"
  struct vm_struct *next;
  void *addr;
  long unsigned int size;
  long unsigned int flags;
  struct page **pages;
  unsigned int nr_pages;
  phys_addr_t phys_addr;
  void const *caller;
};
struct vmap_area
{
  long unsigned int va_start;
  long unsigned int va_end;
  long unsigned int flags;
  struct rb_node rb_node;
  struct list_head list;
  struct list_head purge_list;
  struct vm_struct *vm;
  struct callback_head callback_head;
};
# 54 "include/linux/vmalloc.h"
void vm_unmap_ram(void const *, unsigned int);
void *vm_map_ram(struct page **, unsigned int, int, pgprot_t);
# 57 "include/linux/vmalloc.h"
void vm_unmap_aliases(void);
# 60 "include/linux/vmalloc.h"
void vmalloc_init(void);
# 67 "include/linux/vmalloc.h"
void *vmalloc(long unsigned int);
void *vzalloc(long unsigned int);
void *vmalloc_user(long unsigned int);
void *vmalloc_node(long unsigned int, int);
void *vzalloc_node(long unsigned int, int);
void *vmalloc_exec(long unsigned int);
void *vmalloc_32(long unsigned int);
void *vmalloc_32_user(long unsigned int);
void *__vmalloc(long unsigned int, gfp_t, pgprot_t);
void *__vmalloc_node_range(long unsigned int, long unsigned int, long unsigned int, long unsigned int, gfp_t, pgprot_t, int, void const *);
# 79 "include/linux/vmalloc.h"
void vfree(void const *);
# 81 "include/linux/vmalloc.h"
void *vmap(struct page **, unsigned int, long unsigned int, pgprot_t);
# 83 "include/linux/vmalloc.h"
void vunmap(void const *);
# 85 "include/linux/vmalloc.h"
int remap_vmalloc_range_partial(struct vm_area_struct *, long unsigned int, void *, long unsigned int);
# 89 "include/linux/vmalloc.h"
int remap_vmalloc_range(struct vm_area_struct *, void *, long unsigned int);
# 91 "include/linux/vmalloc.h"
void vmalloc_sync_all(void);
# 97 "include/linux/vmalloc.h"
static inline size_t get_vm_area_size(struct vm_struct const *area)
{
# 100 "include/linux/vmalloc.h"
  return ( size_t ) ( ( long unsigned int ) ( * area ) . size - 4096UL );
}
# 103 "include/linux/vmalloc.h"
struct vm_struct *get_vm_area(long unsigned int, long unsigned int);
struct vm_struct *get_vm_area_caller(long unsigned int, long unsigned int, void const *);
# 106 "include/linux/vmalloc.h"
struct vm_struct *__get_vm_area(long unsigned int, long unsigned int, long unsigned int, long unsigned int);
# 108 "include/linux/vmalloc.h"
struct vm_struct *__get_vm_area_caller(long unsigned int, long unsigned int, long unsigned int, long unsigned int, void const *);
# 112 "include/linux/vmalloc.h"
struct vm_struct *remove_vm_area(void const *);
struct vm_struct *find_vm_area(void const *);
# 115 "include/linux/vmalloc.h"
int map_vm_area(struct vm_struct *, pgprot_t, struct page **);
# 118 "include/linux/vmalloc.h"
int map_kernel_range_noflush(long unsigned int, long unsigned int, pgprot_t, struct page **);
# 120 "include/linux/vmalloc.h"
void unmap_kernel_range_noflush(long unsigned int, long unsigned int);
void unmap_kernel_range(long unsigned int, long unsigned int);
# 140 "include/linux/vmalloc.h"
struct vm_struct *alloc_vm_area(size_t, pte_t **);
void free_vm_area(struct vm_struct *);
# 144 "include/linux/vmalloc.h"
long int vread(char *, char *, long unsigned int);
long int vwrite(char *, char *, long unsigned int);
# 150 "include/linux/vmalloc.h"
extern struct list_head vmap_area_list;
void vm_area_add_early(struct vm_struct *);
void vm_area_register_early(struct vm_struct *, size_t);
# 156 "include/linux/vmalloc.h"
struct vm_struct **pcpu_get_vm_areas(long unsigned int const *, size_t const *, int, size_t);
# 160 "include/linux/vmalloc.h"
void pcpu_free_vm_areas(struct vm_struct **, int);
struct vmalloc_info
{
# 178 "include/linux/vmalloc.h"
  long unsigned int used;
  long unsigned int largest_chunk;
};
# 184 "include/linux/vmalloc.h"
void get_vmalloc_info(struct vmalloc_info *);
# 204 "./arch/x86/include/asm/io.h"
static inline void memset_io(void volatile *addr, unsigned char val, size_t count)
{
  memset ( ( void *) addr , ( int ) val , count );
}
# 210 "./arch/x86/include/asm/io.h"
static inline void memcpy_fromio(void *dst, void const volatile *src, size_t count)
{
  ({
# 212 "./arch/x86/include/asm/io.h"
    size_t __len = count;
# 212 "./arch/x86/include/asm/io.h"
    void *__ret;
    {
# 212 "./arch/x86/include/asm/io.h"
      if (0)
      {
# 212 "./arch/x86/include/asm/io.h"
        __ret = __memcpy ( dst , ( void const *) src , __len );
      }
      else
# 212 "./arch/x86/include/asm/io.h"
        __ret = __builtin_memcpy ( dst , ( void const *) src , __len );
    }
# 212 "./arch/x86/include/asm/io.h"
    __ret;
  } );
}
# 216 "./arch/x86/include/asm/io.h"
static inline void memcpy_toio(void volatile *dst, void const *src, size_t count)
{
  ({
# 218 "./arch/x86/include/asm/io.h"
    size_t __len = count;
# 218 "./arch/x86/include/asm/io.h"
    void *__ret;
    {
# 218 "./arch/x86/include/asm/io.h"
      if (0)
      {
# 218 "./arch/x86/include/asm/io.h"
        __ret = __memcpy ( ( void *) dst , src , __len );
      }
      else
# 218 "./arch/x86/include/asm/io.h"
        __ret = __builtin_memcpy ( ( void *) dst , src , __len );
    }
# 218 "./arch/x86/include/asm/io.h"
    __ret;
  } );
}
# 239 "./arch/x86/include/asm/io.h"
static inline void flush_write_buffers(void)
{
}
# 248 "./arch/x86/include/asm/io.h"
void native_io_delay(void);
# 250 "./arch/x86/include/asm/io.h"
extern int io_delay_type;
void io_delay_init(void);
# 309 "./arch/x86/include/asm/io.h"
static inline void outb(unsigned char value, int port)
{
# 309 "./arch/x86/include/asm/io.h"
  asm volatile ( "outb %b0, %w1" : : "a" ( value ) , "Nd" ( port ) ) ;
}
# 309 "./arch/x86/include/asm/io.h"
static inline unsigned char inb(int port)
{
# 309 "./arch/x86/include/asm/io.h"
  unsigned char value;
# 309 "./arch/x86/include/asm/io.h"
  asm volatile ( "inb %w1, %b0" : "=a" ( value ) : "Nd" ( port ) ) ;
# 309 "./arch/x86/include/asm/io.h"
  return value;
}
# 309 "./arch/x86/include/asm/io.h"
static inline void outb_p(unsigned char value, int port)
{
# 309 "./arch/x86/include/asm/io.h"
  outb ( ( int ) value , port );
# 309 "./arch/x86/include/asm/io.h"
  slow_down_io ( );
}
# 309 "./arch/x86/include/asm/io.h"
static inline unsigned char inb_p(int port)
{
# 309 "./arch/x86/include/asm/io.h"
  unsigned char value = inb ( port );
# 309 "./arch/x86/include/asm/io.h"
  slow_down_io ( );
# 309 "./arch/x86/include/asm/io.h"
  return value;
}
# 309 "./arch/x86/include/asm/io.h"
static inline void outsb(int port, void const *addr, long unsigned int count)
{
# 309 "./arch/x86/include/asm/io.h"
  asm volatile ( "rep; outsb" : "+S" ( addr ) , "+c" ( count ) : "d" ( port ) ) ;
}
# 309 "./arch/x86/include/asm/io.h"
static inline void insb(int port, void *addr, long unsigned int count)
{
# 309 "./arch/x86/include/asm/io.h"
  asm volatile ( "rep; insb" : "+D" ( addr ) , "+c" ( count ) : "d" ( port ) ) ;
}
# 310 "./arch/x86/include/asm/io.h"
static inline void outw(short unsigned int value, int port)
{
# 310 "./arch/x86/include/asm/io.h"
  asm volatile ( "outw %w0, %w1" : : "a" ( value ) , "Nd" ( port ) ) ;
}
# 310 "./arch/x86/include/asm/io.h"
static inline short unsigned int inw(int port)
{
# 310 "./arch/x86/include/asm/io.h"
  short unsigned int value;
# 310 "./arch/x86/include/asm/io.h"
  asm volatile ( "inw %w1, %w0" : "=a" ( value ) : "Nd" ( port ) ) ;
# 310 "./arch/x86/include/asm/io.h"
  return value;
}
# 310 "./arch/x86/include/asm/io.h"
static inline void outw_p(short unsigned int value, int port)
{
# 310 "./arch/x86/include/asm/io.h"
  outw ( ( int ) value , port );
# 310 "./arch/x86/include/asm/io.h"
  slow_down_io ( );
}
# 310 "./arch/x86/include/asm/io.h"
static inline short unsigned int inw_p(int port)
{
# 310 "./arch/x86/include/asm/io.h"
  short unsigned int value = inw ( port );
# 310 "./arch/x86/include/asm/io.h"
  slow_down_io ( );
# 310 "./arch/x86/include/asm/io.h"
  return value;
}
# 310 "./arch/x86/include/asm/io.h"
static inline void outsw(int port, void const *addr, long unsigned int count)
{
# 310 "./arch/x86/include/asm/io.h"
  asm volatile ( "rep; outsw" : "+S" ( addr ) , "+c" ( count ) : "d" ( port ) ) ;
}
# 310 "./arch/x86/include/asm/io.h"
static inline void insw(int port, void *addr, long unsigned int count)
{
# 310 "./arch/x86/include/asm/io.h"
  asm volatile ( "rep; insw" : "+D" ( addr ) , "+c" ( count ) : "d" ( port ) ) ;
}
# 311 "./arch/x86/include/asm/io.h"
static inline void outl(unsigned int value, int port)
{
# 311 "./arch/x86/include/asm/io.h"
  asm volatile ( "outl %0, %w1" : : "a" ( value ) , "Nd" ( port ) ) ;
}
# 311 "./arch/x86/include/asm/io.h"
static inline unsigned int inl(int port)
{
# 311 "./arch/x86/include/asm/io.h"
  unsigned int value;
# 311 "./arch/x86/include/asm/io.h"
  asm volatile ( "inl %w1, %0" : "=a" ( value ) : "Nd" ( port ) ) ;
# 311 "./arch/x86/include/asm/io.h"
  return value;
}
# 311 "./arch/x86/include/asm/io.h"
static inline void outl_p(unsigned int value, int port)
{
# 311 "./arch/x86/include/asm/io.h"
  outl ( value , port );
# 311 "./arch/x86/include/asm/io.h"
  slow_down_io ( );
}
# 311 "./arch/x86/include/asm/io.h"
static inline unsigned int inl_p(int port)
{
# 311 "./arch/x86/include/asm/io.h"
  unsigned int value = inl ( port );
# 311 "./arch/x86/include/asm/io.h"
  slow_down_io ( );
# 311 "./arch/x86/include/asm/io.h"
  return value;
}
# 311 "./arch/x86/include/asm/io.h"
static inline void outsl(int port, void const *addr, long unsigned int count)
{
# 311 "./arch/x86/include/asm/io.h"
  asm volatile ( "rep; outsl" : "+S" ( addr ) , "+c" ( count ) : "d" ( port ) ) ;
}
# 311 "./arch/x86/include/asm/io.h"
static inline void insl(int port, void *addr, long unsigned int count)
{
# 311 "./arch/x86/include/asm/io.h"
  asm volatile ( "rep; insl" : "+D" ( addr ) , "+c" ( count ) : "d" ( port ) ) ;
}
void *xlate_dev_mem_ptr(long unsigned int);
void unxlate_dev_mem_ptr(long unsigned int, void *);
# 316 "./arch/x86/include/asm/io.h"
int ioremap_change_attr(long unsigned int, long unsigned int, long unsigned int);
# 318 "./arch/x86/include/asm/io.h"
void *ioremap_wc(resource_size_t, long unsigned int);
# 320 "./arch/x86/include/asm/io.h"
bool is_early_ioremap_ptep(pte_t *);
enum xen_domain_type
{
  XEN_NATIVE = 0,
  XEN_PV_DOMAIN = 1,
  XEN_HVM_DOMAIN = 2
};
# 11 "include/xen/xen.h"
extern enum xen_domain_type xen_domain_type;
# 53 "./arch/x86/include/asm/xen/interface.h"
typedef long unsigned int xen_pfn_t;
# 55 "./arch/x86/include/asm/xen/interface.h"
typedef long unsigned int xen_ulong_t;
# 57 "./arch/x86/include/asm/xen/interface.h"
typedef long int xen_long_t;
# 61 "./arch/x86/include/asm/xen/interface.h"
typedef unsigned char *__guest_handle_uchar;
typedef unsigned int *__guest_handle_uint;
typedef char *__guest_handle_char;
typedef int *__guest_handle_int;
typedef void *__guest_handle_void;
typedef uint64_t *__guest_handle_uint64_t;
typedef uint32_t *__guest_handle_uint32_t;
typedef xen_pfn_t *__guest_handle_xen_pfn_t;
typedef xen_ulong_t *__guest_handle_xen_ulong_t;
struct trap_info
{
# 113 "./arch/x86/include/asm/xen/interface.h"
  uint8_t vector;
  uint8_t flags;
  uint16_t cs;
  long unsigned int address;
};
typedef struct trap_info *__guest_handle_trap_info;
struct arch_shared_info
{
  long unsigned int max_pfn;
# 123 "./arch/x86/include/asm/xen/interface.h"
  long unsigned int pfn_to_mfn_frame_list_list;
  long unsigned int nmi_reason;
};
struct iret_context
{
# 83 "./arch/x86/include/asm/xen/interface_64.h"
  uint64_t rax;
# 83 "./arch/x86/include/asm/xen/interface_64.h"
  uint64_t r11;
# 83 "./arch/x86/include/asm/xen/interface_64.h"
  uint64_t rcx;
# 83 "./arch/x86/include/asm/xen/interface_64.h"
  uint64_t flags;
# 83 "./arch/x86/include/asm/xen/interface_64.h"
  uint64_t rip;
# 83 "./arch/x86/include/asm/xen/interface_64.h"
  uint64_t cs;
# 83 "./arch/x86/include/asm/xen/interface_64.h"
  uint64_t rflags;
# 83 "./arch/x86/include/asm/xen/interface_64.h"
  uint64_t rsp;
# 83 "./arch/x86/include/asm/xen/interface_64.h"
  uint64_t ss;
};
struct cpu_user_regs
{
# 99 "./arch/x86/include/asm/xen/interface_64.h"
  uint64_t r15;
  uint64_t r14;
  uint64_t r13;
  uint64_t r12;
  union
  {
# 103 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t rbp;
# 103 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t ebp;
# 103 "./arch/x86/include/asm/xen/interface_64.h"
    uint32_t _ebp;
  } ldv_11337;
# 104 "./arch/x86/include/asm/xen/interface_64.h"
  union
  {
# 104 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t rbx;
# 104 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t ebx;
# 104 "./arch/x86/include/asm/xen/interface_64.h"
    uint32_t _ebx;
  } ldv_11342;
# 105 "./arch/x86/include/asm/xen/interface_64.h"
  uint64_t r11;
  uint64_t r10;
  uint64_t r9;
  uint64_t r8;
  union
  {
# 109 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t rax;
# 109 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t eax;
# 109 "./arch/x86/include/asm/xen/interface_64.h"
    uint32_t _eax;
  } ldv_11351;
# 110 "./arch/x86/include/asm/xen/interface_64.h"
  union
  {
# 110 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t rcx;
# 110 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t ecx;
# 110 "./arch/x86/include/asm/xen/interface_64.h"
    uint32_t _ecx;
  } ldv_11356;
# 111 "./arch/x86/include/asm/xen/interface_64.h"
  union
  {
# 111 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t rdx;
# 111 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t edx;
# 111 "./arch/x86/include/asm/xen/interface_64.h"
    uint32_t _edx;
  } ldv_11361;
# 112 "./arch/x86/include/asm/xen/interface_64.h"
  union
  {
# 112 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t rsi;
# 112 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t esi;
# 112 "./arch/x86/include/asm/xen/interface_64.h"
    uint32_t _esi;
  } ldv_11366;
# 113 "./arch/x86/include/asm/xen/interface_64.h"
  union
  {
# 113 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t rdi;
# 113 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t edi;
# 113 "./arch/x86/include/asm/xen/interface_64.h"
    uint32_t _edi;
  } ldv_11371;
# 114 "./arch/x86/include/asm/xen/interface_64.h"
  uint32_t error_code;
  uint32_t entry_vector;
  union
  {
# 116 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t rip;
# 116 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t eip;
# 116 "./arch/x86/include/asm/xen/interface_64.h"
    uint32_t _eip;
  } ldv_11378;
# 117 "./arch/x86/include/asm/xen/interface_64.h"
  uint16_t cs;
# 117 "./arch/x86/include/asm/xen/interface_64.h"
  uint16_t _pad0[1U];
  uint8_t saved_upcall_mask;
  uint8_t _pad1[3U];
  union
  {
# 120 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t rflags;
# 120 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t eflags;
# 120 "./arch/x86/include/asm/xen/interface_64.h"
    uint32_t _eflags;
  } ldv_11387;
# 121 "./arch/x86/include/asm/xen/interface_64.h"
  union
  {
# 121 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t rsp;
# 121 "./arch/x86/include/asm/xen/interface_64.h"
    uint64_t esp;
# 121 "./arch/x86/include/asm/xen/interface_64.h"
    uint32_t _esp;
  } ldv_11392;
# 122 "./arch/x86/include/asm/xen/interface_64.h"
  uint16_t ss;
# 122 "./arch/x86/include/asm/xen/interface_64.h"
  uint16_t _pad2[3U];
  uint16_t es;
# 123 "./arch/x86/include/asm/xen/interface_64.h"
  uint16_t _pad3[3U];
  uint16_t ds;
# 124 "./arch/x86/include/asm/xen/interface_64.h"
  uint16_t _pad4[3U];
  uint16_t fs;
# 125 "./arch/x86/include/asm/xen/interface_64.h"
  uint16_t _pad5[3U];
  uint16_t gs;
# 126 "./arch/x86/include/asm/xen/interface_64.h"
  uint16_t _pad6[3U];
};
typedef struct cpu_user_regs *__guest_handle_cpu_user_regs;
struct arch_vcpu_info
{
# 136 "./arch/x86/include/asm/xen/interface_64.h"
  long unsigned int cr2;
  long unsigned int pad;
};
# 140 "./arch/x86/include/asm/xen/interface_64.h"
typedef long unsigned int xen_callback_t;
struct pvclock_vcpu_time_info
{
# 26 "./arch/x86/include/asm/pvclock-abi.h"
  u32 version;
  u32 pad0;
  u64 tsc_timestamp;
  u64 system_time;
  u32 tsc_to_system_mul;
  s8 tsc_shift;
  u8 flags;
  u8 pad[2U];
};
struct pvclock_wall_clock
{
  u32 version;
  u32 sec;
  u32 nsec;
};
struct vcpu_guest_context
{
# 143 "./arch/x86/include/asm/xen/interface.h"
  struct
  {
# 143 "./arch/x86/include/asm/xen/interface.h"
    char x[512U];
  } fpu_ctxt;
# 147 "./arch/x86/include/asm/xen/interface.h"
  long unsigned int flags;
  struct cpu_user_regs user_regs;
  struct trap_info trap_ctxt[256U];
  long unsigned int ldt_base;
# 150 "./arch/x86/include/asm/xen/interface.h"
  long unsigned int ldt_ents;
  long unsigned int gdt_frames[16U];
# 151 "./arch/x86/include/asm/xen/interface.h"
  long unsigned int gdt_ents;
  long unsigned int kernel_ss;
# 152 "./arch/x86/include/asm/xen/interface.h"
  long unsigned int kernel_sp;
# 154 "./arch/x86/include/asm/xen/interface.h"
  long unsigned int ctrlreg[8U];
  long unsigned int debugreg[8U];
# 162 "./arch/x86/include/asm/xen/interface.h"
  long unsigned int event_callback_eip;
  long unsigned int failsafe_callback_eip;
  long unsigned int syscall_callback_eip;
# 166 "./arch/x86/include/asm/xen/interface.h"
  long unsigned int vm_assist;
# 169 "./arch/x86/include/asm/xen/interface.h"
  uint64_t fs_base;
  uint64_t gs_base_kernel;
  uint64_t gs_base_user;
};
# 174 "./arch/x86/include/asm/xen/interface.h"
typedef struct vcpu_guest_context *__guest_handle_vcpu_guest_context;
struct mmuext_op
{
# 189 "include/xen/interface/xen.h"
  unsigned int cmd;
# 195 "include/xen/interface/xen.h"
  union
  {
# 192 "include/xen/interface/xen.h"
    xen_pfn_t mfn;
# 194 "include/xen/interface/xen.h"
    long unsigned int linear_addr;
  } arg1;
# 201 "include/xen/interface/xen.h"
  union
  {
# 198 "include/xen/interface/xen.h"
    unsigned int nr_ents;
# 200 "include/xen/interface/xen.h"
    void *vcpumask;
  } arg2;
};
typedef struct mmuext_op *__guest_handle_mmuext_op;
# 236 "include/xen/interface/xen.h"
typedef uint16_t domid_t;
struct mmu_update
{
# 268 "include/xen/interface/xen.h"
  uint64_t ptr;
  uint64_t val;
};
typedef struct mmu_update *__guest_handle_mmu_update;
struct multicall_entry
{
# 278 "include/xen/interface/xen.h"
  xen_ulong_t op;
  xen_long_t result;
  xen_ulong_t args[6U];
};
typedef struct multicall_entry *__guest_handle_multicall_entry;
struct vcpu_time_info
{
# 295 "include/xen/interface/xen.h"
  uint32_t version;
  uint32_t pad0;
  uint64_t tsc_timestamp;
  uint64_t system_time;
# 305 "include/xen/interface/xen.h"
  uint32_t tsc_to_system_mul;
  int8_t tsc_shift;
  int8_t pad1[3U];
};
struct vcpu_info
{
# 336 "include/xen/interface/xen.h"
  uint8_t evtchn_upcall_pending;
  uint8_t evtchn_upcall_mask;
  xen_ulong_t evtchn_pending_sel;
  struct arch_vcpu_info arch;
  struct pvclock_vcpu_time_info time;
};
struct shared_info
{
# 348 "include/xen/interface/xen.h"
  struct vcpu_info vcpu_info[32U];
# 381 "include/xen/interface/xen.h"
  xen_ulong_t evtchn_pending[64U];
  xen_ulong_t evtchn_mask[64U];
# 388 "include/xen/interface/xen.h"
  struct pvclock_wall_clock wc;
# 390 "include/xen/interface/xen.h"
  struct arch_shared_info arch;
};
struct start_info
{
# 422 "include/xen/interface/xen.h"
  char magic[32U];
  long unsigned int nr_pages;
  long unsigned int shared_info;
  uint32_t flags;
  xen_pfn_t store_mfn;
  uint32_t store_evtchn;
# 437 "include/xen/interface/xen.h"
  union
  {
# 432 "include/xen/interface/xen.h"
    struct
    {
# 430 "include/xen/interface/xen.h"
      xen_pfn_t mfn;
      uint32_t evtchn;
    } domU;
# 436 "include/xen/interface/xen.h"
    struct
    {
# 434 "include/xen/interface/xen.h"
      uint32_t info_off;
      uint32_t info_size;
    } dom0;
  } console;
# 439 "include/xen/interface/xen.h"
  long unsigned int pt_base;
  long unsigned int nr_pt_frames;
  long unsigned int mfn_list;
  long unsigned int mod_start;
  long unsigned int mod_len;
  int8_t cmd_line[1024U];
};
struct dom0_vga_console_info
{
  uint8_t video_type;
# 484 "include/xen/interface/xen.h"
  union
  {
# 461 "include/xen/interface/xen.h"
    struct
    {
# 456 "include/xen/interface/xen.h"
      uint16_t font_height;
# 458 "include/xen/interface/xen.h"
      uint16_t cursor_x;
# 458 "include/xen/interface/xen.h"
      uint16_t cursor_y;
# 460 "include/xen/interface/xen.h"
      uint16_t rows;
# 460 "include/xen/interface/xen.h"
      uint16_t columns;
    } text_mode_3;
# 483 "include/xen/interface/xen.h"
    struct
    {
# 465 "include/xen/interface/xen.h"
      uint16_t width;
# 465 "include/xen/interface/xen.h"
      uint16_t height;
# 467 "include/xen/interface/xen.h"
      uint16_t bytes_per_line;
# 469 "include/xen/interface/xen.h"
      uint16_t bits_per_pixel;
# 471 "include/xen/interface/xen.h"
      uint32_t lfb_base;
      uint32_t lfb_size;
# 474 "include/xen/interface/xen.h"
      uint8_t red_pos;
# 474 "include/xen/interface/xen.h"
      uint8_t red_size;
      uint8_t green_pos;
# 475 "include/xen/interface/xen.h"
      uint8_t green_size;
      uint8_t blue_pos;
# 476 "include/xen/interface/xen.h"
      uint8_t blue_size;
      uint8_t rsvd_pos;
# 477 "include/xen/interface/xen.h"
      uint8_t rsvd_size;
# 480 "include/xen/interface/xen.h"
      uint32_t gbl_caps;
# 482 "include/xen/interface/xen.h"
      uint16_t mode_attrs;
    } vesa_lfb;
  } u;
};
# 492 "include/xen/interface/xen.h"
typedef uint64_t cpumap_t;
# 494 "include/xen/interface/xen.h"
typedef uint8_t xen_domain_handle_t[16U];
struct tmem_op
{
# 503 "include/xen/interface/xen.h"
  uint32_t cmd;
  int32_t pool_id;
# 518 "include/xen/interface/xen.h"
  union
  {
# 509 "include/xen/interface/xen.h"
    struct
    {
# 507 "include/xen/interface/xen.h"
      uint64_t uuid[2U];
      uint32_t flags;
    } new;
# 517 "include/xen/interface/xen.h"
    struct
    {
# 511 "include/xen/interface/xen.h"
      uint64_t oid[3U];
      uint32_t index;
      uint32_t tmem_offset;
      uint32_t pfn_offset;
      uint32_t len;
      __guest_handle_void gmfn;
    } gen;
  } u;
};
# 521 "include/xen/interface/xen.h"
typedef u64 *__guest_handle_u64;
# 36 "./arch/x86/include/asm/xen/hypervisor.h"
extern struct shared_info *HYPERVISOR_shared_info;
extern struct start_info *xen_start_info;
# 41 "./arch/x86/include/asm/xen/hypervisor.h"
static inline uint32_t xen_cpuid_base(void)
{
  return hypervisor_cpuid_base ( ( char const *) "XenVMMXenVMM" , 2U );
}
# 47 "./arch/x86/include/asm/xen/hypervisor.h"
bool xen_hvm_need_lapic(void);
# 49 "./arch/x86/include/asm/xen/hypervisor.h"
static inline bool xen_x2apic_para_available(void)
{
  return xen_hvm_need_lapic ( );
}
# 14 "include/xen/features.h"
void xen_setup_features(void);
# 16 "include/xen/features.h"
extern u8 xen_features[32U];
# 18 "include/xen/features.h"
static inline int xen_feature(int flag)
{
  return ( int ) xen_features [ flag ];
}
struct bio_vec;
# 326 "./arch/x86/include/asm/io.h"
bool xen_biovec_phys_mergeable(struct bio_vec const *, struct bio_vec const *);
# 337 "./arch/x86/include/asm/io.h"
int arch_phys_wc_add(long unsigned int, long unsigned int);
# 339 "./arch/x86/include/asm/io.h"
void arch_phys_wc_del(int);
struct real_mode_header
{
# 9 "./arch/x86/include/asm/realmode.h"
  u32 text_start;
  u32 ro_end;
# 12 "./arch/x86/include/asm/realmode.h"
  u32 trampoline_start;
  u32 trampoline_status;
  u32 trampoline_header;
# 16 "./arch/x86/include/asm/realmode.h"
  u32 trampoline_pgd;
# 20 "./arch/x86/include/asm/realmode.h"
  u32 wakeup_start;
  u32 wakeup_header;
# 24 "./arch/x86/include/asm/realmode.h"
  u32 machine_real_restart_asm;
# 26 "./arch/x86/include/asm/realmode.h"
  u32 machine_real_restart_seg;
};
struct trampoline_header
{
# 38 "./arch/x86/include/asm/realmode.h"
  u64 start;
  u64 efer;
  u32 cr4;
};
# 44 "./arch/x86/include/asm/realmode.h"
extern struct real_mode_header *real_mode_header;
extern unsigned char real_mode_blob_end[];
# 47 "./arch/x86/include/asm/realmode.h"
extern long unsigned int init_rsp;
extern long unsigned int initial_code;
extern long unsigned int initial_gs;
# 51 "./arch/x86/include/asm/realmode.h"
extern unsigned char real_mode_blob[];
extern unsigned char real_mode_relocs[];
# 58 "./arch/x86/include/asm/realmode.h"
extern unsigned char secondary_startup_64[];
# 61 "./arch/x86/include/asm/realmode.h"
void reserve_real_mode(void);
void setup_real_mode(void);
# 36 "./arch/x86/include/asm/acpi.h"
extern int acpi_lapic;
extern int acpi_ioapic;
extern int acpi_noirq;
extern int acpi_strict;
extern int acpi_disabled;
extern int acpi_pci_disabled;
extern int acpi_skip_timer_override;
extern int acpi_use_timer_override;
extern int acpi_fix_pin2_polarity;
extern int acpi_disable_cmcff;
# 47 "./arch/x86/include/asm/acpi.h"
extern u8 acpi_sci_flags;
extern int acpi_sci_override_gsi;
void acpi_pic_sci_set_trigger(unsigned int, u16);
# 51 "./arch/x86/include/asm/acpi.h"
extern int (*__acpi_register_gsi)(struct device *, u32, int, int);
# 54 "./arch/x86/include/asm/acpi.h"
static inline void disable_acpi(void)
{
  acpi_disabled = 1;
  acpi_pci_disabled = 1;
  acpi_noirq = 1;
}
# 61 "./arch/x86/include/asm/acpi.h"
int acpi_gsi_to_irq(u32, unsigned int *);
# 63 "./arch/x86/include/asm/acpi.h"
static inline void acpi_noirq_set(void)
{
# 63 "./arch/x86/include/asm/acpi.h"
  acpi_noirq = 1;
}
# 64 "./arch/x86/include/asm/acpi.h"
static inline void acpi_disable_pci(void)
{
  acpi_pci_disabled = 1;
  acpi_noirq_set ( );
}
# 71 "./arch/x86/include/asm/acpi.h"
extern int (*acpi_suspend_lowlevel)(void);
# 79 "./arch/x86/include/asm/acpi.h"
static inline unsigned int acpi_processor_cstate_check(unsigned int max_cstate)
{
# 87 "./arch/x86/include/asm/acpi.h"
  if (( unsigned char ) boot_cpu_data . x86 == 15U &&
# 88 "./arch/x86/include/asm/acpi.h"
  ( unsigned char ) boot_cpu_data . x86_vendor == 2U &&
# 89 "./arch/x86/include/asm/acpi.h"
  ( unsigned char ) boot_cpu_data . x86_model <= 5U &&
# 90 "./arch/x86/include/asm/acpi.h"
  ( unsigned char ) boot_cpu_data . x86_mask <= 9U)
  {
# 91 "./arch/x86/include/asm/acpi.h"
    return 1U;
  }
  else
# 92 "./arch/x86/include/asm/acpi.h"
    if (( int ) amd_e400_c1e_detected)
    {
# 93 "./arch/x86/include/asm/acpi.h"
      return 1U;
    }
    else
# 95 "./arch/x86/include/asm/acpi.h"
      return max_cstate;
}
# 98 "./arch/x86/include/asm/acpi.h"
static inline bool arch_has_acpi_pdc(void)
{
  struct cpuinfo_x86 *c = ({
    {
# 100 "./arch/x86/include/asm/acpi.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 100 "./arch/x86/include/asm/acpi.h"
      ( void ) __vpp_verify;
    }
# 100 "./arch/x86/include/asm/acpi.h"
    ({
# 100 "./arch/x86/include/asm/acpi.h"
      long unsigned int __ptr;
# 100 "./arch/x86/include/asm/acpi.h"
      asm ( "" : "=r" ( __ptr ) : "0" ( & cpu_info ) ) ;
# 100 "./arch/x86/include/asm/acpi.h"
      ( struct cpuinfo_x86 *) ( __per_cpu_offset [ 0 ] + __ptr );
    } );
  } );
# 101 "./arch/x86/include/asm/acpi.h"
  return ( bool ) ( ( unsigned char ) ( * c ) . x86_vendor == 0U ||
# 102 "./arch/x86/include/asm/acpi.h"
  ( unsigned char ) ( * c ) . x86_vendor == 5U );
}
# 105 "./arch/x86/include/asm/acpi.h"
static inline void arch_acpi_set_pdc_bits(u32 *buf)
{
  struct cpuinfo_x86 *c = ({
    {
# 107 "./arch/x86/include/asm/acpi.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 107 "./arch/x86/include/asm/acpi.h"
      ( void ) __vpp_verify;
    }
# 107 "./arch/x86/include/asm/acpi.h"
    ({
# 107 "./arch/x86/include/asm/acpi.h"
      long unsigned int __ptr;
# 107 "./arch/x86/include/asm/acpi.h"
      asm ( "" : "=r" ( __ptr ) : "0" ( & cpu_info ) ) ;
# 107 "./arch/x86/include/asm/acpi.h"
      ( struct cpuinfo_x86 *) ( __per_cpu_offset [ 0 ] + __ptr );
    } );
  } );
# 109 "./arch/x86/include/asm/acpi.h"
  * ( buf + 2UL ) |= 794U;
# 111 "./arch/x86/include/asm/acpi.h"
  if (constant_test_bit ( 135L , ( long unsigned int const volatile *) & ( * c ) . x86_capability ) != 0)
    * ( buf + 2UL ) |= 2091U;
# 114 "./arch/x86/include/asm/acpi.h"
  if (constant_test_bit ( 22L , ( long unsigned int const volatile *) & ( * c ) . x86_capability ) != 0)
    * ( buf + 2UL ) |= 4U;
# 120 "./arch/x86/include/asm/acpi.h"
  if (constant_test_bit ( 131L , ( long unsigned int const volatile *) & ( * c ) . x86_capability ) == 0)
    * ( buf + 2UL ) &= 4294966783U;
}
# 124 "./arch/x86/include/asm/acpi.h"
static inline bool acpi_has_cpu_in_madt(void)
{
  return acpi_lapic != 0;
}
# 143 "./arch/x86/include/asm/acpi.h"
extern int acpi_numa;
int x86_acpi_numa_init(void);
# 22 "include/linux/clocksource.h"
typedef u64 cycle_t;
struct clocksource;
struct arch_clocksource_data
{
# 12 "./arch/x86/include/asm/clocksource.h"
  int vclock_mode;
};
struct cyclecounter
{
# 45 "include/linux/clocksource.h"
  cycle_t (*read)(struct cyclecounter const *);
  cycle_t mask;
  u32 mult;
  u32 shift;
};
struct timecounter
{
# 68 "include/linux/clocksource.h"
  struct cyclecounter const *cc;
  cycle_t cycle_last;
  u64 nsec;
};
# 81 "include/linux/clocksource.h"
static inline u64 cyclecounter_cyc2ns(struct cyclecounter const *cc, cycle_t cycles)
{
# 84 "include/linux/clocksource.h"
  u64 ret = cycles;
  ret = ( u64 ) ( * cc ) . mult * ret >> ( int ) ( * cc ) . shift;
  return ret;
}
# 99 "include/linux/clocksource.h"
void timecounter_init(struct timecounter *, struct cyclecounter const *, u64);
# 111 "include/linux/clocksource.h"
u64 timecounter_read(struct timecounter *);
# 127 "include/linux/clocksource.h"
u64 timecounter_cyc2time(struct timecounter *, cycle_t);
struct clocksource
{
# 172 "include/linux/clocksource.h"
  cycle_t (*read)(struct clocksource *);
  cycle_t mask;
  u32 mult;
  u32 shift;
  u64 max_idle_ns;
  u32 maxadj;
# 179 "include/linux/clocksource.h"
  struct arch_clocksource_data archdata;
# 182 "include/linux/clocksource.h"
  char const *name;
  struct list_head list;
  int rating;
  int (*enable)(struct clocksource *);
  void (*disable)(struct clocksource *);
  long unsigned int flags;
  void (*suspend)(struct clocksource *);
  void (*resume)(struct clocksource *);
# 194 "include/linux/clocksource.h"
  struct list_head wd_list;
  cycle_t cs_last;
  cycle_t wd_last;
# 198 "include/linux/clocksource.h"
  struct module *owner;
};
# 224 "include/linux/clocksource.h"
static inline u32 clocksource_khz2mult(u32 khz, u32 shift_constant)
{
# 233 "include/linux/clocksource.h"
  u64 tmp = 1000000ULL << ( int ) shift_constant;
# 235 "include/linux/clocksource.h"
  tmp = ( u64 ) ( khz / 2U ) + tmp;
  ({
# 236 "include/linux/clocksource.h"
    uint32_t __base = khz;
# 236 "include/linux/clocksource.h"
    uint32_t __rem;
# 236 "include/linux/clocksource.h"
    __rem = ( uint32_t ) ( tmp % ( u64 ) __base );
# 236 "include/linux/clocksource.h"
    tmp /= ( u64 ) __base;
# 236 "include/linux/clocksource.h"
    __rem;
  } );
  return ( u32 ) tmp;
}
# 250 "include/linux/clocksource.h"
static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
{
# 259 "include/linux/clocksource.h"
  u64 tmp = 1000000000ULL << ( int ) shift_constant;
# 261 "include/linux/clocksource.h"
  tmp = ( u64 ) ( hz / 2U ) + tmp;
  ({
# 262 "include/linux/clocksource.h"
    uint32_t __base = hz;
# 262 "include/linux/clocksource.h"
    uint32_t __rem;
# 262 "include/linux/clocksource.h"
    __rem = ( uint32_t ) ( tmp % ( u64 ) __base );
# 262 "include/linux/clocksource.h"
    tmp /= ( u64 ) __base;
# 262 "include/linux/clocksource.h"
    __rem;
  } );
  return ( u32 ) tmp;
}
# 277 "include/linux/clocksource.h"
static inline s64 clocksource_cyc2ns(cycle_t cycles, u32 mult, u32 shift)
{
  return ( s64 ) ( ( cycle_t ) mult * cycles >> ( int ) shift );
}
# 283 "include/linux/clocksource.h"
int clocksource_register(struct clocksource *);
int clocksource_unregister(struct clocksource *);
void clocksource_touch_watchdog(void);
struct clocksource *clocksource_get_next(void);
void clocksource_change_rating(struct clocksource *, int);
void clocksource_suspend(void);
void clocksource_resume(void);
struct clocksource *clocksource_default_clock(void);
void clocksource_mark_unstable(struct clocksource *);
# 294 "include/linux/clocksource.h"
u64 clocks_calc_max_nsecs(u32, u32, u32, u64);
# 296 "include/linux/clocksource.h"
void clocks_calc_mult_shift(u32 *, u32 *, u32, u32, u32);
# 303 "include/linux/clocksource.h"
int __clocksource_register_scale(struct clocksource *, u32, u32);
# 305 "include/linux/clocksource.h"
void __clocksource_updatefreq_scale(struct clocksource *, u32, u32);
# 307 "include/linux/clocksource.h"
static inline int clocksource_register_hz(struct clocksource *cs, u32 hz)
{
  return __clocksource_register_scale ( cs , 1U , hz );
}
# 312 "include/linux/clocksource.h"
static inline int clocksource_register_khz(struct clocksource *cs, u32 khz)
{
  return __clocksource_register_scale ( cs , 1000U , khz );
}
# 317 "include/linux/clocksource.h"
static inline void __clocksource_updatefreq_hz(struct clocksource *cs, u32 hz)
{
  __clocksource_updatefreq_scale ( cs , 1U , hz );
}
# 322 "include/linux/clocksource.h"
static inline void __clocksource_updatefreq_khz(struct clocksource *cs, u32 khz)
{
  __clocksource_updatefreq_scale ( cs , 1000U , khz );
}
# 328 "include/linux/clocksource.h"
int timekeeping_notify(struct clocksource *);
# 330 "include/linux/clocksource.h"
cycle_t clocksource_mmio_readl_up(struct clocksource *);
cycle_t clocksource_mmio_readl_down(struct clocksource *);
cycle_t clocksource_mmio_readw_up(struct clocksource *);
cycle_t clocksource_mmio_readw_down(struct clocksource *);
# 335 "include/linux/clocksource.h"
int clocksource_mmio_init(void *, char const *, long unsigned int, int, unsigned int, cycle_t (*)(struct clocksource *));
# 338 "include/linux/clocksource.h"
int clocksource_i8253_init(void);
# 346 "include/linux/clocksource.h"
static inline void clocksource_of_init(void)
{
}
# 8 "./arch/x86/include/asm/pvclock.h"
cycle_t pvclock_clocksource_read(struct pvclock_vcpu_time_info *);
u8 pvclock_read_flags(struct pvclock_vcpu_time_info *);
void pvclock_set_flags(u8);
long unsigned int pvclock_tsc_khz(struct pvclock_vcpu_time_info *);
void pvclock_read_wallclock(struct pvclock_wall_clock *, struct pvclock_vcpu_time_info *, struct timespec *);
# 15 "./arch/x86/include/asm/pvclock.h"
void pvclock_resume(void);
# 17 "./arch/x86/include/asm/pvclock.h"
void pvclock_touch_watchdogs(void);
# 23 "./arch/x86/include/asm/pvclock.h"
static inline u64 pvclock_scale_delta(u64 delta, u32 mul_frac, int shift)
{
  u64 product;
# 29 "./arch/x86/include/asm/pvclock.h"
  ulong tmp;
# 32 "./arch/x86/include/asm/pvclock.h"
  if (shift < 0)
  {
# 33 "./arch/x86/include/asm/pvclock.h"
    delta >>= - shift;
  }
  else
# 35 "./arch/x86/include/asm/pvclock.h"
    delta <<= shift;
# 49 "./arch/x86/include/asm/pvclock.h"
  asm ( "mulq %3 ; shrd $32, %1, %0" : [ lo ] "=a" ( product ) , [ hi ] "=d" ( tmp ) : "0" ( delta ) , [ mul_frac ] "rm" (
# 54 "./arch/x86/include/asm/pvclock.h"
  ( long long unsigned int ) mul_frac ) ) ;
# 59 "./arch/x86/include/asm/pvclock.h"
  return product;
}
# 63 "./arch/x86/include/asm/pvclock.h"
static inline u64 pvclock_get_nsec_offset(struct pvclock_vcpu_time_info const *src)
{
  u64 delta = __native_read_tsc ( ) - ( long long unsigned int ) ( * src ) . tsc_timestamp;
  return pvclock_scale_delta ( delta , ( * src ) . tsc_to_system_mul , ( int ) (
# 67 "./arch/x86/include/asm/pvclock.h"
  * src ) . tsc_shift );
}
# 71 "./arch/x86/include/asm/pvclock.h"
static inline unsigned int __pvclock_read_cycles(struct pvclock_vcpu_time_info const *src, cycle_t *cycles, u8 *flags)
{
# 74 "./arch/x86/include/asm/pvclock.h"
  unsigned int version;
  cycle_t ret;
# 75 "./arch/x86/include/asm/pvclock.h"
  cycle_t offset;
  u8 ret_flags;
# 78 "./arch/x86/include/asm/pvclock.h"
  version = ( * src ) . version;
# 85 "./arch/x86/include/asm/pvclock.h"
  rdtsc_barrier ( );
  offset = pvclock_get_nsec_offset ( src );
  ret = ( long long unsigned int ) ( * src ) . system_time + ( long long unsigned int ) offset;
  ret_flags = ( * src ) . flags;
  rdtsc_barrier ( );
# 91 "./arch/x86/include/asm/pvclock.h"
  * cycles = ret;
  * flags = ret_flags;
  return version;
}
struct pvclock_vsyscall_time_info
{
  struct pvclock_vcpu_time_info pvti;
};
# 103 "./arch/x86/include/asm/pvclock.h"
int pvclock_init_vsyscall(struct pvclock_vsyscall_time_info *, int);
# 105 "./arch/x86/include/asm/pvclock.h"
struct pvclock_vcpu_time_info *pvclock_get_vsyscall_time_info(int);
enum vsyscall_num
{
  __NR_vgettimeofday = 0,
  __NR_vtime = 1,
  __NR_vgetcpu = 2
};
enum fixed_addresses
{
  VSYSCALL_PAGE = 511,
  PVCLOCK_FIXMAP_BEGIN = 512,
  PVCLOCK_FIXMAP_END = 639,
  FIX_DBGP_BASE = 640,
  FIX_EARLYCON_MEM_BASE = 641,
  FIX_OHCI1394_BASE = 642,
  FIX_APIC_BASE = 643,
  FIX_IO_APIC_BASE_0 = 644,
  FIX_IO_APIC_BASE_END = 771,
  FIX_RO_IDT = 772,
  FIX_PARAVIRT_BOOTMAP = 773,
  FIX_TEXT_POKE1 = 774,
  FIX_TEXT_POKE0 = 775,
  __end_of_permanent_fixed_addresses = 776,
  FIX_BTMAP_END = 1024,
  FIX_BTMAP_BEGIN = 1279,
  FIX_TBOOT_BASE = 1280,
  __end_of_fixed_addresses = 1281
};
# 136 "./arch/x86/include/asm/fixmap.h"
void reserve_top_address(long unsigned int);
# 143 "./arch/x86/include/asm/fixmap.h"
extern int fixmaps_set;
# 145 "./arch/x86/include/asm/fixmap.h"
extern pte_t *kmap_pte;
extern pgprot_t kmap_prot;
extern pte_t *pkmap_page_table;
# 149 "./arch/x86/include/asm/fixmap.h"
void __native_set_fixmap(enum fixed_addresses, pte_t);
void native_set_fixmap(enum fixed_addresses, phys_addr_t, pgprot_t);
# 29 "include/asm-generic/fixmap.h"
static inline long unsigned int fix_to_virt(unsigned int const idx)
{
# 32 "include/asm-generic/fixmap.h"
  return 18446744073701158912UL - ( long unsigned int ) ( idx << 12 );
}
# 35 "include/asm-generic/fixmap.h"
static inline long unsigned int virt_to_fix(long unsigned int const vaddr)
{
  if (__builtin_expect ( ( long unsigned int ) vaddr > 18446744073701158911UL , 0L ) != 0L || __builtin_expect ( ( long unsigned int ) vaddr <= 18446744073697980415UL , 0L ) != 0L)
  {
# 37 "include/asm-generic/fixmap.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/asm-generic/fixmap.h" ) , "i" ( 37 ) , "i" ( 12UL ) ) ;
    ldv_11903:;
# 37 "include/asm-generic/fixmap.h"
    goto ldv_11903;
  }
# 38 "include/asm-generic/fixmap.h"
  return 18446744073701158912UL - ( ( long unsigned int ) vaddr & 18446744073709547520UL ) >> 12;
}
# 166 "./arch/x86/include/asm/fixmap.h"
void __early_set_fixmap(enum fixed_addresses, phys_addr_t, pgprot_t);
# 8 "./arch/x86/include/asm/idle.h"
void idle_notifier_register(struct notifier_block *);
void idle_notifier_unregister(struct notifier_block *);
# 12 "./arch/x86/include/asm/idle.h"
void enter_idle(void);
void exit_idle(void);
# 20 "./arch/x86/include/asm/idle.h"
void amd_e400_remove_cpu(int);
# 41 "./arch/x86/include/asm/apic.h"
static inline void generic_apic_probe(void)
{
}
# 48 "./arch/x86/include/asm/apic.h"
extern unsigned int apic_verbosity;
extern int local_apic_timer_c2_ok;
# 51 "./arch/x86/include/asm/apic.h"
extern int disable_apic;
extern unsigned int lapic_timer_frequency;
# 55 "./arch/x86/include/asm/apic.h"
void __inquire_remote_apic(int);
# 62 "./arch/x86/include/asm/apic.h"
static inline void default_inquire_remote_apic(int apicid)
{
  if (apic_verbosity > 1U)
    __inquire_remote_apic ( apicid );
}
# 76 "./arch/x86/include/asm/apic.h"
static inline bool apic_from_smp_config(void)
{
  return ( bool ) ( smp_found_config != 0 && disable_apic == 0 );
}
# 88 "./arch/x86/include/asm/apic.h"
int setup_profiling_timer(unsigned int);
# 90 "./arch/x86/include/asm/apic.h"
static inline void native_apic_mem_write(u32 reg, u32 v)
{
  u32 volatile *addr = ( u32 volatile *) ( fix_to_virt ( 643U ) + ( long unsigned int ) reg );
# 94 "./arch/x86/include/asm/apic.h"
  asm volatile ( "661:\n\tmovl %0, %1\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word (11*32 + (5))\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\txchgl %0, %1\n6641:\n\t.popsection" : "=r" ( v ) , "=m" ( * addr ) : "i" ( 0 ) , "0" ( v ) , "m" ( * addr ) ) ;
}
# 99 "./arch/x86/include/asm/apic.h"
static inline u32 native_apic_mem_read(u32 reg)
{
  return ( u32 ) * ( u32 volatile *) ( fix_to_virt ( 643U ) + ( long unsigned int ) reg );
}
# 104 "./arch/x86/include/asm/apic.h"
void native_apic_wait_icr_idle(void);
u32 native_safe_apic_wait_icr_idle(void);
void native_apic_icr_write(u32, u32);
u64 native_apic_icr_read(void);
# 109 "./arch/x86/include/asm/apic.h"
extern int x2apic_mode;
# 117 "./arch/x86/include/asm/apic.h"
static inline void x2apic_wrmsr_fence(void)
{
  asm volatile ( "mfence" : : : "memory" ) ;
}
# 122 "./arch/x86/include/asm/apic.h"
static inline void native_apic_msr_write(u32 reg, u32 v)
{
  if (reg == 224U || reg == 32U || reg == 208U || reg
# 125 "./arch/x86/include/asm/apic.h"
  == 48U)
    return;
# 128 "./arch/x86/include/asm/apic.h"
  paravirt_write_msr ( ( reg >> 4 ) + 2048U , v , 0U );
}
# 131 "./arch/x86/include/asm/apic.h"
static inline void native_apic_msr_eoi_write(u32 reg, u32 v)
{
  paravirt_write_msr ( 2059U , 0U , 0U );
}
# 136 "./arch/x86/include/asm/apic.h"
static inline u32 native_apic_msr_read(u32 reg)
{
  u64 msr;
# 140 "./arch/x86/include/asm/apic.h"
  if (reg == 224U)
    return 4294967295U;
  {
    int _err;
# 143 "./arch/x86/include/asm/apic.h"
    msr = paravirt_read_msr ( ( reg >> 4 ) + 2048U , & _err );
  }
# 144 "./arch/x86/include/asm/apic.h"
  return ( u32 ) msr;
}
# 147 "./arch/x86/include/asm/apic.h"
static inline void native_x2apic_wait_icr_idle(void)
{
# 150 "./arch/x86/include/asm/apic.h"
  return;
}
# 153 "./arch/x86/include/asm/apic.h"
static inline u32 native_safe_x2apic_wait_icr_idle(void)
{
# 156 "./arch/x86/include/asm/apic.h"
  return 0U;
}
# 159 "./arch/x86/include/asm/apic.h"
static inline void native_x2apic_icr_write(u32 low, u32 id)
{
  paravirt_write_msr ( 2096U , ( unsigned int ) low , ( unsigned int ) ( ( ( long long unsigned int ) id << 32 | ( long long unsigned int ) low ) >> 32 ) );
}
# 164 "./arch/x86/include/asm/apic.h"
static inline u64 native_x2apic_icr_read(void)
{
  long unsigned int val;
  {
    int _err;
# 168 "./arch/x86/include/asm/apic.h"
    val = ( long unsigned int ) paravirt_read_msr ( 2096U , & _err );
  }
# 169 "./arch/x86/include/asm/apic.h"
  return ( u64 ) val;
}
# 172 "./arch/x86/include/asm/apic.h"
extern int x2apic_phys;
extern int x2apic_preenabled;
void check_x2apic(void);
void enable_x2apic(void);
static inline int x2apic_enabled(void)
{
  u64 msr;
# 180 "./arch/x86/include/asm/apic.h"
  if (constant_test_bit ( 149L , ( long unsigned int const volatile *) & boot_cpu_data . x86_capability ) == 0)
    return 0;
  {
    int _err;
# 183 "./arch/x86/include/asm/apic.h"
    msr = paravirt_read_msr ( 27U , & _err );
  }
# 184 "./arch/x86/include/asm/apic.h"
  if (( ( long long unsigned int ) msr & 1024ULL ) != 0ULL)
    return 1;
  return 0;
}
# 190 "./arch/x86/include/asm/apic.h"
static inline void x2apic_force_phys(void)
{
  x2apic_phys = 1;
}
# 216 "./arch/x86/include/asm/apic.h"
void enable_IR_x2apic(void);
# 218 "./arch/x86/include/asm/apic.h"
int get_physical_broadcast(void);
# 220 "./arch/x86/include/asm/apic.h"
int lapic_get_maxlvt(void);
void clear_local_APIC(void);
void connect_bsp_APIC(void);
void disconnect_bsp_APIC(int);
void disable_local_APIC(void);
void lapic_shutdown(void);
int verify_local_APIC(void);
void sync_Arb_IDs(void);
void init_bsp_APIC(void);
void setup_local_APIC(void);
void end_local_APIC_setup(void);
void bsp_end_local_APIC_setup(void);
void init_apic_mappings(void);
void register_lapic_address(long unsigned int);
void setup_boot_APIC_clock(void);
void setup_secondary_APIC_clock(void);
int APIC_init_uniprocessor(void);
int apic_force_enable(long unsigned int);
# 243 "./arch/x86/include/asm/apic.h"
int apic_is_clustered_box(void);
# 251 "./arch/x86/include/asm/apic.h"
int setup_APIC_eilvt(u8, u8, u8, u8);
struct apic
{
# 279 "./arch/x86/include/asm/apic.h"
  char *name;
# 281 "./arch/x86/include/asm/apic.h"
  int (*probe)(void);
  int (*acpi_madt_oem_check)(char *, char *);
  int (*apic_id_valid)(int);
  int (*apic_id_registered)(void);
# 286 "./arch/x86/include/asm/apic.h"
  u32 irq_delivery_mode;
  u32 irq_dest_mode;
# 289 "./arch/x86/include/asm/apic.h"
  struct cpumask const *(*target_cpus)(void);
# 291 "./arch/x86/include/asm/apic.h"
  int disable_esr;
# 293 "./arch/x86/include/asm/apic.h"
  int dest_logical;
  long unsigned int (*check_apicid_used)(physid_mask_t *, int);
# 296 "./arch/x86/include/asm/apic.h"
  void (*vector_allocation_domain)(int, struct cpumask *, struct cpumask const *);
# 298 "./arch/x86/include/asm/apic.h"
  void (*init_apic_ldr)(void);
# 300 "./arch/x86/include/asm/apic.h"
  void (*ioapic_phys_id_map)(physid_mask_t *, physid_mask_t *);
# 302 "./arch/x86/include/asm/apic.h"
  void (*setup_apic_routing)(void);
  int (*cpu_present_to_apicid)(int);
  void (*apicid_to_cpu_present)(int, physid_mask_t *);
  int (*check_phys_apicid_present)(int);
  int (*phys_pkg_id)(int, int);
# 308 "./arch/x86/include/asm/apic.h"
  unsigned int (*get_apic_id)(long unsigned int);
  long unsigned int (*set_apic_id)(unsigned int);
  long unsigned int apic_id_mask;
# 312 "./arch/x86/include/asm/apic.h"
  int (*cpu_mask_to_apicid_and)(struct cpumask const *, struct cpumask const *, unsigned int *);
# 317 "./arch/x86/include/asm/apic.h"
  void (*send_IPI_mask)(struct cpumask const *, int);
  void (*send_IPI_mask_allbutself)(struct cpumask const *, int);
# 320 "./arch/x86/include/asm/apic.h"
  void (*send_IPI_allbutself)(int);
  void (*send_IPI_all)(int);
  void (*send_IPI_self)(int);
# 325 "./arch/x86/include/asm/apic.h"
  int (*wakeup_secondary_cpu)(int, long unsigned int);
# 327 "./arch/x86/include/asm/apic.h"
  bool wait_for_init_deassert;
  void (*inquire_remote_apic)(int);
# 331 "./arch/x86/include/asm/apic.h"
  u32 (*read)(u32);
  void (*write)(u32, u32);
# 340 "./arch/x86/include/asm/apic.h"
  void (*eoi_write)(u32, u32);
  u64 (*icr_read)(void);
  void (*icr_write)(u32, u32);
  void (*wait_icr_idle)(void);
  u32 (*safe_wait_icr_idle)(void);
};
# 366 "./arch/x86/include/asm/apic.h"
extern struct apic *apic;
# 386 "./arch/x86/include/asm/apic.h"
extern struct apic *__apicdrivers[];
# 386 "./arch/x86/include/asm/apic.h"
extern struct apic *__apicdrivers_end[];
# 392 "./arch/x86/include/asm/apic.h"
extern atomic_t init_deasserted;
int wakeup_secondary_cpu_via_nmi(int, long unsigned int);
# 398 "./arch/x86/include/asm/apic.h"
static inline u32 apic_read(u32 reg)
{
  return ( * apic ) . read ( reg );
}
# 403 "./arch/x86/include/asm/apic.h"
static inline void apic_write(u32 reg, u32 val)
{
  ( * apic ) . write ( reg , val );
}
# 408 "./arch/x86/include/asm/apic.h"
static inline void apic_eoi(void)
{
  ( * apic ) . eoi_write ( 176U , 0U );
}
# 413 "./arch/x86/include/asm/apic.h"
static inline u64 apic_icr_read(void)
{
  return ( * apic ) . icr_read ( );
}
# 418 "./arch/x86/include/asm/apic.h"
static inline void apic_icr_write(u32 low, u32 high)
{
  ( * apic ) . icr_write ( low , high );
}
# 423 "./arch/x86/include/asm/apic.h"
static inline void apic_wait_icr_idle(void)
{
  ( * apic ) . wait_icr_idle ( );
}
# 428 "./arch/x86/include/asm/apic.h"
static inline u32 safe_apic_wait_icr_idle(void)
{
  return ( * apic ) . safe_wait_icr_idle ( );
}
# 433 "./arch/x86/include/asm/apic.h"
void apic_set_eoi_write(void (*)(u32, u32));
# 448 "./arch/x86/include/asm/apic.h"
static inline void ack_APIC_irq(void)
{
# 454 "./arch/x86/include/asm/apic.h"
  apic_eoi ( );
}
# 457 "./arch/x86/include/asm/apic.h"
static inline unsigned int default_get_apic_id(long unsigned int x)
{
  unsigned int ver = apic_read ( 48U ) & 255U;
# 461 "./arch/x86/include/asm/apic.h"
  if (ver > 19U || constant_test_bit ( 122L , ( long unsigned int const volatile *) & boot_cpu_data . x86_capability ) != 0)
  {
# 462 "./arch/x86/include/asm/apic.h"
    return ( unsigned int ) ( x >> 24 ) & 255U;
  }
  else
# 464 "./arch/x86/include/asm/apic.h"
    return ( unsigned int ) ( x >> 24 ) & 15U;
}
# 474 "./arch/x86/include/asm/apic.h"
void apic_send_IPI_self(int);
# 476 "./arch/x86/include/asm/apic.h"
extern char __pcpu_scope_x2apic_extra_bits;
# 476 "./arch/x86/include/asm/apic.h"
extern int x2apic_extra_bits;
# 478 "./arch/x86/include/asm/apic.h"
int default_cpu_present_to_apicid(int);
int default_check_phys_apicid_present(int);
# 482 "./arch/x86/include/asm/apic.h"
void generic_bigsmp_probe(void);
# 491 "./arch/x86/include/asm/apic.h"
static inline struct cpumask const *default_target_cpus(void)
{
# 494 "./arch/x86/include/asm/apic.h"
  return ( struct cpumask const *) cpu_online_mask;
}
# 500 "./arch/x86/include/asm/apic.h"
static inline struct cpumask const *online_target_cpus(void)
{
  return ( struct cpumask const *) cpu_online_mask;
}
# 505 "./arch/x86/include/asm/apic.h"
extern char __pcpu_scope_x86_bios_cpu_apicid;
# 505 "./arch/x86/include/asm/apic.h"
extern u16 x86_bios_cpu_apicid;
# 505 "./arch/x86/include/asm/apic.h"
extern u16 *x86_bios_cpu_apicid_early_ptr;
# 505 "./arch/x86/include/asm/apic.h"
extern u16 x86_bios_cpu_apicid_early_map[];
# 508 "./arch/x86/include/asm/apic.h"
static inline unsigned int read_apic_id(void)
{
  unsigned int reg;
# 512 "./arch/x86/include/asm/apic.h"
  reg = apic_read ( 32U );
# 514 "./arch/x86/include/asm/apic.h"
  return ( * apic ) . get_apic_id ( ( long unsigned int ) reg );
}
# 517 "./arch/x86/include/asm/apic.h"
static inline int default_apic_id_valid(int apicid)
{
  return apicid <= 254;
}
# 522 "./arch/x86/include/asm/apic.h"
int default_acpi_madt_oem_check(char *, char *);
# 524 "./arch/x86/include/asm/apic.h"
void default_setup_apic_routing(void);
# 526 "./arch/x86/include/asm/apic.h"
extern struct apic apic_noop;
# 557 "./arch/x86/include/asm/apic.h"
static inline int flat_cpu_mask_to_apicid_and(struct cpumask const *cpumask, struct cpumask const *andmask, unsigned int *apicid)
{
# 561 "./arch/x86/include/asm/apic.h"
  long unsigned int cpu_mask = ( long unsigned int ) ( * cpumask ) . bits [ 0 ] &
# 562 "./arch/x86/include/asm/apic.h"
  ( long unsigned int ) ( * andmask ) . bits [ 0 ] &
# 563 "./arch/x86/include/asm/apic.h"
  ( long unsigned int ) ( * cpu_online_mask ) . bits [ 0 ] & 255UL;
# 566 "./arch/x86/include/asm/apic.h"
  if (__builtin_expect ( cpu_mask != 0UL , 1L ) != 0L)
  {
# 567 "./arch/x86/include/asm/apic.h"
    * apicid = ( unsigned int ) cpu_mask;
    return 0;
  }
  else
# 570 "./arch/x86/include/asm/apic.h"
    return -22;
}
# 575 "./arch/x86/include/asm/apic.h"
int default_cpu_mask_to_apicid_and(struct cpumask const *, struct cpumask const *, unsigned int *);
# 580 "./arch/x86/include/asm/apic.h"
static inline void flat_vector_allocation_domain(int cpu, struct cpumask *retmask, struct cpumask const *mask)
{
# 591 "./arch/x86/include/asm/apic.h"
  cpumask_clear ( retmask );
  ( * retmask ) . bits [ 0 ] = 255UL;
}
# 596 "./arch/x86/include/asm/apic.h"
static inline void default_vector_allocation_domain(int cpu, struct cpumask *retmask, struct cpumask const *mask)
{
# 599 "./arch/x86/include/asm/apic.h"
  cpumask_copy ( retmask , get_cpu_mask ( ( unsigned int ) cpu ) );
}
# 602 "./arch/x86/include/asm/apic.h"
static inline long unsigned int default_check_apicid_used(physid_mask_t *map, int apicid)
{
  return ( long unsigned int ) variable_test_bit ( ( long int ) apicid , ( long unsigned int const volatile *) & ( * map ) . mask );
}
# 607 "./arch/x86/include/asm/apic.h"
static inline void default_ioapic_phys_id_map(physid_mask_t *phys_map, physid_mask_t *retmap)
{
  * retmap = * phys_map;
}
# 612 "./arch/x86/include/asm/apic.h"
static inline int __default_cpu_present_to_apicid(int mps_cpu)
{
  if (mps_cpu < nr_cpu_ids && variable_test_bit ( ( long int ) cpumask_check ( ( unsigned int ) mps_cpu ) , ( long unsigned int const volatile *) & ( * cpu_present_mask ) . bits ) != 0)
  {
# 615 "./arch/x86/include/asm/apic.h"
    return ( int ) * ({
      {
# 615 "./arch/x86/include/asm/apic.h"
        void const *__vpp_verify = ( ( void const *) 0 );
# 615 "./arch/x86/include/asm/apic.h"
        ( void ) __vpp_verify;
      }
# 615 "./arch/x86/include/asm/apic.h"
      ({
# 615 "./arch/x86/include/asm/apic.h"
        long unsigned int __ptr;
# 615 "./arch/x86/include/asm/apic.h"
        asm ( "" : "=r" ( __ptr ) : "0" ( & x86_bios_cpu_apicid ) ) ;
# 615 "./arch/x86/include/asm/apic.h"
        ( u16 *) ( __per_cpu_offset [ mps_cpu ] + __ptr );
      } );
    } );
  }
  else
# 617 "./arch/x86/include/asm/apic.h"
    return 65535;
}
# 621 "./arch/x86/include/asm/apic.h"
static inline int __default_check_phys_apicid_present(int phys_apicid)
{
  return variable_test_bit ( ( long int ) phys_apicid , ( long unsigned int const volatile *) & phys_cpu_present_map . mask );
}
# 638 "./arch/x86/include/asm/apic.h"
int default_cpu_present_to_apicid(int);
int default_check_phys_apicid_present(int);
# 643 "./arch/x86/include/asm/apic.h"
void irq_enter(void);
void irq_exit(void);
# 646 "./arch/x86/include/asm/apic.h"
static inline void entering_irq(void)
{
  irq_enter ( );
  exit_idle ( );
}
# 652 "./arch/x86/include/asm/apic.h"
static inline void entering_ack_irq(void)
{
  ack_APIC_irq ( );
  entering_irq ( );
}
# 658 "./arch/x86/include/asm/apic.h"
static inline void exiting_irq(void)
{
  irq_exit ( );
}
# 663 "./arch/x86/include/asm/apic.h"
static inline void exiting_ack_irq(void)
{
  irq_exit ( );
# 667 "./arch/x86/include/asm/apic.h"
  ack_APIC_irq ( );
}
# 670 "./arch/x86/include/asm/apic.h"
void ioapic_zap_locks(void);
# 135 "./arch/x86/include/asm/irq_vectors.h"
static inline int invalid_vm86_irq(int irq)
{
  return irq <= 2 || irq > 15;
}
union IO_APIC_reg_00
{
# 28 "./arch/x86/include/asm/io_apic.h"
  u32 raw;
# 35 "./arch/x86/include/asm/io_apic.h"
  struct
  {
# 30 "./arch/x86/include/asm/io_apic.h"
    short unsigned int __reserved_2 : 14;
    unsigned char LTS : 1;
    unsigned char delivery_type : 1;
    unsigned char __reserved_1;
    unsigned char ID;
  } bits;
};
union IO_APIC_reg_01
{
  u32 raw;
# 46 "./arch/x86/include/asm/io_apic.h"
  struct
  {
# 41 "./arch/x86/include/asm/io_apic.h"
    unsigned char version;
    unsigned char __reserved_2 : 7;
    unsigned char PRQ : 1;
    unsigned char entries;
    unsigned char __reserved_1;
  } bits;
};
union IO_APIC_reg_02
{
  u32 raw;
# 55 "./arch/x86/include/asm/io_apic.h"
  struct
  {
# 52 "./arch/x86/include/asm/io_apic.h"
    unsigned int __reserved_2 : 24;
    unsigned char arbitration : 4;
    unsigned char __reserved_1 : 4;
  } bits;
};
union IO_APIC_reg_03
{
  u32 raw;
# 63 "./arch/x86/include/asm/io_apic.h"
  struct
  {
# 61 "./arch/x86/include/asm/io_apic.h"
    unsigned char boot_DT : 1;
    unsigned int __reserved_1 : 31;
  } bits;
};
struct IO_APIC_route_entry
{
  unsigned char vector;
  unsigned char delivery_mode : 3;
# 72 "./arch/x86/include/asm/io_apic.h"
  unsigned char dest_mode : 1;
  unsigned char delivery_status : 1;
  unsigned char polarity : 1;
  unsigned char irr : 1;
  unsigned char trigger : 1;
  unsigned char mask : 1;
  short unsigned int __reserved_2 : 15;
# 80 "./arch/x86/include/asm/io_apic.h"
  unsigned int __reserved_3 : 24;
  unsigned char dest;
};
struct IR_IO_APIC_route_entry
{
  unsigned char vector;
  unsigned char zero : 3;
  unsigned char index2 : 1;
  unsigned char delivery_status : 1;
  unsigned char polarity : 1;
  unsigned char irr : 1;
  unsigned char trigger : 1;
  unsigned char mask : 1;
  unsigned int reserved : 31;
  unsigned char format : 1;
  short unsigned int index : 15;
};
# 109 "./arch/x86/include/asm/io_apic.h"
extern int nr_ioapics;
# 111 "./arch/x86/include/asm/io_apic.h"
int mpc_ioapic_id(int);
unsigned int mpc_ioapic_addr(int);
struct mp_ioapic_gsi *mp_ioapic_gsi_routing(int);
# 118 "./arch/x86/include/asm/io_apic.h"
extern int mp_irq_entries;
# 121 "./arch/x86/include/asm/io_apic.h"
extern struct mpc_intsrc mp_irqs[1024U];
# 124 "./arch/x86/include/asm/io_apic.h"
extern int sis_apic_bug;
# 127 "./arch/x86/include/asm/io_apic.h"
extern int skip_ioapic_setup;
# 130 "./arch/x86/include/asm/io_apic.h"
extern int noioapicquirk;
# 133 "./arch/x86/include/asm/io_apic.h"
extern int noioapicreroute;
struct irq_cfg;
# 144 "./arch/x86/include/asm/io_apic.h"
void ioapic_insert_resources(void);
# 146 "./arch/x86/include/asm/io_apic.h"
int native_setup_ioapic_entry(int, struct IO_APIC_route_entry *, unsigned int, int, struct io_apic_irq_attr *);
# 149 "./arch/x86/include/asm/io_apic.h"
void eoi_ioapic_irq(unsigned int, struct irq_cfg *);
# 151 "./arch/x86/include/asm/io_apic.h"
void native_compose_msi_msg(struct pci_dev *, unsigned int, unsigned int, struct msi_msg *, u8);
# 154 "./arch/x86/include/asm/io_apic.h"
void native_eoi_ioapic_pin(int, int, int);
# 156 "./arch/x86/include/asm/io_apic.h"
int save_ioapic_entries(void);
void mask_ioapic_entries(void);
int restore_ioapic_entries(void);
# 160 "./arch/x86/include/asm/io_apic.h"
void setup_ioapic_ids_from_mpc(void);
void setup_ioapic_ids_from_mpc_nocheck(void);
enum ioapic_domain_type
{
  IOAPIC_DOMAIN_INVALID = 0,
  IOAPIC_DOMAIN_LEGACY = 1,
  IOAPIC_DOMAIN_STRICT = 2,
  IOAPIC_DOMAIN_DYNAMIC = 3
};
struct device_node;
struct irq_domain;
struct irq_domain_ops;
struct ioapic_domain_cfg
{
# 175 "./arch/x86/include/asm/io_apic.h"
  enum ioapic_domain_type type;
  struct irq_domain_ops const *ops;
  struct device_node *dev;
};
struct mp_ioapic_gsi
{
  u32 gsi_base;
  u32 gsi_end;
};
extern u32 gsi_top;
# 186 "./arch/x86/include/asm/io_apic.h"
int mp_find_ioapic(u32);
int mp_find_ioapic_pin(int, u32);
u32 mp_pin_to_gsi(int, int);
int mp_map_gsi_to_irq(u32, unsigned int);
void mp_unmap_irq(int);
void mp_register_ioapic(int, u32, u32, struct ioapic_domain_cfg *);
# 193 "./arch/x86/include/asm/io_apic.h"
int mp_irqdomain_map(struct irq_domain *, unsigned int, irq_hw_number_t);
# 195 "./arch/x86/include/asm/io_apic.h"
void mp_irqdomain_unmap(struct irq_domain *, unsigned int);
int mp_set_gsi_attr(u32, int, int, int);
void pre_init_apic_IRQ0(void);
# 199 "./arch/x86/include/asm/io_apic.h"
void mp_save_irq(struct mpc_intsrc *);
# 201 "./arch/x86/include/asm/io_apic.h"
void disable_ioapic_support(void);
# 203 "./arch/x86/include/asm/io_apic.h"
void native_io_apic_init_mappings(void);
unsigned int native_io_apic_read(unsigned int, unsigned int);
void native_io_apic_write(unsigned int, unsigned int, unsigned int);
void native_io_apic_modify(unsigned int, unsigned int, unsigned int);
void native_disable_io_apic(void);
void native_io_apic_print_entries(unsigned int, unsigned int);
void intel_ir_io_apic_print_entries(unsigned int, unsigned int);
int native_ioapic_set_affinity(struct irq_data *, struct cpumask const *, bool);
# 214 "./arch/x86/include/asm/io_apic.h"
static inline unsigned int io_apic_read(unsigned int apic, unsigned int reg)
{
  return x86_io_apic_ops . read ( apic , reg );
}
# 219 "./arch/x86/include/asm/io_apic.h"
static inline void io_apic_write(unsigned int apic, unsigned int reg, unsigned int value)
{
  x86_io_apic_ops . write ( apic , reg , value );
}
static inline void io_apic_modify(unsigned int apic, unsigned int reg, unsigned int value)
{
  x86_io_apic_ops . modify ( apic , reg , value );
}
# 228 "./arch/x86/include/asm/io_apic.h"
void io_apic_eoi(unsigned int, unsigned int);
# 21 "./arch/x86/include/asm/smp.h"
extern int smp_num_siblings;
extern unsigned int num_processors;
# 24 "./arch/x86/include/asm/smp.h"
static inline bool cpu_has_ht_siblings(void)
{
  bool has_siblings = 0;
# 28 "./arch/x86/include/asm/smp.h"
  has_siblings = ( bool ) ( constant_test_bit ( 28L , ( long unsigned int const volatile *) & boot_cpu_data . x86_capability ) != 0 && smp_num_siblings > 1 );
# 30 "./arch/x86/include/asm/smp.h"
  return has_siblings;
}
# 33 "./arch/x86/include/asm/smp.h"
extern char __pcpu_scope_cpu_sibling_map;
# 33 "./arch/x86/include/asm/smp.h"
extern cpumask_var_t cpu_sibling_map;
extern char __pcpu_scope_cpu_core_map;
# 34 "./arch/x86/include/asm/smp.h"
extern cpumask_var_t cpu_core_map;
# 36 "./arch/x86/include/asm/smp.h"
extern char __pcpu_scope_cpu_llc_shared_map;
# 36 "./arch/x86/include/asm/smp.h"
extern cpumask_var_t cpu_llc_shared_map;
extern char __pcpu_scope_cpu_llc_id;
# 37 "./arch/x86/include/asm/smp.h"
extern u16 cpu_llc_id;
extern char __pcpu_scope_cpu_number;
# 38 "./arch/x86/include/asm/smp.h"
extern int cpu_number;
# 40 "./arch/x86/include/asm/smp.h"
static inline struct cpumask *cpu_sibling_mask(int cpu)
{
  return ( struct cpumask *) * ({
    {
# 42 "./arch/x86/include/asm/smp.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 42 "./arch/x86/include/asm/smp.h"
      ( void ) __vpp_verify;
    }
# 42 "./arch/x86/include/asm/smp.h"
    ({
# 42 "./arch/x86/include/asm/smp.h"
      long unsigned int __ptr;
# 42 "./arch/x86/include/asm/smp.h"
      asm ( "" : "=r" ( __ptr ) : "0" ( & cpu_sibling_map ) ) ;
# 42 "./arch/x86/include/asm/smp.h"
      ( cpumask_var_t **) ( __per_cpu_offset [ cpu ] + __ptr );
    } );
  } );
}
# 45 "./arch/x86/include/asm/smp.h"
static inline struct cpumask *cpu_core_mask(int cpu)
{
  return ( struct cpumask *) * ({
    {
# 47 "./arch/x86/include/asm/smp.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 47 "./arch/x86/include/asm/smp.h"
      ( void ) __vpp_verify;
    }
# 47 "./arch/x86/include/asm/smp.h"
    ({
# 47 "./arch/x86/include/asm/smp.h"
      long unsigned int __ptr;
# 47 "./arch/x86/include/asm/smp.h"
      asm ( "" : "=r" ( __ptr ) : "0" ( & cpu_core_map ) ) ;
# 47 "./arch/x86/include/asm/smp.h"
      ( cpumask_var_t **) ( __per_cpu_offset [ cpu ] + __ptr );
    } );
  } );
}
# 50 "./arch/x86/include/asm/smp.h"
static inline struct cpumask *cpu_llc_shared_mask(int cpu)
{
  return ( struct cpumask *) * ({
    {
# 52 "./arch/x86/include/asm/smp.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 52 "./arch/x86/include/asm/smp.h"
      ( void ) __vpp_verify;
    }
# 52 "./arch/x86/include/asm/smp.h"
    ({
# 52 "./arch/x86/include/asm/smp.h"
      long unsigned int __ptr;
# 52 "./arch/x86/include/asm/smp.h"
      asm ( "" : "=r" ( __ptr ) : "0" ( & cpu_llc_shared_map ) ) ;
# 52 "./arch/x86/include/asm/smp.h"
      ( cpumask_var_t **) ( __per_cpu_offset [ cpu ] + __ptr );
    } );
  } );
}
# 55 "./arch/x86/include/asm/smp.h"
extern char __pcpu_scope_x86_cpu_to_apicid;
# 55 "./arch/x86/include/asm/smp.h"
extern u16 x86_cpu_to_apicid;
# 55 "./arch/x86/include/asm/smp.h"
extern u16 *x86_cpu_to_apicid_early_ptr;
# 55 "./arch/x86/include/asm/smp.h"
extern u16 x86_cpu_to_apicid_early_map[];
extern char __pcpu_scope_x86_bios_cpu_apicid;
# 56 "./arch/x86/include/asm/smp.h"
extern u16 x86_bios_cpu_apicid;
# 56 "./arch/x86/include/asm/smp.h"
extern u16 *x86_bios_cpu_apicid_early_ptr;
# 56 "./arch/x86/include/asm/smp.h"
extern u16 x86_bios_cpu_apicid_early_map[];
# 62 "./arch/x86/include/asm/smp.h"
extern long unsigned int stack_start;
struct smp_ops
{
# 67 "./arch/x86/include/asm/smp.h"
  void (*smp_prepare_boot_cpu)(void);
  void (*smp_prepare_cpus)(unsigned int);
  void (*smp_cpus_done)(unsigned int);
# 71 "./arch/x86/include/asm/smp.h"
  void (*stop_other_cpus)(int);
  void (*smp_send_reschedule)(int);
# 74 "./arch/x86/include/asm/smp.h"
  int (*cpu_up)(unsigned int, struct task_struct *);
  int (*cpu_disable)(void);
  void (*cpu_die)(unsigned int);
  void (*play_dead)(void);
# 79 "./arch/x86/include/asm/smp.h"
  void (*send_call_func_ipi)(struct cpumask const *);
  void (*send_call_func_single_ipi)(int);
};
# 84 "./arch/x86/include/asm/smp.h"
void set_cpu_sibling_map(int);
# 90 "./arch/x86/include/asm/smp.h"
extern struct smp_ops smp_ops;
# 92 "./arch/x86/include/asm/smp.h"
static inline void smp_send_stop(void)
{
  smp_ops . stop_other_cpus ( 0 );
}
# 97 "./arch/x86/include/asm/smp.h"
static inline void stop_other_cpus(void)
{
  smp_ops . stop_other_cpus ( 1 );
}
# 102 "./arch/x86/include/asm/smp.h"
static inline void smp_prepare_boot_cpu(void)
{
  smp_ops . smp_prepare_boot_cpu ( );
}
# 107 "./arch/x86/include/asm/smp.h"
static inline void smp_prepare_cpus(unsigned int max_cpus)
{
  smp_ops . smp_prepare_cpus ( max_cpus );
}
# 112 "./arch/x86/include/asm/smp.h"
static inline void smp_cpus_done(unsigned int max_cpus)
{
  smp_ops . smp_cpus_done ( max_cpus );
}
# 117 "./arch/x86/include/asm/smp.h"
static inline int __cpu_up(unsigned int cpu, struct task_struct *tidle)
{
  return smp_ops . cpu_up ( cpu , tidle );
}
# 122 "./arch/x86/include/asm/smp.h"
static inline int __cpu_disable(void)
{
  return smp_ops . cpu_disable ( );
}
# 127 "./arch/x86/include/asm/smp.h"
static inline void __cpu_die(unsigned int cpu)
{
  smp_ops . cpu_die ( cpu );
}
# 132 "./arch/x86/include/asm/smp.h"
static inline void play_dead(void)
{
  smp_ops . play_dead ( );
}
# 137 "./arch/x86/include/asm/smp.h"
static inline void smp_send_reschedule(int cpu)
{
  smp_ops . smp_send_reschedule ( cpu );
}
# 142 "./arch/x86/include/asm/smp.h"
static inline void arch_send_call_function_single_ipi(int cpu)
{
  smp_ops . send_call_func_single_ipi ( cpu );
}
# 147 "./arch/x86/include/asm/smp.h"
static inline void arch_send_call_function_ipi_mask(struct cpumask const *mask)
{
  smp_ops . send_call_func_ipi ( mask );
}
# 152 "./arch/x86/include/asm/smp.h"
void cpu_disable_common(void);
void native_smp_prepare_boot_cpu(void);
void native_smp_prepare_cpus(unsigned int);
void native_smp_cpus_done(unsigned int);
int native_cpu_up(unsigned int, struct task_struct *);
int native_cpu_disable(void);
void native_cpu_die(unsigned int);
void native_play_dead(void);
void play_dead_common(void);
void wbinvd_on_cpu(int);
int wbinvd_on_all_cpus(void);
# 164 "./arch/x86/include/asm/smp.h"
void native_send_call_func_ipi(struct cpumask const *);
void native_send_call_func_single_ipi(int);
void x86_idle_thread_init(unsigned int, struct task_struct *);
# 168 "./arch/x86/include/asm/smp.h"
void smp_store_boot_cpu_info(void);
void smp_store_cpu_info(int);
# 181 "./arch/x86/include/asm/smp.h"
extern unsigned int disabled_cpus;
# 216 "./arch/x86/include/asm/smp.h"
int hard_smp_processor_id(void);
# 227 "./arch/x86/include/asm/smp.h"
void nmi_selftest(void);
# 12 "./arch/x86/include/asm/mmzone_64.h"
extern pg_data_t *node_data[];
# 952 "include/linux/mmzone.h"
struct pglist_data *first_online_pgdat(void);
struct pglist_data *next_online_pgdat(struct pglist_data *);
struct zone *next_zone(struct zone *);
# 984 "include/linux/mmzone.h"
static inline struct zone *zonelist_zone(struct zoneref *zoneref)
{
  return ( * zoneref ) . zone;
}
# 989 "include/linux/mmzone.h"
static inline int zonelist_zone_idx(struct zoneref *zoneref)
{
  return ( * zoneref ) . zone_idx;
}
# 994 "include/linux/mmzone.h"
static inline int zonelist_node_idx(struct zoneref *zoneref)
{
# 998 "include/linux/mmzone.h"
  return ( * ( * zoneref ) . zone ) . node;
}
# 1017 "include/linux/mmzone.h"
struct zoneref *next_zones_zonelist(struct zoneref *, enum zone_type, nodemask_t *, struct zone **);
# 1034 "include/linux/mmzone.h"
static inline struct zoneref *first_zones_zonelist(struct zonelist *zonelist, enum zone_type highest_zoneidx, nodemask_t *nodes, struct zone **zone)
{
# 1039 "include/linux/mmzone.h"
  return next_zones_zonelist ( ( struct zoneref *) & ( * zonelist ) . _zonerefs , highest_zoneidx , nodes , zone );
}
struct page_cgroup;
struct mem_section
{
# 1131 "include/linux/mmzone.h"
  long unsigned int section_mem_map;
# 1134 "include/linux/mmzone.h"
  long unsigned int *pageblock_flags;
# 1140 "include/linux/mmzone.h"
  struct page_cgroup *page_cgroup;
  long unsigned int pad;
};
# 1160 "include/linux/mmzone.h"
extern struct mem_section *mem_section[4096U];
# 1165 "include/linux/mmzone.h"
static inline struct mem_section *__nr_to_section(long unsigned int nr)
{
  if (mem_section [ nr / 128UL ] == ( ( struct mem_section *) 0 ))
    return ( ( struct mem_section *) 0 );
  return mem_section [ nr / 128UL ] + ( nr & 127UL );
}
int __section_nr(struct mem_section *);
long unsigned int usemap_size(void);
# 1185 "include/linux/mmzone.h"
static inline struct page *__section_mem_map_addr(struct mem_section *section)
{
  long unsigned int map = ( * section ) . section_mem_map;
  map &= 18446744073709551612UL;
  return ( struct page *) map;
}
# 1192 "include/linux/mmzone.h"
static inline int present_section(struct mem_section *section)
{
  return section != ( ( struct mem_section *) 0 ) && ( int ) ( * section ) . section_mem_map & 1;
}
# 1197 "include/linux/mmzone.h"
static inline int present_section_nr(long unsigned int nr)
{
  return present_section ( __nr_to_section ( nr ) );
}
# 1202 "include/linux/mmzone.h"
static inline int valid_section(struct mem_section *section)
{
  return section != ( ( struct mem_section *) 0 ) && ( ( * section ) . section_mem_map & 2UL ) != 0UL;
}
# 1207 "include/linux/mmzone.h"
static inline int valid_section_nr(long unsigned int nr)
{
  return valid_section ( __nr_to_section ( nr ) );
}
# 1212 "include/linux/mmzone.h"
static inline struct mem_section *__pfn_to_section(long unsigned int pfn)
{
  return __nr_to_section ( pfn >> 15 );
}
# 1218 "include/linux/mmzone.h"
static inline int pfn_valid(long unsigned int pfn)
{
  if (pfn >> 15 > 524287UL)
    return 0;
  return valid_section ( __nr_to_section ( pfn >> 15 ) );
}
# 1226 "include/linux/mmzone.h"
static inline int pfn_present(long unsigned int pfn)
{
  if (pfn >> 15 > 524287UL)
    return 0;
  return present_section ( __nr_to_section ( pfn >> 15 ) );
}
# 1249 "include/linux/mmzone.h"
void sparse_init(void);
# 1256 "include/linux/mmzone.h"
bool early_pfn_in_nid(long unsigned int, int);
# 1265 "include/linux/mmzone.h"
void memory_present(int, long unsigned int, long unsigned int);
long unsigned int node_memmap_size_bytes(int, long unsigned int, long unsigned int);
# 1299 "include/linux/mmzone.h"
static inline int memmap_valid_within(long unsigned int pfn, struct page *page, struct zone *zone)
{
# 1302 "include/linux/mmzone.h"
  return 1;
}
struct llist_head
{
# 62 "include/linux/llist.h"
  struct llist_node *first;
};
struct llist_node
{
  struct llist_node *next;
};
# 76 "include/linux/llist.h"
static inline void init_llist_head(struct llist_head *list)
{
  ( * list ) . first = ( ( struct llist_node *) 0 );
}
# 158 "include/linux/llist.h"
static inline bool llist_empty(struct llist_head const *head)
{
  return * ( struct llist_node *const volatile *) & ( * head ) . first == ( ( struct llist_node *const volatile ) 0 );
}
# 163 "include/linux/llist.h"
static inline struct llist_node *llist_next(struct llist_node *node)
{
  return ( * node ) . next;
}
# 168 "include/linux/llist.h"
bool llist_add_batch(struct llist_node *, struct llist_node *, struct llist_head *);
# 178 "include/linux/llist.h"
static inline bool llist_add(struct llist_node *new, struct llist_head *head)
{
  return llist_add_batch ( new , new , head );
}
# 191 "include/linux/llist.h"
static inline struct llist_node *llist_del_all(struct llist_head *head)
{
  return ({
# 193 "include/linux/llist.h"
    struct llist_node *__ret = ( ( struct llist_node *) 0 );
    {
# 193 "include/linux/llist.h"
      switch (8UL)
      {
# 193 "include/linux/llist.h"
        case 1:;
# 193 "include/linux/llist.h"
        asm volatile ( "xchgb %b0, %1\n" : "+q" ( __ret ) , "+m" ( ( * head ) . first ) : : "memory" , "cc" ) ;
# 193 "include/linux/llist.h"
        goto ldv_12718;
# 193 "include/linux/llist.h"
        case 2:;
# 193 "include/linux/llist.h"
        asm volatile ( "xchgw %w0, %1\n" : "+r" ( __ret ) , "+m" ( ( * head ) . first ) : : "memory" , "cc" ) ;
# 193 "include/linux/llist.h"
        goto ldv_12718;
# 193 "include/linux/llist.h"
        case 4:;
# 193 "include/linux/llist.h"
        asm volatile ( "xchgl %0, %1\n" : "+r" ( __ret ) , "+m" ( ( * head ) . first ) : : "memory" , "cc" ) ;
# 193 "include/linux/llist.h"
        goto ldv_12718;
# 193 "include/linux/llist.h"
        case 8:;
# 193 "include/linux/llist.h"
        asm volatile ( "xchgq %q0, %1\n" : "+r" ( __ret ) , "+m" ( ( * head ) . first ) : : "memory" , "cc" ) ;
# 193 "include/linux/llist.h"
        goto ldv_12718;
# 193 "include/linux/llist.h"
        default:;
# 193 "include/linux/llist.h"
        __xchg_wrong_size ( );
      }
# 193 "include/linux/llist.h"
      ldv_12718:;
    }
# 193 "include/linux/llist.h"
    __ret;
  } );
}
struct llist_node *llist_del_first(struct llist_head *);
# 198 "include/linux/llist.h"
struct llist_node *llist_reverse_order(struct llist_node *);
# 16 "include/linux/smp.h"
typedef void (*smp_call_func_t)(void *);
struct call_single_data
{
# 18 "include/linux/smp.h"
  struct llist_node llist;
  smp_call_func_t func;
  void *info;
  u16 flags;
};
# 25 "include/linux/smp.h"
extern unsigned int total_cpus;
# 27 "include/linux/smp.h"
int smp_call_function_single(int, smp_call_func_t, void *, int);
# 33 "include/linux/smp.h"
int on_each_cpu(smp_call_func_t, void *, int);
# 39 "include/linux/smp.h"
void on_each_cpu_mask(struct cpumask const *, smp_call_func_t, void *, bool);
# 47 "include/linux/smp.h"
void on_each_cpu_cond(bool (*)(int, void *), smp_call_func_t, void *, bool, gfp_t);
# 51 "include/linux/smp.h"
int smp_call_function_single_async(int, struct call_single_data *);
# 92 "./arch/x86/include/asm/smp.h"
static inline void smp_send_stop(void);
# 137 "./arch/x86/include/asm/smp.h"
static inline void smp_send_reschedule(int cpu);
# 107 "./arch/x86/include/asm/smp.h"
static inline void smp_prepare_cpus(unsigned int max_cpus);
# 117 "./arch/x86/include/asm/smp.h"
static inline int __cpu_up(unsigned int cpu, struct task_struct *tidle);
# 112 "./arch/x86/include/asm/smp.h"
static inline void smp_cpus_done(unsigned int max_cpus);
# 95 "include/linux/smp.h"
int smp_call_function(smp_call_func_t, void *, int);
void smp_call_function_many(struct cpumask const *, smp_call_func_t, void *, bool);
# 99 "include/linux/smp.h"
int smp_call_function_any(struct cpumask const *, smp_call_func_t, void *, int);
# 102 "include/linux/smp.h"
void kick_all_cpus_sync(void);
# 107 "include/linux/smp.h"
void call_function_init(void);
void generic_smp_call_function_single_interrupt(void);
# 102 "./arch/x86/include/asm/smp.h"
static inline void smp_prepare_boot_cpu(void);
# 118 "include/linux/smp.h"
extern unsigned int setup_max_cpus;
void setup_nr_cpu_ids(void);
void smp_init(void);
# 183 "include/linux/smp.h"
void arch_disable_smp_support(void);
# 185 "include/linux/smp.h"
void arch_enable_nonboot_cpus_begin(void);
void arch_enable_nonboot_cpus_end(void);
# 188 "include/linux/smp.h"
void smp_setup_processor_id(void);
# 56 "include/linux/percpu.h"
extern void *pcpu_base_addr;
extern long unsigned int const *pcpu_unit_offsets;
struct pcpu_group_info
{
  int nr_units;
  long unsigned int base_offset;
  unsigned int *cpu_map;
};
struct pcpu_alloc_info
{
# 67 "include/linux/percpu.h"
  size_t static_size;
  size_t reserved_size;
  size_t dyn_size;
  size_t unit_size;
  size_t atom_size;
  size_t alloc_size;
  size_t __ai_size;
  int nr_groups;
  struct pcpu_group_info groups[];
};
enum pcpu_fc
{
  PCPU_FC_AUTO = 0,
  PCPU_FC_EMBED = 1,
  PCPU_FC_PAGE = 2,
  PCPU_FC_NR = 3
};
# 85 "include/linux/percpu.h"
extern char const *const pcpu_fc_names[3U];
# 87 "include/linux/percpu.h"
extern enum pcpu_fc pcpu_chosen_fc;
# 89 "include/linux/percpu.h"
typedef void *(*pcpu_fc_alloc_fn_t)(unsigned int, size_t, size_t);
# 91 "include/linux/percpu.h"
typedef void (*pcpu_fc_free_fn_t)(void *, size_t);
typedef void (*pcpu_fc_populate_pte_fn_t)(long unsigned int);
typedef int pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);
# 95 "include/linux/percpu.h"
struct pcpu_alloc_info *pcpu_alloc_alloc_info(int, int);
# 97 "include/linux/percpu.h"
void pcpu_free_alloc_info(struct pcpu_alloc_info *);
# 99 "include/linux/percpu.h"
int pcpu_setup_first_chunk(struct pcpu_alloc_info const *, void *);
# 103 "include/linux/percpu.h"
int pcpu_embed_first_chunk(size_t, size_t, size_t, pcpu_fc_cpu_distance_fn_t *, pcpu_fc_alloc_fn_t, pcpu_fc_free_fn_t);
# 111 "include/linux/percpu.h"
int pcpu_page_first_chunk(size_t, pcpu_fc_alloc_fn_t, pcpu_fc_free_fn_t, pcpu_fc_populate_pte_fn_t);
# 117 "include/linux/percpu.h"
void *__alloc_reserved_percpu(size_t, size_t);
bool is_kernel_percpu_address(long unsigned int);
# 123 "include/linux/percpu.h"
void percpu_init_late(void);
# 125 "include/linux/percpu.h"
void *__alloc_percpu(size_t, size_t);
void free_percpu(void *);
phys_addr_t per_cpu_ptr_to_phys(void *);
# 49 "include/linux/topology.h"
int arch_update_cpu_topology(void);
# 71 "include/linux/topology.h"
extern char __pcpu_scope_numa_node;
# 71 "include/linux/topology.h"
extern int numa_node;
# 75 "include/linux/topology.h"
static inline int numa_node_id(void)
{
  return ({
# 77 "include/linux/topology.h"
    int pscr_ret__;
    {
# 77 "include/linux/topology.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 77 "include/linux/topology.h"
      ( void ) __vpp_verify;
    }
    {
# 77 "include/linux/topology.h"
      switch (4UL)
      {
# 77 "include/linux/topology.h"
        case 1:;
# 77 "include/linux/topology.h"
        pscr_ret__ = ({
# 77 "include/linux/topology.h"
          int pfo_ret__;
          {
# 77 "include/linux/topology.h"
            switch (4UL)
            {
# 77 "include/linux/topology.h"
              case 1:;
# 77 "include/linux/topology.h"
              asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12893;
# 77 "include/linux/topology.h"
              case 2:;
# 77 "include/linux/topology.h"
              asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12893;
# 77 "include/linux/topology.h"
              case 4:;
# 77 "include/linux/topology.h"
              asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12893;
# 77 "include/linux/topology.h"
              case 8:;
# 77 "include/linux/topology.h"
              asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12893;
# 77 "include/linux/topology.h"
              default:;
# 77 "include/linux/topology.h"
              __bad_percpu_size ( );
            }
# 77 "include/linux/topology.h"
            ldv_12893:;
          }
# 77 "include/linux/topology.h"
          pfo_ret__;
        } );
# 77 "include/linux/topology.h"
        goto ldv_12899;
# 77 "include/linux/topology.h"
        case 2:;
# 77 "include/linux/topology.h"
        pscr_ret__ = ({
# 77 "include/linux/topology.h"
          int pfo_ret__;
          {
# 77 "include/linux/topology.h"
            switch (4UL)
            {
# 77 "include/linux/topology.h"
              case 1:;
# 77 "include/linux/topology.h"
              asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12903;
# 77 "include/linux/topology.h"
              case 2:;
# 77 "include/linux/topology.h"
              asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12903;
# 77 "include/linux/topology.h"
              case 4:;
# 77 "include/linux/topology.h"
              asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12903;
# 77 "include/linux/topology.h"
              case 8:;
# 77 "include/linux/topology.h"
              asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12903;
# 77 "include/linux/topology.h"
              default:;
# 77 "include/linux/topology.h"
              __bad_percpu_size ( );
            }
# 77 "include/linux/topology.h"
            ldv_12903:;
          }
# 77 "include/linux/topology.h"
          pfo_ret__;
        } );
# 77 "include/linux/topology.h"
        goto ldv_12899;
# 77 "include/linux/topology.h"
        case 4:;
# 77 "include/linux/topology.h"
        pscr_ret__ = ({
# 77 "include/linux/topology.h"
          int pfo_ret__;
          {
# 77 "include/linux/topology.h"
            switch (4UL)
            {
# 77 "include/linux/topology.h"
              case 1:;
# 77 "include/linux/topology.h"
              asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12912;
# 77 "include/linux/topology.h"
              case 2:;
# 77 "include/linux/topology.h"
              asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12912;
# 77 "include/linux/topology.h"
              case 4:;
# 77 "include/linux/topology.h"
              asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12912;
# 77 "include/linux/topology.h"
              case 8:;
# 77 "include/linux/topology.h"
              asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12912;
# 77 "include/linux/topology.h"
              default:;
# 77 "include/linux/topology.h"
              __bad_percpu_size ( );
            }
# 77 "include/linux/topology.h"
            ldv_12912:;
          }
# 77 "include/linux/topology.h"
          pfo_ret__;
        } );
# 77 "include/linux/topology.h"
        goto ldv_12899;
# 77 "include/linux/topology.h"
        case 8:;
# 77 "include/linux/topology.h"
        pscr_ret__ = ({
# 77 "include/linux/topology.h"
          int pfo_ret__;
          {
# 77 "include/linux/topology.h"
            switch (4UL)
            {
# 77 "include/linux/topology.h"
              case 1:;
# 77 "include/linux/topology.h"
              asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12921;
# 77 "include/linux/topology.h"
              case 2:;
# 77 "include/linux/topology.h"
              asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12921;
# 77 "include/linux/topology.h"
              case 4:;
# 77 "include/linux/topology.h"
              asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12921;
# 77 "include/linux/topology.h"
              case 8:;
# 77 "include/linux/topology.h"
              asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( numa_node ) ) ;
# 77 "include/linux/topology.h"
              goto ldv_12921;
# 77 "include/linux/topology.h"
              default:;
# 77 "include/linux/topology.h"
              __bad_percpu_size ( );
            }
# 77 "include/linux/topology.h"
            ldv_12921:;
          }
# 77 "include/linux/topology.h"
          pfo_ret__;
        } );
# 77 "include/linux/topology.h"
        goto ldv_12899;
# 77 "include/linux/topology.h"
        default:;
# 77 "include/linux/topology.h"
        __bad_size_call_parameter ( );
# 77 "include/linux/topology.h"
        goto ldv_12899;
      }
# 77 "include/linux/topology.h"
      ldv_12899:;
    }
# 77 "include/linux/topology.h"
    pscr_ret__;
  } );
}
# 89 "include/linux/topology.h"
static inline void set_numa_node(int node)
{
  {
# 91 "include/linux/topology.h"
    void const *__vpp_verify = ( ( void const *) 0 );
# 91 "include/linux/topology.h"
    ( void ) __vpp_verify;
  }
# 91 "include/linux/topology.h"
  switch (4UL)
  {
# 91 "include/linux/topology.h"
    case 1:;
    {
# 91 "include/linux/topology.h"
      typedef int pto_T__;
# 91 "include/linux/topology.h"
      if (0)
      {
# 91 "include/linux/topology.h"
        pto_T__ pto_tmp__;
# 91 "include/linux/topology.h"
        pto_tmp__ = node;
# 91 "include/linux/topology.h"
        ( void ) pto_tmp__;
      }
# 91 "include/linux/topology.h"
      switch (4UL)
      {
# 91 "include/linux/topology.h"
        case 1:;
# 91 "include/linux/topology.h"
        asm ( "movb %1,%%gs:%P0" : "+m" ( numa_node ) : "qi" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12937;
# 91 "include/linux/topology.h"
        case 2:;
# 91 "include/linux/topology.h"
        asm ( "movw %1,%%gs:%P0" : "+m" ( numa_node ) : "ri" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12937;
# 91 "include/linux/topology.h"
        case 4:;
# 91 "include/linux/topology.h"
        asm ( "movl %1,%%gs:%P0" : "+m" ( numa_node ) : "ri" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12937;
# 91 "include/linux/topology.h"
        case 8:;
# 91 "include/linux/topology.h"
        asm ( "movq %1,%%gs:%P0" : "+m" ( numa_node ) : "re" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12937;
# 91 "include/linux/topology.h"
        default:;
# 91 "include/linux/topology.h"
        __bad_percpu_size ( );
      }
# 91 "include/linux/topology.h"
      ldv_12937:;
    }
# 91 "include/linux/topology.h"
    goto ldv_12942;
# 91 "include/linux/topology.h"
    case 2:;
    {
# 91 "include/linux/topology.h"
      typedef int pto_T__;
# 91 "include/linux/topology.h"
      if (0)
      {
# 91 "include/linux/topology.h"
        pto_T__ pto_tmp__;
# 91 "include/linux/topology.h"
        pto_tmp__ = node;
# 91 "include/linux/topology.h"
        ( void ) pto_tmp__;
      }
# 91 "include/linux/topology.h"
      switch (4UL)
      {
# 91 "include/linux/topology.h"
        case 1:;
# 91 "include/linux/topology.h"
        asm ( "movb %1,%%gs:%P0" : "+m" ( numa_node ) : "qi" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12947;
# 91 "include/linux/topology.h"
        case 2:;
# 91 "include/linux/topology.h"
        asm ( "movw %1,%%gs:%P0" : "+m" ( numa_node ) : "ri" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12947;
# 91 "include/linux/topology.h"
        case 4:;
# 91 "include/linux/topology.h"
        asm ( "movl %1,%%gs:%P0" : "+m" ( numa_node ) : "ri" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12947;
# 91 "include/linux/topology.h"
        case 8:;
# 91 "include/linux/topology.h"
        asm ( "movq %1,%%gs:%P0" : "+m" ( numa_node ) : "re" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12947;
# 91 "include/linux/topology.h"
        default:;
# 91 "include/linux/topology.h"
        __bad_percpu_size ( );
      }
# 91 "include/linux/topology.h"
      ldv_12947:;
    }
# 91 "include/linux/topology.h"
    goto ldv_12942;
# 91 "include/linux/topology.h"
    case 4:;
    {
# 91 "include/linux/topology.h"
      typedef int pto_T__;
# 91 "include/linux/topology.h"
      if (0)
      {
# 91 "include/linux/topology.h"
        pto_T__ pto_tmp__;
# 91 "include/linux/topology.h"
        pto_tmp__ = node;
# 91 "include/linux/topology.h"
        ( void ) pto_tmp__;
      }
# 91 "include/linux/topology.h"
      switch (4UL)
      {
# 91 "include/linux/topology.h"
        case 1:;
# 91 "include/linux/topology.h"
        asm ( "movb %1,%%gs:%P0" : "+m" ( numa_node ) : "qi" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12956;
# 91 "include/linux/topology.h"
        case 2:;
# 91 "include/linux/topology.h"
        asm ( "movw %1,%%gs:%P0" : "+m" ( numa_node ) : "ri" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12956;
# 91 "include/linux/topology.h"
        case 4:;
# 91 "include/linux/topology.h"
        asm ( "movl %1,%%gs:%P0" : "+m" ( numa_node ) : "ri" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12956;
# 91 "include/linux/topology.h"
        case 8:;
# 91 "include/linux/topology.h"
        asm ( "movq %1,%%gs:%P0" : "+m" ( numa_node ) : "re" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12956;
# 91 "include/linux/topology.h"
        default:;
# 91 "include/linux/topology.h"
        __bad_percpu_size ( );
      }
# 91 "include/linux/topology.h"
      ldv_12956:;
    }
# 91 "include/linux/topology.h"
    goto ldv_12942;
# 91 "include/linux/topology.h"
    case 8:;
    {
# 91 "include/linux/topology.h"
      typedef int pto_T__;
# 91 "include/linux/topology.h"
      if (0)
      {
# 91 "include/linux/topology.h"
        pto_T__ pto_tmp__;
# 91 "include/linux/topology.h"
        pto_tmp__ = node;
# 91 "include/linux/topology.h"
        ( void ) pto_tmp__;
      }
# 91 "include/linux/topology.h"
      switch (4UL)
      {
# 91 "include/linux/topology.h"
        case 1:;
# 91 "include/linux/topology.h"
        asm ( "movb %1,%%gs:%P0" : "+m" ( numa_node ) : "qi" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12965;
# 91 "include/linux/topology.h"
        case 2:;
# 91 "include/linux/topology.h"
        asm ( "movw %1,%%gs:%P0" : "+m" ( numa_node ) : "ri" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12965;
# 91 "include/linux/topology.h"
        case 4:;
# 91 "include/linux/topology.h"
        asm ( "movl %1,%%gs:%P0" : "+m" ( numa_node ) : "ri" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12965;
# 91 "include/linux/topology.h"
        case 8:;
# 91 "include/linux/topology.h"
        asm ( "movq %1,%%gs:%P0" : "+m" ( numa_node ) : "re" ( node ) ) ;
# 91 "include/linux/topology.h"
        goto ldv_12965;
# 91 "include/linux/topology.h"
        default:;
# 91 "include/linux/topology.h"
        __bad_percpu_size ( );
      }
# 91 "include/linux/topology.h"
      ldv_12965:;
    }
# 91 "include/linux/topology.h"
    goto ldv_12942;
# 91 "include/linux/topology.h"
    default:;
# 91 "include/linux/topology.h"
    __bad_size_call_parameter ( );
# 91 "include/linux/topology.h"
    goto ldv_12942;
  }
# 91 "include/linux/topology.h"
  ldv_12942:;
}
# 96 "include/linux/topology.h"
static inline void set_cpu_numa_node(int cpu, int node)
{
  * ({
    {
# 98 "include/linux/topology.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 98 "include/linux/topology.h"
      ( void ) __vpp_verify;
    }
# 98 "include/linux/topology.h"
    ({
# 98 "include/linux/topology.h"
      long unsigned int __ptr;
# 98 "include/linux/topology.h"
      asm ( "" : "=r" ( __ptr ) : "0" ( & numa_node ) ) ;
# 98 "include/linux/topology.h"
      ( int *) ( __per_cpu_offset [ cpu ] + __ptr );
    } );
  } )
# 98 "include/linux/topology.h"
  = node;
}
# 156 "include/linux/topology.h"
static inline int numa_mem_id(void)
{
  return numa_node_id ( );
}
# 163 "include/linux/topology.h"
static inline int cpu_to_mem(int cpu)
{
  return __cpu_to_node ( cpu );
}
# 185 "include/linux/topology.h"
static inline struct cpumask const *cpu_smt_mask(int cpu)
{
  return ( struct cpumask const *) * ({
    {
# 187 "include/linux/topology.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 187 "include/linux/topology.h"
      ( void ) __vpp_verify;
    }
# 187 "include/linux/topology.h"
    ({
# 187 "include/linux/topology.h"
      long unsigned int __ptr;
# 187 "include/linux/topology.h"
      asm ( "" : "=r" ( __ptr ) : "0" ( & cpu_sibling_map ) ) ;
# 187 "include/linux/topology.h"
      ( cpumask_var_t **) ( __per_cpu_offset [ cpu ] + __ptr );
    } );
  } );
}
static inline struct cpumask const *cpu_cpu_mask(int cpu)
{
  return cpumask_of_node ( __cpu_to_node ( cpu ) );
}
# 159 "include/linux/gfp.h"
static inline int allocflags_to_migratetype(gfp_t gfp_flags)
{
  ({
# 161 "include/linux/gfp.h"
    int __ret_warn_on = ( gfp_flags & 524296U ) == 524296U;
    {
# 161 "include/linux/gfp.h"
      if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 161 "include/linux/gfp.h"
        warn_slowpath_null ( ( char const *) "include/linux/gfp.h" , 161 );
    }
# 161 "include/linux/gfp.h"
    __builtin_expect ( __ret_warn_on != 0 , 0L );
  } );
  if (__builtin_expect ( page_group_by_mobility_disabled != 0 , 0L ) != 0L)
    return 0;
# 167 "include/linux/gfp.h"
  return ( ( gfp_flags & 8U ) != 0U ? 2 : 0 ) | ( gfp_flags
# 168 "include/linux/gfp.h"
  & 524288U ) != 0U;
}
# 254 "include/linux/gfp.h"
static inline enum zone_type gfp_zone(gfp_t flags)
{
  enum zone_type z;
  int bit = ( int ) flags & 15;
# 259 "include/linux/gfp.h"
  z = ( enum zone_type ) ( 20054306 >> bit * 2 & 3 );
# 261 "include/linux/gfp.h"
  if (__builtin_expect ( ( long int ) ( 59624 >> bit ) & 1L , 0L ) != 0L)
  {
# 261 "include/linux/gfp.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/gfp.h" ) , "i" ( 261 ) , "i" ( 12UL ) ) ;
    ldv_13005:;
# 261 "include/linux/gfp.h"
    goto ldv_13005;
  }
# 262 "include/linux/gfp.h"
  return z;
}
# 272 "include/linux/gfp.h"
static inline int gfp_zonelist(gfp_t flags)
{
  if (__builtin_expect ( ( flags & 262144U ) != 0U , 0L ) != 0L)
    return 1;
# 277 "include/linux/gfp.h"
  return 0;
}
# 289 "include/linux/gfp.h"
static inline struct zonelist *node_zonelist(int nid, gfp_t flags)
{
  return ( struct zonelist *) & ( * node_data [ nid ] ) . node_zonelists + ( long unsigned int ) gfp_zonelist ( flags );
}
# 295 "include/linux/gfp.h"
static inline void arch_free_page(struct page *page, int order)
{
}
static inline void arch_alloc_page(struct page *page, int order)
{
}
# 302 "include/linux/gfp.h"
struct page *__alloc_pages_nodemask(gfp_t, unsigned int, struct zonelist *, nodemask_t *);
# 306 "include/linux/gfp.h"
static inline struct page *__alloc_pages(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist)
{
# 309 "include/linux/gfp.h"
  return __alloc_pages_nodemask ( gfp_mask , order , zonelist , ( ( nodemask_t *) 0 ) );
}
# 312 "include/linux/gfp.h"
static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)
{
# 316 "include/linux/gfp.h"
  if (nid < 0)
    nid = numa_node_id ( );
# 319 "include/linux/gfp.h"
  return __alloc_pages ( gfp_mask , order , node_zonelist ( nid , gfp_mask ) );
}
# 322 "include/linux/gfp.h"
static inline struct page *alloc_pages_exact_node(int nid, gfp_t gfp_mask, unsigned int order)
{
# 325 "include/linux/gfp.h"
  if (( __builtin_expect ( nid < 0 , 0L ) != 0L || __builtin_expect ( nid > 1023 , 0L ) != 0L ) != 0 || __builtin_expect ( node_state ( nid , N_ONLINE ) == 0 , 0L ) != 0L)
  {
# 325 "include/linux/gfp.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/gfp.h" ) , "i" ( 325 ) , "i" ( 12UL ) ) ;
    ldv_13041:;
# 325 "include/linux/gfp.h"
    goto ldv_13041;
  }
  return __alloc_pages ( gfp_mask , order , node_zonelist ( nid , gfp_mask ) );
}
# 331 "include/linux/gfp.h"
struct page *alloc_pages_current(gfp_t, unsigned int);
# 334 "include/linux/gfp.h"
static inline struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)
{
  return alloc_pages_current ( gfp_mask , order );
}
struct page *alloc_pages_vma(gfp_t, int, struct vm_area_struct *, long unsigned int, int);
# 353 "include/linux/gfp.h"
struct page *alloc_kmem_pages(gfp_t, unsigned int);
struct page *alloc_kmem_pages_node(int, gfp_t, unsigned int);
# 357 "include/linux/gfp.h"
long unsigned int __get_free_pages(gfp_t, unsigned int);
long unsigned int get_zeroed_page(gfp_t);
# 360 "include/linux/gfp.h"
void *alloc_pages_exact(size_t, gfp_t);
void free_pages_exact(void *, size_t);
# 363 "include/linux/gfp.h"
void *alloc_pages_exact_nid(int, size_t, gfp_t);
# 371 "include/linux/gfp.h"
void __free_pages(struct page *, unsigned int);
void free_pages(long unsigned int, unsigned int);
void free_hot_cold_page(struct page *, bool);
void free_hot_cold_page_list(struct list_head *, bool);
# 376 "include/linux/gfp.h"
void __free_kmem_pages(struct page *, unsigned int);
void free_kmem_pages(long unsigned int, unsigned int);
# 382 "include/linux/gfp.h"
void page_alloc_init(void);
void drain_zone_pages(struct zone *, struct per_cpu_pages *);
void drain_all_pages(void);
void drain_local_pages(void *);
# 394 "include/linux/gfp.h"
extern gfp_t gfp_allowed_mask;
# 397 "include/linux/gfp.h"
bool gfp_pfmemalloc_allowed(gfp_t);
# 399 "include/linux/gfp.h"
void pm_restrict_gfp_mask(void);
void pm_restore_gfp_mask(void);
# 403 "include/linux/gfp.h"
bool pm_suspended_storage(void);
# 414 "include/linux/gfp.h"
int alloc_contig_range(long unsigned int, long unsigned int, unsigned int);
# 416 "include/linux/gfp.h"
void free_contig_range(long unsigned int, unsigned int);
# 419 "include/linux/gfp.h"
void init_cma_reserved_pageblock(struct page *);
struct __sysctl_args
{
# 37 "include/uapi/linux/sysctl.h"
  int *name;
  int nlen;
  void *oldval;
  size_t *oldlenp;
  void *newval;
  size_t newlen;
  long unsigned int __unused[4U];
};
enum ldv_13560
{
  CTL_KERN = 1,
  CTL_VM = 2,
  CTL_NET = 3,
  CTL_PROC = 4,
  CTL_FS = 5,
  CTL_DEBUG = 6,
  CTL_DEV = 7,
  CTL_BUS = 8,
  CTL_ABI = 9,
  CTL_CPU = 10,
  CTL_ARLAN = 254,
  CTL_S390DBF = 5677,
  CTL_SUNRPC = 7249,
  CTL_PM = 9899,
  CTL_FRV = 9898
};
enum ldv_13561
{
  CTL_BUS_ISA = 1
};
enum ldv_13562
{
  INOTIFY_MAX_USER_INSTANCES = 1,
  INOTIFY_MAX_USER_WATCHES = 2,
  INOTIFY_MAX_QUEUED_EVENTS = 3
};
enum ldv_13563
{
  KERN_OSTYPE = 1,
  KERN_OSRELEASE = 2,
  KERN_OSREV = 3,
  KERN_VERSION = 4,
  KERN_SECUREMASK = 5,
  KERN_PROF = 6,
  KERN_NODENAME = 7,
  KERN_DOMAINNAME = 8,
  KERN_PANIC = 15,
  KERN_REALROOTDEV = 16,
  KERN_SPARC_REBOOT = 21,
  KERN_CTLALTDEL = 22,
  KERN_PRINTK = 23,
  KERN_NAMETRANS = 24,
  KERN_PPC_HTABRECLAIM = 25,
  KERN_PPC_ZEROPAGED = 26,
  KERN_PPC_POWERSAVE_NAP = 27,
  KERN_MODPROBE = 28,
  KERN_SG_BIG_BUFF = 29,
  KERN_ACCT = 30,
  KERN_PPC_L2CR = 31,
  KERN_RTSIGNR = 32,
  KERN_RTSIGMAX = 33,
  KERN_SHMMAX = 34,
  KERN_MSGMAX = 35,
  KERN_MSGMNB = 36,
  KERN_MSGPOOL = 37,
  KERN_SYSRQ = 38,
  KERN_MAX_THREADS = 39,
  KERN_RANDOM = 40,
  KERN_SHMALL = 41,
  KERN_MSGMNI = 42,
  KERN_SEM = 43,
  KERN_SPARC_STOP_A = 44,
  KERN_SHMMNI = 45,
  KERN_OVERFLOWUID = 46,
  KERN_OVERFLOWGID = 47,
  KERN_SHMPATH = 48,
  KERN_HOTPLUG = 49,
  KERN_IEEE_EMULATION_WARNINGS = 50,
  KERN_S390_USER_DEBUG_LOGGING = 51,
  KERN_CORE_USES_PID = 52,
  KERN_TAINTED = 53,
  KERN_CADPID = 54,
  KERN_PIDMAX = 55,
  KERN_CORE_PATTERN = 56,
  KERN_PANIC_ON_OOPS = 57,
  KERN_HPPA_PWRSW = 58,
  KERN_HPPA_UNALIGNED = 59,
  KERN_PRINTK_RATELIMIT = 60,
  KERN_PRINTK_RATELIMIT_BURST = 61,
  KERN_PTY = 62,
  KERN_NGROUPS_MAX = 63,
  KERN_SPARC_SCONS_PWROFF = 64,
  KERN_HZ_TIMER = 65,
  KERN_UNKNOWN_NMI_PANIC = 66,
  KERN_BOOTLOADER_TYPE = 67,
  KERN_RANDOMIZE = 68,
  KERN_SETUID_DUMPABLE = 69,
  KERN_SPIN_RETRY = 70,
  KERN_ACPI_VIDEO_FLAGS = 71,
  KERN_IA64_UNALIGNED = 72,
  KERN_COMPAT_LOG = 73,
  KERN_MAX_LOCK_DEPTH = 74,
  KERN_NMI_WATCHDOG = 75,
  KERN_PANIC_ON_NMI = 76
};
enum ldv_13564
{
  VM_UNUSED1 = 1,
  VM_UNUSED2 = 2,
  VM_UNUSED3 = 3,
  VM_UNUSED4 = 4,
  VM_OVERCOMMIT_MEMORY = 5,
  VM_UNUSED5 = 6,
  VM_UNUSED7 = 7,
  VM_UNUSED8 = 8,
  VM_UNUSED9 = 9,
  VM_PAGE_CLUSTER = 10,
  VM_DIRTY_BACKGROUND = 11,
  VM_DIRTY_RATIO = 12,
  VM_DIRTY_WB_CS = 13,
  VM_DIRTY_EXPIRE_CS = 14,
  VM_NR_PDFLUSH_THREADS = 15,
  VM_OVERCOMMIT_RATIO = 16,
  VM_PAGEBUF = 17,
  VM_HUGETLB_PAGES = 18,
  VM_SWAPPINESS = 19,
  VM_LOWMEM_RESERVE_RATIO = 20,
  VM_MIN_FREE_KBYTES = 21,
  VM_MAX_MAP_COUNT = 22,
  VM_LAPTOP_MODE = 23,
  VM_BLOCK_DUMP = 24,
  VM_HUGETLB_GROUP = 25,
  VM_VFS_CACHE_PRESSURE = 26,
  VM_LEGACY_VA_LAYOUT = 27,
  VM_SWAP_TOKEN_TIMEOUT = 28,
  VM_DROP_PAGECACHE = 29,
  VM_PERCPU_PAGELIST_FRACTION = 30,
  VM_ZONE_RECLAIM_MODE = 31,
  VM_MIN_UNMAPPED = 32,
  VM_PANIC_ON_OOM = 33,
  VM_VDSO_ENABLED = 34,
  VM_MIN_SLAB = 35
};
enum ldv_13565
{
  NET_CORE = 1,
  NET_ETHER = 2,
  NET_802 = 3,
  NET_UNIX = 4,
  NET_IPV4 = 5,
  NET_IPX = 6,
  NET_ATALK = 7,
  NET_NETROM = 8,
  NET_AX25 = 9,
  NET_BRIDGE = 10,
  NET_ROSE = 11,
  NET_IPV6 = 12,
  NET_X25 = 13,
  NET_TR = 14,
  NET_DECNET = 15,
  NET_ECONET = 16,
  NET_SCTP = 17,
  NET_LLC = 18,
  NET_NETFILTER = 19,
  NET_DCCP = 20,
  NET_IRDA = 412
};
enum ldv_13566
{
  RANDOM_POOLSIZE = 1,
  RANDOM_ENTROPY_COUNT = 2,
  RANDOM_READ_THRESH = 3,
  RANDOM_WRITE_THRESH = 4,
  RANDOM_BOOT_ID = 5,
  RANDOM_UUID = 6
};
enum ldv_13567
{
  PTY_MAX = 1,
  PTY_NR = 2
};
enum ldv_13568
{
  BUS_ISA_MEM_BASE = 1,
  BUS_ISA_PORT_BASE = 2,
  BUS_ISA_PORT_SHIFT = 3
};
enum ldv_13569
{
  NET_CORE_WMEM_MAX = 1,
  NET_CORE_RMEM_MAX = 2,
  NET_CORE_WMEM_DEFAULT = 3,
  NET_CORE_RMEM_DEFAULT = 4,
  NET_CORE_MAX_BACKLOG = 6,
  NET_CORE_FASTROUTE = 7,
  NET_CORE_MSG_COST = 8,
  NET_CORE_MSG_BURST = 9,
  NET_CORE_OPTMEM_MAX = 10,
  NET_CORE_HOT_LIST_LENGTH = 11,
  NET_CORE_DIVERT_VERSION = 12,
  NET_CORE_NO_CONG_THRESH = 13,
  NET_CORE_NO_CONG = 14,
  NET_CORE_LO_CONG = 15,
  NET_CORE_MOD_CONG = 16,
  NET_CORE_DEV_WEIGHT = 17,
  NET_CORE_SOMAXCONN = 18,
  NET_CORE_BUDGET = 19,
  NET_CORE_AEVENT_ETIME = 20,
  NET_CORE_AEVENT_RSEQTH = 21,
  NET_CORE_WARNINGS = 22
};
enum ldv_13570
{
  NET_UNIX_DESTROY_DELAY = 1,
  NET_UNIX_DELETE_DELAY = 2,
  NET_UNIX_MAX_DGRAM_QLEN = 3
};
enum ldv_13571
{
  NET_NF_CONNTRACK_MAX = 1,
  NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
  NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
  NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
  NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
  NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
  NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
  NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
  NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
  NET_NF_CONNTRACK_UDP_TIMEOUT = 10,
  NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
  NET_NF_CONNTRACK_ICMP_TIMEOUT = 12,
  NET_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
  NET_NF_CONNTRACK_BUCKETS = 14,
  NET_NF_CONNTRACK_LOG_INVALID = 15,
  NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
  NET_NF_CONNTRACK_TCP_LOOSE = 17,
  NET_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
  NET_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
  NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
  NET_NF_CONNTRACK_COUNT = 27,
  NET_NF_CONNTRACK_ICMPV6_TIMEOUT = 28,
  NET_NF_CONNTRACK_FRAG6_TIMEOUT = 29,
  NET_NF_CONNTRACK_FRAG6_LOW_THRESH = 30,
  NET_NF_CONNTRACK_FRAG6_HIGH_THRESH = 31,
  NET_NF_CONNTRACK_CHECKSUM = 32
};
enum ldv_13572
{
  NET_IPV4_FORWARD = 8,
  NET_IPV4_DYNADDR = 9,
  NET_IPV4_CONF = 16,
  NET_IPV4_NEIGH = 17,
  NET_IPV4_ROUTE = 18,
  NET_IPV4_FIB_HASH = 19,
  NET_IPV4_NETFILTER = 20,
  NET_IPV4_TCP_TIMESTAMPS = 33,
  NET_IPV4_TCP_WINDOW_SCALING = 34,
  NET_IPV4_TCP_SACK = 35,
  NET_IPV4_TCP_RETRANS_COLLAPSE = 36,
  NET_IPV4_DEFAULT_TTL = 37,
  NET_IPV4_AUTOCONFIG = 38,
  NET_IPV4_NO_PMTU_DISC = 39,
  NET_IPV4_TCP_SYN_RETRIES = 40,
  NET_IPV4_IPFRAG_HIGH_THRESH = 41,
  NET_IPV4_IPFRAG_LOW_THRESH = 42,
  NET_IPV4_IPFRAG_TIME = 43,
  NET_IPV4_TCP_MAX_KA_PROBES = 44,
  NET_IPV4_TCP_KEEPALIVE_TIME = 45,
  NET_IPV4_TCP_KEEPALIVE_PROBES = 46,
  NET_IPV4_TCP_RETRIES1 = 47,
  NET_IPV4_TCP_RETRIES2 = 48,
  NET_IPV4_TCP_FIN_TIMEOUT = 49,
  NET_IPV4_IP_MASQ_DEBUG = 50,
  NET_TCP_SYNCOOKIES = 51,
  NET_TCP_STDURG = 52,
  NET_TCP_RFC1337 = 53,
  NET_TCP_SYN_TAILDROP = 54,
  NET_TCP_MAX_SYN_BACKLOG = 55,
  NET_IPV4_LOCAL_PORT_RANGE = 56,
  NET_IPV4_ICMP_ECHO_IGNORE_ALL = 57,
  NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS = 58,
  NET_IPV4_ICMP_SOURCEQUENCH_RATE = 59,
  NET_IPV4_ICMP_DESTUNREACH_RATE = 60,
  NET_IPV4_ICMP_TIMEEXCEED_RATE = 61,
  NET_IPV4_ICMP_PARAMPROB_RATE = 62,
  NET_IPV4_ICMP_ECHOREPLY_RATE = 63,
  NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES = 64,
  NET_IPV4_IGMP_MAX_MEMBERSHIPS = 65,
  NET_TCP_TW_RECYCLE = 66,
  NET_IPV4_ALWAYS_DEFRAG = 67,
  NET_IPV4_TCP_KEEPALIVE_INTVL = 68,
  NET_IPV4_INET_PEER_THRESHOLD = 69,
  NET_IPV4_INET_PEER_MINTTL = 70,
  NET_IPV4_INET_PEER_MAXTTL = 71,
  NET_IPV4_INET_PEER_GC_MINTIME = 72,
  NET_IPV4_INET_PEER_GC_MAXTIME = 73,
  NET_TCP_ORPHAN_RETRIES = 74,
  NET_TCP_ABORT_ON_OVERFLOW = 75,
  NET_TCP_SYNACK_RETRIES = 76,
  NET_TCP_MAX_ORPHANS = 77,
  NET_TCP_MAX_TW_BUCKETS = 78,
  NET_TCP_FACK = 79,
  NET_TCP_REORDERING = 80,
  NET_TCP_ECN = 81,
  NET_TCP_DSACK = 82,
  NET_TCP_MEM = 83,
  NET_TCP_WMEM = 84,
  NET_TCP_RMEM = 85,
  NET_TCP_APP_WIN = 86,
  NET_TCP_ADV_WIN_SCALE = 87,
  NET_IPV4_NONLOCAL_BIND = 88,
  NET_IPV4_ICMP_RATELIMIT = 89,
  NET_IPV4_ICMP_RATEMASK = 90,
  NET_TCP_TW_REUSE = 91,
  NET_TCP_FRTO = 92,
  NET_TCP_LOW_LATENCY = 93,
  NET_IPV4_IPFRAG_SECRET_INTERVAL = 94,
  NET_IPV4_IGMP_MAX_MSF = 96,
  NET_TCP_NO_METRICS_SAVE = 97,
  NET_TCP_DEFAULT_WIN_SCALE = 105,
  NET_TCP_MODERATE_RCVBUF = 106,
  NET_TCP_TSO_WIN_DIVISOR = 107,
  NET_TCP_BIC_BETA = 108,
  NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR = 109,
  NET_TCP_CONG_CONTROL = 110,
  NET_TCP_ABC = 111,
  NET_IPV4_IPFRAG_MAX_DIST = 112,
  NET_TCP_MTU_PROBING = 113,
  NET_TCP_BASE_MSS = 114,
  NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS = 115,
  NET_TCP_DMA_COPYBREAK = 116,
  NET_TCP_SLOW_START_AFTER_IDLE = 117,
  NET_CIPSOV4_CACHE_ENABLE = 118,
  NET_CIPSOV4_CACHE_BUCKET_SIZE = 119,
  NET_CIPSOV4_RBM_OPTFMT = 120,
  NET_CIPSOV4_RBM_STRICTVALID = 121,
  NET_TCP_AVAIL_CONG_CONTROL = 122,
  NET_TCP_ALLOWED_CONG_CONTROL = 123,
  NET_TCP_MAX_SSTHRESH = 124,
  NET_TCP_FRTO_RESPONSE = 125
};
enum ldv_13573
{
  NET_IPV4_ROUTE_FLUSH = 1,
  NET_IPV4_ROUTE_MIN_DELAY = 2,
  NET_IPV4_ROUTE_MAX_DELAY = 3,
  NET_IPV4_ROUTE_GC_THRESH = 4,
  NET_IPV4_ROUTE_MAX_SIZE = 5,
  NET_IPV4_ROUTE_GC_MIN_INTERVAL = 6,
  NET_IPV4_ROUTE_GC_TIMEOUT = 7,
  NET_IPV4_ROUTE_GC_INTERVAL = 8,
  NET_IPV4_ROUTE_REDIRECT_LOAD = 9,
  NET_IPV4_ROUTE_REDIRECT_NUMBER = 10,
  NET_IPV4_ROUTE_REDIRECT_SILENCE = 11,
  NET_IPV4_ROUTE_ERROR_COST = 12,
  NET_IPV4_ROUTE_ERROR_BURST = 13,
  NET_IPV4_ROUTE_GC_ELASTICITY = 14,
  NET_IPV4_ROUTE_MTU_EXPIRES = 15,
  NET_IPV4_ROUTE_MIN_PMTU = 16,
  NET_IPV4_ROUTE_MIN_ADVMSS = 17,
  NET_IPV4_ROUTE_SECRET_INTERVAL = 18,
  NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS = 19
};
enum ldv_13574
{
  NET_PROTO_CONF_ALL = -2,
  NET_PROTO_CONF_DEFAULT = -3
};
enum ldv_13575
{
  NET_IPV4_CONF_FORWARDING = 1,
  NET_IPV4_CONF_MC_FORWARDING = 2,
  NET_IPV4_CONF_PROXY_ARP = 3,
  NET_IPV4_CONF_ACCEPT_REDIRECTS = 4,
  NET_IPV4_CONF_SECURE_REDIRECTS = 5,
  NET_IPV4_CONF_SEND_REDIRECTS = 6,
  NET_IPV4_CONF_SHARED_MEDIA = 7,
  NET_IPV4_CONF_RP_FILTER = 8,
  NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE = 9,
  NET_IPV4_CONF_BOOTP_RELAY = 10,
  NET_IPV4_CONF_LOG_MARTIANS = 11,
  NET_IPV4_CONF_TAG = 12,
  NET_IPV4_CONF_ARPFILTER = 13,
  NET_IPV4_CONF_MEDIUM_ID = 14,
  NET_IPV4_CONF_NOXFRM = 15,
  NET_IPV4_CONF_NOPOLICY = 16,
  NET_IPV4_CONF_FORCE_IGMP_VERSION = 17,
  NET_IPV4_CONF_ARP_ANNOUNCE = 18,
  NET_IPV4_CONF_ARP_IGNORE = 19,
  NET_IPV4_CONF_PROMOTE_SECONDARIES = 20,
  NET_IPV4_CONF_ARP_ACCEPT = 21,
  NET_IPV4_CONF_ARP_NOTIFY = 22
};
enum ldv_13576
{
  NET_IPV4_NF_CONNTRACK_MAX = 1,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
  NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT = 10,
  NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
  NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT = 12,
  NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
  NET_IPV4_NF_CONNTRACK_BUCKETS = 14,
  NET_IPV4_NF_CONNTRACK_LOG_INVALID = 15,
  NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
  NET_IPV4_NF_CONNTRACK_TCP_LOOSE = 17,
  NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
  NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
  NET_IPV4_NF_CONNTRACK_COUNT = 27,
  NET_IPV4_NF_CONNTRACK_CHECKSUM = 28
};
enum ldv_13577
{
  NET_IPV6_CONF = 16,
  NET_IPV6_NEIGH = 17,
  NET_IPV6_ROUTE = 18,
  NET_IPV6_ICMP = 19,
  NET_IPV6_BINDV6ONLY = 20,
  NET_IPV6_IP6FRAG_HIGH_THRESH = 21,
  NET_IPV6_IP6FRAG_LOW_THRESH = 22,
  NET_IPV6_IP6FRAG_TIME = 23,
  NET_IPV6_IP6FRAG_SECRET_INTERVAL = 24,
  NET_IPV6_MLD_MAX_MSF = 25
};
enum ldv_13578
{
  NET_IPV6_ROUTE_FLUSH = 1,
  NET_IPV6_ROUTE_GC_THRESH = 2,
  NET_IPV6_ROUTE_MAX_SIZE = 3,
  NET_IPV6_ROUTE_GC_MIN_INTERVAL = 4,
  NET_IPV6_ROUTE_GC_TIMEOUT = 5,
  NET_IPV6_ROUTE_GC_INTERVAL = 6,
  NET_IPV6_ROUTE_GC_ELASTICITY = 7,
  NET_IPV6_ROUTE_MTU_EXPIRES = 8,
  NET_IPV6_ROUTE_MIN_ADVMSS = 9,
  NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS = 10
};
enum ldv_13579
{
  NET_IPV6_FORWARDING = 1,
  NET_IPV6_HOP_LIMIT = 2,
  NET_IPV6_MTU = 3,
  NET_IPV6_ACCEPT_RA = 4,
  NET_IPV6_ACCEPT_REDIRECTS = 5,
  NET_IPV6_AUTOCONF = 6,
  NET_IPV6_DAD_TRANSMITS = 7,
  NET_IPV6_RTR_SOLICITS = 8,
  NET_IPV6_RTR_SOLICIT_INTERVAL = 9,
  NET_IPV6_RTR_SOLICIT_DELAY = 10,
  NET_IPV6_USE_TEMPADDR = 11,
  NET_IPV6_TEMP_VALID_LFT = 12,
  NET_IPV6_TEMP_PREFERED_LFT = 13,
  NET_IPV6_REGEN_MAX_RETRY = 14,
  NET_IPV6_MAX_DESYNC_FACTOR = 15,
  NET_IPV6_MAX_ADDRESSES = 16,
  NET_IPV6_FORCE_MLD_VERSION = 17,
  NET_IPV6_ACCEPT_RA_DEFRTR = 18,
  NET_IPV6_ACCEPT_RA_PINFO = 19,
  NET_IPV6_ACCEPT_RA_RTR_PREF = 20,
  NET_IPV6_RTR_PROBE_INTERVAL = 21,
  NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN = 22,
  NET_IPV6_PROXY_NDP = 23,
  NET_IPV6_ACCEPT_SOURCE_ROUTE = 25,
  NET_IPV6_ACCEPT_RA_FROM_LOCAL = 26,
  __NET_IPV6_MAX = 27
};
enum ldv_13580
{
  NET_IPV6_ICMP_RATELIMIT = 1
};
enum ldv_13581
{
  NET_NEIGH_MCAST_SOLICIT = 1,
  NET_NEIGH_UCAST_SOLICIT = 2,
  NET_NEIGH_APP_SOLICIT = 3,
  NET_NEIGH_RETRANS_TIME = 4,
  NET_NEIGH_REACHABLE_TIME = 5,
  NET_NEIGH_DELAY_PROBE_TIME = 6,
  NET_NEIGH_GC_STALE_TIME = 7,
  NET_NEIGH_UNRES_QLEN = 8,
  NET_NEIGH_PROXY_QLEN = 9,
  NET_NEIGH_ANYCAST_DELAY = 10,
  NET_NEIGH_PROXY_DELAY = 11,
  NET_NEIGH_LOCKTIME = 12,
  NET_NEIGH_GC_INTERVAL = 13,
  NET_NEIGH_GC_THRESH1 = 14,
  NET_NEIGH_GC_THRESH2 = 15,
  NET_NEIGH_GC_THRESH3 = 16,
  NET_NEIGH_RETRANS_TIME_MS = 17,
  NET_NEIGH_REACHABLE_TIME_MS = 18
};
enum ldv_13582
{
  NET_DCCP_DEFAULT = 1
};
enum ldv_13583
{
  NET_IPX_PPROP_BROADCASTING = 1,
  NET_IPX_FORWARDING = 2
};
enum ldv_13584
{
  NET_LLC2 = 1,
  NET_LLC_STATION = 2
};
enum ldv_13585
{
  NET_LLC2_TIMEOUT = 1
};
enum ldv_13586
{
  NET_LLC_STATION_ACK_TIMEOUT = 1
};
enum ldv_13587
{
  NET_LLC2_ACK_TIMEOUT = 1,
  NET_LLC2_P_TIMEOUT = 2,
  NET_LLC2_REJ_TIMEOUT = 3,
  NET_LLC2_BUSY_TIMEOUT = 4
};
enum ldv_13588
{
  NET_ATALK_AARP_EXPIRY_TIME = 1,
  NET_ATALK_AARP_TICK_TIME = 2,
  NET_ATALK_AARP_RETRANSMIT_LIMIT = 3,
  NET_ATALK_AARP_RESOLVE_TIME = 4
};
enum ldv_13589
{
  NET_NETROM_DEFAULT_PATH_QUALITY = 1,
  NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER = 2,
  NET_NETROM_NETWORK_TTL_INITIALISER = 3,
  NET_NETROM_TRANSPORT_TIMEOUT = 4,
  NET_NETROM_TRANSPORT_MAXIMUM_TRIES = 5,
  NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY = 6,
  NET_NETROM_TRANSPORT_BUSY_DELAY = 7,
  NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE = 8,
  NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT = 9,
  NET_NETROM_ROUTING_CONTROL = 10,
  NET_NETROM_LINK_FAILS_COUNT = 11,
  NET_NETROM_RESET = 12
};
enum ldv_13590
{
  NET_AX25_IP_DEFAULT_MODE = 1,
  NET_AX25_DEFAULT_MODE = 2,
  NET_AX25_BACKOFF_TYPE = 3,
  NET_AX25_CONNECT_MODE = 4,
  NET_AX25_STANDARD_WINDOW = 5,
  NET_AX25_EXTENDED_WINDOW = 6,
  NET_AX25_T1_TIMEOUT = 7,
  NET_AX25_T2_TIMEOUT = 8,
  NET_AX25_T3_TIMEOUT = 9,
  NET_AX25_IDLE_TIMEOUT = 10,
  NET_AX25_N2 = 11,
  NET_AX25_PACLEN = 12,
  NET_AX25_PROTOCOL = 13,
  NET_AX25_DAMA_SLAVE_TIMEOUT = 14
};
enum ldv_13591
{
  NET_ROSE_RESTART_REQUEST_TIMEOUT = 1,
  NET_ROSE_CALL_REQUEST_TIMEOUT = 2,
  NET_ROSE_RESET_REQUEST_TIMEOUT = 3,
  NET_ROSE_CLEAR_REQUEST_TIMEOUT = 4,
  NET_ROSE_ACK_HOLD_BACK_TIMEOUT = 5,
  NET_ROSE_ROUTING_CONTROL = 6,
  NET_ROSE_LINK_FAIL_TIMEOUT = 7,
  NET_ROSE_MAX_VCS = 8,
  NET_ROSE_WINDOW_SIZE = 9,
  NET_ROSE_NO_ACTIVITY_TIMEOUT = 10
};
enum ldv_13592
{
  NET_X25_RESTART_REQUEST_TIMEOUT = 1,
  NET_X25_CALL_REQUEST_TIMEOUT = 2,
  NET_X25_RESET_REQUEST_TIMEOUT = 3,
  NET_X25_CLEAR_REQUEST_TIMEOUT = 4,
  NET_X25_ACK_HOLD_BACK_TIMEOUT = 5,
  NET_X25_FORWARD = 6
};
enum ldv_13593
{
  NET_TR_RIF_TIMEOUT = 1
};
enum ldv_13594
{
  NET_DECNET_NODE_TYPE = 1,
  NET_DECNET_NODE_ADDRESS = 2,
  NET_DECNET_NODE_NAME = 3,
  NET_DECNET_DEFAULT_DEVICE = 4,
  NET_DECNET_TIME_WAIT = 5,
  NET_DECNET_DN_COUNT = 6,
  NET_DECNET_DI_COUNT = 7,
  NET_DECNET_DR_COUNT = 8,
  NET_DECNET_DST_GC_INTERVAL = 9,
  NET_DECNET_CONF = 10,
  NET_DECNET_NO_FC_MAX_CWND = 11,
  NET_DECNET_MEM = 12,
  NET_DECNET_RMEM = 13,
  NET_DECNET_WMEM = 14,
  NET_DECNET_DEBUG_LEVEL = 255
};
enum ldv_13595
{
  NET_DECNET_CONF_LOOPBACK = -2,
  NET_DECNET_CONF_DDCMP = -3,
  NET_DECNET_CONF_PPP = -4,
  NET_DECNET_CONF_X25 = -5,
  NET_DECNET_CONF_GRE = -6,
  NET_DECNET_CONF_ETHER = -7
};
enum ldv_13596
{
  NET_DECNET_CONF_DEV_PRIORITY = 1,
  NET_DECNET_CONF_DEV_T1 = 2,
  NET_DECNET_CONF_DEV_T2 = 3,
  NET_DECNET_CONF_DEV_T3 = 4,
  NET_DECNET_CONF_DEV_FORWARDING = 5,
  NET_DECNET_CONF_DEV_BLKSIZE = 6,
  NET_DECNET_CONF_DEV_STATE = 7
};
enum ldv_13597
{
  NET_SCTP_RTO_INITIAL = 1,
  NET_SCTP_RTO_MIN = 2,
  NET_SCTP_RTO_MAX = 3,
  NET_SCTP_RTO_ALPHA = 4,
  NET_SCTP_RTO_BETA = 5,
  NET_SCTP_VALID_COOKIE_LIFE = 6,
  NET_SCTP_ASSOCIATION_MAX_RETRANS = 7,
  NET_SCTP_PATH_MAX_RETRANS = 8,
  NET_SCTP_MAX_INIT_RETRANSMITS = 9,
  NET_SCTP_HB_INTERVAL = 10,
  NET_SCTP_PRESERVE_ENABLE = 11,
  NET_SCTP_MAX_BURST = 12,
  NET_SCTP_ADDIP_ENABLE = 13,
  NET_SCTP_PRSCTP_ENABLE = 14,
  NET_SCTP_SNDBUF_POLICY = 15,
  NET_SCTP_SACK_TIMEOUT = 16,
  NET_SCTP_RCVBUF_POLICY = 17
};
enum ldv_13598
{
  NET_BRIDGE_NF_CALL_ARPTABLES = 1,
  NET_BRIDGE_NF_CALL_IPTABLES = 2,
  NET_BRIDGE_NF_CALL_IP6TABLES = 3,
  NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4,
  NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5
};
enum ldv_13599
{
  NET_IRDA_DISCOVERY = 1,
  NET_IRDA_DEVNAME = 2,
  NET_IRDA_DEBUG = 3,
  NET_IRDA_FAST_POLL = 4,
  NET_IRDA_DISCOVERY_SLOTS = 5,
  NET_IRDA_DISCOVERY_TIMEOUT = 6,
  NET_IRDA_SLOT_TIMEOUT = 7,
  NET_IRDA_MAX_BAUD_RATE = 8,
  NET_IRDA_MIN_TX_TURN_TIME = 9,
  NET_IRDA_MAX_TX_DATA_SIZE = 10,
  NET_IRDA_MAX_TX_WINDOW = 11,
  NET_IRDA_MAX_NOREPLY_TIME = 12,
  NET_IRDA_WARN_NOREPLY_TIME = 13,
  NET_IRDA_LAP_KEEPALIVE_TIME = 14
};
enum ldv_13600
{
  FS_NRINODE = 1,
  FS_STATINODE = 2,
  FS_MAXINODE = 3,
  FS_NRDQUOT = 4,
  FS_MAXDQUOT = 5,
  FS_NRFILE = 6,
  FS_MAXFILE = 7,
  FS_DENTRY = 8,
  FS_NRSUPER = 9,
  FS_MAXSUPER = 10,
  FS_OVERFLOWUID = 11,
  FS_OVERFLOWGID = 12,
  FS_LEASES = 13,
  FS_DIR_NOTIFY = 14,
  FS_LEASE_TIME = 15,
  FS_DQSTATS = 16,
  FS_XFS = 17,
  FS_AIO_NR = 18,
  FS_AIO_MAX_NR = 19,
  FS_INOTIFY = 20,
  FS_OCFS2 = 988
};
enum ldv_13601
{
  FS_DQ_LOOKUPS = 1,
  FS_DQ_DROPS = 2,
  FS_DQ_READS = 3,
  FS_DQ_WRITES = 4,
  FS_DQ_CACHE_HITS = 5,
  FS_DQ_ALLOCATED = 6,
  FS_DQ_FREE = 7,
  FS_DQ_SYNCS = 8,
  FS_DQ_WARNINGS = 9
};
enum ldv_13602
{
  DEV_CDROM = 1,
  DEV_HWMON = 2,
  DEV_PARPORT = 3,
  DEV_RAID = 4,
  DEV_MAC_HID = 5,
  DEV_SCSI = 6,
  DEV_IPMI = 7
};
enum ldv_13603
{
  DEV_CDROM_INFO = 1,
  DEV_CDROM_AUTOCLOSE = 2,
  DEV_CDROM_AUTOEJECT = 3,
  DEV_CDROM_DEBUG = 4,
  DEV_CDROM_LOCK = 5,
  DEV_CDROM_CHECK_MEDIA = 6
};
enum ldv_13604
{
  DEV_PARPORT_DEFAULT = -3
};
enum ldv_13605
{
  DEV_RAID_SPEED_LIMIT_MIN = 1,
  DEV_RAID_SPEED_LIMIT_MAX = 2
};
enum ldv_13606
{
  DEV_PARPORT_DEFAULT_TIMESLICE = 1,
  DEV_PARPORT_DEFAULT_SPINTIME = 2
};
enum ldv_13607
{
  DEV_PARPORT_SPINTIME = 1,
  DEV_PARPORT_BASE_ADDR = 2,
  DEV_PARPORT_IRQ = 3,
  DEV_PARPORT_DMA = 4,
  DEV_PARPORT_MODES = 5,
  DEV_PARPORT_DEVICES = 6,
  DEV_PARPORT_AUTOPROBE = 16
};
enum ldv_13608
{
  DEV_PARPORT_DEVICES_ACTIVE = -3
};
enum ldv_13609
{
  DEV_PARPORT_DEVICE_TIMESLICE = 1
};
enum ldv_13610
{
  DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES = 1,
  DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES = 2,
  DEV_MAC_HID_MOUSE_BUTTON_EMULATION = 3,
  DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE = 4,
  DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE = 5,
  DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES = 6
};
enum ldv_13611
{
  DEV_SCSI_LOGGING_LEVEL = 1
};
enum ldv_13612
{
  DEV_IPMI_POWEROFF_POWERCYCLE = 1
};
enum ldv_13613
{
  ABI_DEFHANDLER_COFF = 1,
  ABI_DEFHANDLER_ELF = 2,
  ABI_DEFHANDLER_LCALL7 = 3,
  ABI_DEFHANDLER_LIBCSO = 4,
  ABI_TRACE = 5,
  ABI_FAKE_UTSNAME = 6
};
struct nsproxy;
struct ctl_table_root;
struct ctl_table_header;
struct ctl_dir;
# 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 40 "include/linux/sysctl.h"
int proc_dostring(struct ctl_table *, int, void *, size_t *, loff_t *);
# 42 "include/linux/sysctl.h"
int proc_dointvec(struct ctl_table *, int, void *, size_t *, loff_t *);
# 44 "include/linux/sysctl.h"
int proc_dointvec_minmax(struct ctl_table *, int, void *, size_t *, loff_t *);
# 46 "include/linux/sysctl.h"
int proc_dointvec_jiffies(struct ctl_table *, int, void *, size_t *, loff_t *);
# 48 "include/linux/sysctl.h"
int proc_dointvec_userhz_jiffies(struct ctl_table *, int, void *, size_t *, loff_t *);
# 50 "include/linux/sysctl.h"
int proc_dointvec_ms_jiffies(struct ctl_table *, int, void *, size_t *, loff_t *);
# 52 "include/linux/sysctl.h"
int proc_doulongvec_minmax(struct ctl_table *, int, void *, size_t *, loff_t *);
# 54 "include/linux/sysctl.h"
int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *, int, void *, size_t *, loff_t *);
# 56 "include/linux/sysctl.h"
int proc_do_large_bitmap(struct ctl_table *, int, void *, size_t *, loff_t *);
struct ctl_table_poll
{
# 88 "include/linux/sysctl.h"
  atomic_t event;
  wait_queue_head_t wait;
};
# 92 "include/linux/sysctl.h"
static inline void *proc_sys_poll_event(struct ctl_table_poll *poll)
{
  return ( void *) ( long unsigned int ) atomic_read ( ( atomic_t const *) & ( * poll ) . event );
}
struct ctl_table
{
# 107 "include/linux/sysctl.h"
  char const *procname;
  void *data;
  int maxlen;
  umode_t mode;
  struct ctl_table *child;
  proc_handler *proc_handler;
  struct ctl_table_poll *poll;
  void *extra1;
  void *extra2;
};
struct ctl_node
{
  struct rb_node node;
  struct ctl_table_header *header;
};
struct ctl_table_header
{
# 135 "include/linux/sysctl.h"
  union
  {
# 133 "include/linux/sysctl.h"
    struct
    {
# 129 "include/linux/sysctl.h"
      struct ctl_table *ctl_table;
      int used;
      int count;
      int nreg;
    } ldv_13901;
    struct callback_head rcu;
  } ldv_13903;
  struct completion *unregistering;
  struct ctl_table *ctl_table_arg;
  struct ctl_table_root *root;
  struct ctl_table_set *set;
  struct ctl_dir *parent;
  struct ctl_node *node;
};
struct ctl_dir
{
# 146 "include/linux/sysctl.h"
  struct ctl_table_header header;
  struct rb_root root;
};
struct ctl_table_set
{
  int (*is_seen)(struct ctl_table_set *);
  struct ctl_dir dir;
};
struct ctl_table_root
{
  struct ctl_table_set default_set;
  struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *);
# 159 "include/linux/sysctl.h"
  int (*permissions)(struct ctl_table_header *, struct ctl_table *);
};
struct ctl_path
{
# 164 "include/linux/sysctl.h"
  char const *procname;
};
# 169 "include/linux/sysctl.h"
void proc_sys_poll_notify(struct ctl_table_poll *);
# 171 "include/linux/sysctl.h"
void setup_sysctl_set(struct ctl_table_set *, struct ctl_table_root *, int (*)(struct ctl_table_set *));
# 174 "include/linux/sysctl.h"
void retire_sysctl_set(struct ctl_table_set *);
# 176 "include/linux/sysctl.h"
void register_sysctl_root(struct ctl_table_root *);
struct ctl_table_header *__register_sysctl_table(struct ctl_table_set *, char const *, struct ctl_table *);
# 180 "include/linux/sysctl.h"
struct ctl_table_header *__register_sysctl_paths(struct ctl_table_set *, struct ctl_path const *, struct ctl_table *);
# 183 "include/linux/sysctl.h"
struct ctl_table_header *register_sysctl(char const *, struct ctl_table *);
struct ctl_table_header *register_sysctl_table(struct ctl_table *);
struct ctl_table_header *register_sysctl_paths(struct ctl_path const *, struct ctl_table *);
# 188 "include/linux/sysctl.h"
void unregister_sysctl_table(struct ctl_table_header *);
# 190 "include/linux/sysctl.h"
int sysctl_init(void);
# 32 "include/linux/kmod.h"
extern char modprobe_path[];
# 36 "include/linux/kmod.h"
int __request_module(bool, char const *, ...);
struct cred;
struct subprocess_info
{
# 57 "include/linux/kmod.h"
  struct work_struct work;
  struct completion *complete;
  char *path;
  char **argv;
  char **envp;
  int wait;
  int retval;
  int (*init)(struct subprocess_info *, struct cred *);
  void (*cleanup)(struct subprocess_info *);
  void *data;
};
# 70 "include/linux/kmod.h"
int call_usermodehelper(char *, char **, char **, int);
# 73 "include/linux/kmod.h"
struct subprocess_info *call_usermodehelper_setup(char *, char **, char **, gfp_t, int (*)(struct subprocess_info *, struct cred *), void (*)(struct subprocess_info *), void *);
# 78 "include/linux/kmod.h"
int call_usermodehelper_exec(struct subprocess_info *, int);
# 80 "include/linux/kmod.h"
extern struct ctl_table usermodehelper_table[];
enum umh_disable_depth
{
  UMH_ENABLED = 0,
  UMH_FREEZING = 1,
  UMH_DISABLED = 2
};
# 88 "include/linux/kmod.h"
void usermodehelper_init(void);
# 90 "include/linux/kmod.h"
int __usermodehelper_disable(enum umh_disable_depth);
void __usermodehelper_set_disable_depth(enum umh_disable_depth);
# 93 "include/linux/kmod.h"
static inline int usermodehelper_disable(void)
{
  return __usermodehelper_disable ( UMH_DISABLED );
}
# 98 "include/linux/kmod.h"
static inline void usermodehelper_enable(void)
{
  __usermodehelper_set_disable_depth ( UMH_ENABLED );
}
# 103 "include/linux/kmod.h"
int usermodehelper_read_trylock(void);
long int usermodehelper_read_lock_wait(long int);
void usermodehelper_read_unlock(void);
struct user_i387_struct
{
# 51 "./arch/x86/include/asm/user_64.h"
  short unsigned int cwd;
  short unsigned int swd;
  short unsigned int twd;
# 55 "./arch/x86/include/asm/user_64.h"
  short unsigned int fop;
  __u64 rip;
  __u64 rdp;
  __u32 mxcsr;
  __u32 mxcsr_mask;
  __u32 st_space[32U];
  __u32 xmm_space[64U];
  __u32 padding[24U];
};
struct user_regs_struct
{
# 69 "./arch/x86/include/asm/user_64.h"
  long unsigned int r15;
  long unsigned int r14;
  long unsigned int r13;
  long unsigned int r12;
  long unsigned int bp;
  long unsigned int bx;
  long unsigned int r11;
  long unsigned int r10;
  long unsigned int r9;
  long unsigned int r8;
  long unsigned int ax;
  long unsigned int cx;
  long unsigned int dx;
  long unsigned int si;
  long unsigned int di;
  long unsigned int orig_ax;
  long unsigned int ip;
  long unsigned int cs;
  long unsigned int flags;
  long unsigned int sp;
  long unsigned int ss;
  long unsigned int fs_base;
  long unsigned int gs_base;
  long unsigned int ds;
  long unsigned int es;
  long unsigned int fs;
  long unsigned int gs;
};
struct user
{
# 105 "./arch/x86/include/asm/user_64.h"
  struct user_regs_struct regs;
# 107 "./arch/x86/include/asm/user_64.h"
  int u_fpvalid;
# 109 "./arch/x86/include/asm/user_64.h"
  int pad0;
  struct user_i387_struct i387;
# 112 "./arch/x86/include/asm/user_64.h"
  long unsigned int u_tsize;
  long unsigned int u_dsize;
  long unsigned int u_ssize;
  long unsigned int start_code;
  long unsigned int start_stack;
# 120 "./arch/x86/include/asm/user_64.h"
  long int signal;
  int reserved;
  int pad1;
  long unsigned int u_ar0;
# 125 "./arch/x86/include/asm/user_64.h"
  struct user_i387_struct *u_fpstate;
  long unsigned int magic;
  char u_comm[32U];
  long unsigned int u_debugreg[8U];
  long unsigned int error_code;
  long unsigned int fault_address;
};
struct user_ymmh_regs
{
# 14 "./arch/x86/include/asm/user.h"
  __u32 ymmh_space[64U];
};
struct user_xsave_hdr
{
  __u64 xstate_bv;
  __u64 reserved1[2U];
  __u64 reserved2[5U];
};
struct user_xstateregs
{
# 57 "./arch/x86/include/asm/user.h"
  struct
  {
# 55 "./arch/x86/include/asm/user.h"
    __u64 fpx_space[58U];
    __u64 xstate_fx_sw[6U];
  } i387;
  struct user_xsave_hdr xsave_hdr;
  struct user_ymmh_regs ymmh;
};
# 13 "./arch/x86/include/asm/elf.h"
typedef long unsigned int elf_greg_t;
# 16 "./arch/x86/include/asm/elf.h"
typedef elf_greg_t elf_gregset_t[27U];
# 18 "./arch/x86/include/asm/elf.h"
typedef struct user_i387_struct elf_fpregset_t;
enum page_debug_flags
{
  PAGE_DEBUG_FLAG_POISON = 0,
  PAGE_DEBUG_FLAG_GUARD = 1
};
struct inode;
enum uprobe_filter_ctx
{
  UPROBE_FILTER_REGISTER = 0,
  UPROBE_FILTER_UNREGISTER = 1,
  UPROBE_FILTER_MMAP = 2
};
struct uprobe_consumer
{
# 49 "include/linux/uprobes.h"
  int (*handler)(struct uprobe_consumer *, struct pt_regs *);
  int (*ret_handler)(struct uprobe_consumer *, long unsigned int, struct pt_regs *);
# 53 "include/linux/uprobes.h"
  bool (*filter)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);
# 57 "include/linux/uprobes.h"
  struct uprobe_consumer *next;
};
# 28 "./arch/x86/include/asm/uprobes.h"
typedef u8 uprobe_opcode_t;
struct uprobe_xol_ops;
struct arch_uprobe
{
# 42 "./arch/x86/include/asm/uprobes.h"
  union
  {
# 40 "./arch/x86/include/asm/uprobes.h"
    u8 insn[16U];
    u8 ixol[16U];
  } ldv_14119;
# 44 "./arch/x86/include/asm/uprobes.h"
  struct uprobe_xol_ops const *ops;
# 56 "./arch/x86/include/asm/uprobes.h"
  union
  {
# 51 "./arch/x86/include/asm/uprobes.h"
    struct
    {
# 48 "./arch/x86/include/asm/uprobes.h"
      s32 offs;
      u8 ilen;
      u8 opc1;
    } branch;
# 55 "./arch/x86/include/asm/uprobes.h"
    struct
    {
# 53 "./arch/x86/include/asm/uprobes.h"
      u8 fixups;
      u8 ilen;
    } defparam;
  } ldv_14131;
};
struct arch_uprobe_task
{
# 61 "./arch/x86/include/asm/uprobes.h"
  long unsigned int saved_scratch_register;
# 63 "./arch/x86/include/asm/uprobes.h"
  unsigned int saved_trap_nr;
  unsigned int saved_tf;
};
enum uprobe_task_state
{
  UTASK_RUNNING = 0,
  UTASK_SSTEP = 1,
  UTASK_SSTEP_ACK = 2,
  UTASK_SSTEP_TRAPPED = 3
};
struct uprobe_task
{
# 74 "include/linux/uprobes.h"
  enum uprobe_task_state state;
# 86 "include/linux/uprobes.h"
  union
  {
# 80 "include/linux/uprobes.h"
    struct
    {
# 78 "include/linux/uprobes.h"
      struct arch_uprobe_task autask;
      long unsigned int vaddr;
    } ldv_14147;
# 85 "include/linux/uprobes.h"
    struct
    {
# 83 "include/linux/uprobes.h"
      struct callback_head dup_xol_work;
      long unsigned int dup_xol_addr;
    } ldv_14151;
  } ldv_14152;
# 88 "include/linux/uprobes.h"
  struct uprobe *active_uprobe;
  long unsigned int xol_vaddr;
# 91 "include/linux/uprobes.h"
  struct return_instance *return_instances;
  unsigned int depth;
};
struct xol_area;
struct uprobes_state
{
# 98 "include/linux/uprobes.h"
  struct xol_area *xol_area;
};
# 101 "include/linux/uprobes.h"
int set_swbp(struct arch_uprobe *, struct mm_struct *, long unsigned int);
int set_orig_insn(struct arch_uprobe *, struct mm_struct *, long unsigned int);
bool is_swbp_insn(uprobe_opcode_t *);
bool is_trap_insn(uprobe_opcode_t *);
long unsigned int uprobe_get_swbp_addr(struct pt_regs *);
long unsigned int uprobe_get_trap_addr(struct pt_regs *);
int uprobe_write_opcode(struct mm_struct *, long unsigned int, uprobe_opcode_t);
int uprobe_register(struct inode *, loff_t, struct uprobe_consumer *);
int uprobe_apply(struct inode *, loff_t, struct uprobe_consumer *, bool);
void uprobe_unregister(struct inode *, loff_t, struct uprobe_consumer *);
int uprobe_mmap(struct vm_area_struct *);
void uprobe_munmap(struct vm_area_struct *, long unsigned int, long unsigned int);
void uprobe_start_dup_mmap(void);
void uprobe_end_dup_mmap(void);
void uprobe_dup_mmap(struct mm_struct *, struct mm_struct *);
void uprobe_free_utask(struct task_struct *);
void uprobe_copy_process(struct task_struct *, long unsigned int);
int uprobe_post_sstep_notifier(struct pt_regs *);
int uprobe_pre_sstep_notifier(struct pt_regs *);
void uprobe_notify_resume(struct pt_regs *);
bool uprobe_deny_signal(void);
bool arch_uprobe_skip_sstep(struct arch_uprobe *, struct pt_regs *);
void uprobe_clear_state(struct mm_struct *);
int arch_uprobe_analyze_insn(struct arch_uprobe *, struct mm_struct *, long unsigned int);
int arch_uprobe_pre_xol(struct arch_uprobe *, struct pt_regs *);
int arch_uprobe_post_xol(struct arch_uprobe *, struct pt_regs *);
bool arch_uprobe_xol_was_trapped(struct task_struct *);
int arch_uprobe_exception_notify(struct notifier_block *, long unsigned int, void *);
void arch_uprobe_abort_xol(struct arch_uprobe *, struct pt_regs *);
long unsigned int arch_uretprobe_hijack_return_addr(long unsigned int, struct pt_regs *);
bool arch_uprobe_ignore(struct arch_uprobe *, struct pt_regs *);
void arch_uprobe_copy_ixol(struct page *, long unsigned int, void *, long unsigned int);
struct address_space;
struct page
{
# 46 "include/linux/mm_types.h"
  long unsigned int flags;
# 57 "include/linux/mm_types.h"
  union
  {
# 49 "include/linux/mm_types.h"
    struct address_space *mapping;
# 56 "include/linux/mm_types.h"
    void *s_mem;
  } ldv_14261;
# 121 "include/linux/mm_types.h"
  struct
  {
# 73 "include/linux/mm_types.h"
    union
    {
# 62 "include/linux/mm_types.h"
      long unsigned int index;
      void *freelist;
      bool pfmemalloc;
    } ldv_14267;
# 120 "include/linux/mm_types.h"
    union
    {
# 79 "include/linux/mm_types.h"
      long unsigned int counters;
# 118 "include/linux/mm_types.h"
      struct
      {
# 116 "include/linux/mm_types.h"
        union
        {
# 108 "include/linux/mm_types.h"
          atomic_t _mapcount;
# 114 "include/linux/mm_types.h"
          struct
          {
# 111 "include/linux/mm_types.h"
            short unsigned int inuse;
            short unsigned int objects : 15;
            unsigned char frozen : 1;
          } ldv_14277;
          int units;
        } ldv_14279;
        atomic_t _count;
      } ldv_14281;
      unsigned int active;
    } ldv_14283;
  } ldv_14284;
# 148 "include/linux/mm_types.h"
  union
  {
# 125 "include/linux/mm_types.h"
    struct list_head lru;
# 139 "include/linux/mm_types.h"
    struct
    {
# 131 "include/linux/mm_types.h"
      struct page *next;
# 133 "include/linux/mm_types.h"
      int pages;
      int pobjects;
    } ldv_14291;
# 141 "include/linux/mm_types.h"
    struct slab *slab_page;
    struct callback_head callback_head;
# 146 "include/linux/mm_types.h"
    pgtable_t pmd_huge_pte;
  } ldv_14296;
# 168 "include/linux/mm_types.h"
  union
  {
# 152 "include/linux/mm_types.h"
    long unsigned int private;
# 161 "include/linux/mm_types.h"
    spinlock_t *ptl;
# 166 "include/linux/mm_types.h"
    struct kmem_cache *slab_cache;
    struct page *first_page;
  } ldv_14302;
# 185 "include/linux/mm_types.h"
  long unsigned int debug_flags;
};
struct page_frag
{
# 210 "include/linux/mm_types.h"
  struct page *page;
# 212 "include/linux/mm_types.h"
  __u32 offset;
  __u32 size;
};
# 220 "include/linux/mm_types.h"
typedef long unsigned int vm_flags_t;
struct vm_region
{
# 228 "include/linux/mm_types.h"
  struct rb_node vm_rb;
  vm_flags_t vm_flags;
  long unsigned int vm_start;
  long unsigned int vm_end;
  long unsigned int vm_top;
  long unsigned int vm_pgoff;
  struct file *vm_file;
# 236 "include/linux/mm_types.h"
  int vm_usage;
  bool vm_icache_flushed;
};
struct vm_area_struct
{
# 250 "include/linux/mm_types.h"
  long unsigned int vm_start;
  long unsigned int vm_end;
# 255 "include/linux/mm_types.h"
  struct vm_area_struct *vm_next;
# 255 "include/linux/mm_types.h"
  struct vm_area_struct *vm_prev;
# 257 "include/linux/mm_types.h"
  struct rb_node vm_rb;
# 265 "include/linux/mm_types.h"
  long unsigned int rb_subtree_gap;
# 269 "include/linux/mm_types.h"
  struct mm_struct *vm_mm;
  pgprot_t vm_page_prot;
  long unsigned int vm_flags;
# 284 "include/linux/mm_types.h"
  union
  {
# 282 "include/linux/mm_types.h"
    struct
    {
# 280 "include/linux/mm_types.h"
      struct rb_node rb;
      long unsigned int rb_subtree_last;
    } linear;
    struct list_head nonlinear;
  } shared;
# 292 "include/linux/mm_types.h"
  struct list_head anon_vma_chain;
# 294 "include/linux/mm_types.h"
  struct anon_vma *anon_vma;
# 297 "include/linux/mm_types.h"
  struct vm_operations_struct const *vm_ops;
# 300 "include/linux/mm_types.h"
  long unsigned int vm_pgoff;
# 302 "include/linux/mm_types.h"
  struct file *vm_file;
  void *vm_private_data;
# 309 "include/linux/mm_types.h"
  struct mempolicy *vm_policy;
};
struct core_thread
{
# 314 "include/linux/mm_types.h"
  struct task_struct *task;
  struct core_thread *next;
};
struct core_state
{
  atomic_t nr_threads;
  struct core_thread dumper;
  struct completion startup;
};
enum ldv_13856
{
  MM_FILEPAGES = 0,
  MM_ANONPAGES = 1,
  MM_SWAPENTS = 2,
  NR_MM_COUNTERS = 3
};
struct task_rss_stat
{
# 335 "include/linux/mm_types.h"
  int events;
  int count[3U];
};
struct mm_rss_stat
{
# 341 "include/linux/mm_types.h"
  atomic_long_t count[3U];
};
struct kioctx_table;
struct mm_struct
{
  struct vm_area_struct *mmap;
  struct rb_root mm_rb;
  u32 vmacache_seqnum;
# 350 "include/linux/mm_types.h"
  long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
# 354 "include/linux/mm_types.h"
  long unsigned int mmap_base;
  long unsigned int mmap_legacy_base;
  long unsigned int task_size;
  long unsigned int highest_vm_end;
  pgd_t *pgd;
  atomic_t mm_users;
  atomic_t mm_count;
  atomic_long_t nr_ptes;
  int map_count;
# 364 "include/linux/mm_types.h"
  spinlock_t page_table_lock;
  struct rw_semaphore mmap_sem;
# 367 "include/linux/mm_types.h"
  struct list_head mmlist;
# 373 "include/linux/mm_types.h"
  long unsigned int hiwater_rss;
  long unsigned int hiwater_vm;
# 376 "include/linux/mm_types.h"
  long unsigned int total_vm;
  long unsigned int locked_vm;
  long unsigned int pinned_vm;
  long unsigned int shared_vm;
  long unsigned int exec_vm;
  long unsigned int stack_vm;
  long unsigned int def_flags;
  long unsigned int start_code;
# 383 "include/linux/mm_types.h"
  long unsigned int end_code;
# 383 "include/linux/mm_types.h"
  long unsigned int start_data;
# 383 "include/linux/mm_types.h"
  long unsigned int end_data;
  long unsigned int start_brk;
# 384 "include/linux/mm_types.h"
  long unsigned int brk;
# 384 "include/linux/mm_types.h"
  long unsigned int start_stack;
  long unsigned int arg_start;
# 385 "include/linux/mm_types.h"
  long unsigned int arg_end;
# 385 "include/linux/mm_types.h"
  long unsigned int env_start;
# 385 "include/linux/mm_types.h"
  long unsigned int env_end;
# 387 "include/linux/mm_types.h"
  long unsigned int saved_auxv[46U];
# 393 "include/linux/mm_types.h"
  struct mm_rss_stat rss_stat;
# 395 "include/linux/mm_types.h"
  struct linux_binfmt *binfmt;
# 397 "include/linux/mm_types.h"
  cpumask_var_t cpu_vm_mask_var;
# 400 "include/linux/mm_types.h"
  mm_context_t context;
# 402 "include/linux/mm_types.h"
  long unsigned int flags;
# 404 "include/linux/mm_types.h"
  struct core_state *core_state;
# 406 "include/linux/mm_types.h"
  spinlock_t ioctx_lock;
  struct kioctx_table *ioctx_table;
# 420 "include/linux/mm_types.h"
  struct task_struct *owner;
# 424 "include/linux/mm_types.h"
  struct file *exe_file;
# 426 "include/linux/mm_types.h"
  struct mmu_notifier_mm *mmu_notifier_mm;
# 432 "include/linux/mm_types.h"
  struct cpumask cpumask_allocation;
# 440 "include/linux/mm_types.h"
  long unsigned int numa_next_scan;
# 443 "include/linux/mm_types.h"
  long unsigned int numa_scan_offset;
# 446 "include/linux/mm_types.h"
  int numa_scan_seq;
# 454 "include/linux/mm_types.h"
  bool tlb_flush_pending;
# 456 "include/linux/mm_types.h"
  struct uprobes_state uprobes_state;
};
# 459 "include/linux/mm_types.h"
static inline void mm_init_cpumask(struct mm_struct *mm)
{
# 462 "include/linux/mm_types.h"
  ( * mm ) . cpu_vm_mask_var = & ( * mm ) . cpumask_allocation;
# 464 "include/linux/mm_types.h"
  cpumask_clear ( ( * mm ) . cpu_vm_mask_var );
}
# 468 "include/linux/mm_types.h"
static inline cpumask_t *mm_cpumask(struct mm_struct *mm)
{
  return ( cpumask_t *) ( * mm ) . cpu_vm_mask_var;
}
# 480 "include/linux/mm_types.h"
static inline bool mm_tlb_flush_pending(struct mm_struct *mm)
{
  asm volatile ( "" : : : "memory" ) ;
  return ( * mm ) . tlb_flush_pending;
}
static inline void set_tlb_flush_pending(struct mm_struct *mm)
{
  ( * mm ) . tlb_flush_pending = 1;
# 493 "include/linux/mm_types.h"
  asm volatile ( "" : : : "memory" ) ;
}
# 496 "include/linux/mm_types.h"
static inline void clear_tlb_flush_pending(struct mm_struct *mm)
{
  asm volatile ( "" : : : "memory" ) ;
  ( * mm ) . tlb_flush_pending = 0;
}
struct vm_special_mapping
{
# 516 "include/linux/mm_types.h"
  char const *name;
  struct page **pages;
};
enum tlb_flush_reason
{
  TLB_FLUSH_ON_TASK_SWITCH = 0,
  TLB_REMOTE_SHOOTDOWN = 1,
  TLB_LOCAL_SHOOTDOWN = 2,
  TLB_LOCAL_MM_SHOOTDOWN = 3,
  NR_TLB_FLUSH_REASONS = 4
};
struct vdso_image
{
# 13 "./arch/x86/include/asm/vdso.h"
  void *data;
  long unsigned int size;
# 17 "./arch/x86/include/asm/vdso.h"
  struct vm_special_mapping text_mapping;
# 19 "./arch/x86/include/asm/vdso.h"
  long unsigned int alt;
# 19 "./arch/x86/include/asm/vdso.h"
  long unsigned int alt_len;
# 21 "./arch/x86/include/asm/vdso.h"
  long int sym_vvar_start;
# 23 "./arch/x86/include/asm/vdso.h"
  long int sym_vvar_page;
  long int sym_hpet_page;
  long int sym_VDSO32_NOTE_MASK;
  long int sym___kernel_sigreturn;
  long int sym___kernel_rt_sigreturn;
  long int sym___kernel_vsyscall;
  long int sym_VDSO32_SYSENTER_RETURN;
};
# 33 "./arch/x86/include/asm/vdso.h"
extern struct vdso_image const vdso_image_64;
# 37 "./arch/x86/include/asm/vdso.h"
extern struct vdso_image const vdso_image_x32;
# 41 "./arch/x86/include/asm/vdso.h"
extern struct vdso_image const vdso_image_32_int80;
# 43 "./arch/x86/include/asm/vdso.h"
extern struct vdso_image const vdso_image_32_syscall;
# 45 "./arch/x86/include/asm/vdso.h"
extern struct vdso_image const vdso_image_32_sysenter;
# 47 "./arch/x86/include/asm/vdso.h"
extern struct vdso_image const *selected_vdso32;
# 50 "./arch/x86/include/asm/vdso.h"
void init_vdso_image(struct vdso_image const *);
# 79 "./arch/x86/include/asm/elf.h"
extern unsigned int vdso64_enabled;
# 82 "./arch/x86/include/asm/elf.h"
extern unsigned int vdso32_enabled;
# 170 "./arch/x86/include/asm/elf.h"
static inline void elf_common_init(struct thread_struct *t, struct pt_regs *regs, u16 const ds)
{
# 173 "./arch/x86/include/asm/elf.h"
  ( * regs ) . ax = ( * regs ) . bx = ( * regs ) . cx = ( * regs ) . dx = 0UL;
  ( * regs ) . si = ( * regs ) . di = ( * regs ) . bp = 0UL;
  ( * regs ) . r8 = ( * regs ) . r9 = ( * regs ) . r10 = ( * regs ) . r11 = 0UL;
  ( * regs ) . r12 = ( * regs ) . r13 = ( * regs ) . r14 = ( * regs ) . r15 = 0UL;
  ( * t ) . fs = ( * t ) . gs = 0UL;
  ( * t ) . fsindex = ( * t ) . gsindex = 0U;
  ( * t ) . ds = ( * t ) . es = ds;
}
# 188 "./arch/x86/include/asm/elf.h"
void start_thread_ia32(struct pt_regs *, u32, u32);
# 191 "./arch/x86/include/asm/elf.h"
void set_personality_ia32(bool);
# 237 "./arch/x86/include/asm/elf.h"
void set_personality_64bit(void);
extern unsigned int sysctl_vsyscall32;
extern int force_personality32;
struct linux_binprm;
# 334 "./arch/x86/include/asm/elf.h"
int arch_setup_additional_pages(struct linux_binprm *, int);
# 336 "./arch/x86/include/asm/elf.h"
int compat_arch_setup_additional_pages(struct linux_binprm *, int);
# 340 "./arch/x86/include/asm/elf.h"
long unsigned int arch_randomize_brk(struct mm_struct *);
# 346 "./arch/x86/include/asm/elf.h"
static inline int mmap_is_ia32(void)
{
# 352 "./arch/x86/include/asm/elf.h"
  if (test_ti_thread_flag ( current_thread_info ( ) , 29 ) != 0)
    return 1;
# 355 "./arch/x86/include/asm/elf.h"
  return 0;
}
enum align_flags
{
  ALIGN_VA_32 = 1,
  ALIGN_VA_64 = 2
};
struct va_alignment
{
# 365 "./arch/x86/include/asm/elf.h"
  int flags;
  long unsigned int mask;
};
# 369 "./arch/x86/include/asm/elf.h"
extern struct va_alignment va_align;
long unsigned int align_vdso_addr(long unsigned int);
# 8 "include/uapi/linux/elf.h"
typedef __u32 Elf32_Addr;
typedef __u16 Elf32_Half;
typedef __u32 Elf32_Off;
typedef __s32 Elf32_Sword;
typedef __u32 Elf32_Word;
# 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __s16 Elf64_SHalf;
typedef __u64 Elf64_Off;
typedef __s32 Elf64_Sword;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
typedef __s64 Elf64_Sxword;
struct dynamic
{
# 138 "include/uapi/linux/elf.h"
  Elf32_Sword d_tag;
# 142 "include/uapi/linux/elf.h"
  union
  {
# 140 "include/uapi/linux/elf.h"
    Elf32_Sword d_val;
    Elf32_Addr d_ptr;
  } d_un;
};
# 143 "include/uapi/linux/elf.h"
typedef struct dynamic Elf32_Dyn;
# 151 "include/uapi/linux/elf.h"
typedef struct
{
# 146 "include/uapi/linux/elf.h"
  Elf64_Sxword d_tag;
# 150 "include/uapi/linux/elf.h"
  union
  {
# 148 "include/uapi/linux/elf.h"
    Elf64_Xword d_val;
    Elf64_Addr d_ptr;
  } d_un;
} Elf64_Dyn;
struct elf32_rel
{
# 161 "include/uapi/linux/elf.h"
  Elf32_Addr r_offset;
  Elf32_Word r_info;
};
# 163 "include/uapi/linux/elf.h"
typedef struct elf32_rel Elf32_Rel;
struct elf64_rel
{
  Elf64_Addr r_offset;
  Elf64_Xword r_info;
};
# 168 "include/uapi/linux/elf.h"
typedef struct elf64_rel Elf64_Rel;
struct elf32_rela
{
  Elf32_Addr r_offset;
  Elf32_Word r_info;
  Elf32_Sword r_addend;
};
# 174 "include/uapi/linux/elf.h"
typedef struct elf32_rela Elf32_Rela;
struct elf64_rela
{
  Elf64_Addr r_offset;
  Elf64_Xword r_info;
  Elf64_Sxword r_addend;
};
# 180 "include/uapi/linux/elf.h"
typedef struct elf64_rela Elf64_Rela;
struct elf32_sym
{
  Elf32_Word st_name;
  Elf32_Addr st_value;
  Elf32_Word st_size;
  unsigned char st_info;
  unsigned char st_other;
  Elf32_Half st_shndx;
};
# 189 "include/uapi/linux/elf.h"
typedef struct elf32_sym Elf32_Sym;
struct elf64_sym
{
  Elf64_Word st_name;
  unsigned char st_info;
  unsigned char st_other;
  Elf64_Half st_shndx;
  Elf64_Addr st_value;
  Elf64_Xword st_size;
};
# 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
struct elf32_hdr
{
# 204 "include/uapi/linux/elf.h"
  unsigned char e_ident[16U];
  Elf32_Half e_type;
  Elf32_Half e_machine;
  Elf32_Word e_version;
  Elf32_Addr e_entry;
  Elf32_Off e_phoff;
  Elf32_Off e_shoff;
  Elf32_Word e_flags;
  Elf32_Half e_ehsize;
  Elf32_Half e_phentsize;
  Elf32_Half e_phnum;
  Elf32_Half e_shentsize;
  Elf32_Half e_shnum;
  Elf32_Half e_shstrndx;
};
# 218 "include/uapi/linux/elf.h"
typedef struct elf32_hdr Elf32_Ehdr;
struct elf64_hdr
{
  unsigned char e_ident[16U];
  Elf64_Half e_type;
  Elf64_Half e_machine;
  Elf64_Word e_version;
  Elf64_Addr e_entry;
  Elf64_Off e_phoff;
  Elf64_Off e_shoff;
  Elf64_Word e_flags;
  Elf64_Half e_ehsize;
  Elf64_Half e_phentsize;
  Elf64_Half e_phnum;
  Elf64_Half e_shentsize;
  Elf64_Half e_shnum;
  Elf64_Half e_shstrndx;
};
# 235 "include/uapi/linux/elf.h"
typedef struct elf64_hdr Elf64_Ehdr;
struct elf32_phdr
{
# 244 "include/uapi/linux/elf.h"
  Elf32_Word p_type;
  Elf32_Off p_offset;
  Elf32_Addr p_vaddr;
  Elf32_Addr p_paddr;
  Elf32_Word p_filesz;
  Elf32_Word p_memsz;
  Elf32_Word p_flags;
  Elf32_Word p_align;
};
# 252 "include/uapi/linux/elf.h"
typedef struct elf32_phdr Elf32_Phdr;
struct elf64_phdr
{
  Elf64_Word p_type;
  Elf64_Word p_flags;
  Elf64_Off p_offset;
  Elf64_Addr p_vaddr;
  Elf64_Addr p_paddr;
  Elf64_Xword p_filesz;
  Elf64_Xword p_memsz;
  Elf64_Xword p_align;
};
# 263 "include/uapi/linux/elf.h"
typedef struct elf64_phdr Elf64_Phdr;
struct elf32_shdr
{
# 300 "include/uapi/linux/elf.h"
  Elf32_Word sh_name;
  Elf32_Word sh_type;
  Elf32_Word sh_flags;
  Elf32_Addr sh_addr;
  Elf32_Off sh_offset;
  Elf32_Word sh_size;
  Elf32_Word sh_link;
  Elf32_Word sh_info;
  Elf32_Word sh_addralign;
  Elf32_Word sh_entsize;
};
# 310 "include/uapi/linux/elf.h"
typedef struct elf32_shdr Elf32_Shdr;
struct elf64_shdr
{
  Elf64_Word sh_name;
  Elf64_Word sh_type;
  Elf64_Xword sh_flags;
  Elf64_Addr sh_addr;
  Elf64_Off sh_offset;
  Elf64_Xword sh_size;
  Elf64_Word sh_link;
  Elf64_Word sh_info;
  Elf64_Xword sh_addralign;
  Elf64_Xword sh_entsize;
};
# 323 "include/uapi/linux/elf.h"
typedef struct elf64_shdr Elf64_Shdr;
struct elf32_note
{
# 405 "include/uapi/linux/elf.h"
  Elf32_Word n_namesz;
  Elf32_Word n_descsz;
  Elf32_Word n_type;
};
# 408 "include/uapi/linux/elf.h"
typedef struct elf32_note Elf32_Nhdr;
struct elf64_note
{
# 412 "include/uapi/linux/elf.h"
  Elf64_Word n_namesz;
  Elf64_Word n_descsz;
  Elf64_Word n_type;
};
# 415 "include/uapi/linux/elf.h"
typedef struct elf64_note Elf64_Nhdr;
# 30 "include/linux/elf.h"
extern Elf64_Dyn _DYNAMIC[];
struct coredump_params;
# 45 "include/linux/elf.h"
static inline int elf_coredump_extra_notes_size(void)
{
# 45 "include/linux/elf.h"
  return 0;
}
# 46 "include/linux/elf.h"
static inline int elf_coredump_extra_notes_write(struct coredump_params *cprm)
{
# 46 "include/linux/elf.h"
  return 0;
}
struct idr_layer
{
# 31 "include/linux/idr.h"
  int prefix;
  int layer;
  struct idr_layer *ary[256U];
  int count;
# 39 "include/linux/idr.h"
  union
  {
# 37 "include/linux/idr.h"
    long unsigned int bitmap[4U];
    struct callback_head callback_head;
  } ldv_14671;
};
struct idr
{
  struct idr_layer *hint;
  struct idr_layer *top;
  int layers;
  int cur;
  spinlock_t lock;
  int id_free_cnt;
  struct idr_layer *id_free;
};
# 79 "include/linux/idr.h"
void *idr_find_slowpath(struct idr *, int);
void idr_preload(gfp_t);
int idr_alloc(struct idr *, void *, int, int, gfp_t);
int idr_alloc_cyclic(struct idr *, void *, int, int, gfp_t);
int idr_for_each(struct idr *, int (*)(int, void *, void *), void *);
# 85 "include/linux/idr.h"
void *idr_get_next(struct idr *, int *);
void *idr_replace(struct idr *, void *, int);
void idr_remove(struct idr *, int);
void idr_destroy(struct idr *);
void idr_init(struct idr *);
bool idr_is_empty(struct idr *);
# 98 "include/linux/idr.h"
static inline void idr_preload_end(void)
{
  asm volatile ( "" : : : "memory" ) ;
# 100 "include/linux/idr.h"
  __preempt_count_sub ( 1 );
}
# 115 "include/linux/idr.h"
static inline void *idr_find(struct idr *idr, int id)
{
  struct idr_layer *hint = ({
# 117 "include/linux/idr.h"
    struct idr_layer *_________p1 = * ( struct idr_layer *volatile *) & ( * idr ) . hint;
    {
# 117 "include/linux/idr.h"
      bool __warned;
# 117 "include/linux/idr.h"
      if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && ( rcu_read_lock_held ( ), 0 ))
      {
# 117 "include/linux/idr.h"
        __warned = 1;
# 117 "include/linux/idr.h"
        lockdep_rcu_suspicious ( ( char const *) "include/linux/idr.h" , 117 , ( char const *) "suspicious rcu_dereference_check() usage" );
      }
    }
    {
    }
# 117 "include/linux/idr.h"
    _________p1;
  } );
  if (hint != ( ( struct idr_layer *) 0 ) && ( id & -256 ) == ( * hint ) . prefix)
    return ( void *) ({
# 120 "include/linux/idr.h"
      struct idr_layer *_________p1 = * ( ( struct idr_layer *volatile *) & ( * hint ) . ary + ( ( long unsigned int ) ( long unsigned int ) id & 255U ) );
      {
# 120 "include/linux/idr.h"
        bool __warned;
# 120 "include/linux/idr.h"
        if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && ( rcu_read_lock_held ( ), 0 ))
        {
# 120 "include/linux/idr.h"
          __warned = 1;
# 120 "include/linux/idr.h"
          lockdep_rcu_suspicious ( ( char const *) "include/linux/idr.h" , 120 , ( char const *) "suspicious rcu_dereference_check() usage" );
        }
      }
      {
      }
# 120 "include/linux/idr.h"
      _________p1;
    } );
  return idr_find_slowpath ( idr , id );
}
struct ida_bitmap
{
# 150 "include/linux/idr.h"
  long int nr_busy;
  long unsigned int bitmap[15U];
};
struct ida
{
  struct idr idr;
  struct ida_bitmap *free_bitmap;
};
# 162 "include/linux/idr.h"
int ida_pre_get(struct ida *, gfp_t);
int ida_get_new_above(struct ida *, int, int *);
void ida_remove(struct ida *, int);
void ida_destroy(struct ida *);
void ida_init(struct ida *);
# 168 "include/linux/idr.h"
int ida_simple_get(struct ida *, unsigned int, unsigned int, gfp_t);
# 170 "include/linux/idr.h"
void ida_simple_remove(struct ida *, unsigned int);
# 179 "include/linux/idr.h"
static inline int ida_get_new(struct ida *ida, int *p_id)
{
  return ida_get_new_above ( ida , 0 , p_id );
}
# 184 "include/linux/idr.h"
void idr_init_cache(void);
struct dentry;
struct iattr;
struct super_block;
struct file_system_type;
struct kernfs_open_node;
struct kernfs_iattrs;
enum kernfs_node_type
{
  KERNFS_DIR = 1,
  KERNFS_FILE = 2,
  KERNFS_LINK = 4
};
enum kernfs_node_flag
{
  KERNFS_ACTIVATED = 16,
  KERNFS_NS = 32,
  KERNFS_HAS_SEQ_SHOW = 64,
  KERNFS_HAS_MMAP = 128,
  KERNFS_LOCKDEP = 256,
  KERNFS_STATIC_NAME = 512,
  KERNFS_SUICIDAL = 1024,
  KERNFS_SUICIDED = 2048
};
enum kernfs_root_flag
{
  KERNFS_ROOT_CREATE_DEACTIVATED = 1,
  KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2
};
struct kernfs_elem_dir
{
# 75 "include/linux/kernfs.h"
  long unsigned int subdirs;
# 77 "include/linux/kernfs.h"
  struct rb_root children;
# 83 "include/linux/kernfs.h"
  struct kernfs_root *root;
};
struct kernfs_elem_symlink
{
  struct kernfs_node *target_kn;
};
struct kernfs_elem_attr
{
  struct kernfs_ops const *ops;
  struct kernfs_open_node *open;
  loff_t size;
  struct kernfs_node *notify_next;
};
struct kernfs_node
{
# 107 "include/linux/kernfs.h"
  atomic_t count;
  atomic_t active;
# 110 "include/linux/kernfs.h"
  struct lockdep_map dep_map;
# 118 "include/linux/kernfs.h"
  struct kernfs_node *parent;
  char const *name;
# 121 "include/linux/kernfs.h"
  struct rb_node rb;
# 123 "include/linux/kernfs.h"
  void const *ns;
  unsigned int hash;
# 129 "include/linux/kernfs.h"
  union
  {
# 126 "include/linux/kernfs.h"
    struct kernfs_elem_dir dir;
    struct kernfs_elem_symlink symlink;
    struct kernfs_elem_attr attr;
  } ldv_14816;
# 131 "include/linux/kernfs.h"
  void *priv;
# 133 "include/linux/kernfs.h"
  short unsigned int flags;
  umode_t mode;
  unsigned int ino;
  struct kernfs_iattrs *iattr;
};
struct kernfs_syscall_ops
{
# 147 "include/linux/kernfs.h"
  int (*remount_fs)(struct kernfs_root *, int *, char *);
  int (*show_options)(struct seq_file *, struct kernfs_root *);
# 150 "include/linux/kernfs.h"
  int (*mkdir)(struct kernfs_node *, char const *, umode_t);
# 152 "include/linux/kernfs.h"
  int (*rmdir)(struct kernfs_node *);
  int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *);
};
struct kernfs_root
{
# 159 "include/linux/kernfs.h"
  struct kernfs_node *kn;
  unsigned int flags;
# 163 "include/linux/kernfs.h"
  struct ida ino_ida;
  struct kernfs_syscall_ops *syscall_ops;
# 167 "include/linux/kernfs.h"
  struct list_head supers;
# 169 "include/linux/kernfs.h"
  wait_queue_head_t deactivate_waitq;
};
struct kernfs_open_file
{
# 174 "include/linux/kernfs.h"
  struct kernfs_node *kn;
  struct file *file;
  void *priv;
# 179 "include/linux/kernfs.h"
  struct mutex mutex;
  int event;
  struct list_head list;
# 183 "include/linux/kernfs.h"
  size_t atomic_write_len;
  bool mmapped;
  struct vm_operations_struct const *vm_ops;
};
struct kernfs_ops
{
# 200 "include/linux/kernfs.h"
  int (*seq_show)(struct seq_file *, void *);
# 202 "include/linux/kernfs.h"
  void *(*seq_start)(struct seq_file *, loff_t *);
  void *(*seq_next)(struct seq_file *, void *, loff_t *);
  void (*seq_stop)(struct seq_file *, void *);
# 206 "include/linux/kernfs.h"
  ssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);
# 216 "include/linux/kernfs.h"
  size_t atomic_write_len;
  ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
# 220 "include/linux/kernfs.h"
  int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);
# 223 "include/linux/kernfs.h"
  struct lock_class_key lockdep_key;
};
# 229 "include/linux/kernfs.h"
static inline enum kernfs_node_type kernfs_type(struct kernfs_node *kn)
{
  return ( enum kernfs_node_type ) ( ( int ) ( * kn ) . flags & 15 );
}
# 242 "include/linux/kernfs.h"
static inline void kernfs_enable_ns(struct kernfs_node *kn)
{
  ({
# 244 "include/linux/kernfs.h"
    bool __warned;
# 244 "include/linux/kernfs.h"
    int __ret_warn_once = ( unsigned int ) kernfs_type ( kn ) != 1U;
    {
# 244 "include/linux/kernfs.h"
      if (__builtin_expect ( __ret_warn_once != 0 , 0L ) != 0L)
# 244 "include/linux/kernfs.h"
        if (({
# 244 "include/linux/kernfs.h"
          int __ret_warn_on = ( int ) ! ( _Bool ) __warned;
          {
# 244 "include/linux/kernfs.h"
            if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 244 "include/linux/kernfs.h"
              warn_slowpath_null ( ( char const *) "include/linux/kernfs.h" , 244 );
          }
# 244 "include/linux/kernfs.h"
          __builtin_expect ( __ret_warn_on != 0 , 0L );
        } )
# 244 "include/linux/kernfs.h"
        != 0L)
# 244 "include/linux/kernfs.h"
          __warned = 1;
    }
# 244 "include/linux/kernfs.h"
    __builtin_expect ( __ret_warn_once != 0 , 0L );
  } );
# 245 "include/linux/kernfs.h"
  ({
# 245 "include/linux/kernfs.h"
    bool __warned;
# 245 "include/linux/kernfs.h"
    int __ret_warn_once = ( * kn ) . ldv_14816 . dir . children . rb_node != ( ( struct rb_node *) 0 );
    {
# 245 "include/linux/kernfs.h"
      if (__builtin_expect ( __ret_warn_once != 0 , 0L ) != 0L)
# 245 "include/linux/kernfs.h"
        if (({
# 245 "include/linux/kernfs.h"
          int __ret_warn_on = ( int ) ! ( _Bool ) __warned;
          {
# 245 "include/linux/kernfs.h"
            if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 245 "include/linux/kernfs.h"
              warn_slowpath_null ( ( char const *) "include/linux/kernfs.h" , 245 );
          }
# 245 "include/linux/kernfs.h"
          __builtin_expect ( __ret_warn_on != 0 , 0L );
        } )
# 245 "include/linux/kernfs.h"
        != 0L)
# 245 "include/linux/kernfs.h"
          __warned = 1;
    }
# 245 "include/linux/kernfs.h"
    __builtin_expect ( __ret_warn_once != 0 , 0L );
  } );
# 246 "include/linux/kernfs.h"
  ( * kn ) . flags |= 32U;
}
# 255 "include/linux/kernfs.h"
static inline bool kernfs_ns_enabled(struct kernfs_node *kn)
{
  return ( ( int ) ( * kn ) . flags & 32 ) != 0;
}
# 260 "include/linux/kernfs.h"
int kernfs_name(struct kernfs_node *, char *, size_t);
char *kernfs_path(struct kernfs_node *, char *, size_t);
# 263 "include/linux/kernfs.h"
void pr_cont_kernfs_name(struct kernfs_node *);
void pr_cont_kernfs_path(struct kernfs_node *);
struct kernfs_node *kernfs_get_parent(struct kernfs_node *);
struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *, char const *, void const *);
# 268 "include/linux/kernfs.h"
void kernfs_get(struct kernfs_node *);
void kernfs_put(struct kernfs_node *);
# 271 "include/linux/kernfs.h"
struct kernfs_node *kernfs_node_from_dentry(struct dentry *);
struct kernfs_root *kernfs_root_from_sb(struct super_block *);
# 274 "include/linux/kernfs.h"
struct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *, unsigned int, void *);
# 276 "include/linux/kernfs.h"
void kernfs_destroy_root(struct kernfs_root *);
# 278 "include/linux/kernfs.h"
struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *, char const *, umode_t, void *, void const *);
# 281 "include/linux/kernfs.h"
struct kernfs_node *__kernfs_create_file(struct kernfs_node *, char const *, umode_t, loff_t, struct kernfs_ops const *, void *, void const *, bool, struct lock_class_key *);
# 288 "include/linux/kernfs.h"
struct kernfs_node *kernfs_create_link(struct kernfs_node *, char const *, struct kernfs_node *);
# 291 "include/linux/kernfs.h"
void kernfs_activate(struct kernfs_node *);
void kernfs_remove(struct kernfs_node *);
void kernfs_break_active_protection(struct kernfs_node *);
void kernfs_unbreak_active_protection(struct kernfs_node *);
bool kernfs_remove_self(struct kernfs_node *);
int kernfs_remove_by_name_ns(struct kernfs_node *, char const *, void const *);
# 298 "include/linux/kernfs.h"
int kernfs_rename_ns(struct kernfs_node *, struct kernfs_node *, char const *, void const *);
# 300 "include/linux/kernfs.h"
int kernfs_setattr(struct kernfs_node *, struct iattr const *);
void kernfs_notify(struct kernfs_node *);
# 303 "include/linux/kernfs.h"
void const *kernfs_super_ns(struct super_block *);
struct dentry *kernfs_mount_ns(struct file_system_type *, int, struct kernfs_root *, long unsigned int, bool *, void const *);
# 307 "include/linux/kernfs.h"
void kernfs_kill_sb(struct super_block *);
struct super_block *kernfs_pin_sb(struct kernfs_root *, void const *);
# 310 "include/linux/kernfs.h"
void kernfs_init(void);
# 411 "include/linux/kernfs.h"
static inline struct kernfs_node *kernfs_find_and_get(struct kernfs_node *kn, char const *name)
{
  return kernfs_find_and_get_ns ( kn , name , ( ( void const *) 0 ) );
}
# 417 "include/linux/kernfs.h"
static inline struct kernfs_node *kernfs_create_dir(struct kernfs_node *parent, char const *name, umode_t mode, void *priv)
{
# 420 "include/linux/kernfs.h"
  return kernfs_create_dir_ns ( parent , name , ( int ) mode , priv , ( ( void const *) 0 ) );
}
# 424 "include/linux/kernfs.h"
static inline struct kernfs_node *kernfs_create_file_ns(struct kernfs_node *parent, char const *name, umode_t mode, loff_t size, struct kernfs_ops const *ops, void *priv, void const *ns)
{
# 428 "include/linux/kernfs.h"
  struct lock_class_key *key = ( ( struct lock_class_key *) 0 );
# 431 "include/linux/kernfs.h"
  key = ( struct lock_class_key *) & ( * ops ) . lockdep_key;
# 433 "include/linux/kernfs.h"
  return __kernfs_create_file ( parent , name , ( int ) mode , size , ops , priv , ns , 0 , key );
}
# 438 "include/linux/kernfs.h"
static inline struct kernfs_node *kernfs_create_file(struct kernfs_node *parent, char const *name, umode_t mode, loff_t size, struct kernfs_ops const *ops, void *priv)
{
# 441 "include/linux/kernfs.h"
  return kernfs_create_file_ns ( parent , name , ( int ) mode , size , ops , priv , ( ( void const *) 0 ) );
}
# 444 "include/linux/kernfs.h"
static inline int kernfs_remove_by_name(struct kernfs_node *parent, char const *name)
{
# 447 "include/linux/kernfs.h"
  return kernfs_remove_by_name_ns ( parent , name , ( ( void const *) 0 ) );
}
# 450 "include/linux/kernfs.h"
static inline int kernfs_rename(struct kernfs_node *kn, struct kernfs_node *new_parent, char const *new_name)
{
# 454 "include/linux/kernfs.h"
  return kernfs_rename_ns ( kn , new_parent , new_name , ( ( void const *) 0 ) );
}
# 458 "include/linux/kernfs.h"
static inline struct dentry *kernfs_mount(struct file_system_type *fs_type, int flags, struct kernfs_root *root, long unsigned int magic, bool *new_sb_created)
{
# 462 "include/linux/kernfs.h"
  return kernfs_mount_ns ( fs_type , flags , root , magic , new_sb_created , ( ( void const *) 0 ) );
}
struct sock;
struct kobject;
enum kobj_ns_type
{
  KOBJ_NS_TYPE_NONE = 0,
  KOBJ_NS_TYPE_NET = 1,
  KOBJ_NS_TYPES = 2
};
struct kobj_ns_type_operations
{
# 41 "include/linux/kobject_ns.h"
  enum kobj_ns_type type;
  bool (*current_may_mount)(void);
  void *(*grab_current_ns)(void);
  void const *(*netlink_ns)(struct sock *);
  void const *(*initial_ns)(void);
  void (*drop_ns)(void *);
};
# 49 "include/linux/kobject_ns.h"
int kobj_ns_type_register(struct kobj_ns_type_operations const *);
int kobj_ns_type_registered(enum kobj_ns_type);
struct kobj_ns_type_operations const *kobj_child_ns_ops(struct kobject *);
struct kobj_ns_type_operations const *kobj_ns_ops(struct kobject *);
# 54 "include/linux/kobject_ns.h"
bool kobj_ns_current_may_mount(enum kobj_ns_type);
void *kobj_ns_grab_current(enum kobj_ns_type);
void const *kobj_ns_netlink(enum kobj_ns_type, struct sock *);
void const *kobj_ns_initial(enum kobj_ns_type);
void kobj_ns_drop(enum kobj_ns_type, void *);
struct bin_attribute;
struct attribute
{
# 30 "include/linux/sysfs.h"
  char const *name;
  umode_t mode;
# 33 "include/linux/sysfs.h"
  bool ignore_lockdep;
  struct lock_class_key *key;
  struct lock_class_key skey;
};
struct attribute_group
{
# 61 "include/linux/sysfs.h"
  char const *name;
  umode_t (*is_visible)(struct kobject *, struct attribute *, int);
# 64 "include/linux/sysfs.h"
  struct attribute **attrs;
  struct bin_attribute **bin_attrs;
};
struct bin_attribute
{
# 122 "include/linux/sysfs.h"
  struct attribute attr;
  size_t size;
  void *private;
  ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
# 127 "include/linux/sysfs.h"
  ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
# 129 "include/linux/sysfs.h"
  int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *);
};
struct sysfs_ops
{
# 176 "include/linux/sysfs.h"
  ssize_t (*show)(struct kobject *, struct attribute *, char *);
  ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t);
};
# 182 "include/linux/sysfs.h"
int sysfs_create_dir_ns(struct kobject *, void const *);
void sysfs_remove_dir(struct kobject *);
int sysfs_rename_dir_ns(struct kobject *, char const *, void const *);
# 186 "include/linux/sysfs.h"
int sysfs_move_dir_ns(struct kobject *, struct kobject *, void const *);
# 190 "include/linux/sysfs.h"
int sysfs_create_file_ns(struct kobject *, struct attribute const *, void const *);
# 193 "include/linux/sysfs.h"
int sysfs_create_files(struct kobject *, struct attribute const **);
# 195 "include/linux/sysfs.h"
int sysfs_chmod_file(struct kobject *, struct attribute const *, umode_t);
# 197 "include/linux/sysfs.h"
void sysfs_remove_file_ns(struct kobject *, struct attribute const *, void const *);
# 199 "include/linux/sysfs.h"
bool sysfs_remove_file_self(struct kobject *, struct attribute const *);
void sysfs_remove_files(struct kobject *, struct attribute const **);
# 202 "include/linux/sysfs.h"
int sysfs_create_bin_file(struct kobject *, struct bin_attribute const *);
# 204 "include/linux/sysfs.h"
void sysfs_remove_bin_file(struct kobject *, struct bin_attribute const *);
# 207 "include/linux/sysfs.h"
int sysfs_create_link(struct kobject *, struct kobject *, char const *);
# 209 "include/linux/sysfs.h"
int sysfs_create_link_nowarn(struct kobject *, struct kobject *, char const *);
# 212 "include/linux/sysfs.h"
void sysfs_remove_link(struct kobject *, char const *);
# 214 "include/linux/sysfs.h"
int sysfs_rename_link_ns(struct kobject *, struct kobject *, char const *, char const *, void const *);
# 218 "include/linux/sysfs.h"
void sysfs_delete_link(struct kobject *, struct kobject *, char const *);
# 221 "include/linux/sysfs.h"
int sysfs_create_group(struct kobject *, struct attribute_group const *);
# 223 "include/linux/sysfs.h"
int sysfs_create_groups(struct kobject *, struct attribute_group const **);
# 225 "include/linux/sysfs.h"
int sysfs_update_group(struct kobject *, struct attribute_group const *);
# 227 "include/linux/sysfs.h"
void sysfs_remove_group(struct kobject *, struct attribute_group const *);
# 229 "include/linux/sysfs.h"
void sysfs_remove_groups(struct kobject *, struct attribute_group const **);
# 231 "include/linux/sysfs.h"
int sysfs_add_file_to_group(struct kobject *, struct attribute const *, char const *);
# 233 "include/linux/sysfs.h"
void sysfs_remove_file_from_group(struct kobject *, struct attribute const *, char const *);
# 235 "include/linux/sysfs.h"
int sysfs_merge_group(struct kobject *, struct attribute_group const *);
# 237 "include/linux/sysfs.h"
void sysfs_unmerge_group(struct kobject *, struct attribute_group const *);
# 239 "include/linux/sysfs.h"
int sysfs_add_link_to_group(struct kobject *, char const *, struct kobject *, char const *);
# 241 "include/linux/sysfs.h"
void sysfs_remove_link_from_group(struct kobject *, char const *, char const *);
# 244 "include/linux/sysfs.h"
void sysfs_notify(struct kobject *, char const *, char const *);
# 246 "include/linux/sysfs.h"
int sysfs_init(void);
# 248 "include/linux/sysfs.h"
static inline void sysfs_enable_ns(struct kernfs_node *kn)
{
  return & kernfs_enable_ns;
}
# 431 "include/linux/sysfs.h"
static inline int sysfs_create_file(struct kobject *kobj, struct attribute const *attr)
{
# 434 "include/linux/sysfs.h"
  return sysfs_create_file_ns ( kobj , attr , ( ( void const *) 0 ) );
}
# 437 "include/linux/sysfs.h"
static inline void sysfs_remove_file(struct kobject *kobj, struct attribute const *attr)
{
# 440 "include/linux/sysfs.h"
  sysfs_remove_file_ns ( kobj , attr , ( ( void const *) 0 ) );
}
# 443 "include/linux/sysfs.h"
static inline int sysfs_rename_link(struct kobject *kobj, struct kobject *target, char const *old_name, char const *new_name)
{
# 446 "include/linux/sysfs.h"
  return sysfs_rename_link_ns ( kobj , target , old_name , new_name , ( ( void const *) 0 ) );
}
# 449 "include/linux/sysfs.h"
static inline void sysfs_notify_dirent(struct kernfs_node *kn)
{
  kernfs_notify ( kn );
}
# 454 "include/linux/sysfs.h"
static inline struct kernfs_node *sysfs_get_dirent(struct kernfs_node *parent, unsigned char const *name)
{
# 457 "include/linux/sysfs.h"
  return kernfs_find_and_get ( parent , ( char const *) name );
}
# 460 "include/linux/sysfs.h"
static inline struct kernfs_node *sysfs_get(struct kernfs_node *kn)
{
  kernfs_get ( kn );
  return kn;
}
# 466 "include/linux/sysfs.h"
static inline void sysfs_put(struct kernfs_node *kn)
{
  kernfs_put ( kn );
}
struct kref
{
# 25 "include/linux/kref.h"
  atomic_t refcount;
};
# 32 "include/linux/kref.h"
static inline void kref_init(struct kref *kref)
{
  atomic_set ( & ( * kref ) . refcount , 1 );
}
# 41 "include/linux/kref.h"
static inline void kref_get(struct kref *kref)
{
# 47 "include/linux/kref.h"
  ({
# 47 "include/linux/kref.h"
    bool __warned;
# 47 "include/linux/kref.h"
    int __ret_warn_once = atomic_add_return ( 1 , & ( * kref ) . refcount ) <= 1;
    {
# 47 "include/linux/kref.h"
      if (__builtin_expect ( __ret_warn_once != 0 , 0L ) != 0L)
# 47 "include/linux/kref.h"
        if (({
# 47 "include/linux/kref.h"
          int __ret_warn_on = ( int ) ! ( _Bool ) __warned;
          {
# 47 "include/linux/kref.h"
            if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 47 "include/linux/kref.h"
              warn_slowpath_null ( ( char const *) "include/linux/kref.h" , 47 );
          }
# 47 "include/linux/kref.h"
          __builtin_expect ( __ret_warn_on != 0 , 0L );
        } )
# 47 "include/linux/kref.h"
        != 0L)
# 47 "include/linux/kref.h"
          __warned = 1;
    }
# 47 "include/linux/kref.h"
    __builtin_expect ( __ret_warn_once != 0 , 0L );
  } );
}
# 68 "include/linux/kref.h"
static inline int kref_sub(struct kref *kref, unsigned int count, void (*release)(struct kref *))
{
# 71 "include/linux/kref.h"
  ({
# 71 "include/linux/kref.h"
    int __ret_warn_on = release == ( ( void (*)(struct kref *)) 0 );
    {
# 71 "include/linux/kref.h"
      if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 71 "include/linux/kref.h"
        warn_slowpath_null ( ( char const *) "include/linux/kref.h" , 71 );
    }
# 71 "include/linux/kref.h"
    __builtin_expect ( __ret_warn_on != 0 , 0L );
  } );
  if (atomic_sub_and_test ( ( int ) count , & ( * kref ) . refcount ) != 0)
  {
# 74 "include/linux/kref.h"
    release ( kref );
    return 1;
  }
  return 0;
}
# 97 "include/linux/kref.h"
static inline int kref_put(struct kref *kref, void (*release)(struct kref *))
{
  return kref_sub ( kref , 1U , release );
}
# 115 "include/linux/kref.h"
static inline int kref_put_spinlock_irqsave(struct kref *kref, void (*release)(struct kref *), spinlock_t *lock)
{
# 119 "include/linux/kref.h"
  long unsigned int flags;
# 121 "include/linux/kref.h"
  ({
# 121 "include/linux/kref.h"
    int __ret_warn_on = release == ( ( void (*)(struct kref *)) 0 );
    {
# 121 "include/linux/kref.h"
      if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 121 "include/linux/kref.h"
        warn_slowpath_null ( ( char const *) "include/linux/kref.h" , 121 );
    }
# 121 "include/linux/kref.h"
    __builtin_expect ( __ret_warn_on != 0 , 0L );
  } );
# 122 "include/linux/kref.h"
  if (atomic_add_unless ( & ( * kref ) . refcount , -1 , 1 ) != 0)
    return 0;
  ({
# 124 "include/linux/kref.h"
    long unsigned int __dummy;
# 124 "include/linux/kref.h"
    long unsigned int __dummy2;
# 124 "include/linux/kref.h"
    ( void ) 0;
# 124 "include/linux/kref.h"
    1;
  } );
# 124 "include/linux/kref.h"
  flags = _raw_spin_lock_irqsave ( spinlock_check ( lock ) );
  if (atomic_dec_and_test ( & ( * kref ) . refcount ) != 0)
  {
# 126 "include/linux/kref.h"
    release ( kref );
    if (({
# 127 "include/linux/kref.h"
      ({
# 127 "include/linux/kref.h"
        long unsigned int __dummy;
# 127 "include/linux/kref.h"
        long unsigned int __dummy2;
# 127 "include/linux/kref.h"
        ( void ) 0;
# 127 "include/linux/kref.h"
        1;
      } );
# 127 "include/linux/kref.h"
      arch_irqs_disabled_flags ( flags );
    } )
# 127 "include/linux/kref.h"
    != 0)
    {
# 127 "include/linux/kref.h"
      ({
# 127 "include/linux/kref.h"
        long unsigned int __dummy;
# 127 "include/linux/kref.h"
        long unsigned int __dummy2;
# 127 "include/linux/kref.h"
        ( void ) 0;
# 127 "include/linux/kref.h"
        1;
      } );
# 127 "include/linux/kref.h"
      arch_local_irq_restore ( flags );
# 127 "include/linux/kref.h"
      trace_hardirqs_off ( );
    }
    else
    {
# 127 "include/linux/kref.h"
      trace_hardirqs_on ( );
# 127 "include/linux/kref.h"
      ({
# 127 "include/linux/kref.h"
        long unsigned int __dummy;
# 127 "include/linux/kref.h"
        long unsigned int __dummy2;
# 127 "include/linux/kref.h"
        ( void ) 0;
# 127 "include/linux/kref.h"
        1;
      } );
# 127 "include/linux/kref.h"
      arch_local_irq_restore ( flags );
    }
# 128 "include/linux/kref.h"
    return 1;
  }
  spin_unlock_irqrestore ( lock , flags );
  return 0;
}
# 134 "include/linux/kref.h"
static inline int kref_put_mutex(struct kref *kref, void (*release)(struct kref *), struct mutex *lock)
{
# 138 "include/linux/kref.h"
  ({
# 138 "include/linux/kref.h"
    int __ret_warn_on = release == ( ( void (*)(struct kref *)) 0 );
    {
# 138 "include/linux/kref.h"
      if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 138 "include/linux/kref.h"
        warn_slowpath_null ( ( char const *) "include/linux/kref.h" , 138 );
    }
# 138 "include/linux/kref.h"
    __builtin_expect ( __ret_warn_on != 0 , 0L );
  } );
# 139 "include/linux/kref.h"
  if (__builtin_expect ( atomic_add_unless ( & ( * kref ) . refcount , -1 , 1 ) == 0 , 0L ) != 0L)
  {
# 140 "include/linux/kref.h"
    ldv_mutex_lock_1 ( lock );
    if (__builtin_expect ( atomic_dec_and_test ( & ( * kref ) . refcount ) == 0 , 0L ) != 0L)
    {
# 142 "include/linux/kref.h"
      ldv_mutex_unlock_2 ( lock );
      return 0;
    }
    release ( kref );
    return 1;
  }
  return 0;
}
# 167 "include/linux/kref.h"
static inline int kref_get_unless_zero(struct kref *kref)
{
  return atomic_add_unless ( & ( * kref ) . refcount , 1 , 0 );
}
# 37 "include/linux/kobject.h"
extern char uevent_helper[];
# 41 "include/linux/kobject.h"
extern u64 uevent_seqnum;
enum kobject_action
{
  KOBJ_ADD = 0,
  KOBJ_REMOVE = 1,
  KOBJ_CHANGE = 2,
  KOBJ_MOVE = 3,
  KOBJ_ONLINE = 4,
  KOBJ_OFFLINE = 5,
  KOBJ_MAX = 6
};
struct kobject
{
# 64 "include/linux/kobject.h"
  char const *name;
  struct list_head entry;
  struct kobject *parent;
  struct kset *kset;
  struct kobj_type *ktype;
  struct kernfs_node *sd;
  struct kref kref;
# 72 "include/linux/kobject.h"
  struct delayed_work release;
# 74 "include/linux/kobject.h"
  unsigned char state_initialized : 1;
  unsigned char state_in_sysfs : 1;
  unsigned char state_add_uevent_sent : 1;
  unsigned char state_remove_uevent_sent : 1;
  unsigned char uevent_suppress : 1;
};
# 82 "include/linux/kobject.h"
int kobject_set_name(struct kobject *, char const *, ...);
int kobject_set_name_vargs(struct kobject *, char const *, __va_list_tag *);
# 86 "include/linux/kobject.h"
static inline char const *kobject_name(struct kobject const *kobj)
{
  return ( char const *) ( * kobj ) . name;
}
# 91 "include/linux/kobject.h"
void kobject_init(struct kobject *, struct kobj_type *);
# 93 "include/linux/kobject.h"
int kobject_add(struct kobject *, struct kobject *, char const *, ...);
# 96 "include/linux/kobject.h"
int kobject_init_and_add(struct kobject *, struct kobj_type *, struct kobject *, char const *, ...);
# 100 "include/linux/kobject.h"
void kobject_del(struct kobject *);
# 102 "include/linux/kobject.h"
struct kobject *kobject_create(void);
struct kobject *kobject_create_and_add(char const *, struct kobject *);
# 106 "include/linux/kobject.h"
int kobject_rename(struct kobject *, char const *);
int kobject_move(struct kobject *, struct kobject *);
# 109 "include/linux/kobject.h"
struct kobject *kobject_get(struct kobject *);
void kobject_put(struct kobject *);
# 112 "include/linux/kobject.h"
void const *kobject_namespace(struct kobject *);
char *kobject_get_path(struct kobject *, gfp_t);
struct kobj_type
{
  void (*release)(struct kobject *);
  struct sysfs_ops const *sysfs_ops;
  struct attribute **default_attrs;
  struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *);
  void const *(*namespace)(struct kobject *);
};
struct kobj_uevent_env
{
  char *argv[3U];
  char *envp[32U];
  int envp_idx;
  char buf[2048U];
  int buflen;
};
struct kset_uevent_ops
{
  int (*const filter)(struct kset *, struct kobject *);
  char const *(*const name)(struct kset *, struct kobject *);
  int (*const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *);
};
struct kobj_attribute
{
# 139 "include/linux/kobject.h"
  struct attribute attr;
  ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
# 142 "include/linux/kobject.h"
  ssize_t (*store)(struct kobject *, struct kobj_attribute *, char const *, size_t);
};
# 146 "include/linux/kobject.h"
extern struct sysfs_ops const kobj_sysfs_ops;
struct kset
{
# 168 "include/linux/kobject.h"
  struct list_head list;
  spinlock_t list_lock;
  struct kobject kobj;
  struct kset_uevent_ops const *uevent_ops;
};
# 174 "include/linux/kobject.h"
void kset_init(struct kset *);
int kset_register(struct kset *);
void kset_unregister(struct kset *);
struct kset *kset_create_and_add(char const *, struct kset_uevent_ops const *, struct kobject *);
# 181 "include/linux/kobject.h"
static inline struct kset *to_kset(struct kobject *kobj)
{
  return kobj != ( ( struct kobject *) 0 ) ? ({
# 183 "include/linux/kobject.h"
    struct kobject const *__mptr = ( struct kobject const *) kobj;
# 183 "include/linux/kobject.h"
    ( struct kset *) __mptr + 18446744073709551528U;
  } )
# 183 "include/linux/kobject.h"
  : ( ( struct kset *) 0 );
}
# 186 "include/linux/kobject.h"
static inline struct kset *kset_get(struct kset *k)
{
  return k != ( ( struct kset *) 0 ) ? to_kset ( kobject_get ( & ( * k ) . kobj ) ) : ( ( struct kset *) 0 );
}
# 191 "include/linux/kobject.h"
static inline void kset_put(struct kset *k)
{
  kobject_put ( & ( * k ) . kobj );
}
# 196 "include/linux/kobject.h"
static inline struct kobj_type *get_ktype(struct kobject *kobj)
{
  return ( * kobj ) . ktype;
}
# 201 "include/linux/kobject.h"
struct kobject *kset_find_obj(struct kset *, char const *);
# 204 "include/linux/kobject.h"
extern struct kobject *kernel_kobj;
# 206 "include/linux/kobject.h"
extern struct kobject *mm_kobj;
# 208 "include/linux/kobject.h"
extern struct kobject *hypervisor_kobj;
# 210 "include/linux/kobject.h"
extern struct kobject *power_kobj;
# 212 "include/linux/kobject.h"
extern struct kobject *firmware_kobj;
# 214 "include/linux/kobject.h"
int kobject_uevent(struct kobject *, enum kobject_action);
int kobject_uevent_env(struct kobject *, enum kobject_action, char **);
# 219 "include/linux/kobject.h"
int add_uevent_var(struct kobj_uevent_env *, char const *, ...);
# 221 "include/linux/kobject.h"
int kobject_action_type(char const *, size_t, enum kobject_action *);
struct kernel_param;
enum ldv_14430
{
  KERNEL_PARAM_FL_NOARG = 1
};
struct kernel_param_ops
{
# 50 "include/linux/moduleparam.h"
  unsigned int flags;
# 52 "include/linux/moduleparam.h"
  int (*set)(char const *, struct kernel_param const *);
# 54 "include/linux/moduleparam.h"
  int (*get)(char *, struct kernel_param const *);
# 56 "include/linux/moduleparam.h"
  void (*free)(void *);
};
struct kernel_param
{
  char const *name;
  struct kernel_param_ops const *ops;
  u16 perm;
  s16 level;
# 68 "include/linux/moduleparam.h"
  union
  {
# 65 "include/linux/moduleparam.h"
    void *arg;
    struct kparam_string const *str;
    struct kparam_array const *arr;
  } ldv_15497;
};
struct kparam_string
{
# 73 "include/linux/moduleparam.h"
  unsigned int maxlen;
  char *string;
};
struct kparam_array
{
# 80 "include/linux/moduleparam.h"
  unsigned int max;
  unsigned int elemsize;
  unsigned int *num;
  struct kernel_param_ops const *ops;
  void *elem;
};
# 206 "include/linux/moduleparam.h"
static inline int __check_old_set_param(int (*oldset)(char const *, struct kernel_param *))
{
  return 0;
}
# 256 "include/linux/moduleparam.h"
void __kernel_param_lock(void);
void __kernel_param_unlock(void);
# 311 "include/linux/moduleparam.h"
bool parameq(char const *, char const *);
# 321 "include/linux/moduleparam.h"
bool parameqn(char const *, char const *, size_t);
# 324 "include/linux/moduleparam.h"
char *parse_args(char const *, char *, struct kernel_param const *, unsigned int, s16, s16, int (*)(char *, char *, char const *));
# 335 "include/linux/moduleparam.h"
void destroy_params(struct kernel_param const *, unsigned int);
# 349 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_byte;
int param_set_byte(char const *, struct kernel_param const *);
int param_get_byte(char *, struct kernel_param const *);
# 354 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_short;
int param_set_short(char const *, struct kernel_param const *);
int param_get_short(char *, struct kernel_param const *);
# 359 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_ushort;
int param_set_ushort(char const *, struct kernel_param const *);
int param_get_ushort(char *, struct kernel_param const *);
# 364 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_int;
int param_set_int(char const *, struct kernel_param const *);
int param_get_int(char *, struct kernel_param const *);
# 369 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_uint;
int param_set_uint(char const *, struct kernel_param const *);
int param_get_uint(char *, struct kernel_param const *);
# 374 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_long;
int param_set_long(char const *, struct kernel_param const *);
int param_get_long(char *, struct kernel_param const *);
# 379 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_ulong;
int param_set_ulong(char const *, struct kernel_param const *);
int param_get_ulong(char *, struct kernel_param const *);
# 384 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_ullong;
int param_set_ullong(char const *, struct kernel_param const *);
int param_get_ullong(char *, struct kernel_param const *);
# 389 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_charp;
int param_set_charp(char const *, struct kernel_param const *);
int param_get_charp(char *, struct kernel_param const *);
# 395 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_bool;
int param_set_bool(char const *, struct kernel_param const *);
int param_get_bool(char *, struct kernel_param const *);
# 400 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_invbool;
int param_set_invbool(char const *, struct kernel_param const *);
int param_get_invbool(char *, struct kernel_param const *);
# 406 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_bint;
int param_set_bint(char const *, struct kernel_param const *);
# 450 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_array_ops;
# 452 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_string;
int param_set_copystring(char const *, struct kernel_param const *);
int param_get_string(char *, struct kernel_param const *);
# 461 "include/linux/moduleparam.h"
int module_param_sysfs_setup(struct module *, struct kernel_param const *, unsigned int);
# 465 "include/linux/moduleparam.h"
void module_param_sysfs_remove(struct module *);
struct mod_arch_specific
{
};
struct modversion_info
{
# 33 "include/linux/module.h"
  long unsigned int crc;
  char name[56U];
};
struct module_kobject
{
# 40 "include/linux/module.h"
  struct kobject kobj;
  struct module *mod;
  struct kobject *drivers_dir;
  struct module_param_attrs *mp;
  struct completion *kobj_completion;
};
struct module_attribute
{
  struct attribute attr;
  ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *);
# 51 "include/linux/module.h"
  ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t);
# 53 "include/linux/module.h"
  void (*setup)(struct module *, char const *);
  int (*test)(struct module *);
  void (*free)(struct module *);
};
struct module_version_attribute
{
  struct module_attribute mattr;
  char const *module_name;
  char const *version;
};
# 64 "include/linux/module.h"
ssize_t __modver_version_show(struct module_attribute *, struct module_kobject *, char *);
# 67 "include/linux/module.h"
extern struct module_attribute module_uevent;
# 70 "include/linux/module.h"
int init_module(void);
void cleanup_module(void);
struct exception_table_entry;
# 77 "include/linux/module.h"
struct exception_table_entry const *search_extable(struct exception_table_entry const *, struct exception_table_entry const *, long unsigned int);
# 80 "include/linux/module.h"
void sort_extable(struct exception_table_entry *, struct exception_table_entry *);
# 82 "include/linux/module.h"
void sort_main_extable(void);
void trim_init_extable(struct module *);
# 187 "include/linux/module.h"
struct exception_table_entry const *search_exception_tables(long unsigned int);
# 193 "include/linux/module.h"
extern int modules_disabled;
# 195 "include/linux/module.h"
void *__symbol_get(char const *);
void *__symbol_get_gpl(char const *);
struct module_use
{
# 201 "include/linux/module.h"
  struct list_head source_list;
  struct list_head target_list;
  struct module *source;
# 203 "include/linux/module.h"
  struct module *target;
};
enum module_state
{
  MODULE_STATE_LIVE = 0,
  MODULE_STATE_COMING = 1,
  MODULE_STATE_GOING = 2,
  MODULE_STATE_UNFORMED = 3
};
struct module_ref
{
# 223 "include/linux/module.h"
  long unsigned int incs;
  long unsigned int decs;
};
struct module
{
  enum module_state state;
# 231 "include/linux/module.h"
  struct list_head list;
# 234 "include/linux/module.h"
  char name[56U];
# 237 "include/linux/module.h"
  struct module_kobject mkobj;
  struct module_attribute *modinfo_attrs;
  char const *version;
  char const *srcversion;
  struct kobject *holders_dir;
# 244 "include/linux/module.h"
  struct kernel_symbol const *syms;
  long unsigned int const *crcs;
  unsigned int num_syms;
# 249 "include/linux/module.h"
  struct kernel_param *kp;
  unsigned int num_kp;
# 253 "include/linux/module.h"
  unsigned int num_gpl_syms;
  struct kernel_symbol const *gpl_syms;
  long unsigned int const *gpl_crcs;
# 259 "include/linux/module.h"
  struct kernel_symbol const *unused_syms;
  long unsigned int const *unused_crcs;
  unsigned int num_unused_syms;
# 264 "include/linux/module.h"
  unsigned int num_unused_gpl_syms;
  struct kernel_symbol const *unused_gpl_syms;
  long unsigned int const *unused_gpl_crcs;
# 271 "include/linux/module.h"
  bool sig_ok;
# 275 "include/linux/module.h"
  struct kernel_symbol const *gpl_future_syms;
  long unsigned int const *gpl_future_crcs;
  unsigned int num_gpl_future_syms;
# 280 "include/linux/module.h"
  unsigned int num_exentries;
  struct exception_table_entry *extable;
# 284 "include/linux/module.h"
  int (*init)(void);
# 287 "include/linux/module.h"
  void *module_init;
# 290 "include/linux/module.h"
  void *module_core;
# 293 "include/linux/module.h"
  unsigned int init_size;
# 293 "include/linux/module.h"
  unsigned int core_size;
# 296 "include/linux/module.h"
  unsigned int init_text_size;
# 296 "include/linux/module.h"
  unsigned int core_text_size;
# 299 "include/linux/module.h"
  unsigned int init_ro_size;
# 299 "include/linux/module.h"
  unsigned int core_ro_size;
# 302 "include/linux/module.h"
  struct mod_arch_specific arch;
# 304 "include/linux/module.h"
  unsigned int taints;
# 308 "include/linux/module.h"
  unsigned int num_bugs;
  struct list_head bug_list;
  struct bug_entry *bug_table;
# 319 "include/linux/module.h"
  Elf64_Sym *symtab;
# 319 "include/linux/module.h"
  Elf64_Sym *core_symtab;
  unsigned int num_symtab;
# 320 "include/linux/module.h"
  unsigned int core_num_syms;
  char *strtab;
# 321 "include/linux/module.h"
  char *core_strtab;
# 324 "include/linux/module.h"
  struct module_sect_attrs *sect_attrs;
# 327 "include/linux/module.h"
  struct module_notes_attrs *notes_attrs;
# 332 "include/linux/module.h"
  char *args;
# 336 "include/linux/module.h"
  void *percpu;
  unsigned int percpu_size;
# 341 "include/linux/module.h"
  unsigned int num_tracepoints;
  struct tracepoint *const *tracepoints_ptrs;
# 349 "include/linux/module.h"
  unsigned int num_trace_bprintk_fmt;
  char const **trace_bprintk_fmt_start;
# 353 "include/linux/module.h"
  struct ftrace_event_call **trace_events;
  unsigned int num_trace_events;
# 363 "include/linux/module.h"
  struct list_head source_list;
# 365 "include/linux/module.h"
  struct list_head target_list;
# 368 "include/linux/module.h"
  void (*exit)(void);
# 370 "include/linux/module.h"
  struct module_ref *refptr;
# 375 "include/linux/module.h"
  ctor_fn_t (**ctors)(void);
  unsigned int num_ctors;
};
# 383 "include/linux/module.h"
extern struct mutex module_mutex;
# 388 "include/linux/module.h"
static inline int module_is_live(struct module *mod)
{
  return ( unsigned int ) ( * mod ) . state != 2U;
}
# 393 "include/linux/module.h"
struct module *__module_text_address(long unsigned int);
struct module *__module_address(long unsigned int);
bool is_module_address(long unsigned int);
bool is_module_percpu_address(long unsigned int);
bool is_module_text_address(long unsigned int);
# 399 "include/linux/module.h"
static inline bool within_module_core(long unsigned int addr, struct module const *mod)
{
# 402 "include/linux/module.h"
  return ( bool ) ( ( long unsigned int ) ( * mod ) . module_core <= addr &&
# 403 "include/linux/module.h"
  ( long unsigned int ) ( * mod ) . module_core + ( long unsigned int ) ( * mod ) . core_size > addr );
}
# 406 "include/linux/module.h"
static inline bool within_module_init(long unsigned int addr, struct module const *mod)
{
# 409 "include/linux/module.h"
  return ( bool ) ( ( long unsigned int ) ( * mod ) . module_init <= addr &&
# 410 "include/linux/module.h"
  ( long unsigned int ) ( * mod ) . module_init + ( long unsigned int ) ( * mod ) . init_size > addr );
}
# 413 "include/linux/module.h"
static inline bool within_module(long unsigned int addr, struct module const *mod)
{
  return ( bool ) ( ( int ) within_module_init ( addr , mod ) || ( int ) within_module_core ( addr , mod ) );
}
# 419 "include/linux/module.h"
struct module *find_module(char const *);
enum ldv_14577
{
  NOT_GPL_ONLY = 0,
  GPL_ONLY = 1,
  WILL_BE_GPL_ONLY = 2
};
struct symsearch
{
# 422 "include/linux/module.h"
  struct kernel_symbol const *start;
# 422 "include/linux/module.h"
  struct kernel_symbol const *stop;
  long unsigned int const *crcs;
# 428 "include/linux/module.h"
  enum ldv_14577 licence;
  bool unused;
};
# 433 "include/linux/module.h"
struct kernel_symbol const *find_symbol(char const *, struct module **, long unsigned int const **, bool, bool);
# 440 "include/linux/module.h"
bool each_symbol_section(bool (*)(struct symsearch const *, struct module *, void *), void *);
# 446 "include/linux/module.h"
int module_get_kallsym(unsigned int, long unsigned int *, char *, char *, char *, int *);
# 450 "include/linux/module.h"
long unsigned int module_kallsyms_lookup_name(char const *);
# 452 "include/linux/module.h"
int module_kallsyms_on_each_symbol(int (*)(void *, char const *, struct module *, long unsigned int), void *);
# 456 "include/linux/module.h"
void __module_put_and_exit(struct module *, long int);
# 461 "include/linux/module.h"
long unsigned int module_refcount(struct module *);
void __symbol_put(char const *);
# 464 "include/linux/module.h"
void symbol_put_addr(void *);
# 468 "include/linux/module.h"
void __module_get(struct module *);
# 472 "include/linux/module.h"
bool try_module_get(struct module *);
# 474 "include/linux/module.h"
void module_put(struct module *);
# 491 "include/linux/module.h"
int ref_module(struct module *, struct module *);
# 503 "include/linux/module.h"
char const *module_address_lookup(long unsigned int, long unsigned int *, long unsigned int *, char **, char *);
# 508 "include/linux/module.h"
int lookup_module_symbol_name(long unsigned int, char *);
int lookup_module_symbol_attrs(long unsigned int, long unsigned int *, long unsigned int *, char *, char *);
# 512 "include/linux/module.h"
struct exception_table_entry const *search_module_extables(long unsigned int);
# 514 "include/linux/module.h"
int register_module_notifier(struct notifier_block *);
int unregister_module_notifier(struct notifier_block *);
# 517 "include/linux/module.h"
void print_modules(void);
# 632 "include/linux/module.h"
extern struct kset *module_kset;
extern struct kobj_type module_ktype;
extern int module_sysfs_initialized;
# 644 "include/linux/module.h"
void set_all_modules_text_rw(void);
void set_all_modules_text_ro(void);
# 652 "include/linux/module.h"
void module_bug_finalize(Elf64_Ehdr const *, Elf64_Shdr const *, struct module *);
# 654 "include/linux/module.h"
void module_bug_cleanup(struct module *);
# 47 "include/linux/sched/prio.h"
static inline long int nice_to_rlimit(long int nice)
{
  return 20L - nice;
}
# 55 "include/linux/sched/prio.h"
static inline long int rlimit_to_nice(long int prio)
{
  return 20L - prio;
}
struct sched_param
{
# 10 "include/linux/sched.h"
  int sched_priority;
};
struct __user_cap_header_struct
{
# 41 "include/uapi/linux/capability.h"
  __u32 version;
  int pid;
};
# 43 "include/uapi/linux/capability.h"
typedef struct __user_cap_header_struct *cap_user_header_t;
struct __user_cap_data_struct
{
  __u32 effective;
  __u32 permitted;
  __u32 inheritable;
};
# 49 "include/uapi/linux/capability.h"
typedef struct __user_cap_data_struct *cap_user_data_t;
struct vfs_cap_data
{
# 70 "include/uapi/linux/capability.h"
  __le32 magic_etc;
# 74 "include/uapi/linux/capability.h"
  struct
  {
# 72 "include/uapi/linux/capability.h"
    __le32 permitted;
    __le32 inheritable;
  } data[2U];
};
# 21 "include/linux/capability.h"
extern int file_caps_enabled;
struct kernel_cap_struct
{
  __u32 cap[2U];
};
# 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
struct cpu_vfs_cap_data
{
# 29 "include/linux/capability.h"
  __u32 magic_etc;
  kernel_cap_t permitted;
  kernel_cap_t inheritable;
};
# 43 "include/linux/capability.h"
struct user_namespace *current_user_ns(void);
# 45 "include/linux/capability.h"
extern kernel_cap_t const __cap_empty_set;
extern kernel_cap_t const __cap_init_eff_set;
# 117 "include/linux/capability.h"
static inline kernel_cap_t cap_combine(kernel_cap_t const a, kernel_cap_t const b)
{
# 120 "include/linux/capability.h"
  kernel_cap_t dest;
  {
# 121 "include/linux/capability.h"
    unsigned int __capi;
# 121 "include/linux/capability.h"
    __capi = 0U;
# 121 "include/linux/capability.h"
    goto ldv_15937;
    ldv_15936:;
# 121 "include/linux/capability.h"
    dest . cap [ __capi ] = ( unsigned int ) a . cap [ __capi ] | ( unsigned int ) b . cap [ __capi ];
# 121 "include/linux/capability.h"
    ++ __capi;
    ldv_15937:;
# 121 "include/linux/capability.h"
    if (__capi <= 1U)
    {
      goto ldv_15936;
    }
    else
      goto ldv_15938;
    ldv_15938:;
  }
# 122 "include/linux/capability.h"
  return dest;
}
# 125 "include/linux/capability.h"
static inline kernel_cap_t cap_intersect(kernel_cap_t const a, kernel_cap_t const b)
{
# 128 "include/linux/capability.h"
  kernel_cap_t dest;
  {
# 129 "include/linux/capability.h"
    unsigned int __capi;
# 129 "include/linux/capability.h"
    __capi = 0U;
# 129 "include/linux/capability.h"
    goto ldv_15946;
    ldv_15945:;
# 129 "include/linux/capability.h"
    dest . cap [ __capi ] = ( unsigned int ) a . cap [ __capi ] & ( unsigned int ) b . cap [ __capi ];
# 129 "include/linux/capability.h"
    ++ __capi;
    ldv_15946:;
# 129 "include/linux/capability.h"
    if (__capi <= 1U)
    {
      goto ldv_15945;
    }
    else
      goto ldv_15947;
    ldv_15947:;
  }
# 130 "include/linux/capability.h"
  return dest;
}
# 133 "include/linux/capability.h"
static inline kernel_cap_t cap_drop(kernel_cap_t const a, kernel_cap_t const drop)
{
# 136 "include/linux/capability.h"
  kernel_cap_t dest;
  {
# 137 "include/linux/capability.h"
    unsigned int __capi;
# 137 "include/linux/capability.h"
    __capi = 0U;
# 137 "include/linux/capability.h"
    goto ldv_15955;
    ldv_15954:;
# 137 "include/linux/capability.h"
    dest . cap [ __capi ] = ( unsigned int ) a . cap [ __capi ] & ( unsigned int ) ~ drop . cap [ __capi ];
# 137 "include/linux/capability.h"
    ++ __capi;
    ldv_15955:;
# 137 "include/linux/capability.h"
    if (__capi <= 1U)
    {
      goto ldv_15954;
    }
    else
      goto ldv_15956;
    ldv_15956:;
  }
# 138 "include/linux/capability.h"
  return dest;
}
# 141 "include/linux/capability.h"
static inline kernel_cap_t cap_invert(kernel_cap_t const c)
{
  kernel_cap_t dest;
  {
# 144 "include/linux/capability.h"
    unsigned int __capi;
# 144 "include/linux/capability.h"
    __capi = 0U;
# 144 "include/linux/capability.h"
    goto ldv_15963;
    ldv_15962:;
# 144 "include/linux/capability.h"
    dest . cap [ __capi ] = ~ c . cap [ __capi ];
# 144 "include/linux/capability.h"
    ++ __capi;
    ldv_15963:;
# 144 "include/linux/capability.h"
    if (__capi <= 1U)
    {
      goto ldv_15962;
    }
    else
      goto ldv_15964;
    ldv_15964:;
  }
# 145 "include/linux/capability.h"
  return dest;
}
# 148 "include/linux/capability.h"
static inline int cap_isclear(kernel_cap_t const a)
{
  unsigned int __capi;
  __capi = 0U;
# 151 "include/linux/capability.h"
  goto ldv_15970;
  ldv_15969:;
# 152 "include/linux/capability.h"
  if (( unsigned int ) a . cap [ __capi ] != 0U)
    return 0;
# 151 "include/linux/capability.h"
  ++ __capi;
  ldv_15970:;
# 151 "include/linux/capability.h"
  if (__capi <= 1U)
  {
    goto ldv_15969;
  }
  else
    goto ldv_15971;
  ldv_15971:;
# 155 "include/linux/capability.h"
  return 1;
}
# 165 "include/linux/capability.h"
static inline int cap_issubset(kernel_cap_t const a, kernel_cap_t const set)
{
  kernel_cap_t dest;
  dest = cap_drop ( a , set );
  return cap_isclear ( dest );
}
# 174 "include/linux/capability.h"
static inline int cap_is_fs_cap(int cap)
{
  kernel_cap_t const __cap_fs_set = ( kernel_cap_t ) { . cap = { [ 0U ] = 134218271U , [ 1U ] = 1U } };
  return ( ( unsigned int ) ( 1 << ( cap & 31 ) ) & ( unsigned int ) __cap_fs_set . cap [ cap >> 5 ] ) != 0U;
}
# 180 "include/linux/capability.h"
static inline kernel_cap_t cap_drop_fs_set(kernel_cap_t const a)
{
  kernel_cap_t const __cap_fs_set = ( kernel_cap_t ) { . cap = { [ 0U ] = 134218271U , [ 1U ] = 1U } };
  return cap_drop ( a , __cap_fs_set );
}
# 186 "include/linux/capability.h"
static inline kernel_cap_t cap_raise_fs_set(kernel_cap_t const a, kernel_cap_t const permitted)
{
# 189 "include/linux/capability.h"
  kernel_cap_t const __cap_fs_set = ( kernel_cap_t ) { . cap = { [ 0U ] = 134218271U , [ 1U ] = 1U } };
  return cap_combine ( a , cap_intersect
# 191 "include/linux/capability.h"
  ( permitted , __cap_fs_set ) );
}
# 194 "include/linux/capability.h"
static inline kernel_cap_t cap_drop_nfsd_set(kernel_cap_t const a)
{
  kernel_cap_t const __cap_fs_set = ( kernel_cap_t ) { . cap = { [ 0U ] = 150994975U , [ 1U ] = 1U } };
  return cap_drop ( a , __cap_fs_set );
}
# 200 "include/linux/capability.h"
static inline kernel_cap_t cap_raise_nfsd_set(kernel_cap_t const a, kernel_cap_t const permitted)
{
# 203 "include/linux/capability.h"
  kernel_cap_t const __cap_nfsd_set = ( kernel_cap_t ) { . cap = { [ 0U ] = 150994975U , [ 1U ] = 1U } };
  return cap_combine ( a , cap_intersect
# 205 "include/linux/capability.h"
  ( permitted , __cap_nfsd_set ) );
}
# 208 "include/linux/capability.h"
bool has_capability(struct task_struct *, int);
bool has_ns_capability(struct task_struct *, struct user_namespace *, int);
# 211 "include/linux/capability.h"
bool has_capability_noaudit(struct task_struct *, int);
bool has_ns_capability_noaudit(struct task_struct *, struct user_namespace *, int);
# 214 "include/linux/capability.h"
bool capable(int);
bool ns_capable(struct user_namespace *, int);
bool capable_wrt_inode_uidgid(struct inode const *, int);
bool file_ns_capable(struct file const *, struct user_namespace *, int);
# 220 "include/linux/capability.h"
int get_vfs_caps_from_disk(struct dentry const *, struct cpu_vfs_cap_data *);
struct plist_head
{
# 82 "include/linux/plist.h"
  struct list_head node_list;
};
struct plist_node
{
  int prio;
  struct list_head prio_list;
  struct list_head node_list;
};
# 124 "include/linux/plist.h"
static inline void plist_head_init(struct plist_head *head)
{
  INIT_LIST_HEAD ( & ( * head ) . node_list );
}
# 134 "include/linux/plist.h"
static inline void plist_node_init(struct plist_node *node, int prio)
{
  ( * node ) . prio = prio;
  INIT_LIST_HEAD ( & ( * node ) . prio_list );
  INIT_LIST_HEAD ( & ( * node ) . node_list );
}
# 141 "include/linux/plist.h"
void plist_add(struct plist_node *, struct plist_head *);
void plist_del(struct plist_node *, struct plist_head *);
# 144 "include/linux/plist.h"
void plist_requeue(struct plist_node *, struct plist_head *);
# 212 "include/linux/plist.h"
static inline int plist_head_empty(struct plist_head const *head)
{
  return list_empty ( & ( * head ) . node_list );
}
# 221 "include/linux/plist.h"
static inline int plist_node_empty(struct plist_node const *node)
{
  return list_empty ( & ( * node ) . node_list );
}
# 282 "include/linux/plist.h"
static inline struct plist_node *plist_first(struct plist_head const *head)
{
  return ({
# 284 "include/linux/plist.h"
    struct list_head const *__mptr = ( struct list_head const *) ( * head ) . node_list . next;
# 284 "include/linux/plist.h"
    ( struct plist_node *) __mptr + 18446744073709551592U;
  } );
}
# 294 "include/linux/plist.h"
static inline struct plist_node *plist_last(struct plist_head const *head)
{
  return ({
# 296 "include/linux/plist.h"
    struct list_head const *__mptr = ( struct list_head const *) ( * head ) . node_list . prev;
# 296 "include/linux/plist.h"
    ( struct plist_node *) __mptr + 18446744073709551592U;
  } );
}
# 4 "include/asm-generic/cputime_jiffies.h"
typedef long unsigned int cputime_t;
# 11 "include/asm-generic/cputime_jiffies.h"
typedef u64 cputime64_t;
struct ipc_perm
{
# 11 "include/uapi/linux/ipc.h"
  __kernel_key_t key;
  __kernel_uid_t uid;
  __kernel_gid_t gid;
  __kernel_uid_t cuid;
  __kernel_gid_t cgid;
  __kernel_mode_t mode;
  short unsigned int seq;
};
struct ipc64_perm
{
# 20 "./include/uapi/asm-generic/ipcbuf.h"
  __kernel_key_t key;
  __kernel_uid32_t uid;
  __kernel_gid32_t gid;
  __kernel_uid32_t cuid;
  __kernel_gid32_t cgid;
  __kernel_mode_t mode;
# 27 "./include/uapi/asm-generic/ipcbuf.h"
  unsigned char __pad1[0U];
  short unsigned int seq;
  short unsigned int __pad2;
  __kernel_ulong_t __unused1;
  __kernel_ulong_t __unused2;
};
struct ipc_kludge
{
# 58 "include/uapi/linux/ipc.h"
  struct msgbuf *msgp;
  long int msgtyp;
};
struct kern_ipc_perm
{
# 13 "include/linux/ipc.h"
  spinlock_t lock;
  bool deleted;
  int id;
  key_t key;
  kuid_t uid;
  kgid_t gid;
  kuid_t cuid;
  kgid_t cgid;
  umode_t mode;
  long unsigned int seq;
  void *security;
};
struct semid_ds
{
# 24 "include/uapi/linux/sem.h"
  struct ipc_perm sem_perm;
  __kernel_time_t sem_otime;
  __kernel_time_t sem_ctime;
  struct sem *sem_base;
  struct sem_queue *sem_pending;
  struct sem_queue **sem_pending_last;
  struct sem_undo *undo;
  short unsigned int sem_nsems;
};
struct semid64_ds
{
# 14 "./arch/x86/include/uapi/asm/sembuf.h"
  struct ipc64_perm sem_perm;
  __kernel_time_t sem_otime;
  __kernel_ulong_t __unused1;
  __kernel_time_t sem_ctime;
  __kernel_ulong_t __unused2;
  __kernel_ulong_t sem_nsems;
  __kernel_ulong_t __unused3;
  __kernel_ulong_t __unused4;
};
struct sembuf
{
# 39 "include/uapi/linux/sem.h"
  short unsigned int sem_num;
  short int sem_op;
  short int sem_flg;
};
union semun
{
# 46 "include/uapi/linux/sem.h"
  int val;
  struct semid_ds *buf;
  short unsigned int *array;
  struct seminfo *__buf;
  void *__pad;
};
struct seminfo
{
  int semmap;
  int semmni;
  int semmns;
  int semmnu;
  int semmsl;
  int semopm;
  int semume;
  int semusz;
  int semvmx;
  int semaem;
};
struct sem_array
{
# 14 "include/linux/sem.h"
  struct kern_ipc_perm sem_perm;
  time_t sem_ctime;
  struct sem *sem_base;
  struct list_head pending_alter;
# 19 "include/linux/sem.h"
  struct list_head pending_const;
# 21 "include/linux/sem.h"
  struct list_head list_id;
  int sem_nsems;
  int complex_count;
};
struct sysv_sem
{
# 29 "include/linux/sem.h"
  struct sem_undo_list *undo_list;
};
# 32 "include/linux/sem.h"
int copy_semundo(long unsigned int, struct task_struct *);
void exit_sem(struct task_struct *);
struct shmid_ds
{
# 27 "include/uapi/linux/shm.h"
  struct ipc_perm shm_perm;
  int shm_segsz;
  __kernel_time_t shm_atime;
  __kernel_time_t shm_dtime;
  __kernel_time_t shm_ctime;
  __kernel_ipc_pid_t shm_cpid;
  __kernel_ipc_pid_t shm_lpid;
  short unsigned int shm_nattch;
  short unsigned int shm_unused;
  void *shm_unused2;
  void *shm_unused3;
};
struct shmid64_ds
{
# 26 "./include/uapi/asm-generic/shmbuf.h"
  struct ipc64_perm shm_perm;
  size_t shm_segsz;
  __kernel_time_t shm_atime;
# 32 "./include/uapi/asm-generic/shmbuf.h"
  __kernel_time_t shm_dtime;
# 36 "./include/uapi/asm-generic/shmbuf.h"
  __kernel_time_t shm_ctime;
# 40 "./include/uapi/asm-generic/shmbuf.h"
  __kernel_pid_t shm_cpid;
  __kernel_pid_t shm_lpid;
  __kernel_ulong_t shm_nattch;
  __kernel_ulong_t __unused4;
  __kernel_ulong_t __unused5;
};
struct shminfo64
{
  __kernel_ulong_t shmmax;
  __kernel_ulong_t shmmin;
  __kernel_ulong_t shmmni;
  __kernel_ulong_t shmseg;
  __kernel_ulong_t shmall;
  __kernel_ulong_t __unused1;
  __kernel_ulong_t __unused2;
  __kernel_ulong_t __unused3;
  __kernel_ulong_t __unused4;
};
struct shminfo
{
# 63 "include/uapi/linux/shm.h"
  int shmmax;
  int shmmin;
  int shmmni;
  int shmseg;
  int shmall;
};
struct shm_info
{
  int used_ids;
  __kernel_ulong_t shm_tot;
  __kernel_ulong_t shm_rss;
  __kernel_ulong_t shm_swp;
  __kernel_ulong_t swap_attempts;
  __kernel_ulong_t swap_successes;
};
struct shmid_kernel
{
# 11 "include/linux/shm.h"
  struct kern_ipc_perm shm_perm;
  struct file *shm_file;
  long unsigned int shm_nattch;
  long unsigned int shm_segsz;
  time_t shm_atim;
  time_t shm_dtim;
  time_t shm_ctim;
  pid_t shm_cprid;
  pid_t shm_lprid;
  struct user_struct *mlock_user;
# 23 "include/linux/shm.h"
  struct task_struct *shm_creator;
  struct list_head shm_clist;
};
struct sysv_shm
{
# 50 "include/linux/shm.h"
  struct list_head shm_clist;
};
# 53 "include/linux/shm.h"
long int do_shmat(int, char *, int, long unsigned int *, long unsigned int);
# 55 "include/linux/shm.h"
int is_file_shm_hugepages(struct file *);
void exit_shm(struct task_struct *);
# 20 "./arch/x86/include/asm/signal.h"
typedef long unsigned int old_sigset_t;
# 24 "./arch/x86/include/asm/signal.h"
typedef struct
{
# 23 "./arch/x86/include/asm/signal.h"
  long unsigned int sig[1U];
} sigset_t;
struct siginfo;
# 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int);
typedef __signalfn_t *__sighandler_t;
# 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
struct sigaltstack
{
# 128 "./arch/x86/include/uapi/asm/signal.h"
  void *ss_sp;
  int ss_flags;
  size_t ss_size;
};
# 131 "./arch/x86/include/uapi/asm/signal.h"
typedef struct sigaltstack stack_t;
# 33 "./arch/x86/include/asm/signal.h"
void do_notify_resume(struct pt_regs *, void *, __u32);
union sigval
{
# 8 "include/uapi/asm-generic/siginfo.h"
  int sival_int;
  void *sival_ptr;
};
# 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
struct siginfo
{
# 49 "include/uapi/asm-generic/siginfo.h"
  int si_signo;
  int si_errno;
  int si_code;
# 108 "include/uapi/asm-generic/siginfo.h"
  union
  {
# 54 "include/uapi/asm-generic/siginfo.h"
    int _pad[28U];
# 60 "include/uapi/asm-generic/siginfo.h"
    struct
    {
# 58 "include/uapi/asm-generic/siginfo.h"
      __kernel_pid_t _pid;
      __kernel_uid32_t _uid;
    } _kill;
# 69 "include/uapi/asm-generic/siginfo.h"
    struct
    {
# 64 "include/uapi/asm-generic/siginfo.h"
      __kernel_timer_t _tid;
      int _overrun;
      char _pad[0U];
      sigval_t _sigval;
      int _sys_private;
    } _timer;
# 76 "include/uapi/asm-generic/siginfo.h"
    struct
    {
# 73 "include/uapi/asm-generic/siginfo.h"
      __kernel_pid_t _pid;
      __kernel_uid32_t _uid;
      sigval_t _sigval;
    } _rt;
# 85 "include/uapi/asm-generic/siginfo.h"
    struct
    {
# 80 "include/uapi/asm-generic/siginfo.h"
      __kernel_pid_t _pid;
      __kernel_uid32_t _uid;
      int _status;
      __kernel_clock_t _utime;
      __kernel_clock_t _stime;
    } _sigchld;
# 94 "include/uapi/asm-generic/siginfo.h"
    struct
    {
# 89 "include/uapi/asm-generic/siginfo.h"
      void *_addr;
# 93 "include/uapi/asm-generic/siginfo.h"
      short int _addr_lsb;
    } _sigfault;
# 100 "include/uapi/asm-generic/siginfo.h"
    struct
    {
# 98 "include/uapi/asm-generic/siginfo.h"
      long int _band;
      int _fd;
    } _sigpoll;
# 107 "include/uapi/asm-generic/siginfo.h"
    struct
    {
# 104 "include/uapi/asm-generic/siginfo.h"
      void *_call_addr;
      int _syscall;
      unsigned int _arch;
    } _sigsys;
  } _sifields;
};
# 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
struct sigevent
{
# 279 "include/uapi/asm-generic/siginfo.h"
  sigval_t sigev_value;
  int sigev_signo;
  int sigev_notify;
# 290 "include/uapi/asm-generic/siginfo.h"
  union
  {
# 283 "include/uapi/asm-generic/siginfo.h"
    int _pad[12U];
    int _tid;
# 289 "include/uapi/asm-generic/siginfo.h"
    struct
    {
# 287 "include/uapi/asm-generic/siginfo.h"
      void (*_function)(sigval_t);
      void *_attribute;
    } _sigev_thread;
  } _sigev_un;
};
# 291 "include/uapi/asm-generic/siginfo.h"
typedef struct sigevent sigevent_t;
# 18 "include/asm-generic/siginfo.h"
void do_schedule_next_timer(struct siginfo *);
# 24 "include/asm-generic/siginfo.h"
static inline void copy_siginfo(struct siginfo *to, struct siginfo *from)
{
  if (( * from ) . si_code < 0)
  {
# 27 "include/asm-generic/siginfo.h"
    ({
# 27 "include/asm-generic/siginfo.h"
      size_t __len = 128UL;
# 27 "include/asm-generic/siginfo.h"
      void *__ret;
      {
# 27 "include/asm-generic/siginfo.h"
        if (__len > 63UL)
        {
# 27 "include/asm-generic/siginfo.h"
          __ret = __memcpy ( ( void *) to , ( void const *) from , __len );
        }
        else
# 27 "include/asm-generic/siginfo.h"
          __ret = __builtin_memcpy ( ( void *) to , ( void const *) from , __len );
      }
# 27 "include/asm-generic/siginfo.h"
      __ret;
    } );
  }
  else
# 30 "include/asm-generic/siginfo.h"
    ({
# 30 "include/asm-generic/siginfo.h"
      size_t __len = 48UL;
# 30 "include/asm-generic/siginfo.h"
      void *__ret;
      {
# 30 "include/asm-generic/siginfo.h"
        if (__len > 63UL)
        {
# 30 "include/asm-generic/siginfo.h"
          __ret = __memcpy ( ( void *) to , ( void const *) from , __len );
        }
        else
# 30 "include/asm-generic/siginfo.h"
          __ret = __builtin_memcpy ( ( void *) to , ( void const *) from , __len );
      }
# 30 "include/asm-generic/siginfo.h"
      __ret;
    } );
}
# 35 "include/asm-generic/siginfo.h"
int copy_siginfo_to_user(struct siginfo *, struct siginfo const *);
# 10 "include/linux/signal.h"
extern int print_fatal_signals;
struct sigqueue
{
# 16 "include/linux/signal.h"
  struct list_head list;
  int flags;
  siginfo_t info;
  struct user_struct *user;
};
struct sigpending
{
# 26 "include/linux/signal.h"
  struct list_head list;
  sigset_t signal;
};
# 39 "include/linux/signal.h"
static inline void sigaddset(sigset_t *set, int _sig)
{
  long unsigned int sig = ( long unsigned int ) ( _sig + -1 );
  if (1)
  {
# 43 "include/linux/signal.h"
    ( * set ) . sig [ 0 ] |= 1UL << ( int ) sig;
  }
  else
# 45 "include/linux/signal.h"
    ( * set ) . sig [ sig / 64UL ] |= 1UL << ( ( int ) sig & 63 );
}
# 48 "include/linux/signal.h"
static inline void sigdelset(sigset_t *set, int _sig)
{
  long unsigned int sig = ( long unsigned int ) ( _sig + -1 );
  if (1)
  {
# 52 "include/linux/signal.h"
    ( * set ) . sig [ 0 ] &= ~ ( 1UL << ( int ) sig );
  }
  else
# 54 "include/linux/signal.h"
    ( * set ) . sig [ sig / 64UL ] &= ~ ( 1UL << ( ( int ) sig & 63 ) );
}
# 57 "include/linux/signal.h"
static inline int sigismember(sigset_t *set, int _sig)
{
  long unsigned int sig = ( long unsigned int ) ( _sig + -1 );
  if (1)
  {
# 61 "include/linux/signal.h"
    return ( int ) ( ( * set ) . sig [ 0 ] >> ( int ) sig ) & 1;
  }
  else
# 63 "include/linux/signal.h"
    return ( int ) ( ( * set ) . sig [ sig / 64UL ] >> ( ( int ) sig & 63 ) ) & 1;
}
# 70 "include/linux/signal.h"
void _NSIG_WORDS_is_unsupported_size(void);
# 68 "include/linux/signal.h"
static inline int sigisemptyset(sigset_t *set)
{
  void _NSIG_WORDS_is_unsupported_size(void);
  switch (1)
  {
# 72 "include/linux/signal.h"
    case 4:;
    return ( ( * set ) . sig [ 3 ] | ( * set ) . sig [ 2 ] | (
# 74 "include/linux/signal.h"
    * set ) . sig [ 1 ] | ( * set ) . sig [ 0 ] ) == 0UL;
    case 2:;
    return ( ( * set ) . sig [ 1 ] | ( * set ) . sig [ 0 ] ) == 0UL;
    case 1:;
    return ( * set ) . sig [ 0 ] == 0UL;
    default:;
    _NSIG_WORDS_is_unsupported_size ( );
    return 0;
  }
}
# 115 "include/linux/signal.h"
void _NSIG_WORDS_is_unsupported_size(void);
# 115 "include/linux/signal.h"
static inline void sigorsets(sigset_t *r, sigset_t const *a, sigset_t const *b)
{
# 115 "include/linux/signal.h"
  void _NSIG_WORDS_is_unsupported_size(void);
# 115 "include/linux/signal.h"
  long unsigned int a0;
# 115 "include/linux/signal.h"
  long unsigned int a1;
# 115 "include/linux/signal.h"
  long unsigned int a2;
# 115 "include/linux/signal.h"
  long unsigned int a3;
# 115 "include/linux/signal.h"
  long unsigned int b0;
# 115 "include/linux/signal.h"
  long unsigned int b1;
# 115 "include/linux/signal.h"
  long unsigned int b2;
# 115 "include/linux/signal.h"
  long unsigned int b3;
# 115 "include/linux/signal.h"
  switch (1)
  {
# 115 "include/linux/signal.h"
    case 4:;
# 115 "include/linux/signal.h"
    a3 = ( * a ) . sig [ 3 ];
# 115 "include/linux/signal.h"
    a2 = ( * a ) . sig [ 2 ];
# 115 "include/linux/signal.h"
    b3 = ( * b ) . sig [ 3 ];
# 115 "include/linux/signal.h"
    b2 = ( * b ) . sig [ 2 ];
# 115 "include/linux/signal.h"
    ( * r ) . sig [ 3 ] = a3 | b3;
# 115 "include/linux/signal.h"
    ( * r ) . sig [ 2 ] = a2 | b2;
# 115 "include/linux/signal.h"
    case 2:;
# 115 "include/linux/signal.h"
    a1 = ( * a ) . sig [ 1 ];
# 115 "include/linux/signal.h"
    b1 = ( * b ) . sig [ 1 ];
# 115 "include/linux/signal.h"
    ( * r ) . sig [ 1 ] = a1 | b1;
# 115 "include/linux/signal.h"
    case 1:;
# 115 "include/linux/signal.h"
    a0 = ( * a ) . sig [ 0 ];
# 115 "include/linux/signal.h"
    b0 = ( * b ) . sig [ 0 ];
# 115 "include/linux/signal.h"
    ( * r ) . sig [ 0 ] = a0 | b0;
# 115 "include/linux/signal.h"
    goto ldv_16388;
# 115 "include/linux/signal.h"
    default:;
# 115 "include/linux/signal.h"
    _NSIG_WORDS_is_unsupported_size ( );
  }
# 115 "include/linux/signal.h"
  ldv_16388:;
}
# 118 "include/linux/signal.h"
void _NSIG_WORDS_is_unsupported_size(void);
# 118 "include/linux/signal.h"
static inline void sigandsets(sigset_t *r, sigset_t const *a, sigset_t const *b)
{
# 118 "include/linux/signal.h"
  void _NSIG_WORDS_is_unsupported_size(void);
# 118 "include/linux/signal.h"
  long unsigned int a0;
# 118 "include/linux/signal.h"
  long unsigned int a1;
# 118 "include/linux/signal.h"
  long unsigned int a2;
# 118 "include/linux/signal.h"
  long unsigned int a3;
# 118 "include/linux/signal.h"
  long unsigned int b0;
# 118 "include/linux/signal.h"
  long unsigned int b1;
# 118 "include/linux/signal.h"
  long unsigned int b2;
# 118 "include/linux/signal.h"
  long unsigned int b3;
# 118 "include/linux/signal.h"
  switch (1)
  {
# 118 "include/linux/signal.h"
    case 4:;
# 118 "include/linux/signal.h"
    a3 = ( * a ) . sig [ 3 ];
# 118 "include/linux/signal.h"
    a2 = ( * a ) . sig [ 2 ];
# 118 "include/linux/signal.h"
    b3 = ( * b ) . sig [ 3 ];
# 118 "include/linux/signal.h"
    b2 = ( * b ) . sig [ 2 ];
# 118 "include/linux/signal.h"
    ( * r ) . sig [ 3 ] = a3 & b3;
# 118 "include/linux/signal.h"
    ( * r ) . sig [ 2 ] = a2 & b2;
# 118 "include/linux/signal.h"
    case 2:;
# 118 "include/linux/signal.h"
    a1 = ( * a ) . sig [ 1 ];
# 118 "include/linux/signal.h"
    b1 = ( * b ) . sig [ 1 ];
# 118 "include/linux/signal.h"
    ( * r ) . sig [ 1 ] = a1 & b1;
# 118 "include/linux/signal.h"
    case 1:;
# 118 "include/linux/signal.h"
    a0 = ( * a ) . sig [ 0 ];
# 118 "include/linux/signal.h"
    b0 = ( * b ) . sig [ 0 ];
# 118 "include/linux/signal.h"
    ( * r ) . sig [ 0 ] = a0 & b0;
# 118 "include/linux/signal.h"
    goto ldv_16409;
# 118 "include/linux/signal.h"
    default:;
# 118 "include/linux/signal.h"
    _NSIG_WORDS_is_unsupported_size ( );
  }
# 118 "include/linux/signal.h"
  ldv_16409:;
}
# 121 "include/linux/signal.h"
void _NSIG_WORDS_is_unsupported_size(void);
# 121 "include/linux/signal.h"
static inline void sigandnsets(sigset_t *r, sigset_t const *a, sigset_t const *b)
{
# 121 "include/linux/signal.h"
  void _NSIG_WORDS_is_unsupported_size(void);
# 121 "include/linux/signal.h"
  long unsigned int a0;
# 121 "include/linux/signal.h"
  long unsigned int a1;
# 121 "include/linux/signal.h"
  long unsigned int a2;
# 121 "include/linux/signal.h"
  long unsigned int a3;
# 121 "include/linux/signal.h"
  long unsigned int b0;
# 121 "include/linux/signal.h"
  long unsigned int b1;
# 121 "include/linux/signal.h"
  long unsigned int b2;
# 121 "include/linux/signal.h"
  long unsigned int b3;
# 121 "include/linux/signal.h"
  switch (1)
  {
# 121 "include/linux/signal.h"
    case 4:;
# 121 "include/linux/signal.h"
    a3 = ( * a ) . sig [ 3 ];
# 121 "include/linux/signal.h"
    a2 = ( * a ) . sig [ 2 ];
# 121 "include/linux/signal.h"
    b3 = ( * b ) . sig [ 3 ];
# 121 "include/linux/signal.h"
    b2 = ( * b ) . sig [ 2 ];
# 121 "include/linux/signal.h"
    ( * r ) . sig [ 3 ] = ~ b3 & a3;
# 121 "include/linux/signal.h"
    ( * r ) . sig [ 2 ] = ~ b2 & a2;
# 121 "include/linux/signal.h"
    case 2:;
# 121 "include/linux/signal.h"
    a1 = ( * a ) . sig [ 1 ];
# 121 "include/linux/signal.h"
    b1 = ( * b ) . sig [ 1 ];
# 121 "include/linux/signal.h"
    ( * r ) . sig [ 1 ] = ~ b1 & a1;
# 121 "include/linux/signal.h"
    case 1:;
# 121 "include/linux/signal.h"
    a0 = ( * a ) . sig [ 0 ];
# 121 "include/linux/signal.h"
    b0 = ( * b ) . sig [ 0 ];
# 121 "include/linux/signal.h"
    ( * r ) . sig [ 0 ] = ~ b0 & a0;
# 121 "include/linux/signal.h"
    goto ldv_16430;
# 121 "include/linux/signal.h"
    default:;
# 121 "include/linux/signal.h"
    _NSIG_WORDS_is_unsupported_size ( );
  }
# 121 "include/linux/signal.h"
  ldv_16430:;
}
# 145 "include/linux/signal.h"
void _NSIG_WORDS_is_unsupported_size(void);
# 145 "include/linux/signal.h"
static inline void signotset(sigset_t *set)
{
# 145 "include/linux/signal.h"
  void _NSIG_WORDS_is_unsupported_size(void);
# 145 "include/linux/signal.h"
  switch (1)
  {
# 145 "include/linux/signal.h"
    case 4:;
# 145 "include/linux/signal.h"
    ( * set ) . sig [ 3 ] = ~ ( * set ) . sig [ 3 ];
# 145 "include/linux/signal.h"
    ( * set ) . sig [ 2 ] = ~ ( * set ) . sig [ 2 ];
# 145 "include/linux/signal.h"
    case 2:;
# 145 "include/linux/signal.h"
    ( * set ) . sig [ 1 ] = ~ ( * set ) . sig [ 1 ];
# 145 "include/linux/signal.h"
    case 1:;
# 145 "include/linux/signal.h"
    ( * set ) . sig [ 0 ] = ~ ( * set ) . sig [ 0 ];
# 145 "include/linux/signal.h"
    goto ldv_16441;
# 145 "include/linux/signal.h"
    default:;
# 145 "include/linux/signal.h"
    _NSIG_WORDS_is_unsupported_size ( );
  }
# 145 "include/linux/signal.h"
  ldv_16441:;
}
# 150 "include/linux/signal.h"
static inline void sigemptyset(sigset_t *set)
{
  switch (1)
  {
# 153 "include/linux/signal.h"
    default:;
    memset ( ( void *) set , 0 , 8UL );
    goto ldv_16448;
    case 2:;
# 156 "include/linux/signal.h"
    ( * set ) . sig [ 1 ] = 0UL;
    case 1:;
# 157 "include/linux/signal.h"
    ( * set ) . sig [ 0 ] = 0UL;
    goto ldv_16448;
  }
  ldv_16448:;
}
static inline void sigfillset(sigset_t *set)
{
  switch (1)
  {
# 165 "include/linux/signal.h"
    default:;
    memset ( ( void *) set , -1 , 8UL );
    goto ldv_16455;
    case 2:;
# 168 "include/linux/signal.h"
    ( * set ) . sig [ 1 ] = 18446744073709551615UL;
    case 1:;
# 169 "include/linux/signal.h"
    ( * set ) . sig [ 0 ] = 18446744073709551615UL;
    goto ldv_16455;
  }
  ldv_16455:;
}
# 176 "include/linux/signal.h"
static inline void sigaddsetmask(sigset_t *set, long unsigned int mask)
{
  ( * set ) . sig [ 0 ] |= mask;
}
# 181 "include/linux/signal.h"
static inline void sigdelsetmask(sigset_t *set, long unsigned int mask)
{
  ( * set ) . sig [ 0 ] &= ~ mask;
}
# 186 "include/linux/signal.h"
static inline int sigtestsetmask(sigset_t *set, long unsigned int mask)
{
  return ( ( * set ) . sig [ 0 ] & mask ) != 0UL;
}
# 191 "include/linux/signal.h"
static inline void siginitset(sigset_t *set, long unsigned int mask)
{
  ( * set ) . sig [ 0 ] = mask;
  switch (1)
  {
# 195 "include/linux/signal.h"
    default:;
    memset ( ( void *) & ( * set ) . sig + 1U , 0 , 0UL );
    goto ldv_16475;
    case 2:;
# 198 "include/linux/signal.h"
    ( * set ) . sig [ 1 ] = 0UL;
    case 1:;
  }
  ldv_16475:;
}
static inline void siginitsetinv(sigset_t *set, long unsigned int mask)
{
  ( * set ) . sig [ 0 ] = ~ mask;
  switch (1)
  {
# 207 "include/linux/signal.h"
    default:;
    memset ( ( void *) & ( * set ) . sig + 1U , -1 , 0UL );
    goto ldv_16483;
    case 2:;
# 210 "include/linux/signal.h"
    ( * set ) . sig [ 1 ] = 18446744073709551615UL;
    case 1:;
  }
  ldv_16483:;
}
# 217 "include/linux/signal.h"
static inline void init_sigpending(struct sigpending *sig)
{
  sigemptyset ( & ( * sig ) . signal );
  INIT_LIST_HEAD ( & ( * sig ) . list );
}
# 223 "include/linux/signal.h"
void flush_sigqueue(struct sigpending *);
# 226 "include/linux/signal.h"
static inline int valid_signal(long unsigned int sig)
{
  return sig <= 64UL;
}
# 234 "include/linux/signal.h"
int next_signal(struct sigpending *, sigset_t *);
int do_send_sig_info(int, struct siginfo *, struct task_struct *, bool);
# 237 "include/linux/signal.h"
int group_send_sig_info(int, struct siginfo *, struct task_struct *);
int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
int do_sigtimedwait(sigset_t const *, siginfo_t *, struct timespec const *);
# 241 "include/linux/signal.h"
int sigprocmask(int, sigset_t *, sigset_t *);
void set_current_blocked(sigset_t *);
void __set_current_blocked(sigset_t const *);
extern int show_unhandled_signals;
int sigsuspend(sigset_t *);
struct sigaction
{
# 249 "include/linux/signal.h"
  __sighandler_t sa_handler;
  long unsigned int sa_flags;
# 256 "include/linux/signal.h"
  __sigrestore_t sa_restorer;
# 258 "include/linux/signal.h"
  sigset_t sa_mask;
};
struct k_sigaction
{
  struct sigaction sa;
};
struct ksignal
{
# 278 "include/linux/signal.h"
  struct k_sigaction ka;
  siginfo_t info;
  int sig;
};
# 283 "include/linux/signal.h"
int get_signal(struct ksignal *);
void signal_setup_done(int, struct ksignal *, int);
void exit_signals(struct task_struct *);
void kernel_sigaction(int, __sighandler_t);
# 288 "include/linux/signal.h"
static inline void allow_signal(int sig)
{
# 295 "include/linux/signal.h"
  kernel_sigaction ( sig , ( ( __signalfn_t *) 2 ) );
}
# 298 "include/linux/signal.h"
static inline void disallow_signal(int sig)
{
  kernel_sigaction ( sig , ( ( __signalfn_t *) 1 ) );
}
# 303 "include/linux/signal.h"
extern struct kmem_cache *sighand_cachep;
# 305 "include/linux/signal.h"
int unhandled_signal(struct task_struct *, int);
# 430 "include/linux/signal.h"
void signals_init(void);
# 432 "include/linux/signal.h"
int restore_altstack(stack_t const *);
int __save_altstack(stack_t *, long unsigned int);
# 445 "include/linux/signal.h"
void render_sigset_t(struct seq_file *, char const *, sigset_t *);
enum pid_type
{
  PIDTYPE_PID = 0,
  PIDTYPE_PGID = 1,
  PIDTYPE_SID = 2,
  PIDTYPE_MAX = 3
};
struct upid
{
# 52 "include/linux/pid.h"
  int nr;
  struct pid_namespace *ns;
  struct hlist_node pid_chain;
};
struct pid
{
# 59 "include/linux/pid.h"
  atomic_t count;
  unsigned int level;
# 62 "include/linux/pid.h"
  struct hlist_head tasks[3U];
  struct callback_head rcu;
  struct upid numbers[1U];
};
# 67 "include/linux/pid.h"
extern struct pid init_struct_pid;
struct pid_link
{
# 71 "include/linux/pid.h"
  struct hlist_node node;
  struct pid *pid;
};
# 75 "include/linux/pid.h"
static inline struct pid *get_pid(struct pid *pid)
{
  if (pid != ( ( struct pid *) 0 ))
    atomic_inc ( & ( * pid ) . count );
  return pid;
}
# 82 "include/linux/pid.h"
void put_pid(struct pid *);
struct task_struct *pid_task(struct pid *, enum pid_type);
struct task_struct *get_pid_task(struct pid *, enum pid_type);
# 86 "include/linux/pid.h"
struct pid *get_task_pid(struct task_struct *, enum pid_type);
# 91 "include/linux/pid.h"
void attach_pid(struct task_struct *, enum pid_type);
void detach_pid(struct task_struct *, enum pid_type);
void change_pid(struct task_struct *, enum pid_type, struct pid *);
# 95 "include/linux/pid.h"
void transfer_pid(struct task_struct *, struct task_struct *, enum pid_type);
# 99 "include/linux/pid.h"
extern struct pid_namespace init_pid_ns;
# 110 "include/linux/pid.h"
struct pid *find_pid_ns(int, struct pid_namespace *);
struct pid *find_vpid(int);
# 116 "include/linux/pid.h"
struct pid *find_get_pid(int);
struct pid *find_ge_pid(int, struct pid_namespace *);
int next_pidmap(struct pid_namespace *, unsigned int);
# 120 "include/linux/pid.h"
struct pid *alloc_pid(struct pid_namespace *);
void free_pid(struct pid *);
void disable_pid_allocation(struct pid_namespace *);
# 134 "include/linux/pid.h"
static inline struct pid_namespace *ns_of_pid(struct pid *pid)
{
  struct pid_namespace *ns = ( ( struct pid_namespace *) 0 );
  if (pid != ( ( struct pid *) 0 ))
    ns = ( * pid ) . numbers [ ( * pid ) . level ] . ns;
  return ns;
}
# 148 "include/linux/pid.h"
static inline bool is_child_reaper(struct pid *pid)
{
  return ( * pid ) . numbers [ ( * pid ) . level ] . nr == 1;
}
# 164 "include/linux/pid.h"
static inline pid_t pid_nr(struct pid *pid)
{
  pid_t nr = 0;
  if (pid != ( ( struct pid *) 0 ))
    nr = ( * pid ) . numbers [ 0 ] . nr;
  return nr;
}
# 172 "include/linux/pid.h"
pid_t pid_nr_ns(struct pid *, struct pid_namespace *);
pid_t pid_vnr(struct pid *);
struct percpu_counter
{
# 19 "include/linux/percpu_counter.h"
  raw_spinlock_t lock;
  s64 count;
# 22 "include/linux/percpu_counter.h"
  struct list_head list;
# 24 "include/linux/percpu_counter.h"
  s32 *counters;
};
# 27 "include/linux/percpu_counter.h"
extern int percpu_counter_batch;
# 29 "include/linux/percpu_counter.h"
int __percpu_counter_init(struct percpu_counter *, s64, struct lock_class_key *);
# 39 "include/linux/percpu_counter.h"
void percpu_counter_destroy(struct percpu_counter *);
void percpu_counter_set(struct percpu_counter *, s64);
void __percpu_counter_add(struct percpu_counter *, s64, s32);
s64 __percpu_counter_sum(struct percpu_counter *);
int percpu_counter_compare(struct percpu_counter *, s64);
# 45 "include/linux/percpu_counter.h"
static inline void percpu_counter_add(struct percpu_counter *fbc, s64 amount)
{
  __percpu_counter_add ( fbc , amount , percpu_counter_batch );
}
# 50 "include/linux/percpu_counter.h"
static inline s64 percpu_counter_sum_positive(struct percpu_counter *fbc)
{
  s64 ret = __percpu_counter_sum ( fbc );
  return ((0LL) > (ret) ? (0LL) : (ret));
}
# 56 "include/linux/percpu_counter.h"
static inline s64 percpu_counter_sum(struct percpu_counter *fbc)
{
  return __percpu_counter_sum ( fbc );
}
# 61 "include/linux/percpu_counter.h"
static inline s64 percpu_counter_read(struct percpu_counter *fbc)
{
  return ( * fbc ) . count;
}
# 71 "include/linux/percpu_counter.h"
static inline s64 percpu_counter_read_positive(struct percpu_counter *fbc)
{
  s64 ret = ( * fbc ) . count;
# 75 "include/linux/percpu_counter.h"
  asm volatile ( "" : : : "memory" ) ;
  if (ret >= 0LL)
    return ret;
  return 0LL;
}
# 81 "include/linux/percpu_counter.h"
static inline int percpu_counter_initialized(struct percpu_counter *fbc)
{
  return ( * fbc ) . counters != ( ( s32 *) 0 );
}
# 162 "include/linux/percpu_counter.h"
static inline void percpu_counter_inc(struct percpu_counter *fbc)
{
  percpu_counter_add ( fbc , 1LL );
}
# 167 "include/linux/percpu_counter.h"
static inline void percpu_counter_dec(struct percpu_counter *fbc)
{
  percpu_counter_add ( fbc , -1LL );
}
# 172 "include/linux/percpu_counter.h"
static inline void percpu_counter_sub(struct percpu_counter *fbc, s64 amount)
{
  percpu_counter_add ( fbc , - amount );
}
struct prop_global
{
# 22 "include/linux/proportions.h"
  int shift;
# 29 "include/linux/proportions.h"
  struct percpu_counter events;
};
struct prop_descriptor
{
# 38 "include/linux/proportions.h"
  int index;
  struct prop_global pg[2U];
  struct mutex mutex;
};
# 43 "include/linux/proportions.h"
int prop_descriptor_init(struct prop_descriptor *, int);
void prop_change_shift(struct prop_descriptor *, int);
struct prop_local_percpu
{
# 54 "include/linux/proportions.h"
  struct percpu_counter events;
# 59 "include/linux/proportions.h"
  int shift;
  long unsigned int period;
  raw_spinlock_t lock;
};
# 64 "include/linux/proportions.h"
int prop_local_init_percpu(struct prop_local_percpu *);
void prop_local_destroy_percpu(struct prop_local_percpu *);
void __prop_inc_percpu(struct prop_descriptor *, struct prop_local_percpu *);
void prop_fraction_percpu(struct prop_descriptor *, struct prop_local_percpu *, long int *, long int *);
# 71 "include/linux/proportions.h"
static inline void prop_inc_percpu(struct prop_descriptor *pd, struct prop_local_percpu *pl)
{
  long unsigned int flags;
# 75 "include/linux/proportions.h"
  ({
# 75 "include/linux/proportions.h"
    long unsigned int __dummy;
# 75 "include/linux/proportions.h"
    long unsigned int __dummy2;
# 75 "include/linux/proportions.h"
    ( void ) 0;
# 75 "include/linux/proportions.h"
    1;
  } );
# 75 "include/linux/proportions.h"
  flags = arch_local_irq_save ( );
# 75 "include/linux/proportions.h"
  trace_hardirqs_off ( );
  __prop_inc_percpu ( pd , pl );
  if (({
# 77 "include/linux/proportions.h"
    ({
# 77 "include/linux/proportions.h"
      long unsigned int __dummy;
# 77 "include/linux/proportions.h"
      long unsigned int __dummy2;
# 77 "include/linux/proportions.h"
      ( void ) 0;
# 77 "include/linux/proportions.h"
      1;
    } );
# 77 "include/linux/proportions.h"
    arch_irqs_disabled_flags ( flags );
  } )
# 77 "include/linux/proportions.h"
  != 0)
  {
# 77 "include/linux/proportions.h"
    ({
# 77 "include/linux/proportions.h"
      long unsigned int __dummy;
# 77 "include/linux/proportions.h"
      long unsigned int __dummy2;
# 77 "include/linux/proportions.h"
      ( void ) 0;
# 77 "include/linux/proportions.h"
      1;
    } );
# 77 "include/linux/proportions.h"
    arch_local_irq_restore ( flags );
# 77 "include/linux/proportions.h"
    trace_hardirqs_off ( );
  }
  else
  {
# 77 "include/linux/proportions.h"
    trace_hardirqs_on ( );
# 77 "include/linux/proportions.h"
    ({
# 77 "include/linux/proportions.h"
      long unsigned int __dummy;
# 77 "include/linux/proportions.h"
      long unsigned int __dummy2;
# 77 "include/linux/proportions.h"
      ( void ) 0;
# 77 "include/linux/proportions.h"
      1;
    } );
# 77 "include/linux/proportions.h"
    arch_local_irq_restore ( flags );
  }
}
# 93 "include/linux/proportions.h"
void __prop_inc_percpu_max(struct prop_descriptor *, struct prop_local_percpu *, long int);
struct prop_local_single
{
# 105 "include/linux/proportions.h"
  long unsigned int events;
# 111 "include/linux/proportions.h"
  long unsigned int period;
  int shift;
  raw_spinlock_t lock;
};
# 120 "include/linux/proportions.h"
int prop_local_init_single(struct prop_local_single *);
void prop_local_destroy_single(struct prop_local_single *);
void __prop_inc_single(struct prop_descriptor *, struct prop_local_single *);
void prop_fraction_single(struct prop_descriptor *, struct prop_local_single *, long int *, long int *);
# 127 "include/linux/proportions.h"
static inline void prop_inc_single(struct prop_descriptor *pd, struct prop_local_single *pl)
{
  long unsigned int flags;
# 131 "include/linux/proportions.h"
  ({
# 131 "include/linux/proportions.h"
    long unsigned int __dummy;
# 131 "include/linux/proportions.h"
    long unsigned int __dummy2;
# 131 "include/linux/proportions.h"
    ( void ) 0;
# 131 "include/linux/proportions.h"
    1;
  } );
# 131 "include/linux/proportions.h"
  flags = arch_local_irq_save ( );
# 131 "include/linux/proportions.h"
  trace_hardirqs_off ( );
  __prop_inc_single ( pd , pl );
  if (({
# 133 "include/linux/proportions.h"
    ({
# 133 "include/linux/proportions.h"
      long unsigned int __dummy;
# 133 "include/linux/proportions.h"
      long unsigned int __dummy2;
# 133 "include/linux/proportions.h"
      ( void ) 0;
# 133 "include/linux/proportions.h"
      1;
    } );
# 133 "include/linux/proportions.h"
    arch_irqs_disabled_flags ( flags );
  } )
# 133 "include/linux/proportions.h"
  != 0)
  {
# 133 "include/linux/proportions.h"
    ({
# 133 "include/linux/proportions.h"
      long unsigned int __dummy;
# 133 "include/linux/proportions.h"
      long unsigned int __dummy2;
# 133 "include/linux/proportions.h"
      ( void ) 0;
# 133 "include/linux/proportions.h"
      1;
    } );
# 133 "include/linux/proportions.h"
    arch_local_irq_restore ( flags );
# 133 "include/linux/proportions.h"
    trace_hardirqs_off ( );
  }
  else
  {
# 133 "include/linux/proportions.h"
    trace_hardirqs_on ( );
# 133 "include/linux/proportions.h"
    ({
# 133 "include/linux/proportions.h"
      long unsigned int __dummy;
# 133 "include/linux/proportions.h"
      long unsigned int __dummy2;
# 133 "include/linux/proportions.h"
      ( void ) 0;
# 133 "include/linux/proportions.h"
      1;
    } );
# 133 "include/linux/proportions.h"
    arch_local_irq_restore ( flags );
  }
}
struct seccomp_data
{
# 48 "include/uapi/linux/seccomp.h"
  int nr;
  __u32 arch;
  __u64 instruction_pointer;
  __u64 args[6U];
};
struct seccomp_filter;
struct seccomp
{
# 26 "include/linux/seccomp.h"
  int mode;
  struct seccomp_filter *filter;
};
# 30 "include/linux/seccomp.h"
int __secure_computing(int);
static inline int secure_computing(int this_syscall)
{
  if (__builtin_expect ( test_ti_thread_flag ( current_thread_info ( ) , 8 ) != 0 , 0L ) != 0L)
    return __secure_computing ( this_syscall );
  return 0;
}
# 39 "include/linux/seccomp.h"
static inline void secure_computing_strict(int this_syscall)
{
  if (__builtin_expect ( secure_computing ( this_syscall ) != 0 , 0L ) != 0L)
  {
# 41 "include/linux/seccomp.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/seccomp.h" ) , "i" ( 41 ) , "i" ( 12UL ) ) ;
    ldv_16810:;
# 41 "include/linux/seccomp.h"
    goto ldv_16810;
  }
}
long int prctl_get_seccomp(void);
long int prctl_set_seccomp(long unsigned int, char *);
# 47 "include/linux/seccomp.h"
static inline int seccomp_mode(struct seccomp *s)
{
  return ( * s ) . mode;
}
# 79 "include/linux/seccomp.h"
void put_seccomp_filter(struct task_struct *);
void get_seccomp_filter(struct task_struct *);
# 30 "include/linux/rculist.h"
static inline void INIT_LIST_HEAD_RCU(struct list_head *list)
{
  * ( struct list_head *volatile *) & ( * list ) . next = list;
  * ( struct list_head *volatile *) & ( * list ) . prev = list;
}
# 58 "include/linux/rculist.h"
void __list_add_rcu(struct list_head *, struct list_head *, struct list_head *);
# 78 "include/linux/rculist.h"
static inline void list_add_rcu(struct list_head *new, struct list_head *head)
{
  __list_add_rcu ( new , head , ( * head ) . next );
}
# 99 "include/linux/rculist.h"
static inline void list_add_tail_rcu(struct list_head *new, struct list_head *head)
{
# 102 "include/linux/rculist.h"
  __list_add_rcu ( new , ( * head ) . prev , head );
}
# 129 "include/linux/rculist.h"
static inline void list_del_rcu(struct list_head *entry)
{
  __list_del_entry ( entry );
  ( * entry ) . prev = ( ( struct list_head *) -2401263026316508672 );
}
# 155 "include/linux/rculist.h"
static inline void hlist_del_init_rcu(struct hlist_node *n)
{
  if (hlist_unhashed ( ( struct hlist_node const *) n ) == 0)
  {
# 158 "include/linux/rculist.h"
    __hlist_del ( n );
    ( * n ) . pprev = ( ( struct hlist_node **) 0 );
  }
}
# 176 "include/linux/rculist.h"
void __compiletime_assert_176(void);
# 171 "include/linux/rculist.h"
static inline void list_replace_rcu(struct list_head *old, struct list_head *new)
{
# 174 "include/linux/rculist.h"
  ( * new ) . next = ( * old ) . next;
  ( * new ) . prev = ( * old ) . prev;
  {
# 176 "include/linux/rculist.h"
    bool __cond = 0;
# 176 "include/linux/rculist.h"
    void __compiletime_assert_176(void);
# 176 "include/linux/rculist.h"
    if (( int ) __cond)
# 176 "include/linux/rculist.h"
      __compiletime_assert_176 ( );
  }
# 176 "include/linux/rculist.h"
  asm volatile ( "" : : : "memory" ) ;
# 176 "include/linux/rculist.h"
  * ( struct list_head *volatile *) & ( * ( * new ) . prev ) . next = new;
  ( * ( * new ) . next ) . prev = new;
  ( * old ) . prev = ( ( struct list_head *) -2401263026316508672 );
}
# 235 "include/linux/rculist.h"
void __compiletime_assert_235(void);
# 198 "include/linux/rculist.h"
static inline void list_splice_init_rcu(struct list_head *list, struct list_head *head, void (*sync)(void))
{
# 202 "include/linux/rculist.h"
  struct list_head *first = ( * list ) . next;
  struct list_head *last = ( * list ) . prev;
  struct list_head *at = ( * head ) . next;
# 206 "include/linux/rculist.h"
  if (list_empty ( ( struct list_head const *) list ) != 0)
    return;
# 215 "include/linux/rculist.h"
  INIT_LIST_HEAD_RCU ( list );
# 224 "include/linux/rculist.h"
  sync ( );
# 234 "include/linux/rculist.h"
  ( * last ) . next = at;
  {
# 235 "include/linux/rculist.h"
    bool __cond = 0;
# 235 "include/linux/rculist.h"
    void __compiletime_assert_235(void);
# 235 "include/linux/rculist.h"
    if (( int ) __cond)
# 235 "include/linux/rculist.h"
      __compiletime_assert_235 ( );
  }
# 235 "include/linux/rculist.h"
  asm volatile ( "" : : : "memory" ) ;
# 235 "include/linux/rculist.h"
  * ( struct list_head *volatile *) & ( * head ) . next = first;
  ( * first ) . prev = head;
  ( * at ) . prev = last;
}
# 343 "include/linux/rculist.h"
static inline void hlist_del_rcu(struct hlist_node *n)
{
  __hlist_del ( n );
  ( * n ) . pprev = ( ( struct hlist_node **) -2401263026316508672 );
}
# 363 "include/linux/rculist.h"
void __compiletime_assert_363(void);
# 356 "include/linux/rculist.h"
static inline void hlist_replace_rcu(struct hlist_node *old, struct hlist_node *new)
{
# 359 "include/linux/rculist.h"
  struct hlist_node *next = ( * old ) . next;
# 361 "include/linux/rculist.h"
  ( * new ) . next = next;
  ( * new ) . pprev = ( * old ) . pprev;
  {
# 363 "include/linux/rculist.h"
    bool __cond = 0;
# 363 "include/linux/rculist.h"
    void __compiletime_assert_363(void);
# 363 "include/linux/rculist.h"
    if (( int ) __cond)
# 363 "include/linux/rculist.h"
      __compiletime_assert_363 ( );
  }
# 363 "include/linux/rculist.h"
  asm volatile ( "" : : : "memory" ) ;
# 363 "include/linux/rculist.h"
  * ( struct hlist_node *volatile *) ( * new ) . pprev = new;
  if (next != ( ( struct hlist_node *) 0 ))
    ( * ( * new ) . next ) . pprev = & ( * new ) . next;
  ( * old ) . pprev = ( ( struct hlist_node **) -2401263026316508672 );
}
# 402 "include/linux/rculist.h"
void __compiletime_assert_402(void);
# 395 "include/linux/rculist.h"
static inline void hlist_add_head_rcu(struct hlist_node *n, struct hlist_head *h)
{
# 398 "include/linux/rculist.h"
  struct hlist_node *first = ( * h ) . first;
# 400 "include/linux/rculist.h"
  ( * n ) . next = first;
  ( * n ) . pprev = & ( * h ) . first;
  {
# 402 "include/linux/rculist.h"
    bool __cond = 0;
# 402 "include/linux/rculist.h"
    void __compiletime_assert_402(void);
# 402 "include/linux/rculist.h"
    if (( int ) __cond)
# 402 "include/linux/rculist.h"
      __compiletime_assert_402 ( );
  }
# 402 "include/linux/rculist.h"
  asm volatile ( "" : : : "memory" ) ;
# 402 "include/linux/rculist.h"
  * ( struct hlist_node *volatile *) & ( * h ) . first = n;
  if (first != ( ( struct hlist_node *) 0 ))
    ( * first ) . pprev = & ( * n ) . next;
}
# 430 "include/linux/rculist.h"
void __compiletime_assert_430(void);
# 425 "include/linux/rculist.h"
static inline void hlist_add_before_rcu(struct hlist_node *n, struct hlist_node *next)
{
# 428 "include/linux/rculist.h"
  ( * n ) . pprev = ( * next ) . pprev;
  ( * n ) . next = next;
  {
# 430 "include/linux/rculist.h"
    bool __cond = 0;
# 430 "include/linux/rculist.h"
    void __compiletime_assert_430(void);
# 430 "include/linux/rculist.h"
    if (( int ) __cond)
# 430 "include/linux/rculist.h"
      __compiletime_assert_430 ( );
  }
# 430 "include/linux/rculist.h"
  asm volatile ( "" : : : "memory" ) ;
# 430 "include/linux/rculist.h"
  * ( struct hlist_node *volatile *) ( * n ) . pprev = n;
  ( * next ) . pprev = & ( * n ) . next;
}
# 457 "include/linux/rculist.h"
void __compiletime_assert_457(void);
# 452 "include/linux/rculist.h"
static inline void hlist_add_behind_rcu(struct hlist_node *n, struct hlist_node *prev)
{
# 455 "include/linux/rculist.h"
  ( * n ) . next = ( * prev ) . next;
  ( * n ) . pprev = & ( * prev ) . next;
  {
# 457 "include/linux/rculist.h"
    bool __cond = 0;
# 457 "include/linux/rculist.h"
    void __compiletime_assert_457(void);
# 457 "include/linux/rculist.h"
    if (( int ) __cond)
# 457 "include/linux/rculist.h"
      __compiletime_assert_457 ( );
  }
# 457 "include/linux/rculist.h"
  asm volatile ( "" : : : "memory" ) ;
# 457 "include/linux/rculist.h"
  * ( struct hlist_node *volatile *) & ( * prev ) . next = n;
  if (( * n ) . next != ( ( struct hlist_node *) 0 ))
    ( * ( * n ) . next ) . pprev = & ( * n ) . next;
}
# 19 "include/linux/rtmutex.h"
extern int max_lock_depth;
struct rt_mutex
{
# 30 "include/linux/rtmutex.h"
  raw_spinlock_t wait_lock;
  struct rb_root waiters;
  struct rb_node *waiters_leftmost;
  struct task_struct *owner;
# 35 "include/linux/rtmutex.h"
  int save_state;
  char const *name;
# 36 "include/linux/rtmutex.h"
  char const *file;
  int line;
  void *magic;
};
struct rt_mutex_waiter;
struct hrtimer_sleeper;
# 46 "include/linux/rtmutex.h"
int rt_mutex_debug_check_no_locks_freed(void const *, long unsigned int);
# 48 "include/linux/rtmutex.h"
void rt_mutex_debug_check_no_locks_held(struct task_struct *);
# 62 "include/linux/rtmutex.h"
void rt_mutex_debug_task_free(struct task_struct *);
# 84 "include/linux/rtmutex.h"
static inline int rt_mutex_is_locked(struct rt_mutex *lock)
{
  return ( * lock ) . owner != ( ( struct task_struct *) 0 );
}
# 89 "include/linux/rtmutex.h"
void __rt_mutex_init(struct rt_mutex *, char const *);
void rt_mutex_destroy(struct rt_mutex *);
# 92 "include/linux/rtmutex.h"
void rt_mutex_lock(struct rt_mutex *);
int rt_mutex_lock_interruptible(struct rt_mutex *);
int rt_mutex_timed_lock(struct rt_mutex *, struct hrtimer_sleeper *);
# 97 "include/linux/rtmutex.h"
int rt_mutex_trylock(struct rt_mutex *);
# 99 "include/linux/rtmutex.h"
void rt_mutex_unlock(struct rt_mutex *);
struct rusage
{
# 24 "include/uapi/linux/resource.h"
  struct timeval ru_utime;
  struct timeval ru_stime;
  __kernel_long_t ru_maxrss;
  __kernel_long_t ru_ixrss;
  __kernel_long_t ru_idrss;
  __kernel_long_t ru_isrss;
  __kernel_long_t ru_minflt;
  __kernel_long_t ru_majflt;
  __kernel_long_t ru_nswap;
  __kernel_long_t ru_inblock;
  __kernel_long_t ru_oublock;
  __kernel_long_t ru_msgsnd;
  __kernel_long_t ru_msgrcv;
  __kernel_long_t ru_nsignals;
  __kernel_long_t ru_nvcsw;
  __kernel_long_t ru_nivcsw;
};
struct rlimit
{
  __kernel_ulong_t rlim_cur;
  __kernel_ulong_t rlim_max;
};
struct rlimit64
{
# 50 "include/uapi/linux/resource.h"
  __u64 rlim_cur;
  __u64 rlim_max;
};
# 9 "include/linux/resource.h"
int getrusage(struct task_struct *, int, struct rusage *);
int do_prlimit(struct task_struct *, unsigned int, struct rlimit *, struct rlimit *);
struct timerqueue_node
{
# 9 "include/linux/timerqueue.h"
  struct rb_node node;
  ktime_t expires;
};
struct timerqueue_head
{
  struct rb_root head;
  struct timerqueue_node *next;
};
# 19 "include/linux/timerqueue.h"
void timerqueue_add(struct timerqueue_head *, struct timerqueue_node *);
# 21 "include/linux/timerqueue.h"
void timerqueue_del(struct timerqueue_head *, struct timerqueue_node *);
# 23 "include/linux/timerqueue.h"
struct timerqueue_node *timerqueue_iterate_next(struct timerqueue_node *);
# 35 "include/linux/timerqueue.h"
static inline struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)
{
  return ( * head ) . next;
}
# 40 "include/linux/timerqueue.h"
static inline void timerqueue_init(struct timerqueue_node *node)
{
  ( * node ) . node . __rb_parent_color = ( long unsigned int ) & ( * node ) . node;
}
# 45 "include/linux/timerqueue.h"
static inline void timerqueue_init_head(struct timerqueue_head *head)
{
  ( * head ) . head = ( struct rb_root ) { . rb_node = ( ( struct rb_node *) 0 ) };
  ( * head ) . next = ( ( struct timerqueue_node *) 0 );
}
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
enum hrtimer_mode
{
  HRTIMER_MODE_ABS = 0,
  HRTIMER_MODE_REL = 1,
  HRTIMER_MODE_PINNED = 2,
  HRTIMER_MODE_ABS_PINNED = 2,
  HRTIMER_MODE_REL_PINNED = 3
};
enum hrtimer_restart
{
  HRTIMER_NORESTART = 0,
  HRTIMER_RESTART = 1
};
struct hrtimer
{
# 109 "include/linux/hrtimer.h"
  struct timerqueue_node node;
  ktime_t _softexpires;
  enum hrtimer_restart (*function)(struct hrtimer *);
  struct hrtimer_clock_base *base;
  long unsigned int state;
# 115 "include/linux/hrtimer.h"
  int start_pid;
  void *start_site;
  char start_comm[16U];
};
struct hrtimer_sleeper
{
# 129 "include/linux/hrtimer.h"
  struct hrtimer timer;
  struct task_struct *task;
};
struct hrtimer_clock_base
{
# 146 "include/linux/hrtimer.h"
  struct hrtimer_cpu_base *cpu_base;
  int index;
  clockid_t clockid;
  struct timerqueue_head active;
  ktime_t resolution;
  ktime_t (*get_time)(void);
  ktime_t softirq_time;
  ktime_t offset;
};
enum hrtimer_base_type
{
  HRTIMER_BASE_MONOTONIC = 0,
  HRTIMER_BASE_REALTIME = 1,
  HRTIMER_BASE_BOOTTIME = 2,
  HRTIMER_BASE_TAI = 3,
  HRTIMER_MAX_CLOCK_BASES = 4
};
struct hrtimer_cpu_base
{
# 182 "include/linux/hrtimer.h"
  raw_spinlock_t lock;
  unsigned int cpu;
  unsigned int active_bases;
  unsigned int clock_was_set;
# 187 "include/linux/hrtimer.h"
  ktime_t expires_next;
  int hres_active;
  int hang_detected;
  long unsigned int nr_events;
  long unsigned int nr_retries;
  long unsigned int nr_hangs;
  ktime_t max_hang_time;
# 195 "include/linux/hrtimer.h"
  struct hrtimer_clock_base clock_base[4U];
};
# 198 "include/linux/hrtimer.h"
static inline void hrtimer_set_expires(struct hrtimer *timer, ktime_t time)
{
  ( * timer ) . node . expires = time;
  ( * timer ) . _softexpires = time;
}
# 204 "include/linux/hrtimer.h"
static inline void hrtimer_set_expires_range(struct hrtimer *timer, ktime_t time, ktime_t delta)
{
  ( * timer ) . _softexpires = time;
  ( * timer ) . node . expires = ktime_add_safe ( time , delta );
}
# 210 "include/linux/hrtimer.h"
static inline void hrtimer_set_expires_range_ns(struct hrtimer *timer, ktime_t time, long unsigned int delta)
{
  ( * timer ) . _softexpires = time;
  ( * timer ) . node . expires = ktime_add_safe ( time , ns_to_ktime ( ( u64 ) delta ) );
}
# 216 "include/linux/hrtimer.h"
static inline void hrtimer_set_expires_tv64(struct hrtimer *timer, s64 tv64)
{
  ( * timer ) . node . expires . tv64 = tv64;
  ( * timer ) . _softexpires . tv64 = tv64;
}
# 222 "include/linux/hrtimer.h"
static inline void hrtimer_add_expires(struct hrtimer *timer, ktime_t time)
{
  ( * timer ) . node . expires = ktime_add_safe ( ( * timer ) . node . expires , time );
  ( * timer ) . _softexpires = ktime_add_safe ( ( * timer ) . _softexpires , time );
}
# 228 "include/linux/hrtimer.h"
static inline void hrtimer_add_expires_ns(struct hrtimer *timer, u64 ns)
{
  ( * timer ) . node . expires = ( ktime_t ) { . tv64 = ( long long int ) ( ( long long unsigned int ) ( * timer ) . node . expires . tv64 + ( long long unsigned int ) ns ) };
  ( * timer ) . _softexpires = ( ktime_t ) { . tv64 = ( long long int ) ( ( long long unsigned int ) ( * timer ) . _softexpires . tv64 + ( long long unsigned int ) ns ) };
}
# 234 "include/linux/hrtimer.h"
static inline ktime_t hrtimer_get_expires(struct hrtimer const *timer)
{
  return ( ktime_t ) ( * timer ) . node . expires;
}
# 239 "include/linux/hrtimer.h"
static inline ktime_t hrtimer_get_softexpires(struct hrtimer const *timer)
{
  return ( ktime_t ) ( * timer ) . _softexpires;
}
# 244 "include/linux/hrtimer.h"
static inline s64 hrtimer_get_expires_tv64(struct hrtimer const *timer)
{
  return ( s64 ) ( * timer ) . node . expires . tv64;
}
static inline s64 hrtimer_get_softexpires_tv64(struct hrtimer const *timer)
{
  return ( s64 ) ( * timer ) . _softexpires . tv64;
}
# 253 "include/linux/hrtimer.h"
static inline s64 hrtimer_get_expires_ns(struct hrtimer const *timer)
{
  return ( s64 ) ( * timer ) . node . expires . tv64;
}
# 258 "include/linux/hrtimer.h"
static inline ktime_t hrtimer_expires_remaining(struct hrtimer const *timer)
{
  return ( ktime_t ) { . tv64 = ( long long int ) ( * timer ) . node . expires . tv64 - ( long long int ) ( * ( * timer ) . base ) . get_time ( ) . tv64 };
}
struct clock_event_device;
# 266 "include/linux/hrtimer.h"
void hrtimer_interrupt(struct clock_event_device *);
# 271 "include/linux/hrtimer.h"
static inline ktime_t hrtimer_cb_get_time(struct hrtimer *timer)
{
  return ( * ( * timer ) . base ) . get_time ( );
}
# 276 "include/linux/hrtimer.h"
static inline int hrtimer_is_hres_active(struct hrtimer *timer)
{
  return ( * ( * ( * timer ) . base ) . cpu_base ) . hres_active;
}
# 281 "include/linux/hrtimer.h"
void hrtimer_peek_ahead_timers(void);
# 294 "include/linux/hrtimer.h"
void clock_was_set_delayed(void);
# 321 "include/linux/hrtimer.h"
void clock_was_set(void);
# 323 "include/linux/hrtimer.h"
void timerfd_clock_was_set(void);
# 327 "include/linux/hrtimer.h"
void hrtimers_resume(void);
# 329 "include/linux/hrtimer.h"
extern char __pcpu_scope_tick_cpu_device;
# 329 "include/linux/hrtimer.h"
extern struct tick_device tick_cpu_device;
# 335 "include/linux/hrtimer.h"
void hrtimer_init(struct hrtimer *, clockid_t, enum hrtimer_mode);
# 339 "include/linux/hrtimer.h"
void hrtimer_init_on_stack(struct hrtimer *, clockid_t, enum hrtimer_mode);
# 342 "include/linux/hrtimer.h"
void destroy_hrtimer_on_stack(struct hrtimer *);
# 354 "include/linux/hrtimer.h"
int hrtimer_start(struct hrtimer *, ktime_t, enum hrtimer_mode const);
# 356 "include/linux/hrtimer.h"
int hrtimer_start_range_ns(struct hrtimer *, ktime_t, long unsigned int, enum hrtimer_mode const);
# 359 "include/linux/hrtimer.h"
int __hrtimer_start_range_ns(struct hrtimer *, ktime_t, long unsigned int, enum hrtimer_mode const, int);
# 363 "include/linux/hrtimer.h"
int hrtimer_cancel(struct hrtimer *);
int hrtimer_try_to_cancel(struct hrtimer *);
# 366 "include/linux/hrtimer.h"
static inline int hrtimer_start_expires(struct hrtimer *timer, enum hrtimer_mode mode)
{
# 369 "include/linux/hrtimer.h"
  long unsigned int delta;
  ktime_t soft;
# 370 "include/linux/hrtimer.h"
  ktime_t hard;
  soft = hrtimer_get_softexpires ( ( struct hrtimer const *) timer );
  hard = hrtimer_get_expires ( ( struct hrtimer const *) timer );
  delta = ( long unsigned int ) ( ktime_t ) { . tv64 = hard . tv64 - soft . tv64 } . tv64;
  return hrtimer_start_range_ns ( timer , soft , delta , mode );
}
# 377 "include/linux/hrtimer.h"
static inline int hrtimer_restart(struct hrtimer *timer)
{
  return hrtimer_start_expires ( timer , HRTIMER_MODE_ABS );
}
# 383 "include/linux/hrtimer.h"
ktime_t hrtimer_get_remaining(struct hrtimer const *);
int hrtimer_get_res(clockid_t const, struct timespec *);
# 386 "include/linux/hrtimer.h"
ktime_t hrtimer_get_next_event(void);
# 393 "include/linux/hrtimer.h"
static inline int hrtimer_active(struct hrtimer const *timer)
{
  return ( long unsigned int ) ( * timer ) . state != 0UL;
}
# 401 "include/linux/hrtimer.h"
static inline int hrtimer_is_queued(struct hrtimer *timer)
{
  return ( int ) ( * timer ) . state & 1;
}
# 410 "include/linux/hrtimer.h"
static inline int hrtimer_callback_running(struct hrtimer *timer)
{
  return ( int ) ( * timer ) . state & 2;
}
# 417 "include/linux/hrtimer.h"
u64 hrtimer_forward(struct hrtimer *, ktime_t, ktime_t);
# 420 "include/linux/hrtimer.h"
static inline u64 hrtimer_forward_now(struct hrtimer *timer, ktime_t interval)
{
# 423 "include/linux/hrtimer.h"
  return hrtimer_forward ( timer , ( * ( * timer ) . base ) . get_time ( ) , interval );
}
# 427 "include/linux/hrtimer.h"
long int hrtimer_nanosleep(struct timespec *, struct timespec *, enum hrtimer_mode const, clockid_t const);
# 431 "include/linux/hrtimer.h"
long int hrtimer_nanosleep_restart(struct restart_block *);
# 433 "include/linux/hrtimer.h"
void hrtimer_init_sleeper(struct hrtimer_sleeper *, struct task_struct *);
# 436 "include/linux/hrtimer.h"
int schedule_hrtimeout_range(ktime_t *, long unsigned int, enum hrtimer_mode const);
# 438 "include/linux/hrtimer.h"
int schedule_hrtimeout_range_clock(ktime_t *, long unsigned int, enum hrtimer_mode const, int);
# 440 "include/linux/hrtimer.h"
int schedule_hrtimeout(ktime_t *, enum hrtimer_mode const);
# 443 "include/linux/hrtimer.h"
void hrtimer_run_queues(void);
void hrtimer_run_pending(void);
# 447 "include/linux/hrtimer.h"
void hrtimers_init(void);
# 450 "include/linux/hrtimer.h"
void sysrq_timer_list_show(void);
struct task_io_accounting
{
# 14 "include/linux/task_io_accounting.h"
  u64 rchar;
# 16 "include/linux/task_io_accounting.h"
  u64 wchar;
# 18 "include/linux/task_io_accounting.h"
  u64 syscr;
# 20 "include/linux/task_io_accounting.h"
  u64 syscw;
# 28 "include/linux/task_io_accounting.h"
  u64 read_bytes;
# 34 "include/linux/task_io_accounting.h"
  u64 write_bytes;
# 43 "include/linux/task_io_accounting.h"
  u64 cancelled_write_bytes;
};
struct latency_record
{
# 21 "include/linux/latencytop.h"
  long unsigned int backtrace[12U];
  unsigned int count;
  long unsigned int time;
  long unsigned int max;
};
# 29 "include/linux/latencytop.h"
extern int latencytop_enabled;
void __account_scheduler_latency(struct task_struct *, int, int);
# 32 "include/linux/latencytop.h"
static inline void account_scheduler_latency(struct task_struct *task, int usecs, int inter)
{
  if (__builtin_expect ( latencytop_enabled != 0 , 0L ) != 0L)
    __account_scheduler_latency ( task , usecs , inter );
}
# 38 "include/linux/latencytop.h"
void clear_all_latency_tracing(struct task_struct *);
struct assoc_array
{
# 27 "include/linux/assoc_array.h"
  struct assoc_array_ptr *root;
  long unsigned int nr_leaves_on_tree;
};
struct assoc_array_ops
{
# 36 "include/linux/assoc_array.h"
  long unsigned int (*get_key_chunk)(void const *, int);
# 39 "include/linux/assoc_array.h"
  long unsigned int (*get_object_key_chunk)(void const *, int);
# 42 "include/linux/assoc_array.h"
  bool (*compare_object)(void const *, void const *);
# 47 "include/linux/assoc_array.h"
  int (*diff_objects)(void const *, void const *);
# 50 "include/linux/assoc_array.h"
  void (*free_object)(void *);
};
struct assoc_array_edit;
# 58 "include/linux/assoc_array.h"
static inline void assoc_array_init(struct assoc_array *array)
{
  ( * array ) . root = ( ( struct assoc_array_ptr *) 0 );
  ( * array ) . nr_leaves_on_tree = 0UL;
}
# 64 "include/linux/assoc_array.h"
int assoc_array_iterate(struct assoc_array const *, int (*)(void const *, void *), void *);
# 68 "include/linux/assoc_array.h"
void *assoc_array_find(struct assoc_array const *, struct assoc_array_ops const *, void const *);
# 71 "include/linux/assoc_array.h"
void assoc_array_destroy(struct assoc_array *, struct assoc_array_ops const *);
# 73 "include/linux/assoc_array.h"
struct assoc_array_edit *assoc_array_insert(struct assoc_array *, struct assoc_array_ops const *, void const *, void *);
# 77 "include/linux/assoc_array.h"
void assoc_array_insert_set_object(struct assoc_array_edit *, void *);
# 79 "include/linux/assoc_array.h"
struct assoc_array_edit *assoc_array_delete(struct assoc_array *, struct assoc_array_ops const *, void const *);
# 82 "include/linux/assoc_array.h"
struct assoc_array_edit *assoc_array_clear(struct assoc_array *, struct assoc_array_ops const *);
# 84 "include/linux/assoc_array.h"
void assoc_array_apply_edit(struct assoc_array_edit *);
void assoc_array_cancel_edit(struct assoc_array_edit *);
int assoc_array_gc(struct assoc_array *, struct assoc_array_ops const *, bool (*)(void *, void *), void *);
# 31 "include/linux/key.h"
typedef int32_t key_serial_t;
# 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
struct key;
struct signal_struct;
struct key_type;
struct key_owner;
struct keyring_list;
struct keyring_name;
struct keyring_index_key
{
# 87 "include/linux/key.h"
  struct key_type *type;
  char const *description;
  size_t desc_len;
};
# 106 "include/linux/key.h"
typedef struct __key_reference_with_attributes *key_ref_t;
# 108 "include/linux/key.h"
static inline key_ref_t make_key_ref(struct key const *key, bool possession)
{
# 111 "include/linux/key.h"
  return ( key_ref_t ) ( ( long unsigned int ) possession | ( long unsigned int ) key );
}
# 114 "include/linux/key.h"
static inline struct key *key_ref_to_ptr(key_ref_t key_ref)
{
  return ( struct key *) ( ( long unsigned int ) key_ref & 18446744073709551614UL );
}
# 119 "include/linux/key.h"
static inline bool is_key_possessed(key_ref_t key_ref)
{
  return ( ( long unsigned int ) key_ref & 1UL ) != 0UL;
}
struct key
{
# 133 "include/linux/key.h"
  atomic_t usage;
  key_serial_t serial;
# 138 "include/linux/key.h"
  union
  {
# 136 "include/linux/key.h"
    struct list_head graveyard_link;
    struct rb_node serial_node;
  } ldv_17324;
  struct rw_semaphore sem;
  struct key_user *user;
  void *security;
# 145 "include/linux/key.h"
  union
  {
# 143 "include/linux/key.h"
    time_t expiry;
    time_t revoked_at;
  } ldv_17332;
  time_t last_used_at;
  kuid_t uid;
  kgid_t gid;
  key_perm_t perm;
  short unsigned int quotalen;
  short unsigned int datalen;
# 162 "include/linux/key.h"
  long unsigned int flags;
# 187 "include/linux/key.h"
  union
  {
# 182 "include/linux/key.h"
    struct keyring_index_key index_key;
# 186 "include/linux/key.h"
    struct
    {
# 184 "include/linux/key.h"
      struct key_type *type;
      char *description;
    } ldv_17345;
  } ldv_17346;
# 197 "include/linux/key.h"
  union
  {
# 193 "include/linux/key.h"
    struct list_head link;
    long unsigned int x[2U];
    void *p[2U];
    int reject_error;
  } type_data;
# 211 "include/linux/key.h"
  union
  {
# 209 "include/linux/key.h"
    union
    {
# 205 "include/linux/key.h"
      long unsigned int value;
      void *rcudata;
      void *data;
      void *data2[2U];
    } payload;
    struct assoc_array keys;
  } ldv_17361;
};
# 214 "include/linux/key.h"
struct key *key_alloc(struct key_type *, char const *, kuid_t, kgid_t, struct cred const *, key_perm_t, long unsigned int);
# 227 "include/linux/key.h"
void key_revoke(struct key *);
void key_invalidate(struct key *);
void key_put(struct key *);
# 231 "include/linux/key.h"
static inline struct key *__key_get(struct key *key)
{
  atomic_inc ( & ( * key ) . usage );
  return key;
}
# 237 "include/linux/key.h"
static inline struct key *key_get(struct key *key)
{
  return key != ( ( struct key *) 0 ) ? __key_get ( key ) : key;
}
# 242 "include/linux/key.h"
static inline void key_ref_put(key_ref_t key_ref)
{
  key_put ( key_ref_to_ptr ( key_ref ) );
}
# 247 "include/linux/key.h"
struct key *request_key(struct key_type *, char const *, char const *);
# 251 "include/linux/key.h"
struct key *request_key_with_auxdata(struct key_type *, char const *, void const *, size_t, void *);
# 257 "include/linux/key.h"
struct key *request_key_async(struct key_type *, char const *, void const *, size_t);
# 262 "include/linux/key.h"
struct key *request_key_async_with_auxdata(struct key_type *, char const *, void const *, size_t, void *);
# 268 "include/linux/key.h"
int wait_for_key_construction(struct key *, bool);
# 270 "include/linux/key.h"
int key_validate(struct key const *);
# 272 "include/linux/key.h"
key_ref_t key_create_or_update(key_ref_t, char const *, char const *, void const *, size_t, key_perm_t, long unsigned int);
# 280 "include/linux/key.h"
int key_update(key_ref_t, void const *, size_t);
# 284 "include/linux/key.h"
int key_link(struct key *, struct key *);
# 287 "include/linux/key.h"
int key_unlink(struct key *, struct key *);
# 290 "include/linux/key.h"
struct key *keyring_alloc(char const *, kuid_t, kgid_t, struct cred const *, key_perm_t, long unsigned int, struct key *);
# 296 "include/linux/key.h"
int keyring_clear(struct key *);
# 298 "include/linux/key.h"
key_ref_t keyring_search(key_ref_t, struct key_type *, char const *);
# 302 "include/linux/key.h"
int keyring_add_key(struct key *, struct key *);
# 305 "include/linux/key.h"
struct key *key_lookup(key_serial_t);
# 307 "include/linux/key.h"
static inline key_serial_t key_serial(struct key const *key)
{
  return key != ( ( struct key const *) 0 ) ? ( key_serial_t ) ( * key ) . serial : 0;
}
# 312 "include/linux/key.h"
void key_set_timeout(struct key *, unsigned int);
# 332 "include/linux/key.h"
static inline bool key_is_instantiated(struct key const *key)
{
  return ( bool ) ( constant_test_bit ( 0L , ( long unsigned int const volatile *) & ( * key ) . flags ) != 0 && constant_test_bit
# 335 "include/linux/key.h"
  ( 5L , ( long unsigned int const volatile *) & ( * key ) . flags ) == 0 );
}
# 348 "include/linux/key.h"
extern struct ctl_table key_sysctls[];
# 353 "include/linux/key.h"
int install_thread_keyring_to_cred(struct cred *);
void key_fsuid_changed(struct task_struct *);
void key_fsgid_changed(struct task_struct *);
void key_init(void);
struct selinux_audit_rule;
struct audit_context;
# 26 "include/linux/selinux.h"
bool selinux_is_enabled(void);
struct group_info
{
# 33 "include/linux/cred.h"
  atomic_t usage;
  int ngroups;
  int nblocks;
  kgid_t small_block[32U];
  kgid_t *blocks[0U];
};
# 49 "include/linux/cred.h"
static inline struct group_info *get_group_info(struct group_info *gi)
{
  atomic_inc ( & ( * gi ) . usage );
  return gi;
}
# 65 "include/linux/cred.h"
struct group_info *groups_alloc(int);
extern struct group_info init_groups;
void groups_free(struct group_info *);
int set_current_groups(struct group_info *);
void set_groups(struct cred *, struct group_info *);
int groups_search(struct group_info const *, kgid_t);
# 76 "include/linux/cred.h"
int in_group_p(kgid_t);
int in_egroup_p(kgid_t);
struct cred
{
# 103 "include/linux/cred.h"
  atomic_t usage;
# 105 "include/linux/cred.h"
  atomic_t subscribers;
  void *put_addr;
  unsigned int magic;
# 111 "include/linux/cred.h"
  kuid_t uid;
  kgid_t gid;
  kuid_t suid;
  kgid_t sgid;
  kuid_t euid;
  kgid_t egid;
  kuid_t fsuid;
  kgid_t fsgid;
  unsigned int securebits;
  kernel_cap_t cap_inheritable;
  kernel_cap_t cap_permitted;
  kernel_cap_t cap_effective;
  kernel_cap_t cap_bset;
# 125 "include/linux/cred.h"
  unsigned char jit_keyring;
# 127 "include/linux/cred.h"
  struct key *session_keyring;
  struct key *process_keyring;
  struct key *thread_keyring;
  struct key *request_key_auth;
# 133 "include/linux/cred.h"
  void *security;
# 135 "include/linux/cred.h"
  struct user_struct *user;
  struct user_namespace *user_ns;
  struct group_info *group_info;
  struct callback_head rcu;
};
# 141 "include/linux/cred.h"
void __put_cred(struct cred *);
void exit_creds(struct task_struct *);
int copy_creds(struct task_struct *, long unsigned int);
struct cred const *get_task_cred(struct task_struct *);
struct cred *cred_alloc_blank(void);
struct cred *prepare_creds(void);
struct cred *prepare_exec_creds(void);
int commit_creds(struct cred *);
void abort_creds(struct cred *);
struct cred const *override_creds(struct cred const *);
void revert_creds(struct cred const *);
struct cred *prepare_kernel_cred(struct task_struct *);
int change_create_files_as(struct cred *, struct inode *);
int set_security_override(struct cred *, u32);
int set_security_override_from_ctx(struct cred *, char const *);
int set_create_files_as(struct cred *, struct inode *);
void cred_init(void);
# 163 "include/linux/cred.h"
void __invalid_creds(struct cred const *, char const *, unsigned int);
void __validate_process_creds(struct task_struct *, char const *, unsigned int);
# 167 "include/linux/cred.h"
bool creds_are_invalid(struct cred const *);
# 169 "include/linux/cred.h"
static inline void __validate_creds(struct cred const *cred, char const *file, unsigned int line)
{
# 172 "include/linux/cred.h"
  if (__builtin_expect ( ( long int ) creds_are_invalid ( cred ) , 0L ) != 0L)
    __invalid_creds ( cred , file , line );
}
# 186 "include/linux/cred.h"
void validate_creds_for_do_exit(struct task_struct *);
# 206 "include/linux/cred.h"
static inline struct cred *get_new_cred(struct cred *cred)
{
  atomic_inc ( & ( * cred ) . usage );
  return cred;
}
# 225 "include/linux/cred.h"
static inline struct cred const *get_cred(struct cred const *cred)
{
  struct cred *nonconst_cred = ( struct cred *) cred;
  __validate_creds ( cred , ( char const *) "include/linux/cred.h" , 228U );
  return ( struct cred const *) get_new_cred ( nonconst_cred );
}
# 243 "include/linux/cred.h"
static inline void put_cred(struct cred const *_cred)
{
  struct cred *cred = ( struct cred *) _cred;
# 247 "include/linux/cred.h"
  __validate_creds ( ( struct cred const *) cred , ( char const *) "include/linux/cred.h" , 247U );
  if (atomic_dec_and_test ( & ( * cred ) . usage ) != 0)
    __put_cred ( cred );
}
# 352 "include/linux/cred.h"
extern struct user_namespace init_user_ns;
struct sched_attr
{
# 110 "include/linux/sched.h"
  u32 size;
# 112 "include/linux/sched.h"
  u32 sched_policy;
  u64 sched_flags;
# 116 "include/linux/sched.h"
  s32 sched_nice;
# 119 "include/linux/sched.h"
  u32 sched_priority;
# 122 "include/linux/sched.h"
  u64 sched_runtime;
  u64 sched_deadline;
  u64 sched_period;
};
struct futex_pi_state;
struct robust_list_head;
struct bio_list;
struct fs_struct;
struct perf_event_context;
struct blk_plug;
struct filename;
# 150 "include/linux/sched.h"
extern long unsigned int avenrun[];
void get_avenrun(long unsigned int *, long unsigned int, int);
# 165 "include/linux/sched.h"
extern long unsigned int total_forks;
extern int nr_threads;
extern char __pcpu_scope_process_counts;
# 167 "include/linux/sched.h"
extern long unsigned int process_counts;
int nr_processes(void);
long unsigned int nr_running(void);
long unsigned int nr_iowait(void);
long unsigned int nr_iowait_cpu(int);
void get_iowait_load(long unsigned int *, long unsigned int *);
# 174 "include/linux/sched.h"
void calc_global_load(long unsigned int);
void update_cpu_load_nohz(void);
# 177 "include/linux/sched.h"
long unsigned int get_parent_ip(long unsigned int);
# 179 "include/linux/sched.h"
void dump_cpu_task(int);
struct cfs_rq;
struct task_group;
# 185 "include/linux/sched.h"
void proc_sched_show_task(struct task_struct *, struct seq_file *);
void proc_sched_set_task(struct task_struct *);
# 188 "include/linux/sched.h"
void print_cfs_rq(struct seq_file *, int, struct cfs_rq *);
# 219 "include/linux/sched.h"
extern char ___assert_task_state[1U];
# 276 "include/linux/sched.h"
extern rwlock_t tasklist_lock;
extern spinlock_t mmlist_lock;
# 282 "include/linux/sched.h"
int lockdep_tasklist_lock_is_held(void);
# 285 "include/linux/sched.h"
void sched_init(void);
void sched_init_smp(void);
void schedule_tail(struct task_struct *);
void init_idle(struct task_struct *, int);
void init_idle_bootup_task(struct task_struct *);
# 291 "include/linux/sched.h"
int runqueue_is_locked(int);
# 294 "include/linux/sched.h"
void nohz_balance_enter_idle(int);
void set_cpu_sd_state_idle(void);
int get_nohz_timer_target(int);
# 309 "include/linux/sched.h"
void show_state_filter(long unsigned int);
# 311 "include/linux/sched.h"
static inline void show_state(void)
{
  show_state_filter ( 0UL );
}
# 316 "include/linux/sched.h"
void show_regs(struct pt_regs *);
# 323 "include/linux/sched.h"
void show_stack(struct task_struct *, long unsigned int *);
# 325 "include/linux/sched.h"
void io_schedule(void);
long int io_schedule_timeout(long int);
# 328 "include/linux/sched.h"
void cpu_init(void);
void trap_init(void);
void update_process_times(int);
void scheduler_tick(void);
# 333 "include/linux/sched.h"
void sched_show_task(struct task_struct *);
# 336 "include/linux/sched.h"
void touch_softlockup_watchdog(void);
void touch_softlockup_watchdog_sync(void);
void touch_all_softlockup_watchdogs(void);
int proc_dowatchdog_thresh(struct ctl_table *, int, void *, size_t *, loff_t *);
# 342 "include/linux/sched.h"
extern unsigned int softlockup_panic;
void lockup_detector_init(void);
# 360 "include/linux/sched.h"
void reset_hung_task_detector(void);
# 371 "include/linux/sched.h"
extern char __sched_text_start[];
# 371 "include/linux/sched.h"
extern char __sched_text_end[];
# 374 "include/linux/sched.h"
int in_sched_functions(long unsigned int);
# 377 "include/linux/sched.h"
long int schedule_timeout(long int);
long int schedule_timeout_interruptible(long int);
long int schedule_timeout_killable(long int);
long int schedule_timeout_uninterruptible(long int);
void schedule(void);
void schedule_preempt_disabled(void);
# 388 "include/linux/sched.h"
void arch_pick_mmap_layout(struct mm_struct *);
# 390 "include/linux/sched.h"
long unsigned int arch_get_unmapped_area(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
# 393 "include/linux/sched.h"
long unsigned int arch_get_unmapped_area_topdown(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
# 410 "include/linux/sched.h"
void set_dumpable(struct mm_struct *, int);
# 417 "include/linux/sched.h"
static inline int __get_dumpable(long unsigned int mm_flags)
{
  return ( int ) mm_flags & 3;
}
# 422 "include/linux/sched.h"
static inline int get_dumpable(struct mm_struct *mm)
{
  return __get_dumpable ( ( * mm ) . flags );
}
struct sighand_struct
{
# 460 "include/linux/sched.h"
  atomic_t count;
  struct k_sigaction action[64U];
  spinlock_t siglock;
  wait_queue_head_t signalfd_wqh;
};
struct pacct_struct
{
  int ac_flag;
  long int ac_exitcode;
  long unsigned int ac_mem;
  cputime_t ac_utime;
# 470 "include/linux/sched.h"
  cputime_t ac_stime;
  long unsigned int ac_minflt;
# 471 "include/linux/sched.h"
  long unsigned int ac_majflt;
};
struct cpu_itimer
{
  cputime_t expires;
  cputime_t incr;
  u32 error;
  u32 incr_error;
};
struct cputime
{
# 489 "include/linux/sched.h"
  cputime_t utime;
  cputime_t stime;
};
struct task_cputime
{
# 508 "include/linux/sched.h"
  cputime_t utime;
  cputime_t stime;
  long long unsigned int sum_exec_runtime;
};
struct thread_group_cputimer
{
# 550 "include/linux/sched.h"
  struct task_cputime cputime;
  int running;
  raw_spinlock_t lock;
};
struct autogroup;
struct signal_struct
{
# 566 "include/linux/sched.h"
  atomic_t sigcnt;
  atomic_t live;
  int nr_threads;
  struct list_head thread_head;
# 571 "include/linux/sched.h"
  wait_queue_head_t wait_chldexit;
# 574 "include/linux/sched.h"
  struct task_struct *curr_target;
# 577 "include/linux/sched.h"
  struct sigpending shared_pending;
# 580 "include/linux/sched.h"
  int group_exit_code;
# 586 "include/linux/sched.h"
  int notify_count;
  struct task_struct *group_exit_task;
# 590 "include/linux/sched.h"
  int group_stop_count;
  unsigned int flags;
# 602 "include/linux/sched.h"
  unsigned char is_child_subreaper : 1;
  unsigned char has_child_subreaper : 1;
# 606 "include/linux/sched.h"
  int posix_timer_id;
  struct list_head posix_timers;
# 610 "include/linux/sched.h"
  struct hrtimer real_timer;
  struct pid *leader_pid;
  ktime_t it_real_incr;
# 619 "include/linux/sched.h"
  struct cpu_itimer it[2U];
# 625 "include/linux/sched.h"
  struct thread_group_cputimer cputimer;
# 628 "include/linux/sched.h"
  struct task_cputime cputime_expires;
# 630 "include/linux/sched.h"
  struct list_head cpu_timers[3U];
# 632 "include/linux/sched.h"
  struct pid *tty_old_pgrp;
# 635 "include/linux/sched.h"
  int leader;
# 637 "include/linux/sched.h"
  struct tty_struct *tty;
# 640 "include/linux/sched.h"
  struct autogroup *autogroup;
# 648 "include/linux/sched.h"
  cputime_t utime;
# 648 "include/linux/sched.h"
  cputime_t stime;
# 648 "include/linux/sched.h"
  cputime_t cutime;
# 648 "include/linux/sched.h"
  cputime_t cstime;
  cputime_t gtime;
  cputime_t cgtime;
# 652 "include/linux/sched.h"
  struct cputime prev_cputime;
# 654 "include/linux/sched.h"
  long unsigned int nvcsw;
# 654 "include/linux/sched.h"
  long unsigned int nivcsw;
# 654 "include/linux/sched.h"
  long unsigned int cnvcsw;
# 654 "include/linux/sched.h"
  long unsigned int cnivcsw;
  long unsigned int min_flt;
# 655 "include/linux/sched.h"
  long unsigned int maj_flt;
# 655 "include/linux/sched.h"
  long unsigned int cmin_flt;
# 655 "include/linux/sched.h"
  long unsigned int cmaj_flt;
  long unsigned int inblock;
# 656 "include/linux/sched.h"
  long unsigned int oublock;
# 656 "include/linux/sched.h"
  long unsigned int cinblock;
# 656 "include/linux/sched.h"
  long unsigned int coublock;
  long unsigned int maxrss;
# 657 "include/linux/sched.h"
  long unsigned int cmaxrss;
  struct task_io_accounting ioac;
# 666 "include/linux/sched.h"
  long long unsigned int sum_sched_runtime;
# 677 "include/linux/sched.h"
  struct rlimit rlim[16U];
# 680 "include/linux/sched.h"
  struct pacct_struct pacct;
# 683 "include/linux/sched.h"
  struct taskstats *stats;
# 686 "include/linux/sched.h"
  unsigned int audit_tty;
  unsigned int audit_tty_log_passwd;
  struct tty_audit_buf *tty_audit_buf;
# 700 "include/linux/sched.h"
  struct rw_semaphore group_rwsem;
# 703 "include/linux/sched.h"
  oom_flags_t oom_flags;
  short int oom_score_adj;
  short int oom_score_adj_min;
# 708 "include/linux/sched.h"
  struct mutex cred_guard_mutex;
};
# 730 "include/linux/sched.h"
static inline int signal_group_exit(struct signal_struct const *sig)
{
  return ( ( unsigned int ) ( * sig ) . flags & 4U ) != 0U || (
# 733 "include/linux/sched.h"
  * sig ) . group_exit_task != ( ( struct task_struct *const ) 0 );
}
struct user_struct
{
# 740 "include/linux/sched.h"
  atomic_t __count;
  atomic_t processes;
  atomic_t sigpending;
# 744 "include/linux/sched.h"
  atomic_t inotify_watches;
  atomic_t inotify_devs;
# 748 "include/linux/sched.h"
  atomic_t fanotify_listeners;
# 751 "include/linux/sched.h"
  atomic_long_t epoll_watches;
# 755 "include/linux/sched.h"
  long unsigned int mq_bytes;
# 757 "include/linux/sched.h"
  long unsigned int locked_shm;
# 760 "include/linux/sched.h"
  struct key *uid_keyring;
  struct key *session_keyring;
# 765 "include/linux/sched.h"
  struct hlist_node uidhash_node;
  kuid_t uid;
# 769 "include/linux/sched.h"
  atomic_long_t locked_vm;
};
# 773 "include/linux/sched.h"
int uids_sysfs_init(void);
# 775 "include/linux/sched.h"
struct user_struct *find_user(kuid_t);
# 777 "include/linux/sched.h"
extern struct user_struct root_user;
struct backing_dev_info;
struct reclaim_state;
struct sched_info
{
# 787 "include/linux/sched.h"
  long unsigned int pcount;
  long long unsigned int run_delay;
# 791 "include/linux/sched.h"
  long long unsigned int last_arrival;
  long long unsigned int last_queued;
};
struct task_delay_info
{
# 798 "include/linux/sched.h"
  spinlock_t lock;
  unsigned int flags;
# 816 "include/linux/sched.h"
  u64 blkio_start;
  u64 blkio_delay;
  u64 swapin_delay;
  u32 blkio_count;
# 821 "include/linux/sched.h"
  u32 swapin_count;
# 824 "include/linux/sched.h"
  u64 freepages_start;
  u64 freepages_delay;
  u32 freepages_count;
};
# 830 "include/linux/sched.h"
static inline int sched_info_on(void)
{
# 833 "include/linux/sched.h"
  return 1;
}
enum cpu_idle_type
{
  CPU_IDLE = 0,
  CPU_NOT_IDLE = 1,
  CPU_NEWLY_IDLE = 2,
  CPU_MAX_IDLE_TYPES = 3
};
# 875 "include/linux/sched.h"
static inline int cpu_smt_flags(void)
{
  return 640;
}
# 882 "include/linux/sched.h"
static inline int cpu_core_flags(void)
{
  return 512;
}
# 889 "include/linux/sched.h"
static inline int cpu_numa_flags(void)
{
  return 16384;
}
struct sched_domain_attr
{
# 896 "include/linux/sched.h"
  int relax_domain_level;
};
# 903 "include/linux/sched.h"
extern int sched_domain_level_max;
struct sched_group;
struct sched_domain
{
# 909 "include/linux/sched.h"
  struct sched_domain *parent;
  struct sched_domain *child;
  struct sched_group *groups;
  long unsigned int min_interval;
  long unsigned int max_interval;
  unsigned int busy_factor;
  unsigned int imbalance_pct;
  unsigned int cache_nice_tries;
  unsigned int busy_idx;
  unsigned int idle_idx;
  unsigned int newidle_idx;
  unsigned int wake_idx;
  unsigned int forkexec_idx;
  unsigned int smt_gain;
# 924 "include/linux/sched.h"
  int nohz_idle;
  int flags;
  int level;
# 929 "include/linux/sched.h"
  long unsigned int last_balance;
  unsigned int balance_interval;
  unsigned int nr_balance_failed;
# 934 "include/linux/sched.h"
  u64 max_newidle_lb_cost;
  long unsigned int next_decay_max_lb_cost;
# 939 "include/linux/sched.h"
  unsigned int lb_count[3U];
  unsigned int lb_failed[3U];
  unsigned int lb_balanced[3U];
  unsigned int lb_imbalance[3U];
  unsigned int lb_gained[3U];
  unsigned int lb_hot_gained[3U];
  unsigned int lb_nobusyg[3U];
  unsigned int lb_nobusyq[3U];
# 949 "include/linux/sched.h"
  unsigned int alb_count;
  unsigned int alb_failed;
  unsigned int alb_pushed;
# 954 "include/linux/sched.h"
  unsigned int sbe_count;
  unsigned int sbe_balanced;
  unsigned int sbe_pushed;
# 959 "include/linux/sched.h"
  unsigned int sbf_count;
  unsigned int sbf_balanced;
  unsigned int sbf_pushed;
# 964 "include/linux/sched.h"
  unsigned int ttwu_wake_remote;
  unsigned int ttwu_move_affine;
  unsigned int ttwu_move_balance;
# 969 "include/linux/sched.h"
  char *name;
# 974 "include/linux/sched.h"
  union
  {
# 972 "include/linux/sched.h"
    void *private;
    struct callback_head rcu;
  } ldv_17952;
# 976 "include/linux/sched.h"
  unsigned int span_weight;
# 984 "include/linux/sched.h"
  long unsigned int span[0U];
};
# 987 "include/linux/sched.h"
static inline struct cpumask *sched_domain_span(struct sched_domain *sd)
{
  return ( struct cpumask *) & ( * sd ) . span;
}
# 992 "include/linux/sched.h"
void partition_sched_domains(int, cpumask_var_t **, struct sched_domain_attr *);
# 996 "include/linux/sched.h"
cpumask_var_t **alloc_sched_domains(unsigned int);
void free_sched_domains(cpumask_var_t **, unsigned int);
# 999 "include/linux/sched.h"
bool cpus_share_cache(int, int);
# 1001 "include/linux/sched.h"
typedef struct cpumask const *(*sched_domain_mask_f)(int);
typedef int (*sched_domain_flags_f)(void);
struct sd_data
{
# 1007 "include/linux/sched.h"
  struct sched_domain **sd;
  struct sched_group **sg;
  struct sched_group_capacity **sgc;
};
struct sched_domain_topology_level
{
  sched_domain_mask_f const mask;
  sched_domain_flags_f sd_flags;
  int flags;
  int numa_level;
  struct sd_data data;
# 1019 "include/linux/sched.h"
  char *name;
};
# 1023 "include/linux/sched.h"
extern struct sched_domain_topology_level *sched_domain_topology;
# 1025 "include/linux/sched.h"
void set_sched_topology(struct sched_domain_topology_level *);
struct io_context;
# 1057 "include/linux/sched.h"
static inline void prefetch_stack(struct task_struct *t)
{
}
struct pipe_inode_info;
struct uts_namespace;
struct load_weight
{
# 1066 "include/linux/sched.h"
  long unsigned int weight;
  u32 inv_weight;
};
struct sched_avg
{
# 1076 "include/linux/sched.h"
  u32 runnable_avg_sum;
# 1076 "include/linux/sched.h"
  u32 runnable_avg_period;
  u64 last_runnable_update;
  s64 decay_count;
  long unsigned int load_avg_contrib;
};
struct sched_statistics
{
# 1084 "include/linux/sched.h"
  u64 wait_start;
  u64 wait_max;
  u64 wait_count;
  u64 wait_sum;
  u64 iowait_count;
  u64 iowait_sum;
# 1091 "include/linux/sched.h"
  u64 sleep_start;
  u64 sleep_max;
  s64 sum_sleep_runtime;
# 1095 "include/linux/sched.h"
  u64 block_start;
  u64 block_max;
  u64 exec_max;
  u64 slice_max;
# 1100 "include/linux/sched.h"
  u64 nr_migrations_cold;
  u64 nr_failed_migrations_affine;
  u64 nr_failed_migrations_running;
  u64 nr_failed_migrations_hot;
  u64 nr_forced_migrations;
# 1106 "include/linux/sched.h"
  u64 nr_wakeups;
  u64 nr_wakeups_sync;
  u64 nr_wakeups_migrate;
  u64 nr_wakeups_local;
  u64 nr_wakeups_remote;
  u64 nr_wakeups_affine;
  u64 nr_wakeups_affine_attempts;
  u64 nr_wakeups_passive;
  u64 nr_wakeups_idle;
};
struct sched_entity
{
# 1119 "include/linux/sched.h"
  struct load_weight load;
  struct rb_node run_node;
  struct list_head group_node;
  unsigned int on_rq;
# 1124 "include/linux/sched.h"
  u64 exec_start;
  u64 sum_exec_runtime;
  u64 vruntime;
  u64 prev_sum_exec_runtime;
# 1129 "include/linux/sched.h"
  u64 nr_migrations;
# 1132 "include/linux/sched.h"
  struct sched_statistics statistics;
# 1136 "include/linux/sched.h"
  int depth;
  struct sched_entity *parent;
# 1139 "include/linux/sched.h"
  struct cfs_rq *cfs_rq;
# 1141 "include/linux/sched.h"
  struct cfs_rq *my_q;
# 1146 "include/linux/sched.h"
  struct sched_avg avg;
};
struct sched_rt_entity
{
# 1151 "include/linux/sched.h"
  struct list_head run_list;
  long unsigned int timeout;
  long unsigned int watchdog_stamp;
  unsigned int time_slice;
# 1156 "include/linux/sched.h"
  struct sched_rt_entity *back;
# 1158 "include/linux/sched.h"
  struct sched_rt_entity *parent;
# 1160 "include/linux/sched.h"
  struct rt_rq *rt_rq;
# 1162 "include/linux/sched.h"
  struct rt_rq *my_q;
};
struct sched_dl_entity
{
# 1167 "include/linux/sched.h"
  struct rb_node rb_node;
# 1174 "include/linux/sched.h"
  u64 dl_runtime;
  u64 dl_deadline;
  u64 dl_period;
  u64 dl_bw;
# 1184 "include/linux/sched.h"
  s64 runtime;
  u64 deadline;
  unsigned int flags;
# 1206 "include/linux/sched.h"
  int dl_throttled;
# 1206 "include/linux/sched.h"
  int dl_new;
# 1206 "include/linux/sched.h"
  int dl_boosted;
# 1206 "include/linux/sched.h"
  int dl_yielded;
# 1212 "include/linux/sched.h"
  struct hrtimer dl_timer;
};
struct rcu_node;
enum perf_event_task_context
{
  perf_invalid_context = -1,
  perf_hw_context = 0,
  perf_sw_context = 1,
  perf_nr_task_contexts = 2
};
struct memcg_oom_info
{
# 1634 "include/linux/sched.h"
  struct mem_cgroup *memcg;
  gfp_t gfp_mask;
  int order;
  unsigned char may_oom : 1;
};
struct task_struct
{
# 1225 "include/linux/sched.h"
  long int volatile state;
  void *stack;
  atomic_t usage;
  unsigned int flags;
  unsigned int ptrace;
# 1232 "include/linux/sched.h"
  struct llist_node wake_entry;
  int on_cpu;
  struct task_struct *last_wakee;
  long unsigned int wakee_flips;
  long unsigned int wakee_flip_decay_ts;
# 1238 "include/linux/sched.h"
  int wake_cpu;
# 1240 "include/linux/sched.h"
  int on_rq;
# 1242 "include/linux/sched.h"
  int prio;
# 1242 "include/linux/sched.h"
  int static_prio;
# 1242 "include/linux/sched.h"
  int normal_prio;
  unsigned int rt_priority;
  struct sched_class const *sched_class;
  struct sched_entity se;
  struct sched_rt_entity rt;
# 1248 "include/linux/sched.h"
  struct task_group *sched_task_group;
# 1250 "include/linux/sched.h"
  struct sched_dl_entity dl;
# 1254 "include/linux/sched.h"
  struct hlist_head preempt_notifiers;
# 1261 "include/linux/sched.h"
  unsigned int policy;
  int nr_cpus_allowed;
  cpumask_t cpus_allowed;
# 1275 "include/linux/sched.h"
  struct sched_info sched_info;
# 1278 "include/linux/sched.h"
  struct list_head tasks;
# 1280 "include/linux/sched.h"
  struct plist_node pushable_tasks;
  struct rb_node pushable_dl_tasks;
# 1284 "include/linux/sched.h"
  struct mm_struct *mm;
# 1284 "include/linux/sched.h"
  struct mm_struct *active_mm;
# 1286 "include/linux/sched.h"
  unsigned char brk_randomized : 1;
# 1289 "include/linux/sched.h"
  u32 vmacache_seqnum;
  struct vm_area_struct *vmacache[4U];
# 1292 "include/linux/sched.h"
  struct task_rss_stat rss_stat;
# 1295 "include/linux/sched.h"
  int exit_state;
  int exit_code;
# 1296 "include/linux/sched.h"
  int exit_signal;
  int pdeath_signal;
  unsigned int jobctl;
# 1301 "include/linux/sched.h"
  unsigned int personality;
# 1303 "include/linux/sched.h"
  unsigned char in_execve : 1;
# 1305 "include/linux/sched.h"
  unsigned char in_iowait : 1;
# 1308 "include/linux/sched.h"
  unsigned char sched_reset_on_fork : 1;
  unsigned char sched_contributes_to_load : 1;
# 1311 "include/linux/sched.h"
  long unsigned int atomic_flags;
# 1313 "include/linux/sched.h"
  pid_t pid;
  pid_t tgid;
# 1325 "include/linux/sched.h"
  struct task_struct *real_parent;
  struct task_struct *parent;
# 1330 "include/linux/sched.h"
  struct list_head children;
  struct list_head sibling;
  struct task_struct *group_leader;
# 1339 "include/linux/sched.h"
  struct list_head ptraced;
  struct list_head ptrace_entry;
# 1343 "include/linux/sched.h"
  struct pid_link pids[3U];
  struct list_head thread_group;
  struct list_head thread_node;
# 1347 "include/linux/sched.h"
  struct completion *vfork_done;
  int *set_child_tid;
  int *clear_child_tid;
# 1351 "include/linux/sched.h"
  cputime_t utime;
# 1351 "include/linux/sched.h"
  cputime_t stime;
# 1351 "include/linux/sched.h"
  cputime_t utimescaled;
# 1351 "include/linux/sched.h"
  cputime_t stimescaled;
  cputime_t gtime;
# 1354 "include/linux/sched.h"
  struct cputime prev_cputime;
# 1365 "include/linux/sched.h"
  long unsigned int nvcsw;
# 1365 "include/linux/sched.h"
  long unsigned int nivcsw;
  u64 start_time;
  u64 real_start_time;
# 1369 "include/linux/sched.h"
  long unsigned int min_flt;
# 1369 "include/linux/sched.h"
  long unsigned int maj_flt;
# 1371 "include/linux/sched.h"
  struct task_cputime cputime_expires;
  struct list_head cpu_timers[3U];
# 1375 "include/linux/sched.h"
  struct cred const *real_cred;
# 1377 "include/linux/sched.h"
  struct cred const *cred;
# 1379 "include/linux/sched.h"
  char comm[16U];
# 1384 "include/linux/sched.h"
  int link_count;
# 1384 "include/linux/sched.h"
  int total_link_count;
# 1387 "include/linux/sched.h"
  struct sysv_sem sysvsem;
  struct sysv_shm sysvshm;
# 1392 "include/linux/sched.h"
  long unsigned int last_switch_count;
# 1395 "include/linux/sched.h"
  struct thread_struct thread;
# 1397 "include/linux/sched.h"
  struct fs_struct *fs;
# 1399 "include/linux/sched.h"
  struct files_struct *files;
# 1401 "include/linux/sched.h"
  struct nsproxy *nsproxy;
# 1403 "include/linux/sched.h"
  struct signal_struct *signal;
  struct sighand_struct *sighand;
# 1406 "include/linux/sched.h"
  sigset_t blocked;
# 1406 "include/linux/sched.h"
  sigset_t real_blocked;
  sigset_t saved_sigmask;
  struct sigpending pending;
# 1410 "include/linux/sched.h"
  long unsigned int sas_ss_sp;
  size_t sas_ss_size;
  int (*notifier)(void *);
  void *notifier_data;
  sigset_t *notifier_mask;
  struct callback_head *task_works;
# 1417 "include/linux/sched.h"
  struct audit_context *audit_context;
# 1419 "include/linux/sched.h"
  kuid_t loginuid;
  unsigned int sessionid;
# 1422 "include/linux/sched.h"
  struct seccomp seccomp;
# 1425 "include/linux/sched.h"
  u32 parent_exec_id;
  u32 self_exec_id;
# 1429 "include/linux/sched.h"
  spinlock_t alloc_lock;
# 1432 "include/linux/sched.h"
  raw_spinlock_t pi_lock;
# 1436 "include/linux/sched.h"
  struct rb_root pi_waiters;
  struct rb_node *pi_waiters_leftmost;
# 1439 "include/linux/sched.h"
  struct rt_mutex_waiter *pi_blocked_on;
# 1444 "include/linux/sched.h"
  struct mutex_waiter *blocked_on;
# 1447 "include/linux/sched.h"
  unsigned int irq_events;
  long unsigned int hardirq_enable_ip;
  long unsigned int hardirq_disable_ip;
  unsigned int hardirq_enable_event;
  unsigned int hardirq_disable_event;
  int hardirqs_enabled;
  int hardirq_context;
  long unsigned int softirq_disable_ip;
  long unsigned int softirq_enable_ip;
  unsigned int softirq_disable_event;
  unsigned int softirq_enable_event;
  int softirqs_enabled;
  int softirq_context;
# 1463 "include/linux/sched.h"
  u64 curr_chain_key;
  int lockdep_depth;
  unsigned int lockdep_recursion;
  struct held_lock held_locks[48U];
  gfp_t lockdep_reclaim_gfp;
# 1471 "include/linux/sched.h"
  void *journal_info;
# 1474 "include/linux/sched.h"
  struct bio_list *bio_list;
# 1478 "include/linux/sched.h"
  struct blk_plug *plug;
# 1482 "include/linux/sched.h"
  struct reclaim_state *reclaim_state;
# 1484 "include/linux/sched.h"
  struct backing_dev_info *backing_dev_info;
# 1486 "include/linux/sched.h"
  struct io_context *io_context;
# 1488 "include/linux/sched.h"
  long unsigned int ptrace_message;
  siginfo_t *last_siginfo;
  struct task_io_accounting ioac;
# 1492 "include/linux/sched.h"
  u64 acct_rss_mem1;
  u64 acct_vm_mem1;
  cputime_t acct_timexpd;
# 1497 "include/linux/sched.h"
  nodemask_t mems_allowed;
  seqcount_t mems_allowed_seq;
  int cpuset_mem_spread_rotor;
  int cpuset_slab_spread_rotor;
# 1504 "include/linux/sched.h"
  struct css_set *cgroups;
# 1506 "include/linux/sched.h"
  struct list_head cg_list;
# 1509 "include/linux/sched.h"
  struct robust_list_head *robust_list;
# 1511 "include/linux/sched.h"
  struct compat_robust_list_head *compat_robust_list;
# 1513 "include/linux/sched.h"
  struct list_head pi_state_list;
  struct futex_pi_state *pi_state_cache;
# 1517 "include/linux/sched.h"
  struct perf_event_context *perf_event_ctxp[2U];
  struct mutex perf_event_mutex;
  struct list_head perf_event_list;
# 1525 "include/linux/sched.h"
  struct mempolicy *mempolicy;
  short int il_next;
  short int pref_node_fork;
# 1530 "include/linux/sched.h"
  int numa_scan_seq;
  unsigned int numa_scan_period;
  unsigned int numa_scan_period_max;
  int numa_preferred_nid;
  long unsigned int numa_migrate_retry;
  u64 node_stamp;
  u64 last_task_numa_placement;
  u64 last_sum_exec_runtime;
  struct callback_head numa_work;
# 1540 "include/linux/sched.h"
  struct list_head numa_entry;
  struct numa_group *numa_group;
# 1548 "include/linux/sched.h"
  long unsigned int *numa_faults_memory;
  long unsigned int total_numa_faults;
# 1556 "include/linux/sched.h"
  long unsigned int *numa_faults_buffer_memory;
# 1562 "include/linux/sched.h"
  long unsigned int *numa_faults_cpu;
  long unsigned int *numa_faults_buffer_cpu;
# 1571 "include/linux/sched.h"
  long unsigned int numa_faults_locality[2U];
# 1573 "include/linux/sched.h"
  long unsigned int numa_pages_migrated;
# 1576 "include/linux/sched.h"
  struct callback_head rcu;
# 1581 "include/linux/sched.h"
  struct pipe_inode_info *splice_pipe;
# 1583 "include/linux/sched.h"
  struct page_frag task_frag;
# 1586 "include/linux/sched.h"
  struct task_delay_info *delays;
# 1589 "include/linux/sched.h"
  int make_it_fail;
# 1595 "include/linux/sched.h"
  int nr_dirtied;
  int nr_dirtied_pause;
  long unsigned int dirty_paused_when;
# 1600 "include/linux/sched.h"
  int latency_record_count;
  struct latency_record latency_record[32U];
# 1607 "include/linux/sched.h"
  long unsigned int timer_slack_ns;
  long unsigned int default_timer_slack_ns;
# 1627 "include/linux/sched.h"
  long unsigned int trace;
# 1629 "include/linux/sched.h"
  long unsigned int trace_recursion;
# 1632 "include/linux/sched.h"
  unsigned int memcg_kmem_skip_account;
# 1638 "include/linux/sched.h"
  struct memcg_oom_info memcg_oom;
# 1641 "include/linux/sched.h"
  struct uprobe_task *utask;
# 1644 "include/linux/sched.h"
  unsigned int sequential_io;
  unsigned int sequential_io_avg;
};
# 1658 "include/linux/sched.h"
void task_numa_fault(int, int, int, int);
pid_t task_numa_group_id(struct task_struct *);
void set_numabalancing_state(bool);
void task_numa_free(struct task_struct *);
bool should_numa_migrate_memory(struct task_struct *, struct page *, int, int);
# 1686 "include/linux/sched.h"
static inline struct pid *task_pid(struct task_struct *task)
{
  return ( * task ) . pids [ 0 ] . pid;
}
# 1691 "include/linux/sched.h"
static inline struct pid *task_tgid(struct task_struct *task)
{
  return ( * ( * task ) . group_leader ) . pids [ 0 ] . pid;
}
# 1701 "include/linux/sched.h"
static inline struct pid *task_pgrp(struct task_struct *task)
{
  return ( * ( * task ) . group_leader ) . pids [ 1 ] . pid;
}
# 1706 "include/linux/sched.h"
static inline struct pid *task_session(struct task_struct *task)
{
  return ( * ( * task ) . group_leader ) . pids [ 2 ] . pid;
}
# 1726 "include/linux/sched.h"
pid_t __task_pid_nr_ns(struct task_struct *, enum pid_type, struct pid_namespace *);
# 1729 "include/linux/sched.h"
static inline pid_t task_pid_nr(struct task_struct *tsk)
{
  return ( * tsk ) . pid;
}
# 1734 "include/linux/sched.h"
static inline pid_t task_pid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
# 1737 "include/linux/sched.h"
  return __task_pid_nr_ns ( tsk , PIDTYPE_PID , ns );
}
# 1740 "include/linux/sched.h"
static inline pid_t task_pid_vnr(struct task_struct *tsk)
{
  return __task_pid_nr_ns ( tsk , PIDTYPE_PID , ( ( struct pid_namespace *) 0 ) );
}
# 1746 "include/linux/sched.h"
static inline pid_t task_tgid_nr(struct task_struct *tsk)
{
  return ( * tsk ) . tgid;
}
# 1751 "include/linux/sched.h"
pid_t task_tgid_nr_ns(struct task_struct *, struct pid_namespace *);
# 1753 "include/linux/sched.h"
static inline pid_t task_tgid_vnr(struct task_struct *tsk)
{
  return pid_vnr ( task_tgid ( tsk ) );
}
# 1759 "include/linux/sched.h"
static inline int pid_alive(struct task_struct const *);
static inline pid_t task_ppid_nr_ns(struct task_struct const *tsk, struct pid_namespace *ns)
{
  pid_t pid = 0;
# 1764 "include/linux/sched.h"
  rcu_read_lock ( );
  if (pid_alive ( tsk ) != 0)
    pid = task_tgid_nr_ns ( ({
# 1766 "include/linux/sched.h"
      struct task_struct *_________p1 = * ( struct task_struct *const volatile *) & ( * tsk ) . real_parent;
      {
# 1766 "include/linux/sched.h"
        bool __warned;
# 1766 "include/linux/sched.h"
        if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && ( rcu_read_lock_held ( ) == 0 && 1 ))
        {
# 1766 "include/linux/sched.h"
          __warned = 1;
# 1766 "include/linux/sched.h"
          lockdep_rcu_suspicious ( ( char const *) "include/linux/sched.h" , 1766 , ( char const *) "suspicious rcu_dereference_check() usage" );
        }
      }
      {
      }
# 1766 "include/linux/sched.h"
      _________p1;
    } ) , ns );
# 1767 "include/linux/sched.h"
  rcu_read_unlock ( );
# 1769 "include/linux/sched.h"
  return pid;
}
# 1772 "include/linux/sched.h"
static inline pid_t task_ppid_nr(struct task_struct const *tsk)
{
  return task_ppid_nr_ns ( tsk , & init_pid_ns );
}
# 1777 "include/linux/sched.h"
static inline pid_t task_pgrp_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
# 1780 "include/linux/sched.h"
  return __task_pid_nr_ns ( tsk , PIDTYPE_PGID , ns );
}
# 1783 "include/linux/sched.h"
static inline pid_t task_pgrp_vnr(struct task_struct *tsk)
{
  return __task_pid_nr_ns ( tsk , PIDTYPE_PGID , ( ( struct pid_namespace *) 0 ) );
}
# 1789 "include/linux/sched.h"
static inline pid_t task_session_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
# 1792 "include/linux/sched.h"
  return __task_pid_nr_ns ( tsk , PIDTYPE_SID , ns );
}
# 1795 "include/linux/sched.h"
static inline pid_t task_session_vnr(struct task_struct *tsk)
{
  return __task_pid_nr_ns ( tsk , PIDTYPE_SID , ( ( struct pid_namespace *) 0 ) );
}
# 1801 "include/linux/sched.h"
static inline pid_t task_pgrp_nr(struct task_struct *tsk)
{
  return task_pgrp_nr_ns ( tsk , & init_pid_ns );
}
# 1816 "include/linux/sched.h"
static inline int pid_alive(struct task_struct const *p)
{
  return ( * p ) . pids [ 0 ] . pid != ( ( struct pid *const ) 0 );
}
# 1829 "include/linux/sched.h"
static inline int is_global_init(struct task_struct *tsk)
{
  return ( int ) ( * tsk ) . pid == 1;
}
# 1834 "include/linux/sched.h"
extern struct pid *cad_pid;
# 1836 "include/linux/sched.h"
void free_task(struct task_struct *);
# 1839 "include/linux/sched.h"
void __put_task_struct(struct task_struct *);
# 1841 "include/linux/sched.h"
static inline void put_task_struct(struct task_struct *t)
{
  if (atomic_dec_and_test ( & ( * t ) . usage ) != 0)
    __put_task_struct ( t );
}
# 1854 "include/linux/sched.h"
static inline void task_cputime(struct task_struct *t, cputime_t *utime, cputime_t *stime)
{
# 1857 "include/linux/sched.h"
  if (utime != ( ( cputime_t *) 0UL ))
    * utime = ( * t ) . utime;
  if (stime != ( ( cputime_t *) 0UL ))
    * stime = ( * t ) . stime;
}
# 1863 "include/linux/sched.h"
static inline void task_cputime_scaled(struct task_struct *t, cputime_t *utimescaled, cputime_t *stimescaled)
{
# 1867 "include/linux/sched.h"
  if (utimescaled != ( ( cputime_t *) 0UL ))
    * utimescaled = ( * t ) . utimescaled;
  if (stimescaled != ( ( cputime_t *) 0UL ))
    * stimescaled = ( * t ) . stimescaled;
}
# 1873 "include/linux/sched.h"
static inline cputime_t task_gtime(struct task_struct *t)
{
  return ( * t ) . gtime;
}
# 1878 "include/linux/sched.h"
void task_cputime_adjusted(struct task_struct *, cputime_t *, cputime_t *);
void thread_group_cputime_adjusted(struct task_struct *, cputime_t *, cputime_t *);
# 1940 "include/linux/sched.h"
static inline gfp_t memalloc_noio_flags(gfp_t flags)
{
  if (__builtin_expect ( ( ( * get_current ( ) ) . flags & 524288U ) != 0U , 0L ) != 0L)
    flags &= 4294967231U;
  return flags;
}
# 1947 "include/linux/sched.h"
static inline unsigned int memalloc_noio_save(void)
{
  unsigned int flags = ( * get_current ( ) ) . flags & 524288U;
  ( * ( get_current ( ) ) ) . flags |= 524288U;
  return flags;
}
# 1954 "include/linux/sched.h"
static inline void memalloc_noio_restore(unsigned int flags)
{
  ( * get_current ( ) ) . flags = ( * get_current ( ) ) . flags & 4294443007U | flags;
}
# 1962 "include/linux/sched.h"
static inline bool task_no_new_privs(struct task_struct *p)
{
  return constant_test_bit ( 1L , ( long unsigned int const volatile *) & ( * p ) . atomic_flags ) != 0;
}
# 1967 "include/linux/sched.h"
static inline void task_set_no_new_privs(struct task_struct *p)
{
  set_bit ( 1L , ( long unsigned int volatile *) & ( * p ) . atomic_flags );
}
# 1996 "include/linux/sched.h"
bool task_set_jobctl_pending(struct task_struct *, unsigned int);
# 1998 "include/linux/sched.h"
void task_clear_jobctl_trapping(struct task_struct *);
void task_clear_jobctl_pending(struct task_struct *, unsigned int);
# 2019 "include/linux/sched.h"
static inline void rcu_copy_process(struct task_struct *p)
{
}
# 2025 "include/linux/sched.h"
static inline void tsk_restore_flags(struct task_struct *task, long unsigned int orig_flags, long unsigned int flags)
{
# 2028 "include/linux/sched.h"
  ( * task ) . flags &= ~ ( unsigned int ) flags;
  ( * task ) . flags |= ( unsigned int ) orig_flags & ( unsigned int ) flags;
}
# 2033 "include/linux/sched.h"
void do_set_cpus_allowed(struct task_struct *, struct cpumask const *);
# 2036 "include/linux/sched.h"
int set_cpus_allowed_ptr(struct task_struct *, struct cpumask const *);
# 2053 "include/linux/sched.h"
void calc_load_enter_idle(void);
void calc_load_exit_idle(void);
# 2075 "include/linux/sched.h"
long long unsigned int sched_clock(void);
# 2079 "include/linux/sched.h"
u64 cpu_clock(int);
u64 local_clock(void);
u64 sched_clock_cpu(int);
# 2084 "include/linux/sched.h"
void sched_clock_init(void);
# 2105 "include/linux/sched.h"
int sched_clock_stable(void);
void set_sched_clock_stable(void);
void clear_sched_clock_stable(void);
# 2109 "include/linux/sched.h"
void sched_clock_tick(void);
void sched_clock_idle_sleep_event(void);
void sched_clock_idle_wakeup_event(u64);
# 2123 "include/linux/sched.h"
static inline void enable_sched_clock_irqtime(void)
{
}
# 2124 "include/linux/sched.h"
static inline void disable_sched_clock_irqtime(void)
{
}
# 2128 "include/linux/sched.h"
long long unsigned int task_sched_runtime(struct task_struct *);
# 2132 "include/linux/sched.h"
void sched_exec(void);
# 2137 "include/linux/sched.h"
void sched_clock_idle_sleep_event(void);
void sched_clock_idle_wakeup_event(u64);
# 2141 "include/linux/sched.h"
void idle_task_exit(void);
# 2147 "include/linux/sched.h"
void wake_up_nohz_cpu(int);
# 2156 "include/linux/sched.h"
static inline bool sched_can_stop_tick(void)
{
# 2156 "include/linux/sched.h"
  return 0;
}
# 2160 "include/linux/sched.h"
void sched_autogroup_create_attach(struct task_struct *);
void sched_autogroup_detach(struct task_struct *);
void sched_autogroup_fork(struct signal_struct *);
void sched_autogroup_exit(struct signal_struct *);
# 2165 "include/linux/sched.h"
void proc_sched_autogroup_show_task(struct task_struct *, struct seq_file *);
int proc_sched_autogroup_set_nice(struct task_struct *, int);
# 2175 "include/linux/sched.h"
int yield_to(struct task_struct *, bool);
void set_user_nice(struct task_struct *, long int);
int task_prio(struct task_struct const *);
# 2184 "include/linux/sched.h"
static inline int task_nice(struct task_struct const *p)
{
  return ( int ) ( * p ) . static_prio + -120;
}
int can_nice(struct task_struct const *, int const);
int task_curr(struct task_struct const *);
int idle_cpu(int);
int sched_setscheduler(struct task_struct *, int, struct sched_param const *);
# 2193 "include/linux/sched.h"
int sched_setscheduler_nocheck(struct task_struct *, int, struct sched_param const *);
# 2195 "include/linux/sched.h"
int sched_setattr(struct task_struct *, struct sched_attr const *);
# 2197 "include/linux/sched.h"
struct task_struct *idle_task(int);
# 2204 "include/linux/sched.h"
static inline bool is_idle_task(struct task_struct const *p)
{
  return ( int ) ( * p ) . pid == 0;
}
struct task_struct *curr_task(int);
void set_curr_task(int, struct task_struct *);
# 2211 "include/linux/sched.h"
void yield(void);
# 2216 "include/linux/sched.h"
extern struct exec_domain default_exec_domain;
union thread_union
{
  struct thread_info thread_info;
  long unsigned int stack[2048U];
};
# 2224 "include/linux/sched.h"
static inline int kstack_end(void *addr)
{
# 2229 "include/linux/sched.h"
  return ( ( long unsigned int ) addr + 7UL & 16376UL ) == 0UL;
}
# 2233 "include/linux/sched.h"
extern union thread_union init_thread_union;
extern struct task_struct init_task;
# 2236 "include/linux/sched.h"
extern struct mm_struct init_mm;
# 2238 "include/linux/sched.h"
extern struct pid_namespace init_pid_ns;
# 2251 "include/linux/sched.h"
struct task_struct *find_task_by_vpid(pid_t);
struct task_struct *find_task_by_pid_ns(pid_t, struct pid_namespace *);
# 2256 "include/linux/sched.h"
struct user_struct *alloc_uid(kuid_t);
static inline struct user_struct *get_uid(struct user_struct *u)
{
  atomic_inc ( & ( * u ) . __count );
  return u;
}
void free_uid(struct user_struct *);
# 2266 "include/linux/sched.h"
void xtime_update(long unsigned int);
# 2268 "include/linux/sched.h"
int wake_up_state(struct task_struct *, unsigned int);
int wake_up_process(struct task_struct *);
void wake_up_new_task(struct task_struct *);
# 2272 "include/linux/sched.h"
void kick_process(struct task_struct *);
# 2276 "include/linux/sched.h"
int sched_fork(long unsigned int, struct task_struct *);
void sched_dead(struct task_struct *);
# 2279 "include/linux/sched.h"
void proc_caches_init(void);
void flush_signals(struct task_struct *);
void __flush_signals(struct task_struct *);
void ignore_signals(struct task_struct *);
void flush_signal_handlers(struct task_struct *, int);
int dequeue_signal(struct task_struct *, sigset_t *, siginfo_t *);
# 2286 "include/linux/sched.h"
static inline int dequeue_signal_lock(struct task_struct *tsk, sigset_t *mask, siginfo_t *info)
{
  long unsigned int flags;
  int ret;
# 2291 "include/linux/sched.h"
  ({
# 2291 "include/linux/sched.h"
    long unsigned int __dummy;
# 2291 "include/linux/sched.h"
    long unsigned int __dummy2;
# 2291 "include/linux/sched.h"
    ( void ) 0;
# 2291 "include/linux/sched.h"
    1;
  } );
# 2291 "include/linux/sched.h"
  flags = _raw_spin_lock_irqsave ( spinlock_check ( & ( * ( * tsk ) . sighand ) . siglock ) );
  ret = dequeue_signal ( tsk , mask , info );
  spin_unlock_irqrestore ( & ( * ( * tsk ) . sighand ) . siglock , flags );
# 2295 "include/linux/sched.h"
  return ret;
}
# 2298 "include/linux/sched.h"
void block_all_signals(int (*)(void *), void *, sigset_t *);
# 2300 "include/linux/sched.h"
void unblock_all_signals(void);
void release_task(struct task_struct *);
int send_sig_info(int, struct siginfo *, struct task_struct *);
int force_sigsegv(int, struct task_struct *);
int force_sig_info(int, struct siginfo *, struct task_struct *);
int __kill_pgrp_info(int, struct siginfo *, struct pid *);
int kill_pid_info(int, struct siginfo *, struct pid *);
int kill_pid_info_as_cred(int, struct siginfo *, struct pid *, struct cred const *, u32);
# 2309 "include/linux/sched.h"
int kill_pgrp(struct pid *, int, int);
int kill_pid(struct pid *, int, int);
int kill_proc_info(int, struct siginfo *, pid_t);
bool do_notify_parent(struct task_struct *, int);
void __wake_up_parent(struct task_struct *, struct task_struct *);
void force_sig(int, struct task_struct *);
int send_sig(int, struct task_struct *, int);
int zap_other_threads(struct task_struct *);
struct sigqueue *sigqueue_alloc(void);
void sigqueue_free(struct sigqueue *);
int send_sigqueue(struct sigqueue *, struct task_struct *, int);
int do_sigaction(int, struct k_sigaction *, struct k_sigaction *);
# 2322 "include/linux/sched.h"
static inline void restore_saved_sigmask(void)
{
  if (( int ) test_and_clear_restore_sigmask ( ))
    __set_current_blocked ( ( sigset_t const *) & ( * get_current ( ) ) . saved_sigmask );
}
# 2328 "include/linux/sched.h"
static inline sigset_t *sigmask_to_save(void)
{
  sigset_t *res = & ( * get_current ( ) ) . blocked;
  if (__builtin_expect ( ( long int ) test_restore_sigmask ( ) , 0L ) != 0L)
    res = & ( * get_current ( ) ) . saved_sigmask;
  return res;
}
# 2336 "include/linux/sched.h"
static inline int kill_cad_pid(int sig, int priv)
{
  return kill_pid ( cad_pid , sig , priv );
}
# 2349 "include/linux/sched.h"
static inline int on_sig_stack(long unsigned int sp)
{
# 2355 "include/linux/sched.h"
  return ( * get_current ( ) ) . sas_ss_sp < sp && sp
# 2356 "include/linux/sched.h"
  - ( * get_current ( ) ) . sas_ss_sp <= ( long unsigned int ) ( * get_current ( ) ) . sas_ss_size;
}
# 2360 "include/linux/sched.h"
static inline int sas_ss_flags(long unsigned int sp)
{
  if (( * get_current ( ) ) . sas_ss_size == 0UL)
    return 2;
# 2365 "include/linux/sched.h"
  return on_sig_stack ( sp ) != 0;
}
# 2368 "include/linux/sched.h"
static inline long unsigned int sigsp(long unsigned int sp, struct ksignal *ksig)
{
  if (__builtin_expect ( ( ( * ksig ) . ka . sa . sa_flags & 134217728UL ) != 0UL , 0L ) != 0L && sas_ss_flags ( sp ) == 0)
# 2374 "include/linux/sched.h"
    return ( * get_current ( ) ) . sas_ss_sp + ( long unsigned int ) ( * get_current ( ) ) . sas_ss_size;
# 2376 "include/linux/sched.h"
  return sp;
}
# 2382 "include/linux/sched.h"
struct mm_struct *mm_alloc(void);
# 2385 "include/linux/sched.h"
void __mmdrop(struct mm_struct *);
static inline void mmdrop(struct mm_struct *mm)
{
  if (__builtin_expect ( atomic_dec_and_test ( & ( * mm ) . mm_count ) != 0 , 0L ) != 0L)
    __mmdrop ( mm );
}
# 2393 "include/linux/sched.h"
void mmput(struct mm_struct *);
# 2395 "include/linux/sched.h"
struct mm_struct *get_task_mm(struct task_struct *);
# 2401 "include/linux/sched.h"
struct mm_struct *mm_access(struct task_struct *, unsigned int);
# 2403 "include/linux/sched.h"
void mm_release(struct task_struct *, struct mm_struct *);
# 2405 "include/linux/sched.h"
int copy_thread(long unsigned int, long unsigned int, long unsigned int, struct task_struct *);
# 2407 "include/linux/sched.h"
void flush_thread(void);
void exit_thread(void);
# 2410 "include/linux/sched.h"
void exit_files(struct task_struct *);
void __cleanup_sighand(struct sighand_struct *);
# 2413 "include/linux/sched.h"
void exit_itimers(struct signal_struct *);
void flush_itimer_signals(void);
# 2416 "include/linux/sched.h"
void do_group_exit(int);
# 2418 "include/linux/sched.h"
int do_execve(struct filename *, char const *const *, char const *const *);
# 2421 "include/linux/sched.h"
long int do_fork(long unsigned int, long unsigned int, long unsigned int, int *, int *);
struct task_struct *fork_idle(int);
pid_t kernel_thread(int (*)(void *), void *, long unsigned int);
# 2425 "include/linux/sched.h"
void __set_task_comm(struct task_struct *, char const *, bool);
static inline void set_task_comm(struct task_struct *tsk, char const *from)
{
  __set_task_comm ( tsk , from , 0 );
}
char *get_task_comm(char *, struct task_struct *);
# 2433 "include/linux/sched.h"
void scheduler_ipi(void);
long unsigned int wait_task_inactive(struct task_struct *, long int);
# 2450 "include/linux/sched.h"
bool current_is_single_threaded(void);
# 2472 "include/linux/sched.h"
static inline int get_nr_threads(struct task_struct *tsk)
{
  return ( * ( * tsk ) . signal ) . nr_threads;
}
# 2477 "include/linux/sched.h"
static inline bool thread_group_leader(struct task_struct *p)
{
  return ( * p ) . exit_signal >= 0;
}
# 2488 "include/linux/sched.h"
static inline bool has_group_leader_pid(struct task_struct *p)
{
  return task_pid ( p ) == ( * ( * p ) . signal ) . leader_pid;
}
# 2494 "include/linux/sched.h"
static inline bool same_thread_group(struct task_struct *p1, struct task_struct *p2)
{
  return ( * p1 ) . signal == ( * p2 ) . signal;
}
# 2499 "include/linux/sched.h"
static inline struct task_struct *next_thread(struct task_struct const *p)
{
  return ({
# 2501 "include/linux/sched.h"
    struct list_head *__ptr = ( * p ) . thread_group . next;
# 2501 "include/linux/sched.h"
    ({
# 2501 "include/linux/sched.h"
      struct list_head const *__mptr = ( struct list_head const *) ({
# 2501 "include/linux/sched.h"
        struct list_head *_________p1 = * ( struct list_head *volatile *) & __ptr;
        {
# 2501 "include/linux/sched.h"
          bool __warned;
# 2501 "include/linux/sched.h"
          if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && ( rcu_read_lock_held ( ), 0 ))
          {
# 2501 "include/linux/sched.h"
            __warned = 1;
# 2501 "include/linux/sched.h"
            lockdep_rcu_suspicious ( ( char const *) "include/linux/sched.h" , 2502 , ( char const *) "suspicious rcu_dereference_check() usage" );
          }
        }
        {
        }
# 2501 "include/linux/sched.h"
        _________p1;
      } );
# 2501 "include/linux/sched.h"
      ( struct task_struct *) __mptr + 18446744073709549424U;
    } );
  } );
}
static inline int thread_group_empty(struct task_struct *p)
{
  return list_empty ( ( struct list_head const *) & ( * p ) . thread_group );
}
# 2523 "include/linux/sched.h"
static inline void task_lock(struct task_struct *p)
{
  spin_lock ( & ( * p ) . alloc_lock );
}
# 2528 "include/linux/sched.h"
static inline void task_unlock(struct task_struct *p)
{
  spin_unlock ( & ( * p ) . alloc_lock );
}
# 2533 "include/linux/sched.h"
struct sighand_struct *__lock_task_sighand(struct task_struct *, long unsigned int *);
# 2536 "include/linux/sched.h"
static inline struct sighand_struct *lock_task_sighand(struct task_struct *tsk, long unsigned int *flags)
{
# 2539 "include/linux/sched.h"
  struct sighand_struct *ret;
# 2541 "include/linux/sched.h"
  ret = __lock_task_sighand ( tsk , flags );
  ( void ) ret;
  return ret;
}
# 2546 "include/linux/sched.h"
static inline void unlock_task_sighand(struct task_struct *tsk, long unsigned int *flags)
{
# 2549 "include/linux/sched.h"
  spin_unlock_irqrestore ( & ( * ( * tsk ) . sighand ) . siglock , * flags );
}
# 2553 "include/linux/sched.h"
static inline void threadgroup_change_begin(struct task_struct *tsk)
{
  down_read ( & ( * ( * tsk ) . signal ) . group_rwsem );
}
static inline void threadgroup_change_end(struct task_struct *tsk)
{
  up_read ( & ( * ( * tsk ) . signal ) . group_rwsem );
}
# 2578 "include/linux/sched.h"
static inline void threadgroup_lock(struct task_struct *tsk)
{
  down_write ( & ( * ( * tsk ) . signal ) . group_rwsem );
}
# 2589 "include/linux/sched.h"
static inline void threadgroup_unlock(struct task_struct *tsk)
{
  up_write ( & ( * ( * tsk ) . signal ) . group_rwsem );
}
# 2605 "include/linux/sched.h"
static inline void setup_thread_stack(struct task_struct *p, struct task_struct *org)
{
  * ( struct thread_info *) ( * p ) . stack = * ( struct thread_info *) ( * org ) . stack;
  ( * ( struct thread_info *) ( * p ) . stack ) . task = p;
}
# 2611 "include/linux/sched.h"
static inline long unsigned int *end_of_stack(struct task_struct *p)
{
  return ( long unsigned int *) ( * p ) . stack + 1U;
}
# 2618 "include/linux/sched.h"
static inline int object_is_on_stack(void *obj)
{
  void *stack = ( * get_current ( ) ) . stack;
# 2622 "include/linux/sched.h"
  return obj >= stack && stack + 16384UL > obj;
}
# 2625 "include/linux/sched.h"
void thread_info_cache_init(void);
# 2628 "include/linux/sched.h"
static inline long unsigned int stack_not_used(struct task_struct *p)
{
  long unsigned int *n = end_of_stack ( p );
  ldv_18842:;
# 2633 "include/linux/sched.h"
  n ++;
  if (* n == 0UL)
  {
    goto ldv_18842;
  }
  else
    goto ldv_18843;
  ldv_18843:;
# 2636 "include/linux/sched.h"
  return ( long unsigned int ) n - ( long unsigned int ) end_of_stack ( p );
}
# 2643 "include/linux/sched.h"
static inline void set_tsk_thread_flag(struct task_struct *tsk, int flag)
{
  set_ti_thread_flag ( ( struct thread_info *) ( * tsk ) . stack , flag );
}
# 2648 "include/linux/sched.h"
static inline void clear_tsk_thread_flag(struct task_struct *tsk, int flag)
{
  clear_ti_thread_flag ( ( struct thread_info *) ( * tsk ) . stack , flag );
}
# 2653 "include/linux/sched.h"
static inline int test_and_set_tsk_thread_flag(struct task_struct *tsk, int flag)
{
  return test_and_set_ti_thread_flag ( ( struct thread_info *) ( * tsk ) . stack , flag );
}
# 2658 "include/linux/sched.h"
static inline int test_and_clear_tsk_thread_flag(struct task_struct *tsk, int flag)
{
  return test_and_clear_ti_thread_flag ( ( struct thread_info *) ( * tsk ) . stack , flag );
}
# 2663 "include/linux/sched.h"
static inline int test_tsk_thread_flag(struct task_struct *tsk, int flag)
{
  return test_ti_thread_flag ( ( struct thread_info *) ( * tsk ) . stack , flag );
}
# 2668 "include/linux/sched.h"
static inline void set_tsk_need_resched(struct task_struct *tsk)
{
  set_tsk_thread_flag ( tsk , 3 );
}
# 2673 "include/linux/sched.h"
static inline void clear_tsk_need_resched(struct task_struct *tsk)
{
  clear_tsk_thread_flag ( tsk , 3 );
}
# 2678 "include/linux/sched.h"
static inline int test_tsk_need_resched(struct task_struct *tsk)
{
  return ( int ) __builtin_expect ( test_tsk_thread_flag ( tsk , 3 ) != 0 , 0L );
}
# 2683 "include/linux/sched.h"
static inline int restart_syscall(void)
{
  set_tsk_thread_flag ( get_current ( ) , 2 );
  return -513;
}
# 2689 "include/linux/sched.h"
static inline int signal_pending(struct task_struct *p)
{
  return ( int ) __builtin_expect ( test_tsk_thread_flag ( p , 2 ) != 0 , 0L );
}
# 2694 "include/linux/sched.h"
static inline int __fatal_signal_pending(struct task_struct *p)
{
  return ( int ) __builtin_expect ( sigismember ( & ( * p ) . pending . signal , 9 ) != 0 , 0L );
}
# 2699 "include/linux/sched.h"
static inline int fatal_signal_pending(struct task_struct *p)
{
  return signal_pending ( p ) != 0 && __fatal_signal_pending ( p ) != 0;
}
# 2704 "include/linux/sched.h"
static inline int signal_pending_state(long int state, struct task_struct *p)
{
  if (( state & 129L ) == 0L)
    return 0;
  if (signal_pending ( p ) == 0)
    return 0;
# 2711 "include/linux/sched.h"
  return ( int ) state & 1 || __fatal_signal_pending ( p ) != 0;
}
# 2721 "include/linux/sched.h"
int _cond_resched(void);
# 2728 "include/linux/sched.h"
int __cond_resched_lock(spinlock_t *);
# 2741 "include/linux/sched.h"
int __cond_resched_softirq(void);
# 2748 "include/linux/sched.h"
static inline void cond_resched_rcu(void)
{
# 2751 "include/linux/sched.h"
  rcu_read_unlock ( );
  ({
# 2752 "include/linux/sched.h"
    __might_sleep ( ( char const *) "include/linux/sched.h" , 2752 , 0 );
# 2752 "include/linux/sched.h"
    _cond_resched ( );
  } );
# 2753 "include/linux/sched.h"
  rcu_read_lock ( );
}
# 2762 "include/linux/sched.h"
static inline int spin_needbreak(spinlock_t *lock)
{
# 2767 "include/linux/sched.h"
  return 0;
}
# 2776 "include/linux/sched.h"
static inline int tsk_is_polling(struct task_struct *p)
{
  return test_tsk_thread_flag ( p , 21 );
}
# 2781 "include/linux/sched.h"
static inline void __current_set_polling(void)
{
  set_ti_thread_flag ( current_thread_info ( ) , 21 );
}
# 2786 "include/linux/sched.h"
static inline bool current_set_polling_and_test(void)
{
  __current_set_polling ( );
# 2794 "include/linux/sched.h"
  asm volatile ( "" : : : "memory" ) ;
# 2796 "include/linux/sched.h"
  return __builtin_expect ( test_ti_thread_flag ( current_thread_info ( ) , 3 ) != 0 , 0L ) != 0L;
}
# 2799 "include/linux/sched.h"
static inline void __current_clr_polling(void)
{
  clear_ti_thread_flag ( current_thread_info ( ) , 21 );
}
# 2804 "include/linux/sched.h"
static inline bool current_clr_polling_and_test(void)
{
  __current_clr_polling ( );
# 2812 "include/linux/sched.h"
  asm volatile ( "" : : : "memory" ) ;
# 2814 "include/linux/sched.h"
  return __builtin_expect ( test_ti_thread_flag ( current_thread_info ( ) , 3 ) != 0 , 0L ) != 0L;
}
# 2832 "include/linux/sched.h"
static inline void current_clr_polling(void)
{
  __current_clr_polling ( );
# 2842 "include/linux/sched.h"
  asm volatile ( "mfence" : : : "memory" ) ;
# 2844 "include/linux/sched.h"
  if (test_ti_thread_flag ( current_thread_info ( ) , 3 ) != 0)
# 2844 "include/linux/sched.h"
    set_preempt_need_resched ( );
}
# 2847 "include/linux/sched.h"
static inline bool need_resched(void)
{
  return __builtin_expect ( test_ti_thread_flag ( current_thread_info ( ) , 3 ) != 0 , 0L ) != 0L;
}
# 2855 "include/linux/sched.h"
void thread_group_cputime(struct task_struct *, struct task_cputime *);
void thread_group_cputimer(struct task_struct *, struct task_cputime *);
# 2858 "include/linux/sched.h"
static inline void thread_group_cputime_init(struct signal_struct *sig)
{
  {
# 2860 "include/linux/sched.h"
    struct lock_class_key __key;
# 2860 "include/linux/sched.h"
    __raw_spin_lock_init ( & ( * sig ) . cputimer . lock , ( char const *) "&sig->cputimer.lock" , & __key );
  }
}
# 2869 "include/linux/sched.h"
void recalc_sigpending_and_wake(struct task_struct *);
void recalc_sigpending(void);
# 2872 "include/linux/sched.h"
void signal_wake_up_state(struct task_struct *, unsigned int);
# 2874 "include/linux/sched.h"
static inline void signal_wake_up(struct task_struct *t, bool resume)
{
  signal_wake_up_state ( t , ( int ) resume ? 128U : 0U );
}
static inline void ptrace_signal_wake_up(struct task_struct *t, bool resume)
{
  signal_wake_up_state ( t , ( int ) resume ? 8U : 0U );
}
# 2888 "include/linux/sched.h"
static inline unsigned int task_cpu(struct task_struct const *p)
{
  return ( unsigned int ) ( * ( struct thread_info *) ( * p ) . stack ) . cpu;
}
# 2893 "include/linux/sched.h"
static inline int task_node(struct task_struct const *p)
{
  return __cpu_to_node ( ( int ) task_cpu ( p ) );
}
# 2898 "include/linux/sched.h"
void set_task_cpu(struct task_struct *, unsigned int);
# 2913 "include/linux/sched.h"
long int sched_setaffinity(pid_t, struct cpumask const *);
long int sched_getaffinity(pid_t, struct cpumask *);
# 2917 "include/linux/sched.h"
extern struct task_group root_task_group;
# 2920 "include/linux/sched.h"
int task_can_switch_user(struct user_struct *, struct task_struct *);
# 2924 "include/linux/sched.h"
static inline void add_rchar(struct task_struct *tsk, ssize_t amt)
{
  ( * tsk ) . ioac . rchar = ( long long unsigned int ) ( * tsk ) . ioac . rchar + ( long long unsigned int ) amt;
}
# 2929 "include/linux/sched.h"
static inline void add_wchar(struct task_struct *tsk, ssize_t amt)
{
  ( * tsk ) . ioac . wchar = ( long long unsigned int ) ( * tsk ) . ioac . wchar + ( long long unsigned int ) amt;
}
# 2934 "include/linux/sched.h"
static inline void inc_syscr(struct task_struct *tsk)
{
  ( * tsk ) . ioac . syscr ++;
}
# 2939 "include/linux/sched.h"
static inline void inc_syscw(struct task_struct *tsk)
{
  ( * tsk ) . ioac . syscw ++;
}
# 2966 "include/linux/sched.h"
void mm_update_next_owner(struct mm_struct *);
# 2973 "include/linux/sched.h"
static inline long unsigned int task_rlimit(struct task_struct const *tsk, unsigned int limit)
{
# 2976 "include/linux/sched.h"
  return ( long unsigned int ) * ( __kernel_ulong_t volatile *) & ( * ( * tsk ) . signal ) . rlim [ limit ] . rlim_cur;
}
# 2979 "include/linux/sched.h"
static inline long unsigned int task_rlimit_max(struct task_struct const *tsk, unsigned int limit)
{
# 2982 "include/linux/sched.h"
  return ( long unsigned int ) * ( __kernel_ulong_t volatile *) & ( * ( * tsk ) . signal ) . rlim [ limit ] . rlim_max;
}
# 2985 "include/linux/sched.h"
static inline long unsigned int rlimit(unsigned int limit)
{
  return task_rlimit ( ( struct task_struct const *) get_current ( ) , limit );
}
# 2990 "include/linux/sched.h"
static inline long unsigned int rlimit_max(unsigned int limit)
{
  return task_rlimit_max ( ( struct task_struct const *) get_current ( ) , limit );
}
# 23 "include/linux/kdev_t.h"
static inline int old_valid_dev(dev_t dev)
{
  return dev >> 20 <= 255U && ( dev & 1048575U ) <= 255U;
}
# 28 "include/linux/kdev_t.h"
static inline u16 old_encode_dev(dev_t dev)
{
  return ( u16 ) ( dev >> 20 ) << 8U | ( u16 ) dev;
}
# 33 "include/linux/kdev_t.h"
static inline dev_t old_decode_dev(u16 val)
{
  return ( dev_t ) ( ( ( int ) ( ( short unsigned int ) val >> 8 ) & 255 ) << 20 | ( int ) val & 255 );
}
# 38 "include/linux/kdev_t.h"
static inline int new_valid_dev(dev_t dev)
{
  return 1;
}
# 43 "include/linux/kdev_t.h"
static inline u32 new_encode_dev(dev_t dev)
{
  unsigned int major = dev >> 20;
  unsigned int minor = dev & 1048575U;
  return ( u32 ) ( minor & 255U | major << 8 | ( minor & 4294967040U ) << 12 );
}
# 50 "include/linux/kdev_t.h"
static inline dev_t new_decode_dev(u32 dev)
{
  unsigned int major = ( dev & 1048320U ) >> 8;
  unsigned int minor = dev & 255U | dev >> 12 & 1048320U;
  return ( dev_t ) ( major << 20 | minor );
}
# 57 "include/linux/kdev_t.h"
static inline int huge_valid_dev(dev_t dev)
{
  return 1;
}
# 62 "include/linux/kdev_t.h"
static inline u64 huge_encode_dev(dev_t dev)
{
  return ( u64 ) new_encode_dev ( dev );
}
# 67 "include/linux/kdev_t.h"
static inline dev_t huge_decode_dev(u64 dev)
{
  return new_decode_dev ( ( u32 ) dev );
}
# 72 "include/linux/kdev_t.h"
static inline int sysv_valid_dev(dev_t dev)
{
  return dev >> 20 <= 16383U && ( dev & 1048575U ) <= 262143U;
}
# 77 "include/linux/kdev_t.h"
static inline u32 sysv_encode_dev(dev_t dev)
{
  return ( u32 ) ( dev & 1048575U | dev >> 20 << 18 );
}
# 82 "include/linux/kdev_t.h"
static inline unsigned int sysv_major(u32 dev)
{
  return ( unsigned int ) ( dev >> 18 );
}
# 87 "include/linux/kdev_t.h"
static inline unsigned int sysv_minor(u32 dev)
{
  return ( unsigned int ) dev & 262143U;
}
# 26 "include/linux/kmemleak.h"
void kmemleak_init(void);
void kmemleak_alloc(void const *, size_t, int, gfp_t);
# 29 "include/linux/kmemleak.h"
void kmemleak_alloc_percpu(void const *, size_t);
void kmemleak_free(void const *);
void kmemleak_free_part(void const *, size_t);
void kmemleak_free_percpu(void const *);
void kmemleak_update_trace(void const *);
void kmemleak_not_leak(void const *);
void kmemleak_ignore(void const *);
void kmemleak_scan_area(void const *, size_t, gfp_t);
void kmemleak_no_scan(void const *);
# 39 "include/linux/kmemleak.h"
static inline void kmemleak_alloc_recursive(void const *ptr, size_t size, int min_count, long unsigned int flags, gfp_t gfp)
{
# 43 "include/linux/kmemleak.h"
  if (( flags & 8388608UL ) == 0UL)
    kmemleak_alloc ( ptr , size , min_count , gfp );
}
# 47 "include/linux/kmemleak.h"
static inline void kmemleak_free_recursive(void const *ptr, long unsigned int flags)
{
  if (( flags & 8388608UL ) == 0UL)
    kmemleak_free ( ptr );
}
# 53 "include/linux/kmemleak.h"
static inline void kmemleak_erase(void **ptr)
{
  * ptr = ( ( void *) 0 );
}
# 112 "include/linux/slab.h"
void kmem_cache_init(void);
int slab_is_available(void);
# 115 "include/linux/slab.h"
struct kmem_cache *kmem_cache_create(char const *, size_t, size_t, long unsigned int, void (*)(void *));
# 119 "include/linux/slab.h"
struct kmem_cache *memcg_create_kmem_cache(struct mem_cgroup *, struct kmem_cache *, char const *);
# 123 "include/linux/slab.h"
void kmem_cache_destroy(struct kmem_cache *);
int kmem_cache_shrink(struct kmem_cache *);
void kmem_cache_free(struct kmem_cache *, void *);
# 142 "include/linux/slab.h"
void *__krealloc(void const *, size_t, gfp_t);
void *krealloc(void const *, size_t, gfp_t);
void kfree(void const *);
void kzfree(void const *);
size_t ksize(void const *);
# 259 "include/linux/slab.h"
extern struct kmem_cache *kmalloc_caches[14U];
# 261 "include/linux/slab.h"
extern struct kmem_cache *kmalloc_dma_caches[14U];
# 272 "include/linux/slab.h"
static inline int kmalloc_index(size_t size)
{
  if (size == 0UL)
    return 0;
# 277 "include/linux/slab.h"
  if (size <= 8UL)
    return 3;
# 280 "include/linux/slab.h"
  if (size > 64UL && size <= 96UL)
    return 1;
  if (size > 128UL && size <= 192UL)
    return 2;
  if (size <= 8UL)
# 284 "include/linux/slab.h"
    return 3;
  if (size <= 16UL)
# 285 "include/linux/slab.h"
    return 4;
  if (size <= 32UL)
# 286 "include/linux/slab.h"
    return 5;
  if (size <= 64UL)
# 287 "include/linux/slab.h"
    return 6;
  if (size <= 128UL)
# 288 "include/linux/slab.h"
    return 7;
  if (size <= 256UL)
# 289 "include/linux/slab.h"
    return 8;
  if (size <= 512UL)
# 290 "include/linux/slab.h"
    return 9;
  if (size <= 1024UL)
# 291 "include/linux/slab.h"
    return 10;
  if (size <= 2048UL)
# 292 "include/linux/slab.h"
    return 11;
  if (size <= 4096UL)
# 293 "include/linux/slab.h"
    return 12;
  if (size <= 8192UL)
# 294 "include/linux/slab.h"
    return 13;
  if (size <= 16384UL)
# 295 "include/linux/slab.h"
    return 14;
  if (size <= 32768UL)
# 296 "include/linux/slab.h"
    return 15;
  if (size <= 65536UL)
# 297 "include/linux/slab.h"
    return 16;
  if (size <= 131072UL)
# 298 "include/linux/slab.h"
    return 17;
  if (size <= 262144UL)
# 299 "include/linux/slab.h"
    return 18;
  if (size <= 524288UL)
# 300 "include/linux/slab.h"
    return 19;
  if (size <= 1048576UL)
# 301 "include/linux/slab.h"
    return 20;
  if (size <= 2097152UL)
# 302 "include/linux/slab.h"
    return 21;
  if (size <= 4194304UL)
# 303 "include/linux/slab.h"
    return 22;
  if (size <= 8388608UL)
# 304 "include/linux/slab.h"
    return 23;
  if (size <= 16777216UL)
# 305 "include/linux/slab.h"
    return 24;
  if (size <= 33554432UL)
# 306 "include/linux/slab.h"
    return 25;
  if (size <= 67108864UL)
# 307 "include/linux/slab.h"
    return 26;
  asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/slab.h" ) , "i" ( 308 ) , "i" ( 12UL ) ) ;
  ldv_19124:;
# 308 "include/linux/slab.h"
  goto ldv_19124;
# 311 "include/linux/slab.h"
  return -1;
}
# 315 "include/linux/slab.h"
void *__kmalloc(size_t, gfp_t);
void *kmem_cache_alloc(struct kmem_cache *, gfp_t);
# 319 "include/linux/slab.h"
void *__kmalloc_node(size_t, gfp_t, int);
void *kmem_cache_alloc_node(struct kmem_cache *, gfp_t, int);
# 334 "include/linux/slab.h"
void *kmem_cache_alloc_trace(struct kmem_cache *, gfp_t, size_t);
# 337 "include/linux/slab.h"
void *kmem_cache_alloc_node_trace(struct kmem_cache *, gfp_t, int, size_t);
enum stat_item
{
  ALLOC_FASTPATH = 0,
  ALLOC_SLOWPATH = 1,
  FREE_FASTPATH = 2,
  FREE_SLOWPATH = 3,
  FREE_FROZEN = 4,
  FREE_ADD_PARTIAL = 5,
  FREE_REMOVE_PARTIAL = 6,
  ALLOC_FROM_PARTIAL = 7,
  ALLOC_SLAB = 8,
  ALLOC_REFILL = 9,
  ALLOC_NODE_MISMATCH = 10,
  FREE_SLAB = 11,
  CPUSLAB_FLUSH = 12,
  DEACTIVATE_FULL = 13,
  DEACTIVATE_EMPTY = 14,
  DEACTIVATE_TO_HEAD = 15,
  DEACTIVATE_TO_TAIL = 16,
  DEACTIVATE_REMOTE_FREES = 17,
  DEACTIVATE_BYPASS = 18,
  ORDER_FALLBACK = 19,
  CMPXCHG_DOUBLE_CPU_FAIL = 20,
  CMPXCHG_DOUBLE_FAIL = 21,
  CPU_PARTIAL_ALLOC = 22,
  CPU_PARTIAL_FREE = 23,
  CPU_PARTIAL_NODE = 24,
  CPU_PARTIAL_DRAIN = 25,
  NR_SLUB_STAT_ITEMS = 26
};
struct kmem_cache_cpu
{
# 41 "include/linux/slub_def.h"
  void **freelist;
  long unsigned int tid;
  struct page *page;
  struct page *partial;
# 46 "include/linux/slub_def.h"
  unsigned int stat[26U];
};
struct kmem_cache_order_objects
{
# 56 "include/linux/slub_def.h"
  long unsigned int x;
};
struct kmem_cache
{
# 63 "include/linux/slub_def.h"
  struct kmem_cache_cpu *cpu_slab;
# 65 "include/linux/slub_def.h"
  long unsigned int flags;
  long unsigned int min_partial;
  int size;
  int object_size;
  int offset;
  int cpu_partial;
  struct kmem_cache_order_objects oo;
# 74 "include/linux/slub_def.h"
  struct kmem_cache_order_objects max;
  struct kmem_cache_order_objects min;
  gfp_t allocflags;
  int refcount;
  void (*ctor)(void *);
  int inuse;
  int align;
  int reserved;
  char const *name;
  struct list_head list;
# 85 "include/linux/slub_def.h"
  struct kobject kobj;
# 88 "include/linux/slub_def.h"
  struct memcg_cache_params *memcg_params;
  int max_attr_size;
# 91 "include/linux/slub_def.h"
  struct kset *memcg_kset;
# 99 "include/linux/slub_def.h"
  int remote_node_defrag_ratio;
# 101 "include/linux/slub_def.h"
  struct kmem_cache_node *node[1024U];
};
# 106 "include/linux/slub_def.h"
void sysfs_slab_remove(struct kmem_cache *);
# 374 "include/linux/slab.h"
void *kmalloc_order(size_t, gfp_t, unsigned int);
# 377 "include/linux/slab.h"
void *kmalloc_order_trace(size_t, gfp_t, unsigned int);
# 386 "include/linux/slab.h"
static inline void *kmalloc_large(size_t size, gfp_t flags)
{
  unsigned int order = ( unsigned int ) __get_order ( size );
  return kmalloc_order_trace ( size , flags , order );
}
# 445 "include/linux/slab.h"
static inline void *kmalloc(size_t size, gfp_t flags)
{
  if (0)
  {
# 448 "include/linux/slab.h"
    if (( long unsigned int ) size > 8192UL)
      return kmalloc_large ( size , flags );
# 451 "include/linux/slab.h"
    if (( flags & 1U ) == 0U)
    {
# 452 "include/linux/slab.h"
      int index = kmalloc_index ( size );
# 454 "include/linux/slab.h"
      if (index == 0)
        return ( ( void *) 16 );
# 457 "include/linux/slab.h"
      return kmem_cache_alloc_trace ( kmalloc_caches [ index ] , flags , size );
    }
  }
# 462 "include/linux/slab.h"
  return __kmalloc ( size , flags );
}
# 470 "include/linux/slab.h"
static inline int kmalloc_size(int n)
{
# 473 "include/linux/slab.h"
  if (n > 2)
    return 1 << n;
# 476 "include/linux/slab.h"
  if (n == 1)
    return 96;
# 479 "include/linux/slab.h"
  if (n == 2)
    return 192;
# 482 "include/linux/slab.h"
  return 0;
}
# 485 "include/linux/slab.h"
static inline void *kmalloc_node(size_t size, gfp_t flags, int node)
{
# 488 "include/linux/slab.h"
  if (0)
  {
    int i = kmalloc_index ( size );
# 492 "include/linux/slab.h"
    if (i == 0)
      return ( ( void *) 16 );
# 495 "include/linux/slab.h"
    return kmem_cache_alloc_node_trace ( kmalloc_caches [ i ] , flags , node , size );
  }
# 499 "include/linux/slab.h"
  return __kmalloc_node ( size , flags , node );
}
struct memcg_cache_params
{
# 532 "include/linux/slab.h"
  bool is_root_cache;
# 544 "include/linux/slab.h"
  union
  {
# 537 "include/linux/slab.h"
    struct
    {
# 535 "include/linux/slab.h"
      struct callback_head callback_head;
      struct kmem_cache *memcg_caches[0U];
    } ldv_19245;
# 543 "include/linux/slab.h"
    struct
    {
# 539 "include/linux/slab.h"
      struct mem_cgroup *memcg;
      struct list_head list;
      struct kmem_cache *root_cache;
      atomic_t nr_pages;
    } ldv_19251;
  } ldv_19252;
};
# 547 "include/linux/slab.h"
int memcg_update_all_caches(int);
# 550 "include/linux/slab.h"
int cache_show(struct kmem_cache *, struct seq_file *);
void print_slabinfo_header(struct seq_file *);
# 559 "include/linux/slab.h"
static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  if (size != 0UL && 18446744073709551615UL / ( long unsigned int ) size < ( long unsigned int ) n)
    return ( ( void *) 0 );
  return __kmalloc ( n * size , flags );
}
# 572 "include/linux/slab.h"
static inline void *kcalloc(size_t n, size_t size, gfp_t flags)
{
  return kmalloc_array ( n , size , flags | 32768U );
}
# 588 "include/linux/slab.h"
void *__kmalloc_track_caller(size_t, gfp_t, long unsigned int);
# 608 "include/linux/slab.h"
void *__kmalloc_node_track_caller(size_t, gfp_t, int, long unsigned int);
# 627 "include/linux/slab.h"
static inline void *kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags)
{
  return kmem_cache_alloc ( k , flags | 32768U );
}
# 637 "include/linux/slab.h"
static inline void *kzalloc(size_t size, gfp_t flags)
{
  return kmalloc ( size , flags | 32768U );
}
# 648 "include/linux/slab.h"
static inline void *kzalloc_node(size_t size, gfp_t flags, int node)
{
  return kmalloc_node ( size , flags | 32768U , node );
}
# 656 "include/linux/slab.h"
static inline unsigned int kmem_cache_size(struct kmem_cache *s)
{
  return ( unsigned int ) ( * s ) . object_size;
}
# 661 "include/linux/slab.h"
void kmem_cache_init_late(void);
# 24 "include/linux/genhd.h"
extern struct device_type part_type;
extern struct kobject *block_depr;
extern struct class block_class;
enum ldv_16250
{
  DOS_EXTENDED_PARTITION = 5,
  LINUX_EXTENDED_PARTITION = 133,
  WIN98_EXTENDED_PARTITION = 15,
  SUN_WHOLE_DISK = 5,
  LINUX_SWAP_PARTITION = 130,
  LINUX_DATA_PARTITION = 131,
  LINUX_LVM_PARTITION = 142,
  LINUX_RAID_PARTITION = 253,
  SOLARIS_X86_PARTITION = 130,
  NEW_SOLARIS_X86_PARTITION = 191,
  DM6_AUX1PARTITION = 81,
  DM6_AUX3PARTITION = 83,
  DM6_PARTITION = 84,
  EZD_PARTITION = 85,
  FREEBSD_PARTITION = 165,
  OPENBSD_PARTITION = 166,
  NETBSD_PARTITION = 169,
  BSDI_PARTITION = 183,
  MINIX_PARTITION = 129,
  UNIXWARE_PARTITION = 99
};
struct klist_node;
struct klist
{
# 21 "include/linux/klist.h"
  spinlock_t k_lock;
  struct list_head k_list;
  void (*get)(struct klist_node *);
  void (*put)(struct klist_node *);
};
# 36 "include/linux/klist.h"
void klist_init(struct klist *, void (*)(struct klist_node *), void (*)(struct klist_node *));
struct klist_node
{
# 40 "include/linux/klist.h"
  void *n_klist;
  struct list_head n_node;
  struct kref n_ref;
};
# 45 "include/linux/klist.h"
void klist_add_tail(struct klist_node *, struct klist *);
void klist_add_head(struct klist_node *, struct klist *);
void klist_add_behind(struct klist_node *, struct klist_node *);
void klist_add_before(struct klist_node *, struct klist_node *);
# 50 "include/linux/klist.h"
void klist_del(struct klist_node *);
void klist_remove(struct klist_node *);
# 53 "include/linux/klist.h"
int klist_node_attached(struct klist_node *);
struct klist_iter
{
# 57 "include/linux/klist.h"
  struct klist *i_klist;
  struct klist_node *i_cur;
};
# 62 "include/linux/klist.h"
void klist_iter_init(struct klist *, struct klist_iter *);
void klist_iter_init_node(struct klist *, struct klist_iter *, struct klist_node *);
# 65 "include/linux/klist.h"
void klist_iter_exit(struct klist_iter *);
struct klist_node *klist_next(struct klist_iter *);
struct path;
struct seq_file
{
# 19 "include/linux/seq_file.h"
  char *buf;
  size_t size;
  size_t from;
  size_t count;
  size_t pad_until;
  loff_t index;
  loff_t read_pos;
  u64 version;
  struct mutex lock;
  struct seq_operations const *op;
  int poll_event;
# 31 "include/linux/seq_file.h"
  struct user_namespace *user_ns;
# 33 "include/linux/seq_file.h"
  void *private;
};
struct seq_operations
{
  void *(*start)(struct seq_file *, loff_t *);
  void (*stop)(struct seq_file *, void *);
  void *(*next)(struct seq_file *, void *, loff_t *);
  int (*show)(struct seq_file *, void *);
};
# 53 "include/linux/seq_file.h"
static inline size_t seq_get_buf(struct seq_file *m, char **bufp)
{
  if (__builtin_expect ( ( * m ) . count > ( * m ) . size , 0L ) != 0L)
  {
# 55 "include/linux/seq_file.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/seq_file.h" ) , "i" ( 55 ) , "i" ( 12UL ) ) ;
    ldv_19403:;
# 55 "include/linux/seq_file.h"
    goto ldv_19403;
  }
# 56 "include/linux/seq_file.h"
  if (( * m ) . count < ( * m ) . size)
  {
# 57 "include/linux/seq_file.h"
    * bufp = ( * m ) . buf + ( * m ) . count;
  }
  else
# 59 "include/linux/seq_file.h"
    * bufp = ( ( char *) 0 );
# 61 "include/linux/seq_file.h"
  return ( * m ) . size - ( * m ) . count;
}
# 73 "include/linux/seq_file.h"
static inline void seq_commit(struct seq_file *m, int num)
{
  if (num < 0)
  {
# 76 "include/linux/seq_file.h"
    ( * m ) . count = ( * m ) . size;
  }
  else
  {
# 78 "include/linux/seq_file.h"
    if (__builtin_expect ( ( * m ) . count + ( size_t ) num > ( * m ) . size , 0L ) != 0L)
    {
# 78 "include/linux/seq_file.h"
      asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/seq_file.h" ) , "i" ( 78 ) , "i" ( 12UL ) ) ;
      ldv_19408:;
# 78 "include/linux/seq_file.h"
      goto ldv_19408;
    }
# 79 "include/linux/seq_file.h"
    ( * m ) . count += ( size_t ) num;
  }
}
# 91 "include/linux/seq_file.h"
static inline void seq_setwidth(struct seq_file *m, size_t size)
{
  ( * m ) . pad_until = ( * m ) . count + size;
}
void seq_pad(struct seq_file *, char);
# 97 "include/linux/seq_file.h"
char *mangle_path(char *, char const *, char const *);
int seq_open(struct file *, struct seq_operations const *);
ssize_t seq_read(struct file *, char *, size_t, loff_t *);
loff_t seq_lseek(struct file *, loff_t, int);
int seq_release(struct inode *, struct file *);
int seq_escape(struct seq_file *, char const *, char const *);
int seq_putc(struct seq_file *, char);
int seq_puts(struct seq_file *, char const *);
int seq_write(struct seq_file *, void const *, size_t);
# 107 "include/linux/seq_file.h"
int seq_printf(struct seq_file *, char const *, ...);
int seq_vprintf(struct seq_file *, char const *, __va_list_tag *);
# 110 "include/linux/seq_file.h"
int seq_path(struct seq_file *, struct path const *, char const *);
int seq_dentry(struct seq_file *, struct dentry *, char const *);
int seq_path_root(struct seq_file *, struct path const *, struct path const *, char const *);
# 114 "include/linux/seq_file.h"
int seq_bitmap(struct seq_file *, long unsigned int const *, unsigned int);
# 116 "include/linux/seq_file.h"
static inline int seq_cpumask(struct seq_file *m, struct cpumask const *mask)
{
  return seq_bitmap ( m , ( long unsigned int const *) & ( * mask ) . bits , ( unsigned int ) nr_cpu_ids );
}
# 121 "include/linux/seq_file.h"
static inline int seq_nodemask(struct seq_file *m, nodemask_t *mask)
{
  return seq_bitmap ( m , ( long unsigned int const *) & ( * mask ) . bits , 1024U );
}
# 126 "include/linux/seq_file.h"
int seq_bitmap_list(struct seq_file *, long unsigned int const *, unsigned int);
# 129 "include/linux/seq_file.h"
static inline int seq_cpumask_list(struct seq_file *m, struct cpumask const *mask)
{
# 132 "include/linux/seq_file.h"
  return seq_bitmap_list ( m , ( long unsigned int const *) & ( * mask ) . bits , ( unsigned int ) nr_cpu_ids );
}
# 135 "include/linux/seq_file.h"
static inline int seq_nodemask_list(struct seq_file *m, nodemask_t *mask)
{
  return seq_bitmap_list ( m , ( long unsigned int const *) & ( * mask ) . bits , 1024U );
}
# 140 "include/linux/seq_file.h"
int single_open(struct file *, int (*)(struct seq_file *, void *), void *);
int single_open_size(struct file *, int (*)(struct seq_file *, void *), void *, size_t);
int single_release(struct inode *, struct file *);
void *__seq_open_private(struct file *, struct seq_operations const *, int);
int seq_open_private(struct file *, struct seq_operations const *, int);
int seq_release_private(struct inode *, struct file *);
int seq_put_decimal_ull(struct seq_file *, char, long long unsigned int);
# 148 "include/linux/seq_file.h"
int seq_put_decimal_ll(struct seq_file *, char, long long int);
# 151 "include/linux/seq_file.h"
static inline struct user_namespace *seq_user_ns(struct seq_file *seq)
{
# 154 "include/linux/seq_file.h"
  return ( * seq ) . user_ns;
}
# 166 "include/linux/seq_file.h"
struct list_head *seq_list_start(struct list_head *, loff_t);
# 168 "include/linux/seq_file.h"
struct list_head *seq_list_start_head(struct list_head *, loff_t);
# 170 "include/linux/seq_file.h"
struct list_head *seq_list_next(void *, struct list_head *, loff_t *);
# 177 "include/linux/seq_file.h"
struct hlist_node *seq_hlist_start(struct hlist_head *, loff_t);
# 179 "include/linux/seq_file.h"
struct hlist_node *seq_hlist_start_head(struct hlist_head *, loff_t);
# 181 "include/linux/seq_file.h"
struct hlist_node *seq_hlist_next(void *, struct hlist_head *, loff_t *);
# 184 "include/linux/seq_file.h"
struct hlist_node *seq_hlist_start_rcu(struct hlist_head *, loff_t);
# 186 "include/linux/seq_file.h"
struct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *, loff_t);
# 188 "include/linux/seq_file.h"
struct hlist_node *seq_hlist_next_rcu(void *, struct hlist_head *, loff_t *);
# 193 "include/linux/seq_file.h"
struct hlist_node *seq_hlist_start_percpu(struct hlist_head *, int *, loff_t);
# 195 "include/linux/seq_file.h"
struct hlist_node *seq_hlist_next_percpu(void *, struct hlist_head *, int *, loff_t *);
struct pinctrl;
struct pinctrl_state;
# 28 "include/linux/pinctrl/consumer.h"
int pinctrl_request_gpio(unsigned int);
void pinctrl_free_gpio(unsigned int);
int pinctrl_gpio_direction_input(unsigned int);
int pinctrl_gpio_direction_output(unsigned int);
# 33 "include/linux/pinctrl/consumer.h"
struct pinctrl *pinctrl_get(struct device *);
void pinctrl_put(struct pinctrl *);
struct pinctrl_state *pinctrl_lookup_state(struct pinctrl *, char const *);
# 38 "include/linux/pinctrl/consumer.h"
int pinctrl_select_state(struct pinctrl *, struct pinctrl_state *);
# 40 "include/linux/pinctrl/consumer.h"
struct pinctrl *devm_pinctrl_get(struct device *);
void devm_pinctrl_put(struct pinctrl *);
# 44 "include/linux/pinctrl/consumer.h"
int pinctrl_pm_select_default_state(struct device *);
int pinctrl_pm_select_sleep_state(struct device *);
int pinctrl_pm_select_idle_state(struct device *);
# 131 "include/linux/pinctrl/consumer.h"
static inline struct pinctrl *pinctrl_get_select(struct device *dev, char const *name)
{
# 134 "include/linux/pinctrl/consumer.h"
  struct pinctrl *p;
  struct pinctrl_state *s;
  int ret;
# 138 "include/linux/pinctrl/consumer.h"
  p = pinctrl_get ( dev );
  if (( int ) IS_ERR ( ( void const *) p ))
    return p;
# 142 "include/linux/pinctrl/consumer.h"
  s = pinctrl_lookup_state ( p , name );
  if (( int ) IS_ERR ( ( void const *) s ))
  {
# 144 "include/linux/pinctrl/consumer.h"
    pinctrl_put ( p );
    return ( struct pinctrl *) ERR_PTR ( PTR_ERR ( ( void const *) s ) );
  }
# 148 "include/linux/pinctrl/consumer.h"
  ret = pinctrl_select_state ( p , s );
  if (ret < 0)
  {
# 150 "include/linux/pinctrl/consumer.h"
    pinctrl_put ( p );
    return ( struct pinctrl *) ERR_PTR ( ( long int ) ret );
  }
# 154 "include/linux/pinctrl/consumer.h"
  return p;
}
# 157 "include/linux/pinctrl/consumer.h"
static inline struct pinctrl *pinctrl_get_select_default(struct device *dev)
{
# 160 "include/linux/pinctrl/consumer.h"
  return pinctrl_get_select ( dev , ( char const *) "default" );
}
# 163 "include/linux/pinctrl/consumer.h"
static inline struct pinctrl *devm_pinctrl_get_select(struct device *dev, char const *name)
{
# 166 "include/linux/pinctrl/consumer.h"
  struct pinctrl *p;
  struct pinctrl_state *s;
  int ret;
# 170 "include/linux/pinctrl/consumer.h"
  p = devm_pinctrl_get ( dev );
  if (( int ) IS_ERR ( ( void const *) p ))
    return p;
# 174 "include/linux/pinctrl/consumer.h"
  s = pinctrl_lookup_state ( p , name );
  if (( int ) IS_ERR ( ( void const *) s ))
  {
# 176 "include/linux/pinctrl/consumer.h"
    devm_pinctrl_put ( p );
    return ( struct pinctrl *) ERR_CAST ( ( void const *) s );
  }
# 180 "include/linux/pinctrl/consumer.h"
  ret = pinctrl_select_state ( p , s );
  if (ret < 0)
  {
# 182 "include/linux/pinctrl/consumer.h"
    devm_pinctrl_put ( p );
    return ( struct pinctrl *) ERR_PTR ( ( long int ) ret );
  }
# 186 "include/linux/pinctrl/consumer.h"
  return p;
}
# 189 "include/linux/pinctrl/consumer.h"
static inline struct pinctrl *devm_pinctrl_get_select_default(struct device *dev)
{
# 192 "include/linux/pinctrl/consumer.h"
  return devm_pinctrl_get_select ( dev , ( char const *) "default" );
}
struct dev_pin_info
{
# 29 "include/linux/pinctrl/devinfo.h"
  struct pinctrl *p;
  struct pinctrl_state *default_state;
# 32 "include/linux/pinctrl/devinfo.h"
  struct pinctrl_state *sleep_state;
  struct pinctrl_state *idle_state;
};
# 37 "include/linux/pinctrl/devinfo.h"
int pinctrl_bind_pins(struct device *);
struct ratelimit_state
{
# 11 "include/linux/ratelimit.h"
  raw_spinlock_t lock;
# 13 "include/linux/ratelimit.h"
  int interval;
  int burst;
  int printed;
  int missed;
  long unsigned int begin;
};
# 28 "include/linux/ratelimit.h"
static inline void ratelimit_state_init(struct ratelimit_state *rs, int interval, int burst)
{
  {
    struct lock_class_key __key;
# 31 "include/linux/ratelimit.h"
    __raw_spin_lock_init ( & ( * rs ) . lock , ( char const *) "&rs->lock" , & __key );
  }
# 32 "include/linux/ratelimit.h"
  ( * rs ) . interval = interval;
  ( * rs ) . burst = burst;
  ( * rs ) . printed = 0;
  ( * rs ) . missed = 0;
  ( * rs ) . begin = 0UL;
}
# 39 "include/linux/ratelimit.h"
extern struct ratelimit_state printk_ratelimit_state;
# 41 "include/linux/ratelimit.h"
int ___ratelimit(struct ratelimit_state *, char const *);
struct dev_archdata
{
# 6 "./arch/x86/include/asm/device.h"
  struct dma_map_ops *dma_ops;
# 9 "./arch/x86/include/asm/device.h"
  void *iommu;
};
struct pdev_archdata
{
};
struct device_private;
struct device_driver;
struct driver_private;
struct subsys_private;
struct bus_type;
struct iommu_ops;
struct iommu_group;
struct bus_attribute
{
# 45 "include/linux/device.h"
  struct attribute attr;
  ssize_t (*show)(struct bus_type *, char *);
  ssize_t (*store)(struct bus_type *, char const *, size_t);
};
# 57 "include/linux/device.h"
int bus_create_file(struct bus_type *, struct bus_attribute *);
# 59 "include/linux/device.h"
void bus_remove_file(struct bus_type *, struct bus_attribute *);
struct bus_type
{
# 105 "include/linux/device.h"
  char const *name;
  char const *dev_name;
  struct device *dev_root;
  struct device_attribute *dev_attrs;
  struct attribute_group const **bus_groups;
  struct attribute_group const **dev_groups;
  struct attribute_group const **drv_groups;
# 113 "include/linux/device.h"
  int (*match)(struct device *, struct device_driver *);
  int (*uevent)(struct device *, struct kobj_uevent_env *);
  int (*probe)(struct device *);
  int (*remove)(struct device *);
  void (*shutdown)(struct device *);
# 119 "include/linux/device.h"
  int (*online)(struct device *);
  int (*offline)(struct device *);
# 122 "include/linux/device.h"
  int (*suspend)(struct device *, pm_message_t);
  int (*resume)(struct device *);
# 125 "include/linux/device.h"
  struct dev_pm_ops const *pm;
# 127 "include/linux/device.h"
  struct iommu_ops const *iommu_ops;
# 129 "include/linux/device.h"
  struct subsys_private *p;
  struct lock_class_key lock_key;
};
# 133 "include/linux/device.h"
int bus_register(struct bus_type *);
# 135 "include/linux/device.h"
void bus_unregister(struct bus_type *);
# 137 "include/linux/device.h"
int bus_rescan_devices(struct bus_type *);
struct subsys_dev_iter
{
# 141 "include/linux/device.h"
  struct klist_iter ki;
  struct device_type const *type;
};
void subsys_dev_iter_init(struct subsys_dev_iter *, struct bus_type *, struct device *, struct device_type const *);
# 148 "include/linux/device.h"
struct device *subsys_dev_iter_next(struct subsys_dev_iter *);
void subsys_dev_iter_exit(struct subsys_dev_iter *);
# 151 "include/linux/device.h"
int bus_for_each_dev(struct bus_type *, struct device *, void *, int (*)(struct device *, void *));
# 153 "include/linux/device.h"
struct device *bus_find_device(struct bus_type *, struct device *, void *, int (*)(struct device *, void *));
# 156 "include/linux/device.h"
struct device *bus_find_device_by_name(struct bus_type *, struct device *, char const *);
# 159 "include/linux/device.h"
struct device *subsys_find_device_by_id(struct bus_type *, unsigned int, struct device *);
# 161 "include/linux/device.h"
int bus_for_each_drv(struct bus_type *, struct device_driver *, void *, int (*)(struct device_driver *, void *));
# 163 "include/linux/device.h"
void bus_sort_breadthfirst(struct bus_type *, int (*)(struct device const *, struct device const *));
# 174 "include/linux/device.h"
int bus_register_notifier(struct bus_type *, struct notifier_block *);
# 176 "include/linux/device.h"
int bus_unregister_notifier(struct bus_type *, struct notifier_block *);
# 193 "include/linux/device.h"
struct kset *bus_get_kset(struct bus_type *);
struct klist *bus_get_device_klist(struct bus_type *);
struct device_driver
{
# 229 "include/linux/device.h"
  char const *name;
  struct bus_type *bus;
# 232 "include/linux/device.h"
  struct module *owner;
  char const *mod_name;
# 235 "include/linux/device.h"
  bool suppress_bind_attrs;
# 237 "include/linux/device.h"
  struct of_device_id const *of_match_table;
  struct acpi_device_id const *acpi_match_table;
# 240 "include/linux/device.h"
  int (*probe)(struct device *);
  int (*remove)(struct device *);
  void (*shutdown)(struct device *);
  int (*suspend)(struct device *, pm_message_t);
  int (*resume)(struct device *);
  struct attribute_group const **groups;
# 247 "include/linux/device.h"
  struct dev_pm_ops const *pm;
# 249 "include/linux/device.h"
  struct driver_private *p;
};
# 253 "include/linux/device.h"
int driver_register(struct device_driver *);
void driver_unregister(struct device_driver *);
# 256 "include/linux/device.h"
struct device_driver *driver_find(char const *, struct bus_type *);
# 258 "include/linux/device.h"
int driver_probe_done(void);
void wait_for_device_probe(void);
struct driver_attribute
{
# 265 "include/linux/device.h"
  struct attribute attr;
  ssize_t (*show)(struct device_driver *, char *);
  ssize_t (*store)(struct device_driver *, char const *, size_t);
};
# 280 "include/linux/device.h"
int driver_create_file(struct device_driver *, struct driver_attribute const *);
# 282 "include/linux/device.h"
void driver_remove_file(struct device_driver *, struct driver_attribute const *);
# 285 "include/linux/device.h"
int driver_for_each_device(struct device_driver *, struct device *, void *, int (*)(struct device *, void *));
# 290 "include/linux/device.h"
struct device *driver_find_device(struct device_driver *, struct device *, void *, int (*)(struct device *, void *));
struct subsys_interface
{
# 308 "include/linux/device.h"
  char const *name;
  struct bus_type *subsys;
  struct list_head node;
  int (*add_dev)(struct device *, struct subsys_interface *);
  int (*remove_dev)(struct device *, struct subsys_interface *);
};
# 315 "include/linux/device.h"
int subsys_interface_register(struct subsys_interface *);
void subsys_interface_unregister(struct subsys_interface *);
# 318 "include/linux/device.h"
int subsys_system_register(struct bus_type *, struct attribute_group const **);
# 320 "include/linux/device.h"
int subsys_virtual_register(struct bus_type *, struct attribute_group const **);
struct class
{
# 352 "include/linux/device.h"
  char const *name;
  struct module *owner;
# 355 "include/linux/device.h"
  struct class_attribute *class_attrs;
  struct attribute_group const **dev_groups;
  struct kobject *dev_kobj;
# 359 "include/linux/device.h"
  int (*dev_uevent)(struct device *, struct kobj_uevent_env *);
  char *(*devnode)(struct device *, umode_t *);
# 362 "include/linux/device.h"
  void (*class_release)(struct class *);
  void (*dev_release)(struct device *);
# 365 "include/linux/device.h"
  int (*suspend)(struct device *, pm_message_t);
  int (*resume)(struct device *);
# 368 "include/linux/device.h"
  struct kobj_ns_type_operations const *ns_type;
  void const *(*namespace)(struct device *);
# 371 "include/linux/device.h"
  struct dev_pm_ops const *pm;
# 373 "include/linux/device.h"
  struct subsys_private *p;
};
struct class_dev_iter
{
  struct klist_iter ki;
  struct device_type const *type;
};
# 381 "include/linux/device.h"
extern struct kobject *sysfs_dev_block_kobj;
extern struct kobject *sysfs_dev_char_kobj;
int __class_register(struct class *, struct lock_class_key *);
# 385 "include/linux/device.h"
void class_unregister(struct class *);
struct class_compat;
# 396 "include/linux/device.h"
struct class_compat *class_compat_register(char const *);
void class_compat_unregister(struct class_compat *);
int class_compat_create_link(struct class_compat *, struct device *, struct device *);
# 400 "include/linux/device.h"
void class_compat_remove_link(struct class_compat *, struct device *, struct device *);
# 403 "include/linux/device.h"
void class_dev_iter_init(struct class_dev_iter *, struct class *, struct device *, struct device_type const *);
# 407 "include/linux/device.h"
struct device *class_dev_iter_next(struct class_dev_iter *);
void class_dev_iter_exit(struct class_dev_iter *);
# 410 "include/linux/device.h"
int class_for_each_device(struct class *, struct device *, void *, int (*)(struct device *, void *));
# 413 "include/linux/device.h"
struct device *class_find_device(struct class *, struct device *, void const *, int (*)(struct device *, void const *));
struct class_attribute
{
# 418 "include/linux/device.h"
  struct attribute attr;
  ssize_t (*show)(struct class *, struct class_attribute *, char *);
# 421 "include/linux/device.h"
  ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t);
};
# 432 "include/linux/device.h"
int class_create_file_ns(struct class *, struct class_attribute const *, void const *);
# 435 "include/linux/device.h"
void class_remove_file_ns(struct class *, struct class_attribute const *, void const *);
# 439 "include/linux/device.h"
static inline int class_create_file(struct class *class, struct class_attribute const *attr)
{
# 442 "include/linux/device.h"
  return class_create_file_ns ( class , attr , ( ( void const *) 0 ) );
}
# 445 "include/linux/device.h"
static inline void class_remove_file(struct class *class, struct class_attribute const *attr)
{
# 448 "include/linux/device.h"
  return & class_remove_file_ns;
}
struct class_attribute_string
{
# 453 "include/linux/device.h"
  struct class_attribute attr;
  char *str;
};
# 464 "include/linux/device.h"
ssize_t show_class_attr_string(struct class *, struct class_attribute *, char *);
struct class_interface
{
# 468 "include/linux/device.h"
  struct list_head node;
  struct class *class;
# 471 "include/linux/device.h"
  int (*add_dev)(struct device *, struct class_interface *);
  void (*remove_dev)(struct device *, struct class_interface *);
};
# 475 "include/linux/device.h"
int class_interface_register(struct class_interface *);
void class_interface_unregister(struct class_interface *);
# 478 "include/linux/device.h"
struct class *__class_create(struct module *, char const *, struct lock_class_key *);
# 481 "include/linux/device.h"
void class_destroy(struct class *);
struct device_type
{
# 501 "include/linux/device.h"
  char const *name;
  struct attribute_group const **groups;
  int (*uevent)(struct device *, struct kobj_uevent_env *);
  char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *);
# 506 "include/linux/device.h"
  void (*release)(struct device *);
# 508 "include/linux/device.h"
  struct dev_pm_ops const *pm;
};
struct device_attribute
{
# 513 "include/linux/device.h"
  struct attribute attr;
  ssize_t (*show)(struct device *, struct device_attribute *, char *);
# 516 "include/linux/device.h"
  ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t);
};
struct dev_ext_attribute
{
# 521 "include/linux/device.h"
  struct device_attribute attr;
  void *var;
};
# 525 "include/linux/device.h"
ssize_t device_show_ulong(struct device *, struct device_attribute *, char *);
# 527 "include/linux/device.h"
ssize_t device_store_ulong(struct device *, struct device_attribute *, char const *, size_t);
# 529 "include/linux/device.h"
ssize_t device_show_int(struct device *, struct device_attribute *, char *);
# 531 "include/linux/device.h"
ssize_t device_store_int(struct device *, struct device_attribute *, char const *, size_t);
# 533 "include/linux/device.h"
ssize_t device_show_bool(struct device *, struct device_attribute *, char *);
# 535 "include/linux/device.h"
ssize_t device_store_bool(struct device *, struct device_attribute *, char const *, size_t);
# 559 "include/linux/device.h"
int device_create_file(struct device *, struct device_attribute const *);
# 561 "include/linux/device.h"
void device_remove_file(struct device *, struct device_attribute const *);
# 563 "include/linux/device.h"
bool device_remove_file_self(struct device *, struct device_attribute const *);
# 565 "include/linux/device.h"
int device_create_bin_file(struct device *, struct bin_attribute const *);
# 567 "include/linux/device.h"
void device_remove_bin_file(struct device *, struct bin_attribute const *);
# 571 "include/linux/device.h"
typedef void (*dr_release_t)(struct device *, void *);
typedef int (*dr_match_t)(struct device *, void *, void *);
# 575 "include/linux/device.h"
void *__devres_alloc(dr_release_t, size_t, gfp_t, char const *);
# 582 "include/linux/device.h"
void devres_for_each_res(struct device *, dr_release_t, dr_match_t, void *, void (*)(struct device *, void *, void *), void *);
# 586 "include/linux/device.h"
void devres_free(void *);
void devres_add(struct device *, void *);
void *devres_find(struct device *, dr_release_t, dr_match_t, void *);
# 590 "include/linux/device.h"
void *devres_get(struct device *, void *, dr_match_t, void *);
# 592 "include/linux/device.h"
void *devres_remove(struct device *, dr_release_t, dr_match_t, void *);
# 594 "include/linux/device.h"
int devres_destroy(struct device *, dr_release_t, dr_match_t, void *);
# 596 "include/linux/device.h"
int devres_release(struct device *, dr_release_t, dr_match_t, void *);
# 600 "include/linux/device.h"
void *devres_open_group(struct device *, void *, gfp_t);
# 602 "include/linux/device.h"
void devres_close_group(struct device *, void *);
void devres_remove_group(struct device *, void *);
int devres_release_group(struct device *, void *);
# 607 "include/linux/device.h"
void *devm_kmalloc(struct device *, size_t, gfp_t);
char *devm_kvasprintf(struct device *, gfp_t, char const *, __va_list_tag *);
# 610 "include/linux/device.h"
char *devm_kasprintf(struct device *, gfp_t, char const *, ...);
# 612 "include/linux/device.h"
static inline void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp)
{
  return devm_kmalloc ( dev , size , gfp | 32768U );
}
static inline void *devm_kmalloc_array(struct device *dev, size_t n, size_t size, gfp_t flags)
{
# 619 "include/linux/device.h"
  if (size != 0UL && 18446744073709551615UL / ( long unsigned int ) size < ( long unsigned int ) n)
    return ( ( void *) 0 );
  return devm_kmalloc ( dev , n * size , flags );
}
static inline void *devm_kcalloc(struct device *dev, size_t n, size_t size, gfp_t flags)
{
# 626 "include/linux/device.h"
  return devm_kmalloc_array ( dev , n , size , flags | 32768U );
}
void devm_kfree(struct device *, void *);
char *devm_kstrdup(struct device *, char const *, gfp_t);
void *devm_kmemdup(struct device *, void const *, size_t, gfp_t);
# 633 "include/linux/device.h"
long unsigned int devm_get_free_pages(struct device *, gfp_t, unsigned int);
# 635 "include/linux/device.h"
void devm_free_pages(struct device *, long unsigned int);
# 637 "include/linux/device.h"
void *devm_ioremap_resource(struct device *, struct resource *);
# 640 "include/linux/device.h"
int devm_add_action(struct device *, void (*)(void *), void *);
void devm_remove_action(struct device *, void (*)(void *), void *);
struct device_dma_parameters
{
# 648 "include/linux/device.h"
  unsigned int max_segment_size;
  long unsigned int segment_boundary_mask;
};
struct acpi_device;
struct acpi_dev_node
{
# 656 "include/linux/device.h"
  struct acpi_device *companion;
};
struct device
{
# 730 "include/linux/device.h"
  struct device *parent;
# 732 "include/linux/device.h"
  struct device_private *p;
# 734 "include/linux/device.h"
  struct kobject kobj;
  char const *init_name;
  struct device_type const *type;
# 738 "include/linux/device.h"
  struct mutex mutex;
# 742 "include/linux/device.h"
  struct bus_type *bus;
  struct device_driver *driver;
# 745 "include/linux/device.h"
  void *platform_data;
# 747 "include/linux/device.h"
  void *driver_data;
# 749 "include/linux/device.h"
  struct dev_pm_info power;
  struct dev_pm_domain *pm_domain;
# 753 "include/linux/device.h"
  struct dev_pin_info *pins;
# 757 "include/linux/device.h"
  int numa_node;
# 759 "include/linux/device.h"
  u64 *dma_mask;
  u64 coherent_dma_mask;
# 765 "include/linux/device.h"
  long unsigned int dma_pfn_offset;
# 767 "include/linux/device.h"
  struct device_dma_parameters *dma_parms;
# 769 "include/linux/device.h"
  struct list_head dma_pools;
# 771 "include/linux/device.h"
  struct dma_coherent_mem *dma_mem;
# 774 "include/linux/device.h"
  struct cma *cma_area;
# 778 "include/linux/device.h"
  struct dev_archdata archdata;
# 780 "include/linux/device.h"
  struct device_node *of_node;
  struct acpi_dev_node acpi_node;
# 783 "include/linux/device.h"
  dev_t devt;
  u32 id;
# 786 "include/linux/device.h"
  spinlock_t devres_lock;
  struct list_head devres_head;
# 789 "include/linux/device.h"
  struct klist_node knode_class;
  struct class *class;
  struct attribute_group const **groups;
# 793 "include/linux/device.h"
  void (*release)(struct device *);
  struct iommu_group *iommu_group;
# 796 "include/linux/device.h"
  bool offline_disabled;
  bool offline;
};
# 800 "include/linux/device.h"
static inline struct device *kobj_to_dev(struct kobject *kobj)
{
  return ({
# 802 "include/linux/device.h"
    struct kobject const *__mptr = ( struct kobject const *) kobj;
# 802 "include/linux/device.h"
    ( struct device *) __mptr + 18446744073709551600U;
  } );
}
struct wakeup_source
{
# 47 "include/linux/pm_wakeup.h"
  char const *name;
  struct list_head entry;
  spinlock_t lock;
  struct timer_list timer;
  long unsigned int timer_expires;
  ktime_t total_time;
  ktime_t max_time;
  ktime_t last_time;
  ktime_t start_prevent_time;
  ktime_t prevent_sleep_time;
  long unsigned int event_count;
  long unsigned int active_count;
  long unsigned int relax_count;
  long unsigned int expire_count;
  long unsigned int wakeup_count;
  bool active;
  bool autosleep_enabled;
};
# 72 "include/linux/pm_wakeup.h"
static inline bool device_can_wakeup(struct device *dev)
{
  return ( int ) ( * dev ) . power . can_wakeup != 0;
}
# 77 "include/linux/pm_wakeup.h"
static inline bool device_may_wakeup(struct device *dev)
{
  return ( bool ) ( ( ( * ( ( unsigned char *) & * dev + 532UL ) ) ) != 0U && ( * dev ) . power . wakeup != ( ( struct wakeup_source *) 0 ) );
}
# 83 "include/linux/pm_wakeup.h"
void wakeup_source_prepare(struct wakeup_source *, char const *);
struct wakeup_source *wakeup_source_create(char const *);
void wakeup_source_drop(struct wakeup_source *);
void wakeup_source_destroy(struct wakeup_source *);
void wakeup_source_add(struct wakeup_source *);
void wakeup_source_remove(struct wakeup_source *);
struct wakeup_source *wakeup_source_register(char const *);
void wakeup_source_unregister(struct wakeup_source *);
int device_wakeup_enable(struct device *);
int device_wakeup_disable(struct device *);
void device_set_wakeup_capable(struct device *, bool);
int device_init_wakeup(struct device *, bool);
int device_set_wakeup_enable(struct device *, bool);
void __pm_stay_awake(struct wakeup_source *);
void pm_stay_awake(struct device *);
void __pm_relax(struct wakeup_source *);
void pm_relax(struct device *);
void __pm_wakeup_event(struct wakeup_source *, unsigned int);
void pm_wakeup_event(struct device *, unsigned int);
# 182 "include/linux/pm_wakeup.h"
static inline void wakeup_source_init(struct wakeup_source *ws, char const *name)
{
# 185 "include/linux/pm_wakeup.h"
  wakeup_source_prepare ( ws , name );
  wakeup_source_add ( ws );
}
# 189 "include/linux/pm_wakeup.h"
static inline void wakeup_source_trash(struct wakeup_source *ws)
{
  wakeup_source_remove ( ws );
  wakeup_source_drop ( ws );
}
# 808 "include/linux/device.h"
static inline char const *dev_name(struct device const *dev)
{
# 811 "include/linux/device.h"
  if (( * dev ) . init_name != ( ( char const *const ) 0 ))
    return ( char const *) ( * dev ) . init_name;
# 814 "include/linux/device.h"
  return kobject_name ( & ( * dev ) . kobj );
}
# 818 "include/linux/device.h"
int dev_set_name(struct device *, char const *, ...);
# 821 "include/linux/device.h"
static inline int dev_to_node(struct device *dev)
{
  return ( * dev ) . numa_node;
}
static inline void set_dev_node(struct device *dev, int node)
{
  ( * dev ) . numa_node = node;
}
# 839 "include/linux/device.h"
static inline void *dev_get_drvdata(struct device const *dev)
{
  return ( void *) ( * dev ) . driver_data;
}
# 844 "include/linux/device.h"
static inline void dev_set_drvdata(struct device *dev, void *data)
{
  ( * dev ) . driver_data = data;
}
# 849 "include/linux/device.h"
static inline struct pm_subsys_data *dev_to_psd(struct device *dev)
{
  return dev != ( ( struct device *) 0 ) ? ( * dev ) . power . subsys_data : ( ( struct pm_subsys_data *) 0 );
}
# 854 "include/linux/device.h"
static inline unsigned int dev_get_uevent_suppress(struct device const *dev)
{
  return ( unsigned int ) ( * dev ) . kobj . uevent_suppress;
}
# 859 "include/linux/device.h"
static inline void dev_set_uevent_suppress(struct device *dev, int val)
{
  ( * dev ) . kobj . uevent_suppress = ( unsigned char ) ( unsigned char ) val;
}
# 864 "include/linux/device.h"
static inline int device_is_registered(struct device *dev)
{
  return ( int ) ( * dev ) . kobj . state_in_sysfs;
}
# 869 "include/linux/device.h"
static inline void device_enable_async_suspend(struct device *dev)
{
  if (( int ) ! ( _Bool ) ( * dev ) . power . is_prepared)
    ( * dev ) . power . async_suspend = 1U;
}
# 875 "include/linux/device.h"
static inline void device_disable_async_suspend(struct device *dev)
{
  if (( int ) ! ( _Bool ) ( * dev ) . power . is_prepared)
    ( * dev ) . power . async_suspend = 0U;
}
# 881 "include/linux/device.h"
static inline bool device_async_suspend_enabled(struct device *dev)
{
  return ( ( * ( ( unsigned char *) & * dev + 532UL ) ) ) != 0U;
}
# 886 "include/linux/device.h"
static inline void pm_suspend_ignore_children(struct device *dev, bool enable)
{
  ( * dev ) . power . ignore_children = enable;
}
# 891 "include/linux/device.h"
static inline void dev_pm_syscore_device(struct device *dev, bool val)
{
# 894 "include/linux/device.h"
  ( * dev ) . power . syscore = val;
}
# 898 "include/linux/device.h"
static inline void device_lock(struct device *dev)
{
  ldv_mutex_lock_3 ( & ( * dev ) . mutex );
}
# 903 "include/linux/device.h"
static inline int device_trylock(struct device *dev)
{
  return ldv_mutex_trylock_4 ( & ( * dev ) . mutex );
}
# 908 "include/linux/device.h"
static inline void device_unlock(struct device *dev)
{
  ldv_mutex_unlock_5 ( & ( * dev ) . mutex );
}
# 913 "include/linux/device.h"
void driver_init(void);
# 918 "include/linux/device.h"
int device_register(struct device *);
void device_unregister(struct device *);
void device_initialize(struct device *);
int device_add(struct device *);
void device_del(struct device *);
int device_for_each_child(struct device *, void *, int (*)(struct device *, void *));
# 925 "include/linux/device.h"
struct device *device_find_child(struct device *, void *, int (*)(struct device *, void *));
# 927 "include/linux/device.h"
int device_rename(struct device *, char const *);
int device_move(struct device *, struct device *, enum dpm_order);
# 930 "include/linux/device.h"
char const *device_get_devnode(struct device *, umode_t *, kuid_t *, kgid_t *, char const **);
# 934 "include/linux/device.h"
static inline bool device_supports_offline(struct device *dev)
{
  return ( bool ) ( ( * dev ) . bus != ( ( struct bus_type *) 0 ) && ( * ( * dev ) . bus ) . offline != ( ( int (*)(struct device *)) 0 ) && ( * ( * dev ) . bus ) . online != ( ( int (*)(struct device *)) 0 ) );
}
# 939 "include/linux/device.h"
void lock_device_hotplug(void);
void unlock_device_hotplug(void);
int lock_device_hotplug_sysfs(void);
int device_offline(struct device *);
int device_online(struct device *);
# 947 "include/linux/device.h"
struct device *__root_device_register(char const *, struct module *);
# 954 "include/linux/device.h"
void root_device_unregister(struct device *);
# 956 "include/linux/device.h"
static inline void *dev_get_platdata(struct device const *dev)
{
  return ( void *) ( * dev ) . platform_data;
}
# 965 "include/linux/device.h"
int device_bind_driver(struct device *);
void device_release_driver(struct device *);
int device_attach(struct device *);
int driver_attach(struct device_driver *);
int device_reprobe(struct device *);
# 974 "include/linux/device.h"
struct device *device_create_vargs(struct class *, struct device *, dev_t, void *, char const *, __va_list_tag *);
# 981 "include/linux/device.h"
struct device *device_create(struct class *, struct device *, dev_t, void *, char const *, ...);
# 985 "include/linux/device.h"
struct device *device_create_with_groups(struct class *, struct device *, dev_t, void *, struct attribute_group const **, char const *, ...);
# 989 "include/linux/device.h"
void device_destroy(struct class *, dev_t);
# 997 "include/linux/device.h"
extern int (*platform_notify)(struct device *);
# 999 "include/linux/device.h"
extern int (*platform_notify_remove)(struct device *);
# 1006 "include/linux/device.h"
struct device *get_device(struct device *);
void put_device(struct device *);
# 1010 "include/linux/device.h"
int devtmpfs_create_node(struct device *);
int devtmpfs_delete_node(struct device *);
int devtmpfs_mount(char const *);
# 1020 "include/linux/device.h"
void device_shutdown(void);
# 1023 "include/linux/device.h"
char const *dev_driver_string(struct device const *);
# 1029 "include/linux/device.h"
int dev_vprintk_emit(int, struct device const *, char const *, __va_list_tag *);
# 1032 "include/linux/device.h"
int dev_printk_emit(int, struct device const *, char const *, ...);
# 1035 "include/linux/device.h"
int dev_printk(char const *, struct device const *, char const *, ...);
# 1038 "include/linux/device.h"
int dev_emerg(struct device const *, char const *, ...);
# 1040 "include/linux/device.h"
int dev_alert(struct device const *, char const *, ...);
# 1042 "include/linux/device.h"
int dev_crit(struct device const *, char const *, ...);
# 1044 "include/linux/device.h"
int dev_err(struct device const *, char const *, ...);
# 1046 "include/linux/device.h"
int dev_warn(struct device const *, char const *, ...);
# 1048 "include/linux/device.h"
int dev_notice(struct device const *, char const *, ...);
# 1050 "include/linux/device.h"
int _dev_info(struct device const *, char const *, ...);
# 1199 "include/linux/device.h"
extern long int sysfs_deprecated;
# 15 "include/linux/bit_spinlock.h"
static inline void bit_spin_lock(int bitnum, long unsigned int *addr)
{
# 24 "include/linux/bit_spinlock.h"
  __preempt_count_add ( 1 );
# 24 "include/linux/bit_spinlock.h"
  asm volatile ( "" : : : "memory" ) ;
# 26 "include/linux/bit_spinlock.h"
  goto ldv_20501;
  ldv_20500:;
# 27 "include/linux/bit_spinlock.h"
  asm volatile ( "" : : : "memory" ) ;
# 27 "include/linux/bit_spinlock.h"
  __preempt_count_sub ( 1 );
  ldv_20498:;
  cpu_relax ( );
  if (variable_test_bit ( ( long int ) bitnum , ( long unsigned int const volatile *) addr ) != 0)
  {
    goto ldv_20498;
  }
  else
    goto ldv_20499;
  ldv_20499:;
# 31 "include/linux/bit_spinlock.h"
  __preempt_count_add ( 1 );
# 31 "include/linux/bit_spinlock.h"
  asm volatile ( "" : : : "memory" ) ;
  ldv_20501:;
# 26 "include/linux/bit_spinlock.h"
  if (__builtin_expect ( test_and_set_bit_lock ( ( long int ) bitnum , ( long unsigned int volatile *) addr ) != 0 , 0L ) != 0L)
  {
    goto ldv_20500;
  }
  else
    goto ldv_20502;
  ldv_20502:;
# 34 "include/linux/bit_spinlock.h"
  ( void ) 0;
}
# 40 "include/linux/bit_spinlock.h"
static inline int bit_spin_trylock(int bitnum, long unsigned int *addr)
{
  __preempt_count_add ( 1 );
# 42 "include/linux/bit_spinlock.h"
  asm volatile ( "" : : : "memory" ) ;
# 44 "include/linux/bit_spinlock.h"
  if (__builtin_expect ( test_and_set_bit_lock ( ( long int ) bitnum , ( long unsigned int volatile *) addr ) != 0 , 0L ) != 0L)
  {
# 45 "include/linux/bit_spinlock.h"
    asm volatile ( "" : : : "memory" ) ;
# 45 "include/linux/bit_spinlock.h"
    __preempt_count_sub ( 1 );
    return 0;
  }
# 49 "include/linux/bit_spinlock.h"
  ( void ) 0;
  return 1;
}
# 56 "include/linux/bit_spinlock.h"
static inline void bit_spin_unlock(int bitnum, long unsigned int *addr)
{
# 59 "include/linux/bit_spinlock.h"
  if (__builtin_expect ( variable_test_bit ( ( long int ) bitnum , ( long unsigned int const volatile *) addr ) == 0 , 0L ) != 0L)
  {
# 59 "include/linux/bit_spinlock.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/bit_spinlock.h" ) , "i" ( 59 ) , "i" ( 12UL ) ) ;
    ldv_20511:;
# 59 "include/linux/bit_spinlock.h"
    goto ldv_20511;
  }
# 62 "include/linux/bit_spinlock.h"
  clear_bit_unlock ( ( long int ) bitnum , ( long unsigned int volatile *) addr );
# 64 "include/linux/bit_spinlock.h"
  asm volatile ( "" : : : "memory" ) ;
# 64 "include/linux/bit_spinlock.h"
  __preempt_count_sub ( 1 );
  ( void ) 0;
}
# 73 "include/linux/bit_spinlock.h"
static inline void __bit_spin_unlock(int bitnum, long unsigned int *addr)
{
# 76 "include/linux/bit_spinlock.h"
  if (__builtin_expect ( variable_test_bit ( ( long int ) bitnum , ( long unsigned int const volatile *) addr ) == 0 , 0L ) != 0L)
  {
# 76 "include/linux/bit_spinlock.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/bit_spinlock.h" ) , "i" ( 76 ) , "i" ( 12UL ) ) ;
    ldv_20516:;
# 76 "include/linux/bit_spinlock.h"
    goto ldv_20516;
  }
# 79 "include/linux/bit_spinlock.h"
  __clear_bit_unlock ( ( long int ) bitnum , ( long unsigned int volatile *) addr );
# 81 "include/linux/bit_spinlock.h"
  asm volatile ( "" : : : "memory" ) ;
# 81 "include/linux/bit_spinlock.h"
  __preempt_count_sub ( 1 );
  ( void ) 0;
}
# 88 "include/linux/bit_spinlock.h"
static inline int bit_spin_is_locked(int bitnum, long unsigned int *addr)
{
# 91 "include/linux/bit_spinlock.h"
  return variable_test_bit ( ( long int ) bitnum , ( long unsigned int const volatile *) addr );
}
struct hlist_bl_head
{
# 34 "include/linux/list_bl.h"
  struct hlist_bl_node *first;
};
struct hlist_bl_node
{
  struct hlist_bl_node *next;
# 38 "include/linux/list_bl.h"
  struct hlist_bl_node **pprev;
};
# 43 "include/linux/list_bl.h"
static inline void INIT_HLIST_BL_NODE(struct hlist_bl_node *h)
{
  ( * h ) . next = ( ( struct hlist_bl_node *) 0 );
  ( * h ) . pprev = ( ( struct hlist_bl_node **) 0 );
}
# 51 "include/linux/list_bl.h"
static inline int hlist_bl_unhashed(struct hlist_bl_node const *h)
{
  return ( * h ) . pprev == ( ( struct hlist_bl_node **const ) 0 );
}
# 56 "include/linux/list_bl.h"
static inline struct hlist_bl_node *hlist_bl_first(struct hlist_bl_head *h)
{
  return ( struct hlist_bl_node *) (
# 59 "include/linux/list_bl.h"
  ( long unsigned int ) ( * h ) . first & 18446744073709551614UL );
}
# 62 "include/linux/list_bl.h"
static inline void hlist_bl_set_first(struct hlist_bl_head *h, struct hlist_bl_node *n)
{
# 65 "include/linux/list_bl.h"
  if (__builtin_expect ( ( long int ) ( int ) ( long unsigned int ) n & 1L , 0L ) != 0L)
  {
# 65 "include/linux/list_bl.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/list_bl.h" ) , "i" ( 65 ) , "i" ( 12UL ) ) ;
    ldv_20539:;
# 65 "include/linux/list_bl.h"
    goto ldv_20539;
  }
# 66 "include/linux/list_bl.h"
  if (__builtin_expect ( ( ( long unsigned int ) ( * h ) . first & 1UL ) == 0UL , 0L ) != 0L)
  {
# 66 "include/linux/list_bl.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 67 "include/linux/list_bl.h"
    ( char *) "include/linux/list_bl.h" ) , "i" ( 67 ) , "i" ( 12UL ) ) ;
    ldv_20540:;
# 66 "include/linux/list_bl.h"
    goto ldv_20540;
  }
  ( * h ) . first = ( struct hlist_bl_node *) ( ( long unsigned int ) n | 1UL );
}
# 71 "include/linux/list_bl.h"
static inline int hlist_bl_empty(struct hlist_bl_head const *h)
{
  return ( ( long unsigned int ) ( * h ) . first & 18446744073709551614UL ) == 0UL;
}
# 76 "include/linux/list_bl.h"
static inline void hlist_bl_add_head(struct hlist_bl_node *n, struct hlist_bl_head *h)
{
# 79 "include/linux/list_bl.h"
  struct hlist_bl_node *first = hlist_bl_first ( h );
# 81 "include/linux/list_bl.h"
  ( * n ) . next = first;
  if (first != ( ( struct hlist_bl_node *) 0 ))
    ( * first ) . pprev = & ( * n ) . next;
  ( * n ) . pprev = & ( * h ) . first;
  hlist_bl_set_first ( h , n );
}
# 88 "include/linux/list_bl.h"
static inline void __hlist_bl_del(struct hlist_bl_node *n)
{
  struct hlist_bl_node *next = ( * n ) . next;
  struct hlist_bl_node **pprev = ( * n ) . pprev;
# 93 "include/linux/list_bl.h"
  if (__builtin_expect ( ( long int ) ( int ) ( long unsigned int ) n & 1L , 0L ) != 0L)
  {
# 93 "include/linux/list_bl.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/list_bl.h" ) , "i" ( 93 ) , "i" ( 12UL ) ) ;
    ldv_20554:;
# 93 "include/linux/list_bl.h"
    goto ldv_20554;
  }
# 96 "include/linux/list_bl.h"
  * pprev = ( struct hlist_bl_node *) (
# 98 "include/linux/list_bl.h"
  ( long unsigned int ) * pprev & 1UL
# 97 "include/linux/list_bl.h"
  | ( long unsigned int ) next );
# 99 "include/linux/list_bl.h"
  if (next != ( ( struct hlist_bl_node *) 0 ))
    ( * next ) . pprev = pprev;
}
# 103 "include/linux/list_bl.h"
static inline void hlist_bl_del(struct hlist_bl_node *n)
{
  __hlist_bl_del ( n );
  ( * n ) . next = ( ( struct hlist_bl_node *) -2401263026317557504 );
  ( * n ) . pprev = ( ( struct hlist_bl_node **) -2401263026316508672 );
}
# 110 "include/linux/list_bl.h"
static inline void hlist_bl_del_init(struct hlist_bl_node *n)
{
  if (hlist_bl_unhashed ( ( struct hlist_bl_node const *) n ) == 0)
  {
# 113 "include/linux/list_bl.h"
    __hlist_bl_del ( n );
    INIT_HLIST_BL_NODE ( n );
  }
}
# 118 "include/linux/list_bl.h"
static inline void hlist_bl_lock(struct hlist_bl_head *b)
{
  bit_spin_lock ( 0 , ( long unsigned int *) b );
}
# 123 "include/linux/list_bl.h"
static inline void hlist_bl_unlock(struct hlist_bl_head *b)
{
  __bit_spin_unlock ( 0 , ( long unsigned int *) b );
}
# 128 "include/linux/list_bl.h"
static inline bool hlist_bl_is_locked(struct hlist_bl_head *b)
{
  return bit_spin_is_locked ( 0 , ( long unsigned int *) b ) != 0;
}
# 17 "include/linux/rculist_bl.h"
void __compiletime_assert_17(void);
# 10 "include/linux/rculist_bl.h"
static inline void hlist_bl_set_first_rcu(struct hlist_bl_head *h, struct hlist_bl_node *n)
{
# 13 "include/linux/rculist_bl.h"
  if (__builtin_expect ( ( long int ) ( int ) ( long unsigned int ) n & 1L , 0L ) != 0L)
  {
# 13 "include/linux/rculist_bl.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/rculist_bl.h" ) , "i" ( 13 ) , "i" ( 12UL ) ) ;
    ldv_20574:;
# 13 "include/linux/rculist_bl.h"
    goto ldv_20574;
  }
# 14 "include/linux/rculist_bl.h"
  if (__builtin_expect ( ( ( long unsigned int ) ( * h ) . first & 1UL ) == 0UL , 0L ) != 0L)
  {
# 14 "include/linux/rculist_bl.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" (
# 15 "include/linux/rculist_bl.h"
    ( char *) "include/linux/rculist_bl.h" ) , "i" ( 15 ) , "i" ( 12UL ) ) ;
    ldv_20575:;
# 14 "include/linux/rculist_bl.h"
    goto ldv_20575;
  }
  {
# 16 "include/linux/rculist_bl.h"
    bool __cond = 0;
    void __compiletime_assert_17(void);
# 16 "include/linux/rculist_bl.h"
    if (( int ) __cond)
# 16 "include/linux/rculist_bl.h"
      __compiletime_assert_17 ( );
  }
# 16 "include/linux/rculist_bl.h"
  asm volatile ( "" : : : "memory" ) ;
# 16 "include/linux/rculist_bl.h"
  * ( struct hlist_bl_node *volatile *) & ( * h ) . first = ( struct hlist_bl_node *) ( ( long unsigned int ) n | 1UL );
}
# 20 "include/linux/rculist_bl.h"
static inline struct hlist_bl_node *hlist_bl_first_rcu(struct hlist_bl_head *h)
{
  return ( struct hlist_bl_node *) (
# 23 "include/linux/rculist_bl.h"
  ( long unsigned int ) ({
# 23 "include/linux/rculist_bl.h"
    struct hlist_bl_node *_________p1 = * ( struct hlist_bl_node *volatile *) & ( * h ) . first;
    {
# 23 "include/linux/rculist_bl.h"
      bool __warned;
# 23 "include/linux/rculist_bl.h"
      if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && ( rcu_read_lock_held ( ) == 0 && ( int ) ! ( _Bool ) hlist_bl_is_locked ( h ) ))
      {
# 23 "include/linux/rculist_bl.h"
        __warned = 1;
# 23 "include/linux/rculist_bl.h"
        lockdep_rcu_suspicious ( ( char const *) "include/linux/rculist_bl.h" , 23 , ( char const *) "suspicious rcu_dereference_check() usage" );
      }
    }
    {
    }
# 23 "include/linux/rculist_bl.h"
    _________p1;
  } )
# 23 "include/linux/rculist_bl.h"
  & 18446744073709551614UL );
}
# 46 "include/linux/rculist_bl.h"
static inline void hlist_bl_del_init_rcu(struct hlist_bl_node *n)
{
  if (hlist_bl_unhashed ( ( struct hlist_bl_node const *) n ) == 0)
  {
# 49 "include/linux/rculist_bl.h"
    __hlist_bl_del ( n );
    ( * n ) . pprev = ( ( struct hlist_bl_node **) 0 );
  }
}
# 73 "include/linux/rculist_bl.h"
static inline void hlist_bl_del_rcu(struct hlist_bl_node *n)
{
  __hlist_bl_del ( n );
  ( * n ) . pprev = ( ( struct hlist_bl_node **) -2401263026316508672 );
}
# 98 "include/linux/rculist_bl.h"
static inline void hlist_bl_add_head_rcu(struct hlist_bl_node *n, struct hlist_bl_head *h)
{
# 101 "include/linux/rculist_bl.h"
  struct hlist_bl_node *first;
# 104 "include/linux/rculist_bl.h"
  first = hlist_bl_first ( h );
# 106 "include/linux/rculist_bl.h"
  ( * n ) . next = first;
  if (first != ( ( struct hlist_bl_node *) 0 ))
    ( * first ) . pprev = & ( * n ) . next;
  ( * n ) . pprev = & ( * h ) . first;
# 112 "include/linux/rculist_bl.h"
  hlist_bl_set_first_rcu ( h , n );
}
struct lockref
{
# 33 "include/linux/lockref.h"
  union
  {
# 32 "include/linux/lockref.h"
    struct
    {
# 30 "include/linux/lockref.h"
      spinlock_t lock;
      unsigned int count;
    } ldv_20602;
  } ldv_20603;
};
# 36 "include/linux/lockref.h"
void lockref_get(struct lockref *);
int lockref_get_not_zero(struct lockref *);
int lockref_get_or_lock(struct lockref *);
int lockref_put_or_lock(struct lockref *);
# 41 "include/linux/lockref.h"
void lockref_mark_dead(struct lockref *);
int lockref_get_not_dead(struct lockref *);
# 45 "include/linux/lockref.h"
static inline int __lockref_is_dead(struct lockref const *l)
{
  return ( int ) ( * l ) . ldv_20603 . ldv_20602 . count < 0;
}
struct nameidata;
struct vfsmount;
struct qstr
{
# 51 "include/linux/dcache.h"
  union
  {
# 49 "include/linux/dcache.h"
    struct
    {
# 48 "include/linux/dcache.h"
      u32 hash;
# 48 "include/linux/dcache.h"
      u32 len;
    } ldv_20626;
    u64 hash_len;
  } ldv_20628;
  unsigned char const *name;
};
struct dentry_stat_t
{
# 60 "include/linux/dcache.h"
  long int nr_dentry;
  long int nr_unused;
  long int age_limit;
  long int want_pages;
  long int dummy[2U];
};
extern struct dentry_stat_t dentry_stat;
# 74 "include/linux/dcache.h"
static inline long unsigned int partial_name_hash(long unsigned int c, long unsigned int prevhash)
{
  return ( ( c << 4 ) + prevhash + ( c >> 4 ) ) * 11UL;
}
# 83 "include/linux/dcache.h"
static inline long unsigned int end_name_hash(long unsigned int hash)
{
  return ( long unsigned int ) ( unsigned int ) hash;
}
# 89 "include/linux/dcache.h"
unsigned int full_name_hash(unsigned char const *, unsigned int);
struct dentry
{
# 110 "include/linux/dcache.h"
  unsigned int d_flags;
  seqcount_t d_seq;
  struct hlist_bl_node d_hash;
  struct dentry *d_parent;
  struct qstr d_name;
  struct inode *d_inode;
# 117 "include/linux/dcache.h"
  unsigned char d_iname[32U];
# 120 "include/linux/dcache.h"
  struct lockref d_lockref;
  struct dentry_operations const *d_op;
  struct super_block *d_sb;
  long unsigned int d_time;
  void *d_fsdata;
# 126 "include/linux/dcache.h"
  struct list_head d_lru;
# 133 "include/linux/dcache.h"
  union
  {
# 131 "include/linux/dcache.h"
    struct list_head d_child;
    struct callback_head d_rcu;
  } d_u;
  struct list_head d_subdirs;
  struct hlist_node d_alias;
};
enum dentry_d_lock_class
{
  DENTRY_D_LOCK_NORMAL = 0,
  DENTRY_D_LOCK_NESTED = 1
};
struct dentry_operations
{
# 151 "include/linux/dcache.h"
  int (*d_revalidate)(struct dentry *, unsigned int);
  int (*d_weak_revalidate)(struct dentry *, unsigned int);
  int (*d_hash)(struct dentry const *, struct qstr *);
  int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int, char const *, struct qstr const *);
# 156 "include/linux/dcache.h"
  int (*d_delete)(struct dentry const *);
  void (*d_release)(struct dentry *);
  void (*d_prune)(struct dentry *);
  void (*d_iput)(struct dentry *, struct inode *);
  char *(*d_dname)(struct dentry *, char *, int);
  struct vfsmount *(*d_automount)(struct path *);
  int (*d_manage)(struct dentry *, bool);
};
# 226 "include/linux/dcache.h"
extern seqlock_t rename_lock;
# 228 "include/linux/dcache.h"
static inline int dname_external(struct dentry const *dentry)
{
  return ( unsigned char const *) ( * dentry ) . d_name . name != ( unsigned char const *) & ( * dentry ) . d_iname;
}
# 236 "include/linux/dcache.h"
void d_instantiate(struct dentry *, struct inode *);
struct dentry *d_instantiate_unique(struct dentry *, struct inode *);
struct dentry *d_materialise_unique(struct dentry *, struct inode *);
int d_instantiate_no_diralias(struct dentry *, struct inode *);
void __d_drop(struct dentry *);
void d_drop(struct dentry *);
void d_delete(struct dentry *);
void d_set_d_op(struct dentry *, struct dentry_operations const *);
# 246 "include/linux/dcache.h"
struct dentry *d_alloc(struct dentry *, struct qstr const *);
struct dentry *d_alloc_pseudo(struct super_block *, struct qstr const *);
struct dentry *d_splice_alias(struct inode *, struct dentry *);
struct dentry *d_add_ci(struct dentry *, struct inode *, struct qstr *);
struct dentry *d_find_any_alias(struct inode *);
struct dentry *d_obtain_alias(struct inode *);
struct dentry *d_obtain_root(struct inode *);
void shrink_dcache_sb(struct super_block *);
void shrink_dcache_parent(struct dentry *);
void shrink_dcache_for_umount(struct super_block *);
int d_invalidate(struct dentry *);
# 259 "include/linux/dcache.h"
struct dentry *d_make_root(struct inode *);
# 262 "include/linux/dcache.h"
void d_genocide(struct dentry *);
# 264 "include/linux/dcache.h"
void d_tmpfile(struct dentry *, struct inode *);
# 266 "include/linux/dcache.h"
struct dentry *d_find_alias(struct inode *);
void d_prune_aliases(struct inode *);
# 270 "include/linux/dcache.h"
int have_submounts(struct dentry *);
int check_submounts_and_drop(struct dentry *);
# 276 "include/linux/dcache.h"
void d_rehash(struct dentry *);
# 287 "include/linux/dcache.h"
static inline void d_add(struct dentry *entry, struct inode *inode)
{
  d_instantiate ( entry , inode );
  d_rehash ( entry );
}
# 301 "include/linux/dcache.h"
static inline struct dentry *d_add_unique(struct dentry *entry, struct inode *inode)
{
  struct dentry *res;
# 305 "include/linux/dcache.h"
  res = d_instantiate_unique ( entry , inode );
  d_rehash ( res != ( ( struct dentry *) 0 ) ? res : entry );
  return res;
}
# 310 "include/linux/dcache.h"
void dentry_update_name_case(struct dentry *, struct qstr *);
# 313 "include/linux/dcache.h"
void d_move(struct dentry *, struct dentry *);
void d_exchange(struct dentry *, struct dentry *);
struct dentry *d_ancestor(struct dentry *, struct dentry *);
# 318 "include/linux/dcache.h"
struct dentry *d_lookup(struct dentry const *, struct qstr const *);
struct dentry *d_hash_and_lookup(struct dentry *, struct qstr *);
struct dentry *__d_lookup(struct dentry const *, struct qstr const *);
struct dentry *__d_lookup_rcu(struct dentry const *, struct qstr const *, unsigned int *);
# 324 "include/linux/dcache.h"
static inline unsigned int d_count(struct dentry const *dentry)
{
  return ( unsigned int ) ( * dentry ) . d_lockref . ldv_20603 . ldv_20602 . count;
}
# 330 "include/linux/dcache.h"
int d_validate(struct dentry *, struct dentry *);
# 335 "include/linux/dcache.h"
char *dynamic_dname(struct dentry *, char *, int, char const *, ...);
char *simple_dname(struct dentry *, char *, int);
# 338 "include/linux/dcache.h"
char *__d_path(struct path const *, struct path const *, char *, int);
char *d_absolute_path(struct path const *, char *, int);
char *d_path(struct path const *, char *, int);
char *dentry_path_raw(struct dentry *, char *, int);
char *dentry_path(struct dentry *, char *, int);
# 354 "include/linux/dcache.h"
static inline struct dentry *dget_dlock(struct dentry *dentry)
{
  if (dentry != ( ( struct dentry *) 0 ))
    ( * dentry ) . d_lockref . ldv_20603 . ldv_20602 . count ++;
  return dentry;
}
# 361 "include/linux/dcache.h"
static inline struct dentry *dget(struct dentry *dentry)
{
  if (dentry != ( ( struct dentry *) 0 ))
    lockref_get ( & ( * dentry ) . d_lockref );
  return dentry;
}
# 368 "include/linux/dcache.h"
struct dentry *dget_parent(struct dentry *);
# 377 "include/linux/dcache.h"
static inline int d_unhashed(struct dentry const *dentry)
{
  return hlist_bl_unhashed ( & ( * dentry ) . d_hash );
}
# 382 "include/linux/dcache.h"
static inline int d_unlinked(struct dentry const *dentry)
{
  return d_unhashed ( dentry ) != 0 && ( struct dentry const *) ( * dentry ) . d_parent != dentry;
}
# 387 "include/linux/dcache.h"
static inline int cant_mount(struct dentry const *dentry)
{
  return ( int ) ( * dentry ) . d_flags & 256;
}
# 392 "include/linux/dcache.h"
static inline void dont_mount(struct dentry *dentry)
{
  spin_lock ( & ( * dentry ) . d_lockref . ldv_20603 . ldv_20602 . lock );
  ( * dentry ) . d_flags |= 256U;
  spin_unlock ( & ( * dentry ) . d_lockref . ldv_20603 . ldv_20602 . lock );
}
# 399 "include/linux/dcache.h"
void dput(struct dentry *);
# 401 "include/linux/dcache.h"
static inline bool d_managed(struct dentry const *dentry)
{
  return ( ( unsigned int ) ( * dentry ) . d_flags & 458752U ) != 0U;
}
# 406 "include/linux/dcache.h"
static inline bool d_mountpoint(struct dentry const *dentry)
{
  return ( ( unsigned int ) ( * dentry ) . d_flags & 65536U ) != 0U;
}
# 414 "include/linux/dcache.h"
static inline void __d_set_type(struct dentry *dentry, unsigned int type)
{
  ( * dentry ) . d_flags = ( * dentry ) . d_flags & 4287627263U | type;
}
# 419 "include/linux/dcache.h"
static inline void __d_clear_type(struct dentry *dentry)
{
  __d_set_type ( dentry , 0U );
}
# 424 "include/linux/dcache.h"
static inline void d_set_type(struct dentry *dentry, unsigned int type)
{
  spin_lock ( & ( * dentry ) . d_lockref . ldv_20603 . ldv_20602 . lock );
  __d_set_type ( dentry , type );
  spin_unlock ( & ( * dentry ) . d_lockref . ldv_20603 . ldv_20602 . lock );
}
# 431 "include/linux/dcache.h"
static inline unsigned int __d_entry_type(struct dentry const *dentry)
{
  return ( unsigned int ) ( * dentry ) . d_flags & 7340032U;
}
# 436 "include/linux/dcache.h"
static inline bool d_can_lookup(struct dentry const *dentry)
{
  return __d_entry_type ( dentry ) == 1048576U;
}
# 441 "include/linux/dcache.h"
static inline bool d_is_autodir(struct dentry const *dentry)
{
  return __d_entry_type ( dentry ) == 2097152U;
}
# 446 "include/linux/dcache.h"
static inline bool d_is_dir(struct dentry const *dentry)
{
  return ( bool ) ( ( int ) d_can_lookup ( dentry ) || ( int ) d_is_autodir ( dentry ) );
}
# 451 "include/linux/dcache.h"
static inline bool d_is_symlink(struct dentry const *dentry)
{
  return __d_entry_type ( dentry ) == 3145728U;
}
# 456 "include/linux/dcache.h"
static inline bool d_is_file(struct dentry const *dentry)
{
  return __d_entry_type ( dentry ) == 4194304U;
}
# 461 "include/linux/dcache.h"
static inline bool d_is_negative(struct dentry const *dentry)
{
  return __d_entry_type ( dentry ) == 0U;
}
# 466 "include/linux/dcache.h"
static inline bool d_is_positive(struct dentry const *dentry)
{
  return ( bool ) ! ( ( int ) d_is_negative ( dentry ) != 0 );
}
# 471 "include/linux/dcache.h"
extern int sysctl_vfs_cache_pressure;
# 473 "include/linux/dcache.h"
static inline long unsigned int vfs_pressure_ratio(long unsigned int val)
{
  return ({
# 475 "include/linux/dcache.h"
    long unsigned int quot = val / 100UL;
# 475 "include/linux/dcache.h"
    long unsigned int rem = val % 100UL;
# 475 "include/linux/dcache.h"
    ( long unsigned int ) sysctl_vfs_cache_pressure * quot + ( long unsigned int ) sysctl_vfs_cache_pressure * rem / 100UL;
  } );
}
struct path
{
# 8 "include/linux/path.h"
  struct vfsmount *mnt;
  struct dentry *dentry;
};
# 12 "include/linux/path.h"
void path_get(struct path const *);
void path_put(struct path const *);
# 15 "include/linux/path.h"
static inline int path_equal(struct path const *path1, struct path const *path2)
{
  return ( * path1 ) . mnt == ( * path2 ) . mnt && ( * path1 ) . dentry == ( * path2 ) . dentry;
}
enum lru_status
{
  LRU_REMOVED = 0,
  LRU_REMOVED_RETRY = 1,
  LRU_ROTATE = 2,
  LRU_SKIP = 3,
  LRU_RETRY = 4
};
struct list_lru_node
{
# 25 "include/linux/list_lru.h"
  spinlock_t lock;
  struct list_head list;
# 28 "include/linux/list_lru.h"
  long int nr_items;
};
struct list_lru
{
  struct list_lru_node *node;
  nodemask_t active_nodes;
};
# 36 "include/linux/list_lru.h"
void list_lru_destroy(struct list_lru *);
int list_lru_init_key(struct list_lru *, struct lock_class_key *);
static inline int list_lru_init(struct list_lru *lru)
{
  return list_lru_init_key ( lru , ( ( struct lock_class_key *) 0 ) );
}
# 59 "include/linux/list_lru.h"
bool list_lru_add(struct list_lru *, struct list_head *);
# 72 "include/linux/list_lru.h"
bool list_lru_del(struct list_lru *, struct list_head *);
# 83 "include/linux/list_lru.h"
long unsigned int list_lru_count_node(struct list_lru *, int);
static inline long unsigned int list_lru_count(struct list_lru *lru)
{
  long int count = 0L;
  int nid;
# 89 "include/linux/list_lru.h"
  nid = __first_node ( ( nodemask_t const *) & ( * lru ) . active_nodes );
# 89 "include/linux/list_lru.h"
  goto ldv_20958;
  ldv_20957:;
# 90 "include/linux/list_lru.h"
  count = ( long int ) ( list_lru_count_node ( lru , nid ) + ( long unsigned int ) count );
# 89 "include/linux/list_lru.h"
  nid = __next_node ( nid , ( nodemask_t const *) & ( * lru ) . active_nodes );
  ldv_20958:;
# 89 "include/linux/list_lru.h"
  if (nid <= 1023)
  {
    goto ldv_20957;
  }
  else
    goto ldv_20959;
  ldv_20959:;
# 92 "include/linux/list_lru.h"
  return ( long unsigned int ) count;
}
# 96 "include/linux/list_lru.h"
typedef enum lru_status (*list_lru_walk_cb)(struct list_head *, spinlock_t *, void *);
# 118 "include/linux/list_lru.h"
long unsigned int list_lru_walk_node(struct list_lru *, int, list_lru_walk_cb, void *, long unsigned int *);
# 123 "include/linux/list_lru.h"
static inline long unsigned int list_lru_walk(struct list_lru *lru, list_lru_walk_cb isolate, void *cb_arg, long unsigned int nr_to_walk)
{
# 126 "include/linux/list_lru.h"
  long int isolated = 0L;
  int nid;
# 129 "include/linux/list_lru.h"
  nid = __first_node ( ( nodemask_t const *) & ( * lru ) . active_nodes );
# 129 "include/linux/list_lru.h"
  goto ldv_20980;
  ldv_20979:;
# 130 "include/linux/list_lru.h"
  isolated = ( long int ) ( list_lru_walk_node ( lru , nid , isolate , cb_arg ,
# 131 "include/linux/list_lru.h"
  & nr_to_walk )
# 130 "include/linux/list_lru.h"
  + ( long unsigned int ) isolated );
# 132 "include/linux/list_lru.h"
  if (nr_to_walk == 0UL)
    goto ldv_20978;
# 129 "include/linux/list_lru.h"
  nid = __next_node ( nid , ( nodemask_t const *) & ( * lru ) . active_nodes );
  ldv_20980:;
# 129 "include/linux/list_lru.h"
  if (nid <= 1023)
  {
    goto ldv_20979;
  }
  else
    goto ldv_20978;
  ldv_20978:;
# 135 "include/linux/list_lru.h"
  return ( long unsigned int ) isolated;
}
# 54 "include/linux/radix-tree.h"
static inline int radix_tree_is_indirect_ptr(void *ptr)
{
  return ( int ) ( long int ) ptr & 1;
}
struct radix_tree_node
{
# 88 "include/linux/radix-tree.h"
  unsigned int path;
  unsigned int count;
# 99 "include/linux/radix-tree.h"
  union
  {
# 96 "include/linux/radix-tree.h"
    struct
    {
# 93 "include/linux/radix-tree.h"
      struct radix_tree_node *parent;
# 95 "include/linux/radix-tree.h"
      void *private_data;
    } ldv_20991;
# 98 "include/linux/radix-tree.h"
    struct callback_head callback_head;
  } ldv_20993;
# 101 "include/linux/radix-tree.h"
  struct list_head private_list;
  void *slots[64U];
  long unsigned int tags[3U][1U];
};
struct radix_tree_root
{
# 108 "include/linux/radix-tree.h"
  unsigned int height;
  gfp_t gfp_mask;
  struct radix_tree_node *rnode;
};
# 194 "include/linux/radix-tree.h"
static inline void *radix_tree_deref_slot(void **pslot)
{
  return ({
# 196 "include/linux/radix-tree.h"
    void *_________p1 = * ( void *volatile *) pslot;
    {
# 196 "include/linux/radix-tree.h"
      bool __warned;
# 196 "include/linux/radix-tree.h"
      if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && ( rcu_read_lock_held ( ) == 0 && 1 ))
      {
# 196 "include/linux/radix-tree.h"
        __warned = 1;
# 196 "include/linux/radix-tree.h"
        lockdep_rcu_suspicious ( ( char const *) "include/linux/radix-tree.h" , 196 , ( char const *) "suspicious rcu_dereference_check() usage" );
      }
    }
    {
    }
# 196 "include/linux/radix-tree.h"
    _________p1;
  } );
}
# 209 "include/linux/radix-tree.h"
static inline void *radix_tree_deref_slot_protected(void **pslot, spinlock_t *treelock)
{
# 212 "include/linux/radix-tree.h"
  return ({
    {
# 212 "include/linux/radix-tree.h"
      bool __warned;
# 212 "include/linux/radix-tree.h"
      if (debug_lockdep_rcu_enabled ( ) != 0 && ( int ) ! ( _Bool ) __warned && lock_is_held ( & ( * treelock ) . ldv_6073 . ldv_6072 . dep_map ) == 0)
      {
# 212 "include/linux/radix-tree.h"
        __warned = 1;
# 212 "include/linux/radix-tree.h"
        lockdep_rcu_suspicious ( ( char const *) "include/linux/radix-tree.h" , 212 , ( char const *) "suspicious rcu_dereference_protected() usage" );
      }
    }
# 212 "include/linux/radix-tree.h"
    * pslot;
  } );
}
# 222 "include/linux/radix-tree.h"
static inline int radix_tree_deref_retry(void *arg)
{
  return ( int ) __builtin_expect ( ( long int ) ( int ) ( long unsigned int ) arg & 1L , 0L );
}
# 232 "include/linux/radix-tree.h"
static inline int radix_tree_exceptional_entry(void *arg)
{
# 235 "include/linux/radix-tree.h"
  return ( int ) ( long int ) arg & 2;
}
# 243 "include/linux/radix-tree.h"
static inline int radix_tree_exception(void *arg)
{
  return ( int ) __builtin_expect ( ( ( long unsigned int ) arg & 3UL ) != 0UL , 0L );
}
# 260 "include/linux/radix-tree.h"
void __compiletime_assert_260(void);
# 257 "include/linux/radix-tree.h"
static inline void radix_tree_replace_slot(void **pslot, void *item)
{
  if (__builtin_expect ( radix_tree_is_indirect_ptr ( item ) != 0 , 0L ) != 0L)
  {
# 259 "include/linux/radix-tree.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/radix-tree.h" ) , "i" ( 259 ) , "i" ( 12UL ) ) ;
    ldv_21026:;
# 259 "include/linux/radix-tree.h"
    goto ldv_21026;
  }
  {
# 260 "include/linux/radix-tree.h"
    bool __cond = 0;
# 260 "include/linux/radix-tree.h"
    void __compiletime_assert_260(void);
# 260 "include/linux/radix-tree.h"
    if (( int ) __cond)
# 260 "include/linux/radix-tree.h"
      __compiletime_assert_260 ( );
  }
# 260 "include/linux/radix-tree.h"
  asm volatile ( "" : : : "memory" ) ;
# 260 "include/linux/radix-tree.h"
  * ( void *volatile *) pslot = item;
}
# 263 "include/linux/radix-tree.h"
int __radix_tree_create(struct radix_tree_root *, long unsigned int, struct radix_tree_node **, void ***);
# 265 "include/linux/radix-tree.h"
int radix_tree_insert(struct radix_tree_root *, long unsigned int, void *);
void *__radix_tree_lookup(struct radix_tree_root *, long unsigned int, struct radix_tree_node **, void ***);
# 268 "include/linux/radix-tree.h"
void *radix_tree_lookup(struct radix_tree_root *, long unsigned int);
void **radix_tree_lookup_slot(struct radix_tree_root *, long unsigned int);
bool __radix_tree_delete_node(struct radix_tree_root *, struct radix_tree_node *);
# 272 "include/linux/radix-tree.h"
void *radix_tree_delete_item(struct radix_tree_root *, long unsigned int, void *);
void *radix_tree_delete(struct radix_tree_root *, long unsigned int);
# 275 "include/linux/radix-tree.h"
unsigned int radix_tree_gang_lookup(struct radix_tree_root *, void **, long unsigned int, unsigned int);
# 277 "include/linux/radix-tree.h"
unsigned int radix_tree_gang_lookup_slot(struct radix_tree_root *, void ***, long unsigned int *, long unsigned int, unsigned int);
# 280 "include/linux/radix-tree.h"
int radix_tree_preload(gfp_t);
int radix_tree_maybe_preload(gfp_t);
void radix_tree_init(void);
void *radix_tree_tag_set(struct radix_tree_root *, long unsigned int, unsigned int);
# 285 "include/linux/radix-tree.h"
void *radix_tree_tag_clear(struct radix_tree_root *, long unsigned int, unsigned int);
# 287 "include/linux/radix-tree.h"
int radix_tree_tag_get(struct radix_tree_root *, long unsigned int, unsigned int);
# 290 "include/linux/radix-tree.h"
unsigned int radix_tree_gang_lookup_tag(struct radix_tree_root *, void **, long unsigned int, unsigned int, unsigned int);
# 294 "include/linux/radix-tree.h"
unsigned int radix_tree_gang_lookup_tag_slot(struct radix_tree_root *, void ***, long unsigned int, unsigned int, unsigned int);
# 297 "include/linux/radix-tree.h"
long unsigned int radix_tree_range_tag_if_tagged(struct radix_tree_root *, long unsigned int *, long unsigned int, long unsigned int, unsigned int, unsigned int);
# 301 "include/linux/radix-tree.h"
int radix_tree_tagged(struct radix_tree_root *, unsigned int);
long unsigned int radix_tree_locate_item(struct radix_tree_root *, void *);
# 304 "include/linux/radix-tree.h"
static inline void radix_tree_preload_end(void)
{
  asm volatile ( "" : : : "memory" ) ;
# 306 "include/linux/radix-tree.h"
  __preempt_count_sub ( 1 );
}
struct radix_tree_iter
{
# 324 "include/linux/radix-tree.h"
  long unsigned int index;
  long unsigned int next_index;
  long unsigned int tags;
};
# 341 "include/linux/radix-tree.h"
static inline void **radix_tree_iter_init(struct radix_tree_iter *iter, long unsigned int start)
{
# 351 "include/linux/radix-tree.h"
  ( * iter ) . index = 0UL;
  ( * iter ) . next_index = start;
  return ( ( void **) 0 );
}
# 369 "include/linux/radix-tree.h"
void **radix_tree_next_chunk(struct radix_tree_root *, struct radix_tree_iter *, unsigned int);
# 379 "include/linux/radix-tree.h"
static inline unsigned int radix_tree_chunk_size(struct radix_tree_iter *iter)
{
  return ( unsigned int ) ( * iter ) . next_index - ( unsigned int ) ( * iter ) . index;
}
# 396 "include/linux/radix-tree.h"
static inline void **radix_tree_next_slot(void **slot, struct radix_tree_iter *iter, unsigned int flags)
{
  if (( flags & 256U ) != 0U)
  {
# 399 "include/linux/radix-tree.h"
    ( * iter ) . tags >>= 1;
    if (__builtin_expect ( ( long int ) ( int ) ( * iter ) . tags & 1L , 1L ) != 0L)
    {
# 401 "include/linux/radix-tree.h"
      ( * iter ) . index ++;
      return slot + 1UL;
    }
    if (( flags & 512U ) == 0U && __builtin_expect ( ( * iter ) . tags != 0UL , 1L ) != 0L)
    {
# 405 "include/linux/radix-tree.h"
      unsigned int offset = ( unsigned int ) __ffs ( ( * iter ) . tags );
# 407 "include/linux/radix-tree.h"
      ( * iter ) . tags >>= ( int ) offset;
      ( * iter ) . index += ( long unsigned int ) ( offset + 1U );
      return slot + ( ( long unsigned int ) offset + 1U );
    }
  }
  else
  {
# 412 "include/linux/radix-tree.h"
    unsigned int size = radix_tree_chunk_size ( iter ) - 1U;
# 414 "include/linux/radix-tree.h"
    goto ldv_21142;
    ldv_21141:;
# 415 "include/linux/radix-tree.h"
    slot ++;
    ( * iter ) . index ++;
    if (__builtin_expect ( * slot != ( ( void *) 0 ) , 1L ) != 0L)
      return slot;
    if (( flags & 512U ) != 0U)
    {
      ( * iter ) . next_index = 0UL;
      goto ldv_21140;
    }
    ldv_21142:;
# 414 "include/linux/radix-tree.h"
    if (size -- != 0U)
    {
      goto ldv_21141;
    }
    else
      goto ldv_21140;
    ldv_21140:;
  }
# 426 "include/linux/radix-tree.h"
  return ( ( void **) 0 );
}
struct semaphore
{
# 17 "include/linux/semaphore.h"
  raw_spinlock_t lock;
  unsigned int count;
  struct list_head wait_list;
};
# 32 "include/linux/semaphore.h"
static inline void sema_init(struct semaphore *sem, int val)
{
  struct lock_class_key __key;
  * sem = ( struct semaphore ) { . lock = ( raw_spinlock_t ) { . raw_lock = { . ldv_1452 = { . head_tail = 0U } } , . magic = 3735899821U , . owner_cpu = 4294967295U , . owner = ( ( void *) -1 ) , . dep_map = { . name = ( char const *) "(*sem).lock" } } , . count = ( unsigned int ) val , . wait_list = { . next = & ( * sem ) . wait_list , . prev = & ( * sem ) . wait_list } };
  lockdep_init_map ( & ( * sem ) . lock . dep_map , ( char const *) "semaphore->lock" , & __key , 0 );
}
# 39 "include/linux/semaphore.h"
void down(struct semaphore *);
int down_interruptible(struct semaphore *);
int down_killable(struct semaphore *);
int down_trylock(struct semaphore *);
int down_timeout(struct semaphore *, long int);
void up(struct semaphore *);
struct fiemap_extent
{
# 17 "./include/uapi/linux/fiemap.h"
  __u64 fe_logical;
# 19 "./include/uapi/linux/fiemap.h"
  __u64 fe_physical;
# 21 "./include/uapi/linux/fiemap.h"
  __u64 fe_length;
  __u64 fe_reserved64[2U];
  __u32 fe_flags;
  __u32 fe_reserved[3U];
};
struct fiemap
{
  __u64 fm_start;
# 30 "./include/uapi/linux/fiemap.h"
  __u64 fm_length;
# 32 "./include/uapi/linux/fiemap.h"
  __u32 fm_flags;
  __u32 fm_mapped_extents;
  __u32 fm_extent_count;
  __u32 fm_reserved;
  struct fiemap_extent fm_extents[0U];
};
struct shrink_control
{
# 12 "include/linux/shrinker.h"
  gfp_t gfp_mask;
# 19 "include/linux/shrinker.h"
  long unsigned int nr_to_scan;
# 22 "include/linux/shrinker.h"
  nodemask_t nodes_to_scan;
# 24 "include/linux/shrinker.h"
  int nid;
};
struct shrinker
{
# 49 "include/linux/shrinker.h"
  long unsigned int (*count_objects)(struct shrinker *, struct shrink_control *);
# 51 "include/linux/shrinker.h"
  long unsigned int (*scan_objects)(struct shrinker *, struct shrink_control *);
# 54 "include/linux/shrinker.h"
  int seeks;
  long int batch;
  long unsigned int flags;
# 59 "include/linux/shrinker.h"
  struct list_head list;
# 61 "include/linux/shrinker.h"
  atomic_long_t *nr_deferred;
};
# 68 "include/linux/shrinker.h"
int register_shrinker(struct shrinker *);
void unregister_shrinker(struct shrinker *);
enum migrate_mode
{
  MIGRATE_ASYNC = 0,
  MIGRATE_SYNC_LIGHT = 1,
  MIGRATE_SYNC = 2
};
struct percpu_rw_semaphore
{
# 11 "include/linux/percpu-rwsem.h"
  unsigned int *fast_read_ctr;
  atomic_t write_ctr;
  struct rw_semaphore rw_sem;
  atomic_t slow_read_ctr;
  wait_queue_head_t write_waitq;
};
# 18 "include/linux/percpu-rwsem.h"
void percpu_down_read(struct percpu_rw_semaphore *);
void percpu_up_read(struct percpu_rw_semaphore *);
# 21 "include/linux/percpu-rwsem.h"
void percpu_down_write(struct percpu_rw_semaphore *);
void percpu_up_write(struct percpu_rw_semaphore *);
# 24 "include/linux/percpu-rwsem.h"
int __percpu_init_rwsem(struct percpu_rw_semaphore *, char const *, struct lock_class_key *);
# 26 "include/linux/percpu-rwsem.h"
void percpu_free_rwsem(struct percpu_rw_semaphore *);
struct bio_set;
struct bio;
struct bio_integrity_payload;
struct block_device;
struct cgroup_subsys_state;
# 17 "include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio *, int);
typedef void bio_destructor_t(struct bio *);
struct bio_vec
{
# 24 "include/linux/blk_types.h"
  struct page *bv_page;
  unsigned int bv_len;
  unsigned int bv_offset;
};
struct bvec_iter
{
# 32 "include/linux/blk_types.h"
  sector_t bi_sector;
# 34 "include/linux/blk_types.h"
  unsigned int bi_size;
# 36 "include/linux/blk_types.h"
  unsigned int bi_idx;
# 38 "include/linux/blk_types.h"
  unsigned int bi_bvec_done;
};
struct bio
{
# 47 "include/linux/blk_types.h"
  struct bio *bi_next;
  struct block_device *bi_bdev;
  long unsigned int bi_flags;
  long unsigned int bi_rw;
# 54 "include/linux/blk_types.h"
  struct bvec_iter bi_iter;
# 59 "include/linux/blk_types.h"
  unsigned int bi_phys_segments;
# 65 "include/linux/blk_types.h"
  unsigned int bi_seg_front_size;
  unsigned int bi_seg_back_size;
# 68 "include/linux/blk_types.h"
  atomic_t bi_remaining;
# 70 "include/linux/blk_types.h"
  bio_end_io_t *bi_end_io;
# 72 "include/linux/blk_types.h"
  void *bi_private;
# 78 "include/linux/blk_types.h"
  struct io_context *bi_ioc;
  struct cgroup_subsys_state *bi_css;
# 82 "include/linux/blk_types.h"
  struct bio_integrity_payload *bi_integrity;
# 85 "include/linux/blk_types.h"
  short unsigned int bi_vcnt;
# 91 "include/linux/blk_types.h"
  short unsigned int bi_max_vecs;
# 93 "include/linux/blk_types.h"
  atomic_t bi_cnt;
# 95 "include/linux/blk_types.h"
  struct bio_vec *bi_io_vec;
# 97 "include/linux/blk_types.h"
  struct bio_set *bi_pool;
# 104 "include/linux/blk_types.h"
  struct bio_vec bi_inline_vecs[0U];
};
enum rq_flag_bits
{
  __REQ_WRITE = 0,
  __REQ_FAILFAST_DEV = 1,
  __REQ_FAILFAST_TRANSPORT = 2,
  __REQ_FAILFAST_DRIVER = 3,
  __REQ_SYNC = 4,
  __REQ_META = 5,
  __REQ_PRIO = 6,
  __REQ_DISCARD = 7,
  __REQ_SECURE = 8,
  __REQ_WRITE_SAME = 9,
  __REQ_NOIDLE = 10,
  __REQ_FUA = 11,
  __REQ_FLUSH = 12,
  __REQ_RAHEAD = 13,
  __REQ_THROTTLED = 14,
  __REQ_SORTED = 15,
  __REQ_SOFTBARRIER = 16,
  __REQ_NOMERGE = 17,
  __REQ_STARTED = 18,
  __REQ_DONTPREP = 19,
  __REQ_QUEUED = 20,
  __REQ_ELVPRIV = 21,
  __REQ_FAILED = 22,
  __REQ_QUIET = 23,
  __REQ_PREEMPT = 24,
  __REQ_ALLOCED = 25,
  __REQ_COPY_USER = 26,
  __REQ_FLUSH_SEQ = 27,
  __REQ_IO_STAT = 28,
  __REQ_MIXED_MERGE = 29,
  __REQ_KERNEL = 30,
  __REQ_PM = 31,
  __REQ_END = 32,
  __REQ_HASHED = 33,
  __REQ_MQ_INFLIGHT = 34,
  __REQ_NR_BITS = 35
};
struct fstrim_range
{
# 42 "include/uapi/linux/fs.h"
  __u64 start;
  __u64 len;
  __u64 minlen;
};
struct files_stat_struct
{
# 49 "include/uapi/linux/fs.h"
  long unsigned int nr_files;
  long unsigned int nr_free_files;
  long unsigned int max_files;
};
struct inodes_stat_t
{
  long int nr_inodes;
  long int nr_unused;
  long int dummy[5U];
};
struct export_operations;
struct hd_geometry;
struct iovec;
struct kiocb;
struct poll_table_struct;
struct kstatfs;
struct swap_info_struct;
struct iov_iter;
# 53 "include/linux/fs.h"
void inode_init(void);
void inode_init_early(void);
void files_init(long unsigned int);
# 57 "include/linux/fs.h"
extern struct files_stat_struct files_stat;
long unsigned int get_max_files(void);
extern int sysctl_nr_open;
extern struct inodes_stat_t inodes_stat;
extern int leases_enable;
# 61 "include/linux/fs.h"
extern int lease_break_time;
extern int sysctl_protected_symlinks;
extern int sysctl_protected_hardlinks;
struct buffer_head;
# 66 "include/linux/fs.h"
typedef int get_block_t(struct inode *, sector_t, struct buffer_head *, int);
# 68 "include/linux/fs.h"
typedef void dio_iodone_t(struct kiocb *, loff_t, ssize_t, void *);
struct iattr
{
# 237 "include/linux/fs.h"
  unsigned int ia_valid;
  umode_t ia_mode;
  kuid_t ia_uid;
  kgid_t ia_gid;
  loff_t ia_size;
  struct timespec ia_atime;
  struct timespec ia_mtime;
  struct timespec ia_ctime;
# 251 "include/linux/fs.h"
  struct file *ia_file;
};
struct fs_disk_quota
{
# 52 "./include/uapi/linux/dqblk_xfs.h"
  __s8 d_version;
  __s8 d_flags;
  __u16 d_fieldmask;
  __u32 d_id;
  __u64 d_blk_hardlimit;
  __u64 d_blk_softlimit;
  __u64 d_ino_hardlimit;
  __u64 d_ino_softlimit;
  __u64 d_bcount;
  __u64 d_icount;
  __s32 d_itimer;
# 64 "./include/uapi/linux/dqblk_xfs.h"
  __s32 d_btimer;
  __u16 d_iwarns;
  __u16 d_bwarns;
  __s32 d_padding2;
  __u64 d_rtb_hardlimit;
  __u64 d_rtb_softlimit;
  __u64 d_rtbcount;
  __s32 d_rtbtimer;
  __u16 d_rtbwarns;
  __s16 d_padding3;
  char d_padding4[8U];
};
# 75 "./include/uapi/linux/dqblk_xfs.h"
typedef struct fs_disk_quota fs_disk_quota_t;
struct fs_qfilestat
{
# 148 "./include/uapi/linux/dqblk_xfs.h"
  __u64 qfs_ino;
  __u64 qfs_nblks;
  __u32 qfs_nextents;
};
# 151 "./include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
struct fs_quota_stat
{
  __s8 qs_version;
  __u16 qs_flags;
  __s8 qs_pad;
  fs_qfilestat_t qs_uquota;
  fs_qfilestat_t qs_gquota;
  __u32 qs_incoredqs;
  __s32 qs_btimelimit;
  __s32 qs_itimelimit;
  __s32 qs_rtbtimelimit;
  __u16 qs_bwarnlimit;
  __u16 qs_iwarnlimit;
};
# 165 "./include/uapi/linux/dqblk_xfs.h"
typedef struct fs_quota_stat fs_quota_stat_t;
struct fs_qfilestatv
{
# 191 "./include/uapi/linux/dqblk_xfs.h"
  __u64 qfs_ino;
  __u64 qfs_nblks;
  __u32 qfs_nextents;
  __u32 qfs_pad;
};
struct fs_quota_statv
{
  __s8 qs_version;
  __u8 qs_pad1;
  __u16 qs_flags;
  __u32 qs_incoredqs;
  struct fs_qfilestatv qs_uquota;
  struct fs_qfilestatv qs_gquota;
  struct fs_qfilestatv qs_pquota;
  __s32 qs_btimelimit;
  __s32 qs_itimelimit;
  __s32 qs_rtbtimelimit;
  __u16 qs_bwarnlimit;
  __u16 qs_iwarnlimit;
  __u64 qs_pad2[8U];
};
struct dquot;
struct qtree_fmt_operations
{
# 21 "include/linux/dqblk_qtree.h"
  void (*mem2disk_dqblk)(void *, struct dquot *);
  void (*disk2mem_dqblk)(struct dquot *, void *);
  int (*is_id)(void *, struct dquot *);
};
struct qtree_mem_dqinfo
{
# 28 "include/linux/dqblk_qtree.h"
  struct super_block *dqi_sb;
  int dqi_type;
  unsigned int dqi_blocks;
  unsigned int dqi_free_blk;
  unsigned int dqi_free_entry;
  unsigned int dqi_blocksize_bits;
  unsigned int dqi_entry_size;
  unsigned int dqi_usable_bs;
  unsigned int dqi_qtree_depth;
  struct qtree_fmt_operations *dqi_ops;
};
# 40 "include/linux/dqblk_qtree.h"
int qtree_write_dquot(struct qtree_mem_dqinfo *, struct dquot *);
int qtree_read_dquot(struct qtree_mem_dqinfo *, struct dquot *);
int qtree_delete_dquot(struct qtree_mem_dqinfo *, struct dquot *);
int qtree_release_dquot(struct qtree_mem_dqinfo *, struct dquot *);
int qtree_entry_unused(struct qtree_mem_dqinfo *, char *);
static inline int qtree_depth(struct qtree_mem_dqinfo *info)
{
  unsigned int epb = ( * info ) . dqi_usable_bs >> 2;
  long long unsigned int entries = ( long long unsigned int ) epb;
  int i;
# 51 "include/linux/dqblk_qtree.h"
  i = 1;
# 51 "include/linux/dqblk_qtree.h"
  goto ldv_21462;
  ldv_21461:;
# 52 "include/linux/dqblk_qtree.h"
  entries = ( long long unsigned int ) epb * entries;
# 51 "include/linux/dqblk_qtree.h"
  i ++;
  ldv_21462:;
# 51 "include/linux/dqblk_qtree.h"
  if (entries <= 4294967295ULL)
  {
    goto ldv_21461;
  }
  else
    goto ldv_21463;
  ldv_21463:;
# 53 "include/linux/dqblk_qtree.h"
  return i;
}
# 17 "include/linux/projid.h"
extern struct user_namespace init_user_ns;
# 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
# 23 "include/linux/projid.h"
typedef struct
{
# 22 "include/linux/projid.h"
  projid_t val;
} kprojid_t;
# 25 "include/linux/projid.h"
static inline projid_t __kprojid_val(kprojid_t projid)
{
  return projid . val;
}
# 35 "include/linux/projid.h"
static inline bool projid_eq(kprojid_t left, kprojid_t right)
{
  return __kprojid_val ( left ) == __kprojid_val ( right );
}
# 40 "include/linux/projid.h"
static inline bool projid_lt(kprojid_t left, kprojid_t right)
{
  return __kprojid_val ( left ) < __kprojid_val ( right );
}
# 45 "include/linux/projid.h"
static inline bool projid_valid(kprojid_t projid)
{
  return ( bool ) ! ( ( int ) projid_eq ( projid , ( kprojid_t ) { . val = 4294967295U } ) != 0 );
}
# 52 "include/linux/projid.h"
kprojid_t make_kprojid(struct user_namespace *, projid_t);
# 54 "include/linux/projid.h"
projid_t from_kprojid(struct user_namespace *, kprojid_t);
projid_t from_kprojid_munged(struct user_namespace *, kprojid_t);
# 57 "include/linux/projid.h"
static inline bool kprojid_has_mapping(struct user_namespace *ns, kprojid_t projid)
{
  return from_kprojid ( ns , projid ) != 4294967295U;
}
enum ldv_17437
{
  QIF_BLIMITS_B = 0,
  QIF_SPACE_B = 1,
  QIF_ILIMITS_B = 2,
  QIF_INODES_B = 3,
  QIF_BTIME_B = 4,
  QIF_ITIME_B = 5
};
struct if_dqblk
{
# 109 "include/uapi/linux/quota.h"
  __u64 dqb_bhardlimit;
  __u64 dqb_bsoftlimit;
  __u64 dqb_curspace;
  __u64 dqb_ihardlimit;
  __u64 dqb_isoftlimit;
  __u64 dqb_curinodes;
  __u64 dqb_btime;
  __u64 dqb_itime;
  __u32 dqb_valid;
};
struct if_dqinfo
{
# 130 "include/uapi/linux/quota.h"
  __u64 dqi_bgrace;
  __u64 dqi_igrace;
  __u32 dqi_flags;
  __u32 dqi_valid;
};
enum ldv_17440
{
  QUOTA_NL_C_UNSPEC = 0,
  QUOTA_NL_C_WARNING = 1,
  __QUOTA_NL_C_MAX = 2
};
enum ldv_17441
{
  QUOTA_NL_A_UNSPEC = 0,
  QUOTA_NL_A_QTYPE = 1,
  QUOTA_NL_A_EXCESS_ID = 2,
  QUOTA_NL_A_WARNING = 3,
  QUOTA_NL_A_DEV_MAJOR = 4,
  QUOTA_NL_A_DEV_MINOR = 5,
  QUOTA_NL_A_CAUSED_ID = 6,
  __QUOTA_NL_A_MAX = 7
};
enum quota_type
{
  USRQUOTA = 0,
  GRPQUOTA = 1,
  PRJQUOTA = 2
};
# 59 "include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
typedef long long int qsize_t;
struct kqid
{
# 67 "include/linux/quota.h"
  union
  {
# 64 "include/linux/quota.h"
    kuid_t uid;
    kgid_t gid;
    kprojid_t projid;
  } ldv_21543;
  enum quota_type type;
};
# 71 "include/linux/quota.h"
bool qid_eq(struct kqid, struct kqid);
bool qid_lt(struct kqid, struct kqid);
qid_t from_kqid(struct user_namespace *, struct kqid);
qid_t from_kqid_munged(struct user_namespace *, struct kqid);
bool qid_valid(struct kqid);
# 91 "include/linux/quota.h"
static inline struct kqid make_kqid(struct user_namespace *from, enum quota_type type, qid_t qid)
{
# 94 "include/linux/quota.h"
  struct kqid kqid;
# 96 "include/linux/quota.h"
  kqid . type = type;
  switch (( unsigned int ) type)
  {
# 98 "include/linux/quota.h"
    case 0:;
    kqid . ldv_21543 . uid = make_kuid ( from , qid );
    goto ldv_21566;
    case 1:;
    kqid . ldv_21543 . gid = make_kgid ( from , qid );
    goto ldv_21566;
    case 2:;
    kqid . ldv_21543 . projid = make_kprojid ( from , qid );
    goto ldv_21566;
    default:;
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/quota.h" ) , "i" ( 108 ) , "i" ( 12UL ) ) ;
    ldv_21570:;
# 108 "include/linux/quota.h"
    goto ldv_21570;
  }
  ldv_21566:;
# 110 "include/linux/quota.h"
  return kqid;
}
# 119 "include/linux/quota.h"
static inline struct kqid make_kqid_invalid(enum quota_type type)
{
  struct kqid kqid;
# 123 "include/linux/quota.h"
  kqid . type = type;
  switch (( unsigned int ) type)
  {
# 125 "include/linux/quota.h"
    case 0:;
    kqid . ldv_21543 . uid = ( kuid_t ) { . val = 4294967295U };
    goto ldv_21577;
    case 1:;
    kqid . ldv_21543 . gid = ( kgid_t ) { . val = 4294967295U };
    goto ldv_21577;
    case 2:;
    kqid . ldv_21543 . projid = ( kprojid_t ) { . val = 4294967295U };
    goto ldv_21577;
    default:;
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/quota.h" ) , "i" ( 135 ) , "i" ( 12UL ) ) ;
    ldv_21583:;
# 135 "include/linux/quota.h"
    goto ldv_21583;
  }
  ldv_21577:;
# 137 "include/linux/quota.h"
  return kqid;
}
# 144 "include/linux/quota.h"
static inline struct kqid make_kqid_uid(kuid_t uid)
{
  struct kqid kqid;
  kqid . type = USRQUOTA;
  kqid . ldv_21543 . uid = uid;
  return kqid;
}
# 156 "include/linux/quota.h"
static inline struct kqid make_kqid_gid(kgid_t gid)
{
  struct kqid kqid;
  kqid . type = GRPQUOTA;
  kqid . ldv_21543 . gid = gid;
  return kqid;
}
# 168 "include/linux/quota.h"
static inline struct kqid make_kqid_projid(kprojid_t projid)
{
  struct kqid kqid;
  kqid . type = PRJQUOTA;
  kqid . ldv_21543 . projid = projid;
  return kqid;
}
# 177 "include/linux/quota.h"
extern spinlock_t dq_data_lock;
struct mem_dqblk
{
# 190 "include/linux/quota.h"
  qsize_t dqb_bhardlimit;
  qsize_t dqb_bsoftlimit;
  qsize_t dqb_curspace;
  qsize_t dqb_rsvspace;
  qsize_t dqb_ihardlimit;
  qsize_t dqb_isoftlimit;
  qsize_t dqb_curinodes;
  time_t dqb_btime;
  time_t dqb_itime;
};
struct quota_format_type;
struct mem_dqinfo
{
# 207 "include/linux/quota.h"
  struct quota_format_type *dqi_format;
  int dqi_fmt_id;
# 210 "include/linux/quota.h"
  struct list_head dqi_dirty_list;
  long unsigned int dqi_flags;
  unsigned int dqi_bgrace;
  unsigned int dqi_igrace;
  qsize_t dqi_maxblimit;
  qsize_t dqi_maxilimit;
  void *dqi_priv;
};
# 229 "include/linux/quota.h"
void mark_info_dirty(struct super_block *, int);
static inline int info_dirty(struct mem_dqinfo *info)
{
  return constant_test_bit ( 31L , ( long unsigned int const volatile *) & ( * info ) . dqi_flags );
}
enum ldv_17499
{
  DQST_LOOKUPS = 0,
  DQST_DROPS = 1,
  DQST_READS = 2,
  DQST_WRITES = 3,
  DQST_CACHE_HITS = 4,
  DQST_ALLOC_DQUOTS = 5,
  DQST_FREE_DQUOTS = 6,
  DQST_SYNCS = 7,
  _DQST_DQSTAT_LAST = 8
};
struct dqstats
{
  int stat[8U];
  struct percpu_counter counter[8U];
};
# 252 "include/linux/quota.h"
extern struct dqstats *dqstats_pcpu;
extern struct dqstats dqstats;
# 255 "include/linux/quota.h"
static inline void dqstats_inc(unsigned int type)
{
  percpu_counter_inc ( ( struct percpu_counter *) & dqstats . counter + ( long unsigned int ) type );
}
# 260 "include/linux/quota.h"
static inline void dqstats_dec(unsigned int type)
{
  percpu_counter_dec ( ( struct percpu_counter *) & dqstats . counter + ( long unsigned int ) type );
}
struct dquot
{
# 278 "include/linux/quota.h"
  struct hlist_node dq_hash;
  struct list_head dq_inuse;
  struct list_head dq_free;
  struct list_head dq_dirty;
  struct mutex dq_lock;
  atomic_t dq_count;
  wait_queue_head_t dq_wait_unused;
  struct super_block *dq_sb;
  struct kqid dq_id;
  loff_t dq_off;
  long unsigned int dq_flags;
  struct mem_dqblk dq_dqb;
};
struct quota_format_ops
{
# 294 "include/linux/quota.h"
  int (*check_quota_file)(struct super_block *, int);
  int (*read_file_info)(struct super_block *, int);
  int (*write_file_info)(struct super_block *, int);
  int (*free_file_info)(struct super_block *, int);
  int (*read_dqblk)(struct dquot *);
  int (*commit_dqblk)(struct dquot *);
  int (*release_dqblk)(struct dquot *);
};
struct dquot_operations
{
# 305 "include/linux/quota.h"
  int (*write_dquot)(struct dquot *);
  struct dquot *(*alloc_dquot)(struct super_block *, int);
  void (*destroy_dquot)(struct dquot *);
  int (*acquire_dquot)(struct dquot *);
  int (*release_dquot)(struct dquot *);
  int (*mark_dirty)(struct dquot *);
  int (*write_info)(struct super_block *, int);
# 314 "include/linux/quota.h"
  qsize_t *(*get_reserved_space)(struct inode *);
};
struct quotactl_ops
{
# 321 "include/linux/quota.h"
  int (*quota_on)(struct super_block *, int, int, struct path *);
  int (*quota_on_meta)(struct super_block *, int, int);
  int (*quota_off)(struct super_block *, int);
  int (*quota_sync)(struct super_block *, int);
  int (*get_info)(struct super_block *, int, struct if_dqinfo *);
  int (*set_info)(struct super_block *, int, struct if_dqinfo *);
  int (*get_dqblk)(struct super_block *, struct kqid, struct fs_disk_quota *);
  int (*set_dqblk)(struct super_block *, struct kqid, struct fs_disk_quota *);
  int (*get_xstate)(struct super_block *, struct fs_quota_stat *);
  int (*set_xstate)(struct super_block *, unsigned int, int);
  int (*get_xstatev)(struct super_block *, struct fs_quota_statv *);
  int (*rm_xquota)(struct super_block *, unsigned int);
};
struct quota_format_type
{
  int qf_fmt_id;
  struct quota_format_ops const *qf_ops;
  struct module *qf_owner;
  struct quota_format_type *qf_next;
};
enum ldv_17562
{
  _DQUOT_USAGE_ENABLED = 0,
  _DQUOT_LIMITS_ENABLED = 1,
  _DQUOT_SUSPENDED = 2,
  _DQUOT_STATE_FLAGS = 3
};
# 368 "include/linux/quota.h"
static inline unsigned int dquot_state_flag(unsigned int flags, int type)
{
  return flags << type * 3;
}
# 373 "include/linux/quota.h"
static inline unsigned int dquot_generic_flag(unsigned int flags, int type)
{
  return flags >> type * 3 & 7U;
}
# 379 "include/linux/quota.h"
void quota_send_warning(struct kqid, dev_t, char const);
struct quota_info
{
# 390 "include/linux/quota.h"
  unsigned int flags;
  struct mutex dqio_mutex;
  struct mutex dqonoff_mutex;
  struct inode *files[2U];
  struct mem_dqinfo info[2U];
  struct quota_format_ops const *ops[2U];
};
# 398 "include/linux/quota.h"
int register_quota_format(struct quota_format_type *);
void unregister_quota_format(struct quota_format_type *);
struct quota_module_name
{
  int qm_fmt_id;
  char *qm_mod_name;
};
enum positive_aop_returns
{
  AOP_WRITEPAGE_ACTIVATE = 524288,
  AOP_TRUNCATED_PAGE = 524289
};
struct writeback_control;
# 320 "include/linux/fs.h"
typedef struct
{
# 313 "include/linux/fs.h"
  size_t written;
  size_t count;
# 318 "include/linux/fs.h"
  union
  {
# 316 "include/linux/fs.h"
    char *buf;
    void *data;
  } arg;
  int error;
} read_descriptor_t;
# 322 "include/linux/fs.h"
typedef int (*read_actor_t)(read_descriptor_t *, struct page *, long unsigned int, long unsigned int);
struct address_space_operations
{
# 326 "include/linux/fs.h"
  int (*writepage)(struct page *, struct writeback_control *);
  int (*readpage)(struct file *, struct page *);
# 330 "include/linux/fs.h"
  int (*writepages)(struct address_space *, struct writeback_control *);
# 333 "include/linux/fs.h"
  int (*set_page_dirty)(struct page *);
# 335 "include/linux/fs.h"
  int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int);
# 338 "include/linux/fs.h"
  int (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page **, void **);
# 341 "include/linux/fs.h"
  int (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page *, void *);
# 346 "include/linux/fs.h"
  sector_t (*bmap)(struct address_space *, sector_t);
  void (*invalidatepage)(struct page *, unsigned int, unsigned int);
  int (*releasepage)(struct page *, gfp_t);
  void (*freepage)(struct page *);
  ssize_t (*direct_IO)(int, struct kiocb *, struct iov_iter *, loff_t);
  int (*get_xip_mem)(struct address_space *, long unsigned int, int, void **, long unsigned int *);
# 357 "include/linux/fs.h"
  int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode);
# 359 "include/linux/fs.h"
  int (*launder_page)(struct page *);
  int (*is_partially_uptodate)(struct page *, long unsigned int, long unsigned int);
# 362 "include/linux/fs.h"
  void (*is_dirty_writeback)(struct page *, bool *, bool *);
  int (*error_remove_page)(struct address_space *, struct page *);
# 366 "include/linux/fs.h"
  int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);
# 368 "include/linux/fs.h"
  void (*swap_deactivate)(struct file *);
};
# 371 "include/linux/fs.h"
extern struct address_space_operations const empty_aops;
# 377 "include/linux/fs.h"
int pagecache_write_begin(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page **, void **);
# 381 "include/linux/fs.h"
int pagecache_write_end(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page *, void *);
struct address_space
{
# 387 "include/linux/fs.h"
  struct inode *host;
  struct radix_tree_root page_tree;
  spinlock_t tree_lock;
  atomic_t i_mmap_writable;
  struct rb_root i_mmap;
  struct list_head i_mmap_nonlinear;
  struct mutex i_mmap_mutex;
# 395 "include/linux/fs.h"
  long unsigned int nrpages;
  long unsigned int nrshadows;
  long unsigned int writeback_index;
  struct address_space_operations const *a_ops;
  long unsigned int flags;
  struct backing_dev_info *backing_dev_info;
  spinlock_t private_lock;
  struct list_head private_list;
  void *private_data;
};
struct request_queue;
struct block_device
{
# 413 "include/linux/fs.h"
  dev_t bd_dev;
  int bd_openers;
  struct inode *bd_inode;
  struct super_block *bd_super;
  struct mutex bd_mutex;
  struct list_head bd_inodes;
  void *bd_claiming;
  void *bd_holder;
  int bd_holders;
  bool bd_write_holder;
# 424 "include/linux/fs.h"
  struct list_head bd_holder_disks;
# 426 "include/linux/fs.h"
  struct block_device *bd_contains;
  unsigned int bd_block_size;
  struct hd_struct *bd_part;
# 430 "include/linux/fs.h"
  unsigned int bd_part_count;
  int bd_invalidated;
  struct gendisk *bd_disk;
  struct request_queue *bd_queue;
  struct list_head bd_list;
# 441 "include/linux/fs.h"
  long unsigned int bd_private;
# 444 "include/linux/fs.h"
  int bd_fsfreeze_count;
# 446 "include/linux/fs.h"
  struct mutex bd_fsfreeze_mutex;
};
# 457 "include/linux/fs.h"
int mapping_tagged(struct address_space *, int);
# 462 "include/linux/fs.h"
static inline int mapping_mapped(struct address_space *mapping)
{
  return ( * mapping ) . i_mmap . rb_node != ( ( struct rb_node *) 0 ) || list_empty
# 465 "include/linux/fs.h"
  ( ( struct list_head const *) & ( * mapping ) . i_mmap_nonlinear ) == 0;
}
# 477 "include/linux/fs.h"
static inline int mapping_writably_mapped(struct address_space *mapping)
{
  return atomic_read ( ( atomic_t const *) & ( * mapping ) . i_mmap_writable ) > 0;
}
# 482 "include/linux/fs.h"
static inline int mapping_map_writable(struct address_space *mapping)
{
  return atomic_inc_unless_negative ( & ( * mapping ) . i_mmap_writable ) != 0 ? 0
# 485 "include/linux/fs.h"
  : -1;
}
# 488 "include/linux/fs.h"
static inline void mapping_unmap_writable(struct address_space *mapping)
{
  atomic_dec ( & ( * mapping ) . i_mmap_writable );
}
# 493 "include/linux/fs.h"
static inline int mapping_deny_writable(struct address_space *mapping)
{
  return atomic_dec_unless_positive ( & ( * mapping ) . i_mmap_writable ) != 0 ? 0
# 496 "include/linux/fs.h"
  : -16;
}
# 499 "include/linux/fs.h"
static inline void mapping_allow_writable(struct address_space *mapping)
{
  atomic_inc ( & ( * mapping ) . i_mmap_writable );
}
struct posix_acl;
struct inode
{
# 528 "include/linux/fs.h"
  umode_t i_mode;
  short unsigned int i_opflags;
  kuid_t i_uid;
  kgid_t i_gid;
  unsigned int i_flags;
# 535 "include/linux/fs.h"
  struct posix_acl *i_acl;
  struct posix_acl *i_default_acl;
# 539 "include/linux/fs.h"
  struct inode_operations const *i_op;
  struct super_block *i_sb;
  struct address_space *i_mapping;
# 544 "include/linux/fs.h"
  void *i_security;
# 548 "include/linux/fs.h"
  long unsigned int i_ino;
# 559 "include/linux/fs.h"
  union
  {
# 557 "include/linux/fs.h"
    unsigned int const i_nlink;
    unsigned int __i_nlink;
  } ldv_21969;
  dev_t i_rdev;
  loff_t i_size;
  struct timespec i_atime;
  struct timespec i_mtime;
  struct timespec i_ctime;
  spinlock_t i_lock;
  short unsigned int i_bytes;
  unsigned int i_blkbits;
  blkcnt_t i_blocks;
# 575 "include/linux/fs.h"
  long unsigned int i_state;
  struct mutex i_mutex;
# 578 "include/linux/fs.h"
  long unsigned int dirtied_when;
# 580 "include/linux/fs.h"
  struct hlist_node i_hash;
  struct list_head i_wb_list;
  struct list_head i_lru;
  struct list_head i_sb_list;
# 587 "include/linux/fs.h"
  union
  {
# 585 "include/linux/fs.h"
    struct hlist_head i_dentry;
    struct callback_head i_rcu;
  } ldv_21989;
  u64 i_version;
  atomic_t i_count;
  atomic_t i_dio_count;
  atomic_t i_writecount;
# 593 "include/linux/fs.h"
  atomic_t i_readcount;
# 595 "include/linux/fs.h"
  struct file_operations const *i_fop;
  struct file_lock *i_flock;
  struct address_space i_data;
# 599 "include/linux/fs.h"
  struct dquot *i_dquot[2U];
# 601 "include/linux/fs.h"
  struct list_head i_devices;
# 606 "include/linux/fs.h"
  union
  {
# 603 "include/linux/fs.h"
    struct pipe_inode_info *i_pipe;
    struct block_device *i_bdev;
    struct cdev *i_cdev;
  } ldv_22006;
# 608 "include/linux/fs.h"
  __u32 i_generation;
# 611 "include/linux/fs.h"
  __u32 i_fsnotify_mask;
  struct hlist_head i_fsnotify_marks;
# 615 "include/linux/fs.h"
  void *i_private;
};
# 618 "include/linux/fs.h"
static inline int inode_unhashed(struct inode *inode)
{
  return hlist_unhashed ( ( struct hlist_node const *) & ( * inode ) . i_hash );
}
enum inode_i_mutex_lock_class
{
  I_MUTEX_NORMAL = 0,
  I_MUTEX_PARENT = 1,
  I_MUTEX_CHILD = 2,
  I_MUTEX_XATTR = 3,
  I_MUTEX_NONDIR2 = 4
};
# 646 "include/linux/fs.h"
void lock_two_nondirectories(struct inode *, struct inode *);
void unlock_two_nondirectories(struct inode *, struct inode *);
# 659 "include/linux/fs.h"
static inline loff_t i_size_read(struct inode const *inode)
{
# 678 "include/linux/fs.h"
  return ( loff_t ) ( * inode ) . i_size;
}
# 687 "include/linux/fs.h"
static inline void i_size_write(struct inode *inode, loff_t i_size)
{
# 700 "include/linux/fs.h"
  ( * inode ) . i_size = i_size;
}
# 709 "include/linux/fs.h"
static inline uid_t i_uid_read(struct inode const *inode)
{
  return from_kuid ( & init_user_ns , ( * inode ) . i_uid );
}
# 714 "include/linux/fs.h"
static inline gid_t i_gid_read(struct inode const *inode)
{
  return from_kgid ( & init_user_ns , ( * inode ) . i_gid );
}
# 719 "include/linux/fs.h"
static inline void i_uid_write(struct inode *inode, uid_t uid)
{
  ( * inode ) . i_uid = make_kuid ( & init_user_ns , uid );
}
# 724 "include/linux/fs.h"
static inline void i_gid_write(struct inode *inode, gid_t gid)
{
  ( * inode ) . i_gid = make_kgid ( & init_user_ns , gid );
}
# 729 "include/linux/fs.h"
static inline unsigned int iminor(struct inode const *inode)
{
  return ( unsigned int ) ( * inode ) . i_rdev & 1048575U;
}
# 734 "include/linux/fs.h"
static inline unsigned int imajor(struct inode const *inode)
{
  return ( unsigned int ) ( ( * inode ) . i_rdev >> 20 );
}
# 739 "include/linux/fs.h"
struct block_device *I_BDEV(struct inode *);
struct fown_struct
{
  rwlock_t lock;
  struct pid *pid;
  enum pid_type pid_type;
  kuid_t uid;
# 745 "include/linux/fs.h"
  kuid_t euid;
  int signum;
};
struct file_ra_state
{
# 753 "include/linux/fs.h"
  long unsigned int start;
  unsigned int size;
  unsigned int async_size;
# 758 "include/linux/fs.h"
  unsigned int ra_pages;
  unsigned int mmap_miss;
  loff_t prev_pos;
};
# 766 "include/linux/fs.h"
static inline int ra_has_index(struct file_ra_state *ra, long unsigned int index)
{
  return ( * ra ) . start <= index && (
# 769 "include/linux/fs.h"
  * ra ) . start + ( long unsigned int ) ( * ra ) . size > index;
}
struct file
{
# 776 "include/linux/fs.h"
  union
  {
# 774 "include/linux/fs.h"
    struct llist_node fu_llist;
    struct callback_head fu_rcuhead;
  } f_u;
  struct path f_path;
# 779 "include/linux/fs.h"
  struct inode *f_inode;
  struct file_operations const *f_op;
# 786 "include/linux/fs.h"
  spinlock_t f_lock;
  atomic_long_t f_count;
  unsigned int f_flags;
  fmode_t f_mode;
  struct mutex f_pos_lock;
  loff_t f_pos;
  struct fown_struct f_owner;
  struct cred const *f_cred;
  struct file_ra_state f_ra;
# 796 "include/linux/fs.h"
  u64 f_version;
# 798 "include/linux/fs.h"
  void *f_security;
# 801 "include/linux/fs.h"
  void *private_data;
# 805 "include/linux/fs.h"
  struct list_head f_ep_links;
  struct list_head f_tfile_llink;
# 808 "include/linux/fs.h"
  struct address_space *f_mapping;
};
struct file_handle
{
  __u32 handle_bytes;
  int handle_type;
# 815 "include/linux/fs.h"
  unsigned char f_handle[0U];
};
# 818 "include/linux/fs.h"
static inline struct file *get_file(struct file *f)
{
  atomic_long_inc ( & ( * f ) . f_count );
  return f;
}
# 861 "include/linux/fs.h"
typedef void *fl_owner_t;
struct file_lock_operations
{
  void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
  void (*fl_release_private)(struct file_lock *);
};
struct lock_manager_operations
{
  int (*lm_compare_owner)(struct file_lock *, struct file_lock *);
  long unsigned int (*lm_owner_key)(struct file_lock *);
  void (*lm_notify)(struct file_lock *);
  int (*lm_grant)(struct file_lock *, struct file_lock *, int);
  void (*lm_break)(struct file_lock *);
  int (*lm_change)(struct file_lock **, int);
};
struct lock_manager
{
  struct list_head list;
};
struct net;
# 882 "include/linux/fs.h"
void locks_start_grace(struct net *, struct lock_manager *);
void locks_end_grace(struct lock_manager *);
int locks_in_grace(struct net *);
struct nlm_lockowner;
struct nfs_lock_info
{
# 10 "include/linux/nfs_fs_i.h"
  u32 state;
  struct nlm_lockowner *owner;
  struct list_head list;
};
struct nfs4_lock_state;
struct nfs4_lock_info
{
  struct nfs4_lock_state *owner;
};
struct file_lock
{
# 908 "include/linux/fs.h"
  struct file_lock *fl_next;
  struct hlist_node fl_link;
  struct list_head fl_block;
  fl_owner_t fl_owner;
  unsigned int fl_flags;
  unsigned char fl_type;
  unsigned int fl_pid;
  int fl_link_cpu;
  struct pid *fl_nspid;
  wait_queue_head_t fl_wait;
  struct file *fl_file;
  loff_t fl_start;
  loff_t fl_end;
# 922 "include/linux/fs.h"
  struct fasync_struct *fl_fasync;
# 924 "include/linux/fs.h"
  long unsigned int fl_break_time;
  long unsigned int fl_downgrade_time;
# 927 "include/linux/fs.h"
  struct file_lock_operations const *fl_ops;
  struct lock_manager_operations const *fl_lmops;
# 936 "include/linux/fs.h"
  union
  {
# 930 "include/linux/fs.h"
    struct nfs_lock_info nfs_fl;
    struct nfs4_lock_info nfs4_fl;
# 935 "include/linux/fs.h"
    struct
    {
# 933 "include/linux/fs.h"
      struct list_head link;
      int state;
    } afs;
  } fl_u;
};
struct f_owner_ex
{
# 156 "./include/uapi/asm-generic/fcntl.h"
  int type;
  __kernel_pid_t pid;
};
struct flock
{
# 196 "./include/uapi/asm-generic/fcntl.h"
  short int l_type;
  short int l_whence;
  __kernel_off_t l_start;
  __kernel_off_t l_len;
  __kernel_pid_t l_pid;
};
struct flock64
{
# 211 "./include/uapi/asm-generic/fcntl.h"
  short int l_type;
  short int l_whence;
  __kernel_loff_t l_start;
  __kernel_loff_t l_len;
  __kernel_pid_t l_pid;
};
# 948 "include/linux/fs.h"
void send_sigio(struct fown_struct *, int, int);
# 951 "include/linux/fs.h"
int fcntl_getlk(struct file *, unsigned int, struct flock *);
int fcntl_setlk(unsigned int, struct file *, unsigned int, struct flock *);
# 961 "include/linux/fs.h"
int fcntl_setlease(unsigned int, struct file *, long int);
int fcntl_getlease(struct file *);
# 965 "include/linux/fs.h"
void locks_free_lock(struct file_lock *);
void locks_init_lock(struct file_lock *);
struct file_lock *locks_alloc_lock(void);
void locks_copy_lock(struct file_lock *, struct file_lock *);
void __locks_copy_lock(struct file_lock *, struct file_lock const *);
void locks_remove_posix(struct file *, fl_owner_t);
void locks_remove_file(struct file *);
void locks_release_private(struct file_lock *);
void posix_test_lock(struct file *, struct file_lock *);
int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
int posix_lock_file_wait(struct file *, struct file_lock *);
int posix_unblock_lock(struct file_lock *);
int vfs_test_lock(struct file *, struct file_lock *);
int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
int vfs_cancel_lock(struct file *, struct file_lock *);
int flock_lock_file_wait(struct file *, struct file_lock *);
int __break_lease(struct inode *, unsigned int, unsigned int);
void lease_get_mtime(struct inode *, struct timespec *);
int generic_setlease(struct file *, long int, struct file_lock **);
int vfs_setlease(struct file *, long int, struct file_lock **);
int lease_modify(struct file_lock **, int);
int lock_may_read(struct inode *, loff_t, long unsigned int);
int lock_may_write(struct inode *, loff_t, long unsigned int);
struct fasync_struct
{
# 1134 "include/linux/fs.h"
  spinlock_t fa_lock;
  int magic;
  int fa_fd;
  struct fasync_struct *fa_next;
  struct file *fa_file;
  struct callback_head fa_rcu;
};
# 1145 "include/linux/fs.h"
int fasync_helper(int, struct file *, int, struct fasync_struct **);
struct fasync_struct *fasync_insert_entry(int, struct file *, struct fasync_struct **, struct fasync_struct *);
int fasync_remove_entry(struct file *, struct fasync_struct **);
struct fasync_struct *fasync_alloc(void);
void fasync_free(struct fasync_struct *);
# 1152 "include/linux/fs.h"
void kill_fasync(struct fasync_struct **, int, int);
# 1154 "include/linux/fs.h"
int __f_setown(struct file *, struct pid *, enum pid_type, int);
int f_setown(struct file *, long unsigned int, int);
void f_delown(struct file *);
pid_t f_getown(struct file *);
int send_sigurg(struct fown_struct *);
# 1172 "include/linux/fs.h"
extern struct list_head super_blocks;
extern spinlock_t sb_lock;
enum ldv_17809
{
  SB_UNFROZEN = 0,
  SB_FREEZE_WRITE = 1,
  SB_FREEZE_PAGEFAULT = 2,
  SB_FREEZE_FS = 3,
  SB_FREEZE_COMPLETE = 4
};
struct sb_writers
{
# 1189 "include/linux/fs.h"
  struct percpu_counter counter[3U];
  wait_queue_head_t wait;
# 1192 "include/linux/fs.h"
  int frozen;
  wait_queue_head_t wait_unfrozen;
# 1196 "include/linux/fs.h"
  struct lockdep_map lock_map[3U];
};
struct super_block
{
# 1201 "include/linux/fs.h"
  struct list_head s_list;
  dev_t s_dev;
  unsigned char s_blocksize_bits;
  long unsigned int s_blocksize;
  loff_t s_maxbytes;
  struct file_system_type *s_type;
  struct super_operations const *s_op;
  struct dquot_operations const *dq_op;
  struct quotactl_ops const *s_qcop;
  struct export_operations const *s_export_op;
  long unsigned int s_flags;
  long unsigned int s_magic;
  struct dentry *s_root;
  struct rw_semaphore s_umount;
  int s_count;
  atomic_t s_active;
# 1218 "include/linux/fs.h"
  void *s_security;
# 1220 "include/linux/fs.h"
  struct xattr_handler const **s_xattr;
# 1222 "include/linux/fs.h"
  struct list_head s_inodes;
  struct hlist_bl_head s_anon;
  struct list_head s_mounts;
  struct block_device *s_bdev;
  struct backing_dev_info *s_bdi;
  struct mtd_info *s_mtd;
  struct hlist_node s_instances;
  struct quota_info s_dquot;
# 1231 "include/linux/fs.h"
  struct sb_writers s_writers;
# 1233 "include/linux/fs.h"
  char s_id[32U];
  u8 s_uuid[16U];
# 1236 "include/linux/fs.h"
  void *s_fs_info;
  unsigned int s_max_links;
  fmode_t s_mode;
# 1242 "include/linux/fs.h"
  u32 s_time_gran;
# 1248 "include/linux/fs.h"
  struct mutex s_vfs_rename_mutex;
# 1254 "include/linux/fs.h"
  char *s_subtype;
# 1260 "include/linux/fs.h"
  char *s_options;
  struct dentry_operations const *s_d_op;
# 1266 "include/linux/fs.h"
  int cleancache_poolid;
# 1268 "include/linux/fs.h"
  struct shrinker s_shrink;
# 1271 "include/linux/fs.h"
  atomic_long_t s_remove_count;
# 1274 "include/linux/fs.h"
  int s_readonly_remount;
# 1277 "include/linux/fs.h"
  struct workqueue_struct *s_dio_done_wq;
  struct hlist_head s_pins;
# 1284 "include/linux/fs.h"
  struct list_lru s_dentry_lru;
  struct list_lru s_inode_lru;
  struct callback_head rcu;
};
# 1289 "include/linux/fs.h"
struct timespec current_fs_time(struct super_block *);
# 1295 "include/linux/fs.h"
void __sb_end_write(struct super_block *, int);
int __sb_start_write(struct super_block *, int, bool);
# 1305 "include/linux/fs.h"
static inline void sb_end_write(struct super_block *sb)
{
  __sb_end_write ( sb , 1 );
}
# 1317 "include/linux/fs.h"
static inline void sb_end_pagefault(struct super_block *sb)
{
  __sb_end_write ( sb , 2 );
}
# 1329 "include/linux/fs.h"
static inline void sb_end_intwrite(struct super_block *sb)
{
  __sb_end_write ( sb , 3 );
}
# 1353 "include/linux/fs.h"
static inline void sb_start_write(struct super_block *sb)
{
  __sb_start_write ( sb , 1 , 1 );
}
# 1358 "include/linux/fs.h"
static inline int sb_start_write_trylock(struct super_block *sb)
{
  return __sb_start_write ( sb , 1 , 0 );
}
# 1382 "include/linux/fs.h"
static inline void sb_start_pagefault(struct super_block *sb)
{
  __sb_start_write ( sb , 2 , 1 );
}
# 1400 "include/linux/fs.h"
static inline void sb_start_intwrite(struct super_block *sb)
{
  __sb_start_write ( sb , 3 , 1 );
}
# 1406 "include/linux/fs.h"
bool inode_owner_or_capable(struct inode const *);
# 1411 "include/linux/fs.h"
int vfs_create(struct inode *, struct dentry *, umode_t, bool);
int vfs_mkdir(struct inode *, struct dentry *, umode_t);
int vfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
int vfs_symlink(struct inode *, struct dentry *, char const *);
int vfs_link(struct dentry *, struct inode *, struct dentry *, struct inode **);
int vfs_rmdir(struct inode *, struct dentry *);
int vfs_unlink(struct inode *, struct dentry *, struct inode **);
int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);
# 1423 "include/linux/fs.h"
void dentry_unhash(struct dentry *);
# 1428 "include/linux/fs.h"
void inode_init_owner(struct inode *, struct inode const *, umode_t);
struct fiemap_extent_info
{
# 1434 "include/linux/fs.h"
  unsigned int fi_flags;
  unsigned int fi_extents_mapped;
  unsigned int fi_extents_max;
  struct fiemap_extent *fi_extents_start;
};
# 1440 "include/linux/fs.h"
int fiemap_fill_next_extent(struct fiemap_extent_info *, u64, u64, u64, u32);
# 1442 "include/linux/fs.h"
int fiemap_check_flags(struct fiemap_extent_info *, u32);
# 1466 "include/linux/fs.h"
typedef int (*filldir_t)(void *, char const *, int, loff_t, u64, unsigned int);
struct dir_context
{
# 1468 "include/linux/fs.h"
  filldir_t actor;
  loff_t pos;
};
struct block_device_operations;
struct file_operations
{
# 1483 "include/linux/fs.h"
  struct module *owner;
  loff_t (*llseek)(struct file *, loff_t, int);
  ssize_t (*read)(struct file *, char *, size_t, loff_t *);
  ssize_t (*write)(struct file *, char const *, size_t, loff_t *);
  ssize_t (*aio_read)(struct kiocb *, struct iovec const *, long unsigned int, loff_t);
  ssize_t (*aio_write)(struct kiocb *, struct iovec const *, long unsigned int, loff_t);
  ssize_t (*read_iter)(struct kiocb *, struct iov_iter *);
  ssize_t (*write_iter)(struct kiocb *, struct iov_iter *);
  int (*iterate)(struct file *, struct dir_context *);
  unsigned int (*poll)(struct file *, struct poll_table_struct *);
  long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
  long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
  int (*mmap)(struct file *, struct vm_area_struct *);
  int (*open)(struct inode *, struct file *);
  int (*flush)(struct file *, fl_owner_t);
  int (*release)(struct inode *, struct file *);
  int (*fsync)(struct file *, loff_t, loff_t, int);
  int (*aio_fsync)(struct kiocb *, int);
  int (*fasync)(int, struct file *, int);
  int (*lock)(struct file *, int, struct file_lock *);
  ssize_t (*sendpage)(struct file *, struct page *, int, size_t, loff_t *, int);
  long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
  int (*check_flags)(int);
  int (*flock)(struct file *, int, struct file_lock *);
  ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
  ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
  int (*setlease)(struct file *, long int, struct file_lock **);
  long int (*fallocate)(struct file *, int, loff_t, loff_t);
# 1512 "include/linux/fs.h"
  int (*show_fdinfo)(struct seq_file *, struct file *);
};
struct inode_operations
{
  struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int);
  void *(*follow_link)(struct dentry *, struct nameidata *);
  int (*permission)(struct inode *, int);
  struct posix_acl *(*get_acl)(struct inode *, int);
# 1521 "include/linux/fs.h"
  int (*readlink)(struct dentry *, char *, int);
  void (*put_link)(struct dentry *, struct nameidata *, void *);
# 1524 "include/linux/fs.h"
  int (*create)(struct inode *, struct dentry *, umode_t, bool);
  int (*link)(struct dentry *, struct inode *, struct dentry *);
  int (*unlink)(struct inode *, struct dentry *);
  int (*symlink)(struct inode *, struct dentry *, char const *);
  int (*mkdir)(struct inode *, struct dentry *, umode_t);
  int (*rmdir)(struct inode *, struct dentry *);
  int (*mknod)(struct inode *, struct dentry *, umode_t, dev_t);
  int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *);
# 1533 "include/linux/fs.h"
  int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);
# 1535 "include/linux/fs.h"
  int (*setattr)(struct dentry *, struct iattr *);
  int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *);
  int (*setxattr)(struct dentry *, char const *, void const *, size_t, int);
  ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t);
  ssize_t (*listxattr)(struct dentry *, char *, size_t);
  int (*removexattr)(struct dentry *, char const *);
  int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);
# 1543 "include/linux/fs.h"
  int (*update_time)(struct inode *, struct timespec *, int);
  int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t, int *);
# 1547 "include/linux/fs.h"
  int (*tmpfile)(struct inode *, struct dentry *, umode_t);
  int (*set_acl)(struct inode *, struct posix_acl *, int);
};
# 1551 "include/linux/fs.h"
ssize_t rw_copy_check_uvector(int, struct iovec const *, long unsigned int, long unsigned int, struct iovec *, struct iovec **);
# 1556 "include/linux/fs.h"
ssize_t vfs_read(struct file *, char *, size_t, loff_t *);
ssize_t vfs_write(struct file *, char const *, size_t, loff_t *);
ssize_t vfs_readv(struct file *, struct iovec const *, long unsigned int, loff_t *);
# 1560 "include/linux/fs.h"
ssize_t vfs_writev(struct file *, struct iovec const *, long unsigned int, loff_t *);
struct super_operations
{
# 1564 "include/linux/fs.h"
  struct inode *(*alloc_inode)(struct super_block *);
  void (*destroy_inode)(struct inode *);
# 1567 "include/linux/fs.h"
  void (*dirty_inode)(struct inode *, int);
  int (*write_inode)(struct inode *, struct writeback_control *);
  int (*drop_inode)(struct inode *);
  void (*evict_inode)(struct inode *);
  void (*put_super)(struct super_block *);
  int (*sync_fs)(struct super_block *, int);
  int (*freeze_fs)(struct super_block *);
  int (*unfreeze_fs)(struct super_block *);
  int (*statfs)(struct dentry *, struct kstatfs *);
  int (*remount_fs)(struct super_block *, int *, char *);
  void (*umount_begin)(struct super_block *);
# 1579 "include/linux/fs.h"
  int (*show_options)(struct seq_file *, struct dentry *);
  int (*show_devname)(struct seq_file *, struct dentry *);
  int (*show_path)(struct seq_file *, struct dentry *);
  int (*show_stats)(struct seq_file *, struct dentry *);
# 1584 "include/linux/fs.h"
  ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
  ssize_t (*quota_write)(struct super_block *, int, char const *, size_t, loff_t);
# 1587 "include/linux/fs.h"
  int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t);
  long int (*nr_cached_objects)(struct super_block *, int);
  long int (*free_cached_objects)(struct super_block *, long int, int);
};
# 1716 "include/linux/fs.h"
void __mark_inode_dirty(struct inode *, int);
static inline void mark_inode_dirty(struct inode *inode)
{
  __mark_inode_dirty ( inode , 7 );
}
# 1722 "include/linux/fs.h"
static inline void mark_inode_dirty_sync(struct inode *inode)
{
  __mark_inode_dirty ( inode , 1 );
}
# 1727 "include/linux/fs.h"
void inc_nlink(struct inode *);
void drop_nlink(struct inode *);
void clear_nlink(struct inode *);
void set_nlink(struct inode *, unsigned int);
# 1732 "include/linux/fs.h"
static inline void inode_inc_link_count(struct inode *inode)
{
  inc_nlink ( inode );
  mark_inode_dirty ( inode );
}
# 1738 "include/linux/fs.h"
static inline void inode_dec_link_count(struct inode *inode)
{
  drop_nlink ( inode );
  mark_inode_dirty ( inode );
}
# 1752 "include/linux/fs.h"
static inline void inode_inc_iversion(struct inode *inode)
{
  spin_lock ( & ( * inode ) . i_lock );
  ( * inode ) . i_version ++;
  spin_unlock ( & ( * inode ) . i_lock );
}
enum file_time_flags
{
  S_ATIME = 1,
  S_MTIME = 2,
  S_CTIME = 4,
  S_VERSION = 8
};
# 1766 "include/linux/fs.h"
void touch_atime(struct path const *);
static inline void file_accessed(struct file *file)
{
  if (( ( * file ) . f_flags & 262144U ) == 0U)
    touch_atime ( ( struct path const *) & ( * file ) . f_path );
}
# 1773 "include/linux/fs.h"
int sync_inode(struct inode *, struct writeback_control *);
int sync_inode_metadata(struct inode *, int);
struct file_system_type
{
  char const *name;
  int fs_flags;
# 1785 "include/linux/fs.h"
  struct dentry *(*mount)(struct file_system_type *, int, char const *, void *);
# 1787 "include/linux/fs.h"
  void (*kill_sb)(struct super_block *);
  struct module *owner;
  struct file_system_type *next;
  struct hlist_head fs_supers;
# 1792 "include/linux/fs.h"
  struct lock_class_key s_lock_key;
  struct lock_class_key s_umount_key;
  struct lock_class_key s_vfs_rename_key;
  struct lock_class_key s_writers_key[3U];
# 1797 "include/linux/fs.h"
  struct lock_class_key i_lock_key;
  struct lock_class_key i_mutex_key;
  struct lock_class_key i_mutex_dir_key;
};
# 1804 "include/linux/fs.h"
struct dentry *mount_ns(struct file_system_type *, int, void *, int (*)(struct super_block *, void *, int));
# 1806 "include/linux/fs.h"
struct dentry *mount_bdev(struct file_system_type *, int, char const *, void *, int (*)(struct super_block *, void *, int));
# 1809 "include/linux/fs.h"
struct dentry *mount_single(struct file_system_type *, int, void *, int (*)(struct super_block *, void *, int));
# 1812 "include/linux/fs.h"
struct dentry *mount_nodev(struct file_system_type *, int, void *, int (*)(struct super_block *, void *, int));
# 1815 "include/linux/fs.h"
struct dentry *mount_subtree(struct vfsmount *, char const *);
void generic_shutdown_super(struct super_block *);
void kill_block_super(struct super_block *);
void kill_anon_super(struct super_block *);
void kill_litter_super(struct super_block *);
void deactivate_super(struct super_block *);
void deactivate_locked_super(struct super_block *);
int set_anon_super(struct super_block *, void *);
int get_anon_bdev(dev_t *);
void free_anon_bdev(dev_t);
struct super_block *sget(struct file_system_type *, int (*)(struct super_block *, void *), int (*)(struct super_block *, void *), int, void *);
# 1829 "include/linux/fs.h"
struct dentry *mount_pseudo(struct file_system_type *, char *, struct super_operations const *, struct dentry_operations const *, long unsigned int);
# 1851 "include/linux/fs.h"
int register_filesystem(struct file_system_type *);
int unregister_filesystem(struct file_system_type *);
struct vfsmount *kern_mount_data(struct file_system_type *, void *);
# 1855 "include/linux/fs.h"
void kern_unmount(struct vfsmount *);
int may_umount_tree(struct vfsmount *);
int may_umount(struct vfsmount *);
long int do_mount(char const *, char const *, char const *, long unsigned int, void *);
struct vfsmount *collect_mounts(struct path *);
void drop_collected_mounts(struct vfsmount *);
int iterate_mounts(int (*)(struct vfsmount *, void *), void *, struct vfsmount *);
# 1863 "include/linux/fs.h"
int vfs_statfs(struct path *, struct kstatfs *);
int user_statfs(char const *, struct kstatfs *);
int fd_statfs(int, struct kstatfs *);
int vfs_ustat(dev_t, struct kstatfs *);
int freeze_super(struct super_block *);
int thaw_super(struct super_block *);
bool our_mnt(struct vfsmount *);
bool fs_fully_visible(struct file_system_type *);
# 1872 "include/linux/fs.h"
int current_umask(void);
# 1874 "include/linux/fs.h"
void ihold(struct inode *);
void iput(struct inode *);
# 1877 "include/linux/fs.h"
static inline struct inode *file_inode(struct file *f)
{
  return ( * f ) . f_inode;
}
# 1883 "include/linux/fs.h"
extern struct kobject *fs_kobj;
# 1891 "include/linux/fs.h"
int locks_mandatory_locked(struct file *);
int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size_t);
# 1899 "include/linux/fs.h"
static inline int __mandatory_lock(struct inode *ino)
{
  return ( ( int ) ( * ino ) . i_mode & 1032 ) == 1024;
}
# 1909 "include/linux/fs.h"
static inline int mandatory_lock(struct inode *ino)
{
  return ( ( * ( * ino ) . i_sb ) . s_flags & 64UL ) != 0UL && __mandatory_lock ( ino ) != 0;
}
# 1914 "include/linux/fs.h"
static inline int locks_verify_locked(struct file *file)
{
  if (mandatory_lock ( file_inode ( file ) ) != 0)
    return locks_mandatory_locked ( file );
  return 0;
}
# 1921 "include/linux/fs.h"
static inline int locks_verify_truncate(struct inode *inode, struct file *filp, loff_t size)
{
# 1925 "include/linux/fs.h"
  if (( * inode ) . i_flock != ( ( struct file_lock *) 0 ) && mandatory_lock ( inode ) != 0)
    return locks_mandatory_area ( 2 , inode , filp ,
# 1928 "include/linux/fs.h"
# 1926 "include/linux/fs.h"
                                                     ((size) < (( * inode ) . i_size) ? (size) : (( * inode ) . i_size))

                             , ( size_t ) ( (
# 1929 "include/linux/fs.h"
    * inode ) . i_size > size ? ( * inode ) . i_size - size : size
# 1930 "include/linux/fs.h"
    - ( * inode ) . i_size ) );
# 1932 "include/linux/fs.h"
  return 0;
}
# 1935 "include/linux/fs.h"
static inline int break_lease(struct inode *inode, unsigned int mode)
{
# 1942 "include/linux/fs.h"
  asm volatile ( "mfence" : : : "memory" ) ;
  if (( * inode ) . i_flock != ( ( struct file_lock *) 0 ))
    return __break_lease ( inode , mode , 32U );
  return 0;
}
# 1948 "include/linux/fs.h"
static inline int break_deleg(struct inode *inode, unsigned int mode)
{
# 1955 "include/linux/fs.h"
  asm volatile ( "mfence" : : : "memory" ) ;
  if (( * inode ) . i_flock != ( ( struct file_lock *) 0 ))
    return __break_lease ( inode , mode , 4U );
  return 0;
}
# 1961 "include/linux/fs.h"
static inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)
{
  int ret;
# 1965 "include/linux/fs.h"
  ret = break_deleg ( inode , 2049U );
  if (ret == -11 && delegated_inode != ( ( struct inode **) 0 ))
  {
# 1967 "include/linux/fs.h"
    * delegated_inode = inode;
    ihold ( inode );
  }
  return ret;
}
# 1973 "include/linux/fs.h"
static inline int break_deleg_wait(struct inode **delegated_inode)
{
  int ret;
# 1977 "include/linux/fs.h"
  ret = break_deleg ( * delegated_inode , 1U );
  iput ( * delegated_inode );
  * delegated_inode = ( ( struct inode *) 0 );
  return ret;
}
struct audit_names;
struct filename
{
# 2043 "include/linux/fs.h"
  char const *name;
  char const *uptr;
  struct audit_names *aname;
  bool separate;
};
# 2049 "include/linux/fs.h"
long int vfs_truncate(struct path *, loff_t);
int do_truncate(struct dentry *, loff_t, unsigned int, struct file *);
# 2052 "include/linux/fs.h"
int do_fallocate(struct file *, int, loff_t, loff_t);
# 2054 "include/linux/fs.h"
long int do_sys_open(int, char const *, int, umode_t);
# 2056 "include/linux/fs.h"
struct file *file_open_name(struct filename *, int, umode_t);
struct file *filp_open(char const *, int, umode_t);
struct file *file_open_root(struct dentry *, struct vfsmount *, char const *, int);
# 2060 "include/linux/fs.h"
struct file *dentry_open(struct path const *, int, struct cred const *);
int filp_close(struct file *, fl_owner_t);
# 2063 "include/linux/fs.h"
struct filename *getname(char const *);
struct filename *getname_kernel(char const *);
enum ldv_18203
{
  FILE_CREATED = 1,
  FILE_OPENED = 2
};
int finish_open(struct file *, struct dentry *, int (*)(struct inode *, struct file *), int *);
# 2073 "include/linux/fs.h"
int finish_no_open(struct file *, struct dentry *);
# 2077 "include/linux/fs.h"
int ioctl_preallocate(struct file *, void *);
# 2080 "include/linux/fs.h"
void vfs_caches_init_early(void);
void vfs_caches_init(long unsigned int);
# 2083 "include/linux/fs.h"
extern struct kmem_cache *names_cachep;
# 2085 "include/linux/fs.h"
void final_putname(struct filename *);
# 2092 "include/linux/fs.h"
void putname(struct filename *);
# 2096 "include/linux/fs.h"
int register_blkdev(unsigned int, char const *);
void unregister_blkdev(unsigned int, char const *);
struct block_device *bdget(dev_t);
struct block_device *bdgrab(struct block_device *);
void bd_set_size(struct block_device *, loff_t);
void bd_forget(struct inode *);
void bdput(struct block_device *);
void invalidate_bdev(struct block_device *);
void iterate_bdevs(void (*)(struct block_device *, void *), void *);
int sync_blockdev(struct block_device *);
void kill_bdev(struct block_device *);
struct super_block *freeze_bdev(struct block_device *);
void emergency_thaw_all(void);
int thaw_bdev(struct block_device *, struct super_block *);
int fsync_bdev(struct block_device *);
int sb_is_blkdev_sb(struct super_block *);
# 2137 "include/linux/fs.h"
int sync_filesystem(struct super_block *);
extern struct file_operations const def_blk_fops;
extern struct file_operations const def_chr_fops;
extern struct file_operations const bad_sock_fops;
# 2142 "include/linux/fs.h"
int ioctl_by_bdev(struct block_device *, unsigned int, long unsigned int);
int blkdev_ioctl(struct block_device *, fmode_t, unsigned int, long unsigned int);
long int compat_blkdev_ioctl(struct file *, unsigned int, long unsigned int);
int blkdev_get(struct block_device *, fmode_t, void *);
struct block_device *blkdev_get_by_path(char const *, fmode_t, void *);
# 2148 "include/linux/fs.h"
struct block_device *blkdev_get_by_dev(dev_t, fmode_t, void *);
# 2150 "include/linux/fs.h"
void blkdev_put(struct block_device *, fmode_t);
# 2152 "include/linux/fs.h"
int bd_link_disk_holder(struct block_device *, struct gendisk *);
void bd_unlink_disk_holder(struct block_device *, struct gendisk *);
# 2170 "include/linux/fs.h"
int alloc_chrdev_region(dev_t *, unsigned int, unsigned int, char const *);
int register_chrdev_region(dev_t, unsigned int, char const *);
int __register_chrdev(unsigned int, unsigned int, unsigned int, char const *, struct file_operations const *);
# 2175 "include/linux/fs.h"
void __unregister_chrdev(unsigned int, unsigned int, unsigned int, char const *);
# 2177 "include/linux/fs.h"
void unregister_chrdev_region(dev_t, unsigned int);
void chrdev_show(struct seq_file *, off_t);
# 2180 "include/linux/fs.h"
static inline int register_chrdev(unsigned int major, char const *name, struct file_operations const *fops)
{
# 2183 "include/linux/fs.h"
  return __register_chrdev ( major , 0U , 256U , name , fops );
}
# 2186 "include/linux/fs.h"
static inline void unregister_chrdev(unsigned int major, char const *name)
{
  __unregister_chrdev ( major , 0U , 256U , name );
}
# 2197 "include/linux/fs.h"
char const *__bdevname(dev_t, char *);
char const *bdevname(struct block_device *, char *);
struct block_device *lookup_bdev(char const *);
void blkdev_show(struct seq_file *, off_t);
# 2206 "include/linux/fs.h"
void init_special_inode(struct inode *, umode_t, dev_t);
# 2209 "include/linux/fs.h"
void make_bad_inode(struct inode *);
int is_bad_inode(struct inode *);
# 2223 "include/linux/fs.h"
void check_disk_size_change(struct gendisk *, struct block_device *);
# 2225 "include/linux/fs.h"
int revalidate_disk(struct gendisk *);
int check_disk_change(struct block_device *);
int __invalidate_device(struct block_device *, bool);
int invalidate_partition(struct gendisk *, int);
# 2230 "include/linux/fs.h"
long unsigned int invalidate_mapping_pages(struct address_space *, long unsigned int, long unsigned int);
# 2233 "include/linux/fs.h"
static inline void invalidate_remote_inode(struct inode *inode)
{
  if (( ( int ) ( * inode ) . i_mode & 61440 ) == 32768 || ( ( int ) ( * inode ) . i_mode & 61440 ) == 16384 || ( ( int ) (
# 2236 "include/linux/fs.h"
  * inode ) . i_mode & 61440 ) == 40960)
    invalidate_mapping_pages ( ( * inode ) . i_mapping , 0UL , 18446744073709551615UL );
}
int invalidate_inode_pages2(struct address_space *);
int invalidate_inode_pages2_range(struct address_space *, long unsigned int, long unsigned int);
# 2242 "include/linux/fs.h"
int write_inode_now(struct inode *, int);
int filemap_fdatawrite(struct address_space *);
int filemap_flush(struct address_space *);
int filemap_fdatawait(struct address_space *);
int filemap_fdatawait_range(struct address_space *, loff_t, loff_t);
# 2248 "include/linux/fs.h"
int filemap_write_and_wait(struct address_space *);
int filemap_write_and_wait_range(struct address_space *, loff_t, loff_t);
# 2251 "include/linux/fs.h"
int __filemap_fdatawrite_range(struct address_space *, loff_t, loff_t, int);
# 2253 "include/linux/fs.h"
int filemap_fdatawrite_range(struct address_space *, loff_t, loff_t);
# 2256 "include/linux/fs.h"
int vfs_fsync_range(struct file *, loff_t, loff_t, int);
# 2258 "include/linux/fs.h"
int vfs_fsync(struct file *, int);
static inline int generic_write_sync(struct file *file, loff_t pos, loff_t count)
{
  if (( ( * file ) . f_flags & 4096U ) == 0U && ( ( ( * ( * ( * ( * file ) . f_mapping ) . host ) . i_sb ) . s_flags & 16UL ) == 0UL && ( ( * ( * ( * file ) . f_mapping ) . host ) . i_flags & 1U ) == 0U ))
    return 0;
  return vfs_fsync_range ( file , pos , pos + count + -1LL , ( (
# 2264 "include/linux/fs.h"
  * file ) . f_flags & 1048576U ) == 0U );
}
void emergency_sync(void);
void emergency_remount(void);
# 2269 "include/linux/fs.h"
sector_t bmap(struct inode *, sector_t);
# 2271 "include/linux/fs.h"
int notify_change(struct dentry *, struct iattr *, struct inode **);
int inode_permission(struct inode *, int);
int generic_permission(struct inode *, int);
# 2275 "include/linux/fs.h"
static inline bool execute_ok(struct inode *inode)
{
  return ( bool ) ( ( ( int ) ( * inode ) . i_mode & 73 ) != 0 || ( ( int ) ( * inode ) . i_mode & 61440 ) == 16384 );
}
# 2280 "include/linux/fs.h"
static inline void file_start_write(struct file *file)
{
  if (( ( int ) ( * file_inode ( file ) ) . i_mode & 61440 ) != 32768)
    return;
  __sb_start_write ( ( * file_inode ( file ) ) . i_sb , 1 , 1 );
}
# 2287 "include/linux/fs.h"
static inline bool file_start_write_trylock(struct file *file)
{
  if (( ( int ) ( * file_inode ( file ) ) . i_mode & 61440 ) != 32768)
    return 1;
  return __sb_start_write ( ( * file_inode ( file ) ) . i_sb , 1 , 0 ) != 0;
}
# 2294 "include/linux/fs.h"
static inline void file_end_write(struct file *file)
{
  if (( ( int ) ( * file_inode ( file ) ) . i_mode & 61440 ) != 32768)
    return;
  __sb_end_write ( ( * file_inode ( file ) ) . i_sb , 1 );
}
# 2317 "include/linux/fs.h"
static inline int get_write_access(struct inode *inode)
{
  return atomic_inc_unless_negative ( & ( * inode ) . i_writecount ) != 0 ? 0 : -26;
}
static inline int deny_write_access(struct file *file)
{
  struct inode *inode = file_inode ( file );
  return atomic_dec_unless_positive ( & ( * inode ) . i_writecount ) != 0 ? 0 : -26;
}
static inline void put_write_access(struct inode *inode)
{
  atomic_dec ( & ( * inode ) . i_writecount );
}
static inline void allow_write_access(struct file *file)
{
  if (file != ( ( struct file *) 0 ))
    atomic_inc ( & ( * file_inode ( file ) ) . i_writecount );
}
static inline bool inode_is_open_for_write(struct inode const *inode)
{
  return atomic_read ( & ( * inode ) . i_writecount ) > 0;
}
# 2341 "include/linux/fs.h"
static inline void i_readcount_dec(struct inode *inode)
{
  if (__builtin_expect ( atomic_read ( ( atomic_t const *) & ( * inode ) . i_readcount ) == 0 , 0L ) != 0L)
  {
# 2343 "include/linux/fs.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/fs.h" ) , "i" ( 2343 ) , "i" ( 12UL ) ) ;
    ldv_23350:;
# 2343 "include/linux/fs.h"
    goto ldv_23350;
  }
# 2344 "include/linux/fs.h"
  atomic_dec ( & ( * inode ) . i_readcount );
}
static inline void i_readcount_inc(struct inode *inode)
{
  atomic_inc ( & ( * inode ) . i_readcount );
}
# 2360 "include/linux/fs.h"
int do_pipe_flags(int *, int);
# 2362 "include/linux/fs.h"
int kernel_read(struct file *, loff_t, char *, long unsigned int);
ssize_t kernel_write(struct file *, char const *, size_t, loff_t);
ssize_t __kernel_write(struct file *, char const *, size_t, loff_t *);
struct file *open_exec(char const *);
# 2368 "include/linux/fs.h"
int is_subdir(struct dentry *, struct dentry *);
int path_is_under(struct path *, struct path *);
# 2374 "include/linux/fs.h"
loff_t default_llseek(struct file *, loff_t, int);
# 2376 "include/linux/fs.h"
loff_t vfs_llseek(struct file *, loff_t, int);
# 2378 "include/linux/fs.h"
int inode_init_always(struct super_block *, struct inode *);
void inode_init_once(struct inode *);
void address_space_init_once(struct address_space *);
struct inode *igrab(struct inode *);
ino_t iunique(struct super_block *, ino_t);
int inode_needs_sync(struct inode *);
int generic_delete_inode(struct inode *);
static inline int generic_drop_inode(struct inode *inode)
{
  return ( unsigned int ) ( * inode ) . ldv_21969 . i_nlink == 0U || inode_unhashed ( inode ) != 0;
}
# 2390 "include/linux/fs.h"
struct inode *ilookup5_nowait(struct super_block *, long unsigned int, int (*)(struct inode *, void *), void *);
# 2393 "include/linux/fs.h"
struct inode *ilookup5(struct super_block *, long unsigned int, int (*)(struct inode *, void *), void *);
# 2395 "include/linux/fs.h"
struct inode *ilookup(struct super_block *, long unsigned int);
# 2397 "include/linux/fs.h"
struct inode *iget5_locked(struct super_block *, long unsigned int, int (*)(struct inode *, void *), int (*)(struct inode *, void *), void *);
struct inode *iget_locked(struct super_block *, long unsigned int);
int insert_inode_locked4(struct inode *, long unsigned int, int (*)(struct inode *, void *), void *);
int insert_inode_locked(struct inode *);
# 2402 "include/linux/fs.h"
void lockdep_annotate_inode_mutex_key(struct inode *);
# 2406 "include/linux/fs.h"
void unlock_new_inode(struct inode *);
unsigned int get_next_ino(void);
# 2409 "include/linux/fs.h"
void __iget(struct inode *);
void iget_failed(struct inode *);
void clear_inode(struct inode *);
void __destroy_inode(struct inode *);
struct inode *new_inode_pseudo(struct super_block *);
struct inode *new_inode(struct super_block *);
void free_inode_nonrcu(struct inode *);
int should_remove_suid(struct dentry *);
int file_remove_suid(struct file *);
# 2419 "include/linux/fs.h"
void __insert_inode_hash(struct inode *, long unsigned int);
static inline void insert_inode_hash(struct inode *inode)
{
  __insert_inode_hash ( inode , ( * inode ) . i_ino );
}
# 2425 "include/linux/fs.h"
void __remove_inode_hash(struct inode *);
static inline void remove_inode_hash(struct inode *inode)
{
  if (inode_unhashed ( inode ) == 0)
    __remove_inode_hash ( inode );
}
# 2432 "include/linux/fs.h"
void inode_sb_list_add(struct inode *);
# 2435 "include/linux/fs.h"
void submit_bio(int, struct bio *);
int bdev_read_only(struct block_device *);
# 2438 "include/linux/fs.h"
int set_blocksize(struct block_device *, int);
int sb_set_blocksize(struct super_block *, int);
int sb_min_blocksize(struct super_block *, int);
# 2442 "include/linux/fs.h"
int generic_file_mmap(struct file *, struct vm_area_struct *);
int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
int generic_file_remap_pages(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int);
# 2446 "include/linux/fs.h"
int generic_write_checks(struct file *, loff_t *, size_t *, int);
ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);
ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *, loff_t);
ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
ssize_t do_sync_read(struct file *, char *, size_t, loff_t *);
ssize_t do_sync_write(struct file *, char const *, size_t, loff_t *);
ssize_t new_sync_read(struct file *, char *, size_t, loff_t *);
ssize_t new_sync_write(struct file *, char const *, size_t, loff_t *);
# 2458 "include/linux/fs.h"
ssize_t blkdev_write_iter(struct kiocb *, struct iov_iter *);
int blkdev_fsync(struct file *, loff_t, loff_t, int);
# 2461 "include/linux/fs.h"
void block_sync_page(struct page *);
# 2464 "include/linux/fs.h"
ssize_t generic_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
# 2466 "include/linux/fs.h"
ssize_t default_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
# 2468 "include/linux/fs.h"
ssize_t iter_file_splice_write(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
# 2470 "include/linux/fs.h"
ssize_t generic_splice_sendpage(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
# 2474 "include/linux/fs.h"
void file_ra_state_init(struct file_ra_state *, struct address_space *);
loff_t noop_llseek(struct file *, loff_t, int);
loff_t no_llseek(struct file *, loff_t, int);
loff_t vfs_setpos(struct file *, loff_t, loff_t);
loff_t generic_file_llseek(struct file *, loff_t, int);
loff_t generic_file_llseek_size(struct file *, loff_t, int, loff_t, loff_t);
# 2481 "include/linux/fs.h"
loff_t fixed_size_llseek(struct file *, loff_t, int, loff_t);
# 2483 "include/linux/fs.h"
int generic_file_open(struct inode *, struct file *);
int nonseekable_open(struct inode *, struct file *);
# 2487 "include/linux/fs.h"
ssize_t xip_file_read(struct file *, char *, size_t, loff_t *);
# 2489 "include/linux/fs.h"
int xip_file_mmap(struct file *, struct vm_area_struct *);
ssize_t xip_file_write(struct file *, char const *, size_t, loff_t *);
# 2492 "include/linux/fs.h"
int xip_truncate_page(struct address_space *, loff_t);
# 2501 "include/linux/fs.h"
typedef void dio_submit_t(int, struct bio *, struct inode *, loff_t);
enum ldv_18456
{
  DIO_LOCKING = 1,
  DIO_SKIP_HOLES = 2,
  DIO_ASYNC_EXTEND = 4
};
# 2515 "include/linux/fs.h"
void dio_end_io(struct bio *, int);
# 2517 "include/linux/fs.h"
ssize_t __blockdev_direct_IO(int, struct kiocb *, struct inode *, struct block_device *, struct iov_iter *, loff_t, get_block_t *, dio_iodone_t *, dio_submit_t *, int);
# 2522 "include/linux/fs.h"
static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode, struct iov_iter *iter, loff_t offset, get_block_t *get_block)
{
# 2526 "include/linux/fs.h"
  return __blockdev_direct_IO ( rw , iocb , inode , ( * ( * inode ) . i_sb ) . s_bdev , iter , offset , get_block , ( ( dio_iodone_t *) 0 ) , ( ( dio_submit_t *) 0 ) , 3 );
}
# 2532 "include/linux/fs.h"
void inode_dio_wait(struct inode *);
void inode_dio_done(struct inode *);
# 2535 "include/linux/fs.h"
void inode_set_flags(struct inode *, unsigned int, unsigned int);
# 2538 "include/linux/fs.h"
extern struct file_operations const generic_ro_fops;
# 2542 "include/linux/fs.h"
int readlink_copy(char *, int, char const *);
int page_readlink(struct dentry *, char *, int);
void *page_follow_link_light(struct dentry *, struct nameidata *);
void page_put_link(struct dentry *, struct nameidata *, void *);
int __page_symlink(struct inode *, char const *, int, int);
# 2548 "include/linux/fs.h"
int page_symlink(struct inode *, char const *, int);
extern struct inode_operations const page_symlink_inode_operations;
void kfree_put_link(struct dentry *, struct nameidata *, void *);
int generic_readlink(struct dentry *, char *, int);
void generic_fillattr(struct inode *, struct kstat *);
int vfs_getattr_nosec(struct path *, struct kstat *);
int vfs_getattr(struct path *, struct kstat *);
void __inode_add_bytes(struct inode *, loff_t);
void inode_add_bytes(struct inode *, loff_t);
void __inode_sub_bytes(struct inode *, loff_t);
void inode_sub_bytes(struct inode *, loff_t);
loff_t inode_get_bytes(struct inode *);
void inode_set_bytes(struct inode *, loff_t);
# 2562 "include/linux/fs.h"
int vfs_readdir(struct file *, filldir_t, void *);
int iterate_dir(struct file *, struct dir_context *);
# 2565 "include/linux/fs.h"
int vfs_stat(char const *, struct kstat *);
int vfs_lstat(char const *, struct kstat *);
int vfs_fstat(unsigned int, struct kstat *);
int vfs_fstatat(int, char const *, struct kstat *, int);
# 2570 "include/linux/fs.h"
int do_vfs_ioctl(struct file *, unsigned int, unsigned int, long unsigned int);
# 2572 "include/linux/fs.h"
int __generic_block_fiemap(struct inode *, struct fiemap_extent_info *, loff_t, loff_t, get_block_t *);
# 2576 "include/linux/fs.h"
int generic_block_fiemap(struct inode *, struct fiemap_extent_info *, u64, u64, get_block_t *);
# 2580 "include/linux/fs.h"
void get_filesystem(struct file_system_type *);
void put_filesystem(struct file_system_type *);
struct file_system_type *get_fs_type(char const *);
struct super_block *get_super(struct block_device *);
struct super_block *get_super_thawed(struct block_device *);
struct super_block *get_active_super(struct block_device *);
void drop_super(struct super_block *);
void iterate_supers(void (*)(struct super_block *, void *), void *);
void iterate_supers_type(struct file_system_type *, void (*)(struct super_block *, void *), void *);
# 2591 "include/linux/fs.h"
int dcache_dir_open(struct inode *, struct file *);
int dcache_dir_close(struct inode *, struct file *);
loff_t dcache_dir_lseek(struct file *, loff_t, int);
int dcache_readdir(struct file *, struct dir_context *);
int simple_setattr(struct dentry *, struct iattr *);
int simple_getattr(struct vfsmount *, struct dentry *, struct kstat *);
int simple_statfs(struct dentry *, struct kstatfs *);
int simple_open(struct inode *, struct file *);
int simple_link(struct dentry *, struct inode *, struct dentry *);
int simple_unlink(struct inode *, struct dentry *);
int simple_rmdir(struct inode *, struct dentry *);
int simple_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
int noop_fsync(struct file *, loff_t, loff_t, int);
int simple_empty(struct dentry *);
int simple_readpage(struct file *, struct page *);
int simple_write_begin(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page **, void **);
# 2609 "include/linux/fs.h"
int simple_write_end(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page *, void *);
# 2612 "include/linux/fs.h"
int always_delete_dentry(struct dentry const *);
struct inode *alloc_anon_inode(struct super_block *);
extern struct dentry_operations const simple_dentry_operations;
# 2616 "include/linux/fs.h"
struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned int);
ssize_t generic_read_dir(struct file *, char *, size_t, loff_t *);
extern struct file_operations const simple_dir_operations;
extern struct inode_operations const simple_dir_inode_operations;
struct tree_descr
{
# 2620 "include/linux/fs.h"
  char *name;
# 2620 "include/linux/fs.h"
  struct file_operations const *ops;
# 2620 "include/linux/fs.h"
  int mode;
};
# 2621 "include/linux/fs.h"
struct dentry *d_alloc_name(struct dentry *, char const *);
int simple_fill_super(struct super_block *, long unsigned int, struct tree_descr *);
int simple_pin_fs(struct file_system_type *, struct vfsmount **, int *);
void simple_release_fs(struct vfsmount **, int *);
# 2626 "include/linux/fs.h"
ssize_t simple_read_from_buffer(void *, size_t, loff_t *, void const *, size_t);
# 2628 "include/linux/fs.h"
ssize_t simple_write_to_buffer(void *, size_t, loff_t *, void const *, size_t);
# 2631 "include/linux/fs.h"
int __generic_file_fsync(struct file *, loff_t, loff_t, int);
int generic_file_fsync(struct file *, loff_t, loff_t, int);
# 2634 "include/linux/fs.h"
int generic_check_addressable(unsigned int, u64);
# 2637 "include/linux/fs.h"
int buffer_migrate_page(struct address_space *, struct page *, struct page *, enum migrate_mode);
# 2644 "include/linux/fs.h"
int inode_change_ok(struct inode const *, struct iattr *);
int inode_newsize_ok(struct inode const *, loff_t);
void setattr_copy(struct inode *, struct iattr const *);
# 2648 "include/linux/fs.h"
int file_update_time(struct file *);
# 2650 "include/linux/fs.h"
int generic_show_options(struct seq_file *, struct dentry *);
void save_mount_options(struct super_block *, char *);
void replace_mount_options(struct super_block *, char *);
# 2654 "include/linux/fs.h"
static inline ino_t parent_ino(struct dentry *dentry)
{
  ino_t res;
# 2662 "include/linux/fs.h"
  spin_lock ( & ( * dentry ) . d_lockref . ldv_20603 . ldv_20602 . lock );
  res = ( * ( * ( * dentry ) . d_parent ) . d_inode ) . i_ino;
  spin_unlock ( & ( * dentry ) . d_lockref . ldv_20603 . ldv_20602 . lock );
  return res;
}
struct simple_transaction_argresp
{
# 2675 "include/linux/fs.h"
  ssize_t size;
  char data[0U];
};
# 2681 "include/linux/fs.h"
char *simple_transaction_get(struct file *, char const *, size_t);
# 2683 "include/linux/fs.h"
ssize_t simple_transaction_read(struct file *, char *, size_t, loff_t *);
# 2685 "include/linux/fs.h"
int simple_transaction_release(struct inode *, struct file *);
# 2687 "include/linux/fs.h"
void simple_transaction_set(struct file *, size_t);
# 2721 "include/linux/fs.h"
static inline void __simple_attr_check_format(char const *fmt, ...)
{
}
# 2726 "include/linux/fs.h"
int simple_attr_open(struct inode *, struct file *, int (*)(void *, u64 *), int (*)(void *, u64), char const *);
# 2729 "include/linux/fs.h"
int simple_attr_release(struct inode *, struct file *);
ssize_t simple_attr_read(struct file *, char *, size_t, loff_t *);
# 2732 "include/linux/fs.h"
ssize_t simple_attr_write(struct file *, char const *, size_t, loff_t *);
# 2736 "include/linux/fs.h"
int proc_nr_files(struct ctl_table *, int, void *, size_t *, loff_t *);
# 2738 "include/linux/fs.h"
int proc_nr_dentry(struct ctl_table *, int, void *, size_t *, loff_t *);
# 2740 "include/linux/fs.h"
int proc_nr_inodes(struct ctl_table *, int, void *, size_t *, loff_t *);
# 2742 "include/linux/fs.h"
int get_filesystem_list(char *);
# 2751 "include/linux/fs.h"
static inline int is_sxid(umode_t mode)
{
  return ( ( int ) mode & 2048 ) != 0 || ( ( int ) mode & 1024 ) != 0 && ( ( int ) mode & 8 ) != 0;
}
# 2756 "include/linux/fs.h"
static inline void inode_has_no_xattr(struct inode *inode)
{
  if (is_sxid ( ( int ) ( * inode ) . i_mode ) == 0 && ( ( * ( * inode ) . i_sb ) . s_flags & 268435456UL ) != 0UL)
    ( * inode ) . i_flags |= 4096U;
}
# 2762 "include/linux/fs.h"
static inline bool dir_emit(struct dir_context *ctx, char const *name, int namelen, u64 ino, unsigned int type)
{
# 2766 "include/linux/fs.h"
  return ( * ctx ) . actor ( ( void *) ctx , name , namelen , ( * ctx ) . pos , ino , type ) == 0;
}
static inline bool dir_emit_dot(struct file *file, struct dir_context *ctx)
{
  return ( * ctx ) . actor ( ( void *) ctx , ( char const *) "." , 1 , ( * ctx ) . pos , ( u64 ) (
# 2771 "include/linux/fs.h"
  * ( * ( * file ) . f_path . dentry ) . d_inode ) . i_ino , 4U ) == 0;
}
static inline bool dir_emit_dotdot(struct file *file, struct dir_context *ctx)
{
  return ( * ctx ) . actor ( ( void *) ctx , ( char const *) ".." , 2 , ( * ctx ) . pos , ( u64 ) parent_ino
# 2776 "include/linux/fs.h"
  ( ( * file ) . f_path . dentry ) , 4U ) == 0;
}
static inline bool dir_emit_dots(struct file *file, struct dir_context *ctx)
{
  if (( * ctx ) . pos == 0LL)
  {
# 2781 "include/linux/fs.h"
    if (( int ) ! ( _Bool ) dir_emit_dot ( file , ctx ))
      return 0;
    ( * ctx ) . pos = 1LL;
  }
  if (( * ctx ) . pos == 1LL)
  {
# 2786 "include/linux/fs.h"
    if (( int ) ! ( _Bool ) dir_emit_dotdot ( file , ctx ))
      return 0;
    ( * ctx ) . pos = 2LL;
  }
  return 1;
}
static inline bool dir_relax(struct inode *inode)
{
  ldv_mutex_unlock_6 ( & ( * inode ) . i_mutex );
  ldv_mutex_lock_7 ( & ( * inode ) . i_mutex );
  return ( ( * inode ) . i_flags & 16U ) == 0U;
}
struct partition
{
# 69 "include/linux/genhd.h"
  unsigned char boot_ind;
  unsigned char head;
  unsigned char sector;
  unsigned char cyl;
  unsigned char sys_ind;
  unsigned char end_head;
  unsigned char end_sector;
  unsigned char end_cyl;
  __le32 start_sect;
  __le32 nr_sects;
};
struct disk_stats
{
  long unsigned int sectors[2U];
  long unsigned int ios[2U];
  long unsigned int merges[2U];
  long unsigned int ticks[2U];
  long unsigned int io_ticks;
  long unsigned int time_in_queue;
};
struct partition_meta_info
{
# 98 "include/linux/genhd.h"
  char uuid[37U];
  u8 volname[64U];
};
struct hd_struct
{
  sector_t start_sect;
# 109 "include/linux/genhd.h"
  sector_t nr_sects;
  seqcount_t nr_sects_seq;
  sector_t alignment_offset;
  unsigned int discard_alignment;
  struct device __dev;
  struct kobject *holder_dir;
  int policy;
# 115 "include/linux/genhd.h"
  int partno;
  struct partition_meta_info *info;
# 118 "include/linux/genhd.h"
  int make_it_fail;
# 120 "include/linux/genhd.h"
  long unsigned int stamp;
  atomic_t in_flight[2U];
# 123 "include/linux/genhd.h"
  struct disk_stats *dkstats;
# 127 "include/linux/genhd.h"
  atomic_t ref;
  struct callback_head callback_head;
};
enum ldv_18657
{
  DISK_EVENT_MEDIA_CHANGE = 1,
  DISK_EVENT_EJECT_REQUEST = 2
};
struct blk_scsi_cmd_filter
{
# 151 "include/linux/genhd.h"
  long unsigned int read_ok[4U];
  long unsigned int write_ok[4U];
  struct kobject kobj;
};
struct disk_part_tbl
{
  struct callback_head callback_head;
  int len;
  struct hd_struct *last_lookup;
  struct hd_struct *part[];
};
struct disk_events;
struct gendisk
{
# 169 "include/linux/genhd.h"
  int major;
  int first_minor;
  int minors;
# 174 "include/linux/genhd.h"
  char disk_name[32U];
  char *(*devnode)(struct gendisk *, umode_t *);
# 177 "include/linux/genhd.h"
  unsigned int events;
  unsigned int async_events;
# 185 "include/linux/genhd.h"
  struct disk_part_tbl *part_tbl;
  struct hd_struct part0;
# 188 "include/linux/genhd.h"
  struct block_device_operations const *fops;
  struct request_queue *queue;
  void *private_data;
# 192 "include/linux/genhd.h"
  int flags;
  struct device *driverfs_dev;
  struct kobject *slave_dir;
# 196 "include/linux/genhd.h"
  struct timer_rand_state *random;
  atomic_t sync_io;
  struct disk_events *ev;
# 200 "include/linux/genhd.h"
  struct blk_integrity *integrity;
# 202 "include/linux/genhd.h"
  int node_id;
};
# 205 "include/linux/genhd.h"
static inline struct gendisk *part_to_disk(struct hd_struct *part)
{
  if (__builtin_expect ( part != ( ( struct hd_struct *) 0 ) , 1L ) != 0L)
    if (( * part ) . partno != 0)
    {
# 209 "include/linux/genhd.h"
      return ({
# 209 "include/linux/genhd.h"
        struct device const *__mptr = ( struct device const *) ( * part ) . __dev . parent;
# 209 "include/linux/genhd.h"
        ( struct gendisk *) __mptr + 18446744073709551456U;
      } );
    }
    else
# 211 "include/linux/genhd.h"
      return ({
# 211 "include/linux/genhd.h"
        struct device const *__mptr = ( struct device const *) & ( * part ) . __dev;
# 211 "include/linux/genhd.h"
        ( struct gendisk *) __mptr + 18446744073709551456U;
      } );
  return ( ( struct gendisk *) 0 );
}
# 216 "include/linux/genhd.h"
static inline void part_pack_uuid(u8 const *uuid_str, u8 *to)
{
  int i;
  i = 0;
# 219 "include/linux/genhd.h"
  goto ldv_24137;
  ldv_24136:;
# 220 "include/linux/genhd.h"
  * to ++ = ( u8 ) ( ( signed char ) ( hex_to_bin ( ( int ) ( char ) * uuid_str ) << 4 ) | ( signed char ) hex_to_bin
# 221 "include/linux/genhd.h"
  ( ( int ) ( char ) * ( uuid_str + 1UL ) ) );
  uuid_str += 2UL;
  switch (i)
  {
# 224 "include/linux/genhd.h"
    case 3:;
    case 5:;
    case 7:;
    case 9:;
    uuid_str ++;
    goto ldv_24135;
  }
  ldv_24135:;
# 219 "include/linux/genhd.h"
  ++ i;
  ldv_24137:;
# 219 "include/linux/genhd.h"
  if (i <= 15)
  {
    goto ldv_24136;
  }
  else
    goto ldv_24138;
  ldv_24138:;
}
# 234 "include/linux/genhd.h"
static inline int blk_part_pack_uuid(u8 const *uuid_str, u8 *to)
{
  part_pack_uuid ( uuid_str , to );
  return 0;
}
# 240 "include/linux/genhd.h"
static inline int disk_max_parts(struct gendisk *disk)
{
  if (( ( * disk ) . flags & 64 ) != 0)
    return 256;
  return ( * disk ) . minors;
}
# 247 "include/linux/genhd.h"
static inline bool disk_part_scan_enabled(struct gendisk *disk)
{
  return ( bool ) ( disk_max_parts ( disk ) > 1 && ( (
# 250 "include/linux/genhd.h"
  * disk ) . flags & 512 ) == 0 );
}
# 253 "include/linux/genhd.h"
static inline dev_t disk_devt(struct gendisk *disk)
{
  return ( * disk ) . part0 . __dev . devt;
}
# 258 "include/linux/genhd.h"
static inline dev_t part_devt(struct hd_struct *part)
{
  return ( * part ) . __dev . devt;
}
# 263 "include/linux/genhd.h"
struct hd_struct *disk_get_part(struct gendisk *, int);
# 265 "include/linux/genhd.h"
static inline void disk_put_part(struct hd_struct *part)
{
  if (__builtin_expect ( part != ( ( struct hd_struct *) 0 ) , 1L ) != 0L)
    put_device ( & ( * part ) . __dev );
}
struct disk_part_iter
{
# 280 "include/linux/genhd.h"
  struct gendisk *disk;
  struct hd_struct *part;
  int idx;
  unsigned int flags;
};
# 286 "include/linux/genhd.h"
void disk_part_iter_init(struct disk_part_iter *, struct gendisk *, unsigned int);
# 288 "include/linux/genhd.h"
struct hd_struct *disk_part_iter_next(struct disk_part_iter *);
void disk_part_iter_exit(struct disk_part_iter *);
# 291 "include/linux/genhd.h"
struct hd_struct *disk_map_sector_rcu(struct gendisk *, sector_t);
# 322 "include/linux/genhd.h"
static inline void part_stat_set_all(struct hd_struct *part, int value)
{
  int i;
# 326 "include/linux/genhd.h"
  i = -1;
# 326 "include/linux/genhd.h"
  goto ldv_24187;
  ldv_24186:;
# 327 "include/linux/genhd.h"
  memset ( ( void *) ({
    {
# 327 "include/linux/genhd.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 327 "include/linux/genhd.h"
      ( void ) __vpp_verify;
    }
# 327 "include/linux/genhd.h"
    ({
# 327 "include/linux/genhd.h"
      long unsigned int __ptr;
# 327 "include/linux/genhd.h"
      asm ( "" : "=r" ( __ptr ) : "0" ( ( * part ) . dkstats ) ) ;
# 327 "include/linux/genhd.h"
      ( struct disk_stats *) ( __per_cpu_offset [ i ] + __ptr );
    } );
  } ) , value , 80UL );
  ldv_24187:;
# 326 "include/linux/genhd.h"
  if (i = ( int ) cpumask_next ( i , cpu_possible_mask ), i < nr_cpu_ids)
  {
    goto ldv_24186;
  }
  else
    goto ldv_24188;
  ldv_24188:;
}
# 331 "include/linux/genhd.h"
static inline int init_part_stats(struct hd_struct *part)
{
  ( * part ) . dkstats = ( struct disk_stats *) __alloc_percpu ( 80UL , 8UL );
  if (( * part ) . dkstats == ( ( struct disk_stats *) 0 ))
    return 0;
  return 1;
}
# 339 "include/linux/genhd.h"
static inline void free_part_stats(struct hd_struct *part)
{
  free_percpu ( ( void *) ( * part ) . dkstats );
}
# 383 "include/linux/genhd.h"
static inline void part_inc_in_flight(struct hd_struct *part, int rw)
{
  atomic_inc ( ( atomic_t *) & ( * part ) . in_flight + ( long unsigned int ) rw );
  if (( * part ) . partno != 0)
    atomic_inc ( ( atomic_t *) & ( * part_to_disk ( part ) ) . part0 . in_flight + ( long unsigned int ) rw );
}
# 390 "include/linux/genhd.h"
static inline void part_dec_in_flight(struct hd_struct *part, int rw)
{
  atomic_dec ( ( atomic_t *) & ( * part ) . in_flight + ( long unsigned int ) rw );
  if (( * part ) . partno != 0)
    atomic_dec ( ( atomic_t *) & ( * part_to_disk ( part ) ) . part0 . in_flight + ( long unsigned int ) rw );
}
# 397 "include/linux/genhd.h"
static inline int part_in_flight(struct hd_struct *part)
{
  return atomic_read ( ( atomic_t const *) & ( * part ) . in_flight ) + atomic_read ( ( atomic_t const *) & ( * part ) . in_flight + 1U );
}
# 402 "include/linux/genhd.h"
static inline struct partition_meta_info *alloc_part_info(struct gendisk *disk)
{
  if (disk != ( ( struct gendisk *) 0 ))
    return ( struct partition_meta_info *) kzalloc_node ( 101UL , 208U , (
# 406 "include/linux/genhd.h"
    * disk ) . node_id );
  return ( struct partition_meta_info *) kzalloc ( 101UL , 208U );
}
# 410 "include/linux/genhd.h"
static inline void free_part_info(struct hd_struct *part)
{
  kfree ( ( void const *) ( * part ) . info );
}
# 416 "include/linux/genhd.h"
void part_round_stats(int, struct hd_struct *);
# 419 "include/linux/genhd.h"
void add_disk(struct gendisk *);
void del_gendisk(struct gendisk *);
struct gendisk *get_gendisk(dev_t, int *);
struct block_device *bdget_disk(struct gendisk *, int);
# 424 "include/linux/genhd.h"
void set_device_ro(struct block_device *, int);
void set_disk_ro(struct gendisk *, int);
# 427 "include/linux/genhd.h"
static inline int get_disk_ro(struct gendisk *disk)
{
  return ( * disk ) . part0 . policy;
}
# 432 "include/linux/genhd.h"
void disk_block_events(struct gendisk *);
void disk_unblock_events(struct gendisk *);
void disk_flush_events(struct gendisk *, unsigned int);
unsigned int disk_clear_events(struct gendisk *, unsigned int);
# 438 "include/linux/genhd.h"
void add_disk_randomness(struct gendisk *);
void rand_initialize_disk(struct gendisk *);
# 441 "include/linux/genhd.h"
static inline sector_t get_start_sect(struct block_device *bdev)
{
  return ( * ( * bdev ) . bd_part ) . start_sect;
}
static inline sector_t get_capacity(struct gendisk *disk)
{
  return ( * disk ) . part0 . nr_sects;
}
static inline void set_capacity(struct gendisk *disk, sector_t size)
{
  ( * disk ) . part0 . nr_sects = size;
}
struct solaris_x86_slice
{
# 460 "include/linux/genhd.h"
  __le16 s_tag;
  __le16 s_flag;
  __le32 s_start;
  __le32 s_size;
};
struct solaris_x86_vtoc
{
  unsigned int v_bootinfo[3U];
  __le32 v_sanity;
  __le32 v_version;
  char v_volume[8U];
  __le16 v_sectorsz;
  __le16 v_nparts;
  unsigned int v_reserved[10U];
# 475 "include/linux/genhd.h"
  struct solaris_x86_slice v_slice[16U];
  unsigned int timestamp[16U];
  char v_asciilabel[128U];
};
struct bsd_partition
{
# 528 "include/linux/genhd.h"
  __le32 p_size;
  __le32 p_offset;
  __le32 p_fsize;
  __u8 p_fstype;
  __u8 p_frag;
  __le16 p_cpg;
};
struct bsd_disklabel
{
# 495 "include/linux/genhd.h"
  __le32 d_magic;
  __s16 d_type;
  __s16 d_subtype;
  char d_typename[16U];
  char d_packname[16U];
  __u32 d_secsize;
  __u32 d_nsectors;
  __u32 d_ntracks;
  __u32 d_ncylinders;
  __u32 d_secpercyl;
  __u32 d_secperunit;
  __u16 d_sparespertrack;
  __u16 d_sparespercyl;
  __u32 d_acylinders;
  __u16 d_rpm;
  __u16 d_interleave;
  __u16 d_trackskew;
  __u16 d_cylskew;
  __u32 d_headswitch;
  __u32 d_trkseek;
  __u32 d_flags;
# 517 "include/linux/genhd.h"
  __u32 d_drivedata[5U];
# 519 "include/linux/genhd.h"
  __u32 d_spare[5U];
  __le32 d_magic2;
  __le16 d_checksum;
# 524 "include/linux/genhd.h"
  __le16 d_npartitions;
  __le32 d_bbsize;
  __le32 d_sbsize;
# 534 "include/linux/genhd.h"
  struct bsd_partition d_partitions[16U];
};
struct unixware_slice
{
# 551 "include/linux/genhd.h"
  __le16 s_label;
  __le16 s_flags;
  __le32 start_sect;
  __le32 nr_sects;
};
struct unixware_vtoc
{
# 579 "include/linux/genhd.h"
  __le32 v_magic;
  __le32 v_version;
  char v_name[8U];
  __le16 v_nslices;
  __le16 v_unknown1;
  __le32 v_reserved[10U];
# 586 "include/linux/genhd.h"
  struct unixware_slice v_slice[16U];
};
struct unixware_disklabel
{
# 558 "include/linux/genhd.h"
  __le32 d_type;
  __le32 d_magic;
  __le32 d_version;
  char d_serial[12U];
  __le32 d_ncylinders;
  __le32 d_ntracks;
  __le32 d_nsectors;
  __le32 d_secsize;
  __le32 d_part_start;
  __le32 d_unknown1[12U];
  __le32 d_alt_tbl;
  __le32 d_alt_len;
  __le32 d_phys_cyl;
  __le32 d_phys_trk;
  __le32 d_phys_sec;
  __le32 d_phys_bytes;
  __le32 d_unknown2;
  __le32 d_unknown3;
  __le32 d_pad[8U];
# 587 "include/linux/genhd.h"
  struct unixware_vtoc vtoc;
};
# 601 "include/linux/genhd.h"
int blk_alloc_devt(struct hd_struct *, dev_t *);
void blk_free_devt(dev_t);
dev_t blk_lookup_devt(char const *, int);
char *disk_name(struct gendisk *, int, char *);
# 606 "include/linux/genhd.h"
int disk_expand_part_tbl(struct gendisk *, int);
int rescan_partitions(struct gendisk *, struct block_device *);
int invalidate_partitions(struct gendisk *, struct block_device *);
struct hd_struct *add_partition(struct gendisk *, int, sector_t, sector_t, int, struct partition_meta_info *);
# 614 "include/linux/genhd.h"
void __delete_partition(struct hd_struct *);
void delete_partition(struct gendisk *, int);
void printk_all_partitions(void);
# 618 "include/linux/genhd.h"
struct gendisk *alloc_disk_node(int, int);
struct gendisk *alloc_disk(int);
struct kobject *get_disk(struct gendisk *);
void put_disk(struct gendisk *);
void blk_register_region(dev_t, long unsigned int, struct module *, struct kobject *(*)(dev_t, int *, void *), int (*)(dev_t, void *), void *);
# 627 "include/linux/genhd.h"
void blk_unregister_region(dev_t, long unsigned int);
# 629 "include/linux/genhd.h"
ssize_t part_size_show(struct device *, struct device_attribute *, char *);
# 631 "include/linux/genhd.h"
ssize_t part_stat_show(struct device *, struct device_attribute *, char *);
# 633 "include/linux/genhd.h"
ssize_t part_inflight_show(struct device *, struct device_attribute *, char *);
# 636 "include/linux/genhd.h"
ssize_t part_fail_show(struct device *, struct device_attribute *, char *);
# 638 "include/linux/genhd.h"
ssize_t part_fail_store(struct device *, struct device_attribute *, char const *, size_t);
# 643 "include/linux/genhd.h"
static inline void hd_ref_init(struct hd_struct *part)
{
  atomic_set ( & ( * part ) . ref , 1 );
  asm volatile ( "mfence" : : : "memory" ) ;
}
# 649 "include/linux/genhd.h"
static inline void hd_struct_get(struct hd_struct *part)
{
  atomic_inc ( & ( * part ) . ref );
  asm volatile ( "" : : : "memory" ) ;
}
# 655 "include/linux/genhd.h"
static inline int hd_struct_try_get(struct hd_struct *part)
{
  return atomic_add_unless ( & ( * part ) . ref , 1 , 0 );
}
# 660 "include/linux/genhd.h"
static inline void hd_struct_put(struct hd_struct *part)
{
  if (atomic_dec_and_test ( & ( * part ) . ref ) != 0)
    __delete_partition ( part );
}
# 675 "include/linux/genhd.h"
static inline sector_t part_nr_sects_read(struct hd_struct *part)
{
# 693 "include/linux/genhd.h"
  return ( * part ) . nr_sects;
}
# 702 "include/linux/genhd.h"
static inline void part_nr_sects_write(struct hd_struct *part, sector_t size)
{
# 713 "include/linux/genhd.h"
  ( * part ) . nr_sects = size;
}
struct anon_vma_chain;
# 37 "include/linux/mm.h"
static inline void set_max_mapnr(long unsigned int limit)
{
}
extern long unsigned int totalram_pages;
extern void *high_memory;
extern int page_cluster;
# 45 "include/linux/mm.h"
extern int sysctl_legacy_va_layout;
# 20 "./arch/x86/include/asm/pgtable.h"
void ptdump_walk_pgd_level(struct seq_file *, pgd_t *);
# 26 "./arch/x86/include/asm/pgtable.h"
extern long unsigned int empty_zero_page[512U];
# 30 "./arch/x86/include/asm/pgtable.h"
extern spinlock_t pgd_lock;
extern struct list_head pgd_list;
# 33 "./arch/x86/include/asm/pgtable.h"
struct mm_struct *pgd_page_get_mm(struct page *);
# 92 "./arch/x86/include/asm/pgtable.h"
static inline int pte_dirty(pte_t pte)
{
  return ( int ) pte_flags ( pte ) & 64;
}
# 97 "./arch/x86/include/asm/pgtable.h"
static inline int pte_young(pte_t pte)
{
  return ( int ) pte_flags ( pte ) & 32;
}
# 102 "./arch/x86/include/asm/pgtable.h"
static inline int pmd_young(pmd_t pmd)
{
  return ( int ) pmd_flags ( pmd ) & 32;
}
# 107 "./arch/x86/include/asm/pgtable.h"
static inline int pte_write(pte_t pte)
{
  return ( int ) pte_flags ( pte ) & 2;
}
# 112 "./arch/x86/include/asm/pgtable.h"
static inline int pte_file(pte_t pte)
{
  return ( int ) pte_flags ( pte ) & 64;
}
# 117 "./arch/x86/include/asm/pgtable.h"
static inline int pte_huge(pte_t pte)
{
  return ( int ) pte_flags ( pte ) & 128;
}
# 122 "./arch/x86/include/asm/pgtable.h"
static inline int pte_global(pte_t pte)
{
  return ( int ) pte_flags ( pte ) & 256;
}
# 127 "./arch/x86/include/asm/pgtable.h"
static inline int pte_exec(pte_t pte)
{
  return ( long int ) pte_flags ( pte ) >= 0L;
}
# 132 "./arch/x86/include/asm/pgtable.h"
static inline int pte_special(pte_t pte)
{
  return ( ( long unsigned int ) pte_flags ( pte ) & 513UL ) == 513UL;
}
# 138 "./arch/x86/include/asm/pgtable.h"
static inline long unsigned int pte_pfn(pte_t pte)
{
  return ( ( long unsigned int ) pte_val ( pte ) & 70368744173568UL ) >> 12;
}
# 143 "./arch/x86/include/asm/pgtable.h"
static inline long unsigned int pmd_pfn(pmd_t pmd)
{
  return ( ( long unsigned int ) pmd_val ( pmd ) & 70368744173568UL ) >> 12;
}
# 148 "./arch/x86/include/asm/pgtable.h"
static inline long unsigned int pud_pfn(pud_t pud)
{
  return ( ( long unsigned int ) pud_val ( pud ) & 70368744173568UL ) >> 12;
}
# 155 "./arch/x86/include/asm/pgtable.h"
static inline int pmd_large(pmd_t pte)
{
  return ( int ) pmd_flags ( pte ) & 128;
}
# 161 "./arch/x86/include/asm/pgtable.h"
static inline int pmd_trans_splitting(pmd_t pmd)
{
  return ( int ) pmd_val ( pmd ) & 1024;
}
# 166 "./arch/x86/include/asm/pgtable.h"
static inline int pmd_trans_huge(pmd_t pmd)
{
  return ( int ) pmd_val ( pmd ) & 128;
}
# 171 "./arch/x86/include/asm/pgtable.h"
static inline int has_transparent_hugepage(void)
{
  return constant_test_bit ( 3L , ( long unsigned int const volatile *) & boot_cpu_data . x86_capability );
}
# 177 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_set_flags(pte_t pte, pteval_t set)
{
  pteval_t v = native_pte_val ( pte );
# 181 "./arch/x86/include/asm/pgtable.h"
  return native_make_pte ( v | set );
}
# 184 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_clear_flags(pte_t pte, pteval_t clear)
{
  pteval_t v = native_pte_val ( pte );
# 188 "./arch/x86/include/asm/pgtable.h"
  return native_make_pte ( ~ clear & v );
}
# 191 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_mkclean(pte_t pte)
{
  return pte_clear_flags ( pte , 64UL );
}
# 196 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_mkold(pte_t pte)
{
  return pte_clear_flags ( pte , 32UL );
}
# 201 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_wrprotect(pte_t pte)
{
  return pte_clear_flags ( pte , 2UL );
}
# 206 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_mkexec(pte_t pte)
{
  return pte_clear_flags ( pte , 9223372036854775808UL );
}
# 211 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_mkdirty(pte_t pte)
{
  return pte_set_flags ( pte , 2112UL );
}
# 216 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_mkyoung(pte_t pte)
{
  return pte_set_flags ( pte , 32UL );
}
# 221 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_mkwrite(pte_t pte)
{
  return pte_set_flags ( pte , 2UL );
}
# 226 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_mkhuge(pte_t pte)
{
  return pte_set_flags ( pte , 128UL );
}
# 231 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_clrhuge(pte_t pte)
{
  return pte_clear_flags ( pte , 128UL );
}
# 236 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_mkglobal(pte_t pte)
{
  return pte_set_flags ( pte , 256UL );
}
# 241 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_clrglobal(pte_t pte)
{
  return pte_clear_flags ( pte , 256UL );
}
# 246 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_mkspecial(pte_t pte)
{
  return pte_set_flags ( pte , 512UL );
}
# 251 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pmd_set_flags(pmd_t pmd, pmdval_t set)
{
  pmdval_t v = native_pmd_val ( pmd );
# 255 "./arch/x86/include/asm/pgtable.h"
  return __pmd ( v | set );
}
# 258 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pmd_clear_flags(pmd_t pmd, pmdval_t clear)
{
  pmdval_t v = native_pmd_val ( pmd );
# 262 "./arch/x86/include/asm/pgtable.h"
  return __pmd ( ~ clear & v );
}
# 265 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pmd_mkold(pmd_t pmd)
{
  return pmd_clear_flags ( pmd , 32UL );
}
# 270 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pmd_wrprotect(pmd_t pmd)
{
  return pmd_clear_flags ( pmd , 2UL );
}
# 275 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pmd_mkdirty(pmd_t pmd)
{
  return pmd_set_flags ( pmd , 2112UL );
}
# 280 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pmd_mkhuge(pmd_t pmd)
{
  return pmd_set_flags ( pmd , 128UL );
}
# 285 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pmd_mkyoung(pmd_t pmd)
{
  return pmd_set_flags ( pmd , 32UL );
}
# 290 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pmd_mkwrite(pmd_t pmd)
{
  return pmd_set_flags ( pmd , 2UL );
}
# 295 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pmd_mknotpresent(pmd_t pmd)
{
  return pmd_clear_flags ( pmd , 1UL );
}
# 301 "./arch/x86/include/asm/pgtable.h"
static inline int pte_soft_dirty(pte_t pte)
{
  return ( int ) pte_flags ( pte ) & 2048;
}
# 306 "./arch/x86/include/asm/pgtable.h"
static inline int pmd_soft_dirty(pmd_t pmd)
{
  return ( int ) pmd_flags ( pmd ) & 2048;
}
# 311 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_mksoft_dirty(pte_t pte)
{
  return pte_set_flags ( pte , 2048UL );
}
# 316 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pmd_mksoft_dirty(pmd_t pmd)
{
  return pmd_set_flags ( pmd , 2048UL );
}
# 321 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_file_clear_soft_dirty(pte_t pte)
{
  return pte_clear_flags ( pte , 2048UL );
}
# 326 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_file_mksoft_dirty(pte_t pte)
{
  return pte_set_flags ( pte , 2048UL );
}
# 331 "./arch/x86/include/asm/pgtable.h"
static inline int pte_file_soft_dirty(pte_t pte)
{
  return ( int ) pte_flags ( pte ) & 2048;
}
# 342 "./arch/x86/include/asm/pgtable.h"
static inline pgprotval_t massage_pgprot(pgprot_t pgprot)
{
  pgprotval_t protval = pgprot . pgprot;
# 346 "./arch/x86/include/asm/pgtable.h"
  if (( int ) protval & 1)
    protval = ( long unsigned int ) protval & ( long unsigned int ) __supported_pte_mask;
# 349 "./arch/x86/include/asm/pgtable.h"
  return protval;
}
# 352 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pfn_pte(long unsigned int page_nr, pgprot_t pgprot)
{
  return __pte ( ( pteval_t ) ( ( long long unsigned int ) page_nr << 12 | ( long long unsigned int ) massage_pgprot
# 355 "./arch/x86/include/asm/pgtable.h"
  ( pgprot ) ) );
}
# 358 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pfn_pmd(long unsigned int page_nr, pgprot_t pgprot)
{
  return __pmd ( ( pmdval_t ) ( ( long long unsigned int ) page_nr << 12 | ( long long unsigned int ) massage_pgprot
# 361 "./arch/x86/include/asm/pgtable.h"
  ( pgprot ) ) );
}
# 364 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
{
  pteval_t val = pte_val ( pte );
# 372 "./arch/x86/include/asm/pgtable.h"
  val = ( long unsigned int ) val & 70368744176248UL;
  val = ( long unsigned int ) massage_pgprot ( newprot ) & 18446673704965375367UL | ( long unsigned int ) val;
# 375 "./arch/x86/include/asm/pgtable.h"
  return __pte ( val );
}
# 378 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pmd_modify(pmd_t pmd, pgprot_t newprot)
{
  pmdval_t val = pmd_val ( pmd );
# 382 "./arch/x86/include/asm/pgtable.h"
  val = ( long unsigned int ) val & 70368744176376UL;
  val = ( long unsigned int ) massage_pgprot ( newprot ) & 18446673704965375239UL | ( long unsigned int ) val;
# 385 "./arch/x86/include/asm/pgtable.h"
  return __pmd ( val );
}
# 390 "./arch/x86/include/asm/pgtable.h"
static inline pgprot_t pgprot_modify(pgprot_t oldprot, pgprot_t newprot)
{
  pgprotval_t preservebits = ( long unsigned int ) oldprot . pgprot & 70368744176248UL;
  pgprotval_t addbits = newprot . pgprot;
  return ( pgprot_t ) { . pgprot = preservebits | addbits };
}
# 401 "./arch/x86/include/asm/pgtable.h"
static inline int is_new_memtype_allowed(u64 paddr, long unsigned int size, long unsigned int flags, long unsigned int new_flags)
{
# 408 "./arch/x86/include/asm/pgtable.h"
  if (( int ) x86_platform . is_untracked_pat_range ( paddr , ( long long unsigned int ) paddr + ( long long unsigned int ) size ))
    return 1;
# 417 "./arch/x86/include/asm/pgtable.h"
  if (flags == 16UL && new_flags
# 418 "./arch/x86/include/asm/pgtable.h"
  == 0UL || flags
# 419 "./arch/x86/include/asm/pgtable.h"
  == 8UL && new_flags
# 420 "./arch/x86/include/asm/pgtable.h"
  == 0UL)
    return 0;
# 424 "./arch/x86/include/asm/pgtable.h"
  return 1;
}
# 427 "./arch/x86/include/asm/pgtable.h"
pmd_t *populate_extra_pmd(long unsigned int);
pte_t *populate_extra_pte(long unsigned int);
# 17 "./arch/x86/include/asm/pgtable_64.h"
extern pud_t level3_kernel_pgt[512U];
extern pud_t level3_ident_pgt[512U];
extern pmd_t level2_kernel_pgt[512U];
extern pmd_t level2_fixmap_pgt[512U];
extern pmd_t level2_ident_pgt[512U];
extern pgd_t init_level4_pgt[];
# 26 "./arch/x86/include/asm/pgtable_64.h"
void paging_init(void);
# 43 "./arch/x86/include/asm/pgtable_64.h"
void set_pte_vaddr_pud(pud_t *, long unsigned int, pte_t);
# 46 "./arch/x86/include/asm/pgtable_64.h"
static inline void native_pte_clear(struct mm_struct *mm, long unsigned int addr, pte_t *ptep)
{
# 49 "./arch/x86/include/asm/pgtable_64.h"
  * ptep = native_make_pte ( 0UL );
}
# 52 "./arch/x86/include/asm/pgtable_64.h"
static inline void native_set_pte(pte_t *ptep, pte_t pte)
{
  * ptep = pte;
}
# 57 "./arch/x86/include/asm/pgtable_64.h"
static inline void native_set_pte_atomic(pte_t *ptep, pte_t pte)
{
  native_set_pte ( ptep , pte );
}
# 62 "./arch/x86/include/asm/pgtable_64.h"
static inline void native_set_pmd(pmd_t *pmdp, pmd_t pmd)
{
  * pmdp = pmd;
}
# 67 "./arch/x86/include/asm/pgtable_64.h"
static inline void native_pmd_clear(pmd_t *pmd)
{
  native_set_pmd ( pmd , native_make_pmd ( 0UL ) );
}
# 72 "./arch/x86/include/asm/pgtable_64.h"
static inline pte_t native_ptep_get_and_clear(pte_t *xp)
{
# 75 "./arch/x86/include/asm/pgtable_64.h"
  return native_make_pte ( ({
# 75 "./arch/x86/include/asm/pgtable_64.h"
    pteval_t __ret = 0UL;
    {
# 75 "./arch/x86/include/asm/pgtable_64.h"
      switch (8UL)
      {
# 75 "./arch/x86/include/asm/pgtable_64.h"
        case 1:;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        asm volatile ( "xchgb %b0, %1\n" : "+q" ( __ret ) , "+m" ( ( * xp ) . pte ) : : "memory" , "cc" ) ;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        goto ldv_24682;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        case 2:;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        asm volatile ( "xchgw %w0, %1\n" : "+r" ( __ret ) , "+m" ( ( * xp ) . pte ) : : "memory" , "cc" ) ;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        goto ldv_24682;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        case 4:;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        asm volatile ( "xchgl %0, %1\n" : "+r" ( __ret ) , "+m" ( ( * xp ) . pte ) : : "memory" , "cc" ) ;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        goto ldv_24682;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        case 8:;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        asm volatile ( "xchgq %q0, %1\n" : "+r" ( __ret ) , "+m" ( ( * xp ) . pte ) : : "memory" , "cc" ) ;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        goto ldv_24682;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        default:;
# 75 "./arch/x86/include/asm/pgtable_64.h"
        __xchg_wrong_size ( );
      }
# 75 "./arch/x86/include/asm/pgtable_64.h"
      ldv_24682:;
    }
# 75 "./arch/x86/include/asm/pgtable_64.h"
    __ret;
  } ) );
}
# 85 "./arch/x86/include/asm/pgtable_64.h"
static inline pmd_t native_pmdp_get_and_clear(pmd_t *xp)
{
# 88 "./arch/x86/include/asm/pgtable_64.h"
  return native_make_pmd ( ({
# 88 "./arch/x86/include/asm/pgtable_64.h"
    pmdval_t __ret = 0UL;
    {
# 88 "./arch/x86/include/asm/pgtable_64.h"
      switch (8UL)
      {
# 88 "./arch/x86/include/asm/pgtable_64.h"
        case 1:;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        asm volatile ( "xchgb %b0, %1\n" : "+q" ( __ret ) , "+m" ( ( * xp ) . pmd ) : : "memory" , "cc" ) ;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        goto ldv_24693;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        case 2:;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        asm volatile ( "xchgw %w0, %1\n" : "+r" ( __ret ) , "+m" ( ( * xp ) . pmd ) : : "memory" , "cc" ) ;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        goto ldv_24693;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        case 4:;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        asm volatile ( "xchgl %0, %1\n" : "+r" ( __ret ) , "+m" ( ( * xp ) . pmd ) : : "memory" , "cc" ) ;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        goto ldv_24693;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        case 8:;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        asm volatile ( "xchgq %q0, %1\n" : "+r" ( __ret ) , "+m" ( ( * xp ) . pmd ) : : "memory" , "cc" ) ;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        goto ldv_24693;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        default:;
# 88 "./arch/x86/include/asm/pgtable_64.h"
        __xchg_wrong_size ( );
      }
# 88 "./arch/x86/include/asm/pgtable_64.h"
      ldv_24693:;
    }
# 88 "./arch/x86/include/asm/pgtable_64.h"
    __ret;
  } ) );
}
# 98 "./arch/x86/include/asm/pgtable_64.h"
static inline void native_set_pud(pud_t *pudp, pud_t pud)
{
  * pudp = pud;
}
# 103 "./arch/x86/include/asm/pgtable_64.h"
static inline void native_pud_clear(pud_t *pud)
{
  native_set_pud ( pud , native_make_pud ( 0UL ) );
}
# 108 "./arch/x86/include/asm/pgtable_64.h"
static inline void native_set_pgd(pgd_t *pgdp, pgd_t pgd)
{
  * pgdp = pgd;
}
# 113 "./arch/x86/include/asm/pgtable_64.h"
static inline void native_pgd_clear(pgd_t *pgd)
{
  native_set_pgd ( pgd , native_make_pgd ( 0UL ) );
}
# 118 "./arch/x86/include/asm/pgtable_64.h"
void sync_global_pgds(long unsigned int, long unsigned int);
# 128 "./arch/x86/include/asm/pgtable_64.h"
static inline int pgd_large(pgd_t pgd)
{
# 128 "./arch/x86/include/asm/pgtable_64.h"
  return 0;
}
# 165 "./arch/x86/include/asm/pgtable_64.h"
int kern_addr_valid(long unsigned int);
void cleanup_highmap(void);
# 185 "./arch/x86/include/asm/pgtable_64.h"
void init_extra_mapping_uc(long unsigned int, long unsigned int);
void init_extra_mapping_wb(long unsigned int, long unsigned int);
# 442 "./arch/x86/include/asm/pgtable.h"
static inline int pte_none(pte_t pte)
{
  return pte . pte == 0UL;
}
# 448 "./arch/x86/include/asm/pgtable.h"
static inline int pte_same(pte_t a, pte_t b)
{
  return a . pte == b . pte;
}
# 453 "./arch/x86/include/asm/pgtable.h"
static inline int pte_present(pte_t a)
{
  return ( int ) pte_flags ( a ) & 769;
}
# 460 "./arch/x86/include/asm/pgtable.h"
static inline int pte_present_nonuma(pte_t a)
{
  return ( int ) pte_flags ( a ) & 257;
}
# 466 "./arch/x86/include/asm/pgtable.h"
static inline bool pte_accessible(struct mm_struct *mm, pte_t a)
{
  if (( int ) pte_flags ( a ) & 1)
    return 1;
# 471 "./arch/x86/include/asm/pgtable.h"
  if (( ( long unsigned int ) pte_flags ( a ) & 768UL ) != 0UL && ( int ) mm_tlb_flush_pending
# 472 "./arch/x86/include/asm/pgtable.h"
  ( mm ))
    return 1;
# 475 "./arch/x86/include/asm/pgtable.h"
  return 0;
}
# 478 "./arch/x86/include/asm/pgtable.h"
static inline int pte_hidden(pte_t pte)
{
  return pte_flags ( pte ), 0;
}
# 483 "./arch/x86/include/asm/pgtable.h"
static inline int pmd_present(pmd_t pmd)
{
# 491 "./arch/x86/include/asm/pgtable.h"
  return ( int ) pmd_flags ( pmd ) & 897;
}
# 495 "./arch/x86/include/asm/pgtable.h"
static inline int pmd_none(pmd_t pmd)
{
# 499 "./arch/x86/include/asm/pgtable.h"
  return native_pmd_val ( pmd ) == 0UL;
}
# 502 "./arch/x86/include/asm/pgtable.h"
static inline long unsigned int pmd_page_vaddr(pmd_t pmd)
{
  return ( ( long unsigned int ) pmd_val ( pmd ) & 70368744173568UL ) + 18446612132314218496UL;
}
# 519 "./arch/x86/include/asm/pgtable.h"
static inline long unsigned int pmd_index(long unsigned int address)
{
  return address >> 21 & 511UL;
}
# 539 "./arch/x86/include/asm/pgtable.h"
static inline long unsigned int pte_index(long unsigned int address)
{
  return address >> 12 & 511UL;
}
# 544 "./arch/x86/include/asm/pgtable.h"
static inline pte_t *pte_offset_kernel(pmd_t *pmd, long unsigned int address)
{
  return ( pte_t *) ( ( long unsigned int ) pte_index ( address ) + ( long unsigned int ) pmd_page_vaddr ( * pmd ) );
}
# 549 "./arch/x86/include/asm/pgtable.h"
static inline int pmd_bad(pmd_t pmd)
{
# 553 "./arch/x86/include/asm/pgtable.h"
  if (( ( long unsigned int ) pmd_flags ( pmd ) & 513UL ) == 512UL)
    return 0;
# 556 "./arch/x86/include/asm/pgtable.h"
  return ( ( long unsigned int ) pmd_flags ( pmd ) & 18446744073709551611UL ) != 99UL;
}
# 559 "./arch/x86/include/asm/pgtable.h"
static inline long unsigned int pages_to_mb(long unsigned int npg)
{
  return npg >> 8;
}
# 565 "./arch/x86/include/asm/pgtable.h"
static inline int pud_none(pud_t pud)
{
  return native_pud_val ( pud ) == 0UL;
}
# 570 "./arch/x86/include/asm/pgtable.h"
static inline int pud_present(pud_t pud)
{
  return ( int ) pud_flags ( pud ) & 1;
}
# 575 "./arch/x86/include/asm/pgtable.h"
static inline long unsigned int pud_page_vaddr(pud_t pud)
{
  return ( ( long unsigned int ) pud_val ( pud ) & 70368744173568UL ) + 18446612132314218496UL;
}
# 587 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t *pmd_offset(pud_t *pud, long unsigned int address)
{
  return ( pmd_t *) ( ( long unsigned int ) pmd_index ( address ) + ( long unsigned int ) pud_page_vaddr ( * pud ) );
}
# 592 "./arch/x86/include/asm/pgtable.h"
static inline int pud_large(pud_t pud)
{
  return ( ( long unsigned int ) pud_val ( pud ) & 129UL ) == 129UL;
}
# 598 "./arch/x86/include/asm/pgtable.h"
static inline int pud_bad(pud_t pud)
{
  return ( ( long unsigned int ) pud_flags ( pud ) & 18446744073709551512UL ) != 0UL;
}
# 610 "./arch/x86/include/asm/pgtable.h"
static inline int pgd_present(pgd_t pgd)
{
  return ( int ) pgd_flags ( pgd ) & 1;
}
# 615 "./arch/x86/include/asm/pgtable.h"
static inline long unsigned int pgd_page_vaddr(pgd_t pgd)
{
  return ( ( long unsigned int ) pgd_val ( pgd ) & 70368744173568UL ) + 18446612132314218496UL;
}
# 627 "./arch/x86/include/asm/pgtable.h"
static inline long unsigned int pud_index(long unsigned int address)
{
  return address >> 30 & 511UL;
}
# 632 "./arch/x86/include/asm/pgtable.h"
static inline pud_t *pud_offset(pgd_t *pgd, long unsigned int address)
{
  return ( pud_t *) ( ( long unsigned int ) pud_index ( address ) + ( long unsigned int ) pgd_page_vaddr ( * pgd ) );
}
# 637 "./arch/x86/include/asm/pgtable.h"
static inline int pgd_bad(pgd_t pgd)
{
  return ( ( long unsigned int ) pgd_flags ( pgd ) & 18446744073709551611UL ) != 99UL;
}
# 642 "./arch/x86/include/asm/pgtable.h"
static inline int pgd_none(pgd_t pgd)
{
  return native_pgd_val ( pgd ) == 0UL;
}
# 675 "./arch/x86/include/asm/pgtable.h"
extern int direct_gbpages;
void init_mem_mapping(void);
void early_alloc_pgt_buf(void);
# 680 "./arch/x86/include/asm/pgtable.h"
static inline pte_t native_local_ptep_get_and_clear(pte_t *ptep)
{
  pte_t res = * ptep;
# 685 "./arch/x86/include/asm/pgtable.h"
  native_pte_clear ( ( ( struct mm_struct *) 0 ) , 0UL , ptep );
  return res;
}
# 689 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t native_local_pmdp_get_and_clear(pmd_t *pmdp)
{
  pmd_t res = * pmdp;
# 693 "./arch/x86/include/asm/pgtable.h"
  native_pmd_clear ( pmdp );
  return res;
}
# 697 "./arch/x86/include/asm/pgtable.h"
static inline void native_set_pte_at(struct mm_struct *mm, long unsigned int addr, pte_t *ptep, pte_t pte)
{
# 700 "./arch/x86/include/asm/pgtable.h"
  native_set_pte ( ptep , pte );
}
# 703 "./arch/x86/include/asm/pgtable.h"
static inline void native_set_pmd_at(struct mm_struct *mm, long unsigned int addr, pmd_t *pmdp, pmd_t pmd)
{
# 706 "./arch/x86/include/asm/pgtable.h"
  native_set_pmd ( pmdp , pmd );
}
# 737 "./arch/x86/include/asm/pgtable.h"
int ptep_set_access_flags(struct vm_area_struct *, long unsigned int, pte_t *, pte_t, int);
# 742 "./arch/x86/include/asm/pgtable.h"
int ptep_test_and_clear_young(struct vm_area_struct *, long unsigned int, pte_t *);
# 746 "./arch/x86/include/asm/pgtable.h"
int ptep_clear_flush_young(struct vm_area_struct *, long unsigned int, pte_t *);
# 750 "./arch/x86/include/asm/pgtable.h"
static inline pte_t ptep_get_and_clear(struct mm_struct *mm, long unsigned int addr, pte_t *ptep)
{
# 753 "./arch/x86/include/asm/pgtable.h"
  pte_t pte = native_ptep_get_and_clear ( ptep );
  pte_update ( mm , addr , ptep );
  return pte;
}
# 759 "./arch/x86/include/asm/pgtable.h"
static inline pte_t ptep_get_and_clear_full(struct mm_struct *mm, long unsigned int addr, pte_t *ptep, int full)
{
# 763 "./arch/x86/include/asm/pgtable.h"
  pte_t pte;
  if (full != 0)
  {
# 769 "./arch/x86/include/asm/pgtable.h"
    pte = native_local_ptep_get_and_clear ( ptep );
  }
  else
# 771 "./arch/x86/include/asm/pgtable.h"
    pte = ptep_get_and_clear ( mm , addr , ptep );
# 773 "./arch/x86/include/asm/pgtable.h"
  return pte;
}
# 777 "./arch/x86/include/asm/pgtable.h"
static inline void ptep_set_wrprotect(struct mm_struct *mm, long unsigned int addr, pte_t *ptep)
{
# 780 "./arch/x86/include/asm/pgtable.h"
  clear_bit ( 1L , ( long unsigned int volatile *) & ( * ptep ) . pte );
  pte_update ( mm , addr , ptep );
}
# 789 "./arch/x86/include/asm/pgtable.h"
int pmdp_set_access_flags(struct vm_area_struct *, long unsigned int, pmd_t *, pmd_t, int);
# 794 "./arch/x86/include/asm/pgtable.h"
int pmdp_test_and_clear_young(struct vm_area_struct *, long unsigned int, pmd_t *);
# 798 "./arch/x86/include/asm/pgtable.h"
int pmdp_clear_flush_young(struct vm_area_struct *, long unsigned int, pmd_t *);
# 803 "./arch/x86/include/asm/pgtable.h"
void pmdp_splitting_flush(struct vm_area_struct *, long unsigned int, pmd_t *);
# 807 "./arch/x86/include/asm/pgtable.h"
static inline int pmd_write(pmd_t pmd)
{
  return ( int ) pmd_flags ( pmd ) & 2;
}
# 813 "./arch/x86/include/asm/pgtable.h"
static inline pmd_t pmdp_get_and_clear(struct mm_struct *mm, long unsigned int addr, pmd_t *pmdp)
{
# 816 "./arch/x86/include/asm/pgtable.h"
  pmd_t pmd = native_pmdp_get_and_clear ( pmdp );
  pmd_update ( mm , addr , pmdp );
  return pmd;
}
# 822 "./arch/x86/include/asm/pgtable.h"
static inline void pmdp_set_wrprotect(struct mm_struct *mm, long unsigned int addr, pmd_t *pmdp)
{
# 825 "./arch/x86/include/asm/pgtable.h"
  clear_bit ( 1L , ( long unsigned int volatile *) pmdp );
  pmd_update ( mm , addr , pmdp );
}
# 839 "./arch/x86/include/asm/pgtable.h"
static inline void clone_pgd_range(pgd_t *dst, pgd_t *src, int count)
{
  ({
# 841 "./arch/x86/include/asm/pgtable.h"
    size_t __len = ( long unsigned int ) count * 8UL;
# 841 "./arch/x86/include/asm/pgtable.h"
    void *__ret;
    {
# 841 "./arch/x86/include/asm/pgtable.h"
      if (0)
      {
# 841 "./arch/x86/include/asm/pgtable.h"
        __ret = __memcpy ( ( void *) dst , ( void const *) src , __len );
      }
      else
# 841 "./arch/x86/include/asm/pgtable.h"
        __ret = __builtin_memcpy ( ( void *) dst , ( void const *) src , __len );
    }
# 841 "./arch/x86/include/asm/pgtable.h"
    __ret;
  } );
}
# 845 "./arch/x86/include/asm/pgtable.h"
static inline int page_level_shift(enum pg_level level)
{
  return ( int ) ( ( unsigned int ) level * 9U + 3U );
}
static inline long unsigned int page_level_size(enum pg_level level)
{
  return 1UL << page_level_shift ( level );
}
static inline long unsigned int page_level_mask(enum pg_level level)
{
  return - page_level_size ( level );
}
# 862 "./arch/x86/include/asm/pgtable.h"
static inline void update_mmu_cache(struct vm_area_struct *vma, long unsigned int addr, pte_t *ptep)
{
}
# 866 "./arch/x86/include/asm/pgtable.h"
static inline void update_mmu_cache_pmd(struct vm_area_struct *vma, long unsigned int addr, pmd_t *pmd)
{
}
# 872 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_swp_mksoft_dirty(pte_t pte)
{
  if (__builtin_expect ( pte_present_nonuma ( pte ) != 0 , 0L ) != 0L)
  {
# 874 "./arch/x86/include/asm/pgtable.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/pgtable.h" ) , "i" ( 874 ) , "i" ( 12UL ) ) ;
    ldv_24931:;
# 874 "./arch/x86/include/asm/pgtable.h"
    goto ldv_24931;
  }
# 875 "./arch/x86/include/asm/pgtable.h"
  return pte_set_flags ( pte , 128UL );
}
# 878 "./arch/x86/include/asm/pgtable.h"
static inline int pte_swp_soft_dirty(pte_t pte)
{
  if (__builtin_expect ( pte_present_nonuma ( pte ) != 0 , 0L ) != 0L)
  {
# 880 "./arch/x86/include/asm/pgtable.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/pgtable.h" ) , "i" ( 880 ) , "i" ( 12UL ) ) ;
    ldv_24935:;
# 880 "./arch/x86/include/asm/pgtable.h"
    goto ldv_24935;
  }
# 881 "./arch/x86/include/asm/pgtable.h"
  return ( int ) pte_flags ( pte ) & 128;
}
# 884 "./arch/x86/include/asm/pgtable.h"
static inline pte_t pte_swp_clear_soft_dirty(pte_t pte)
{
  if (__builtin_expect ( pte_present_nonuma ( pte ) != 0 , 0L ) != 0L)
  {
# 886 "./arch/x86/include/asm/pgtable.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "./arch/x86/include/asm/pgtable.h" ) , "i" ( 886 ) , "i" ( 12UL ) ) ;
    ldv_24939:;
# 886 "./arch/x86/include/asm/pgtable.h"
    goto ldv_24939;
  }
# 887 "./arch/x86/include/asm/pgtable.h"
  return pte_clear_flags ( pte , 128UL );
}
# 123 "include/asm-generic/pgtable.h"
static inline void pte_clear_not_present_full(struct mm_struct *mm, long unsigned int address, pte_t *ptep, int full)
{
# 128 "include/asm-generic/pgtable.h"
  pte_clear ( mm , address , ptep );
}
# 133 "include/asm-generic/pgtable.h"
pte_t ptep_clear_flush(struct vm_area_struct *, long unsigned int, pte_t *);
# 139 "include/asm-generic/pgtable.h"
pmd_t pmdp_clear_flush(struct vm_area_struct *, long unsigned int, pmd_t *);
# 176 "include/asm-generic/pgtable.h"
void pgtable_trans_huge_deposit(struct mm_struct *, pmd_t *, pgtable_t);
# 181 "include/asm-generic/pgtable.h"
pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *, pmd_t *);
# 185 "include/asm-generic/pgtable.h"
void pmdp_invalidate(struct vm_area_struct *, long unsigned int, pmd_t *);
# 203 "include/asm-generic/pgtable.h"
static inline int pte_unused(pte_t pte)
{
  return 0;
}
# 211 "include/asm-generic/pgtable.h"
static inline int pmd_same(pmd_t pmd_a, pmd_t pmd_b)
{
  return pmd_val ( pmd_a ) == pmd_val ( pmd_b );
}
# 282 "include/asm-generic/pgtable.h"
void pgd_clear_bad(pgd_t *);
void pud_clear_bad(pud_t *);
void pmd_clear_bad(pmd_t *);
# 286 "include/asm-generic/pgtable.h"
static inline int pgd_none_or_clear_bad(pgd_t *pgd)
{
  if (pgd_none ( * pgd ) != 0)
    return 1;
  if (__builtin_expect ( pgd_bad ( * pgd ) != 0 , 0L ) != 0L)
  {
# 291 "include/asm-generic/pgtable.h"
    pgd_clear_bad ( pgd );
    return 1;
  }
  return 0;
}
# 297 "include/asm-generic/pgtable.h"
static inline int pud_none_or_clear_bad(pud_t *pud)
{
  if (pud_none ( * pud ) != 0)
    return 1;
  if (__builtin_expect ( pud_bad ( * pud ) != 0 , 0L ) != 0L)
  {
# 302 "include/asm-generic/pgtable.h"
    pud_clear_bad ( pud );
    return 1;
  }
  return 0;
}
# 308 "include/asm-generic/pgtable.h"
static inline int pmd_none_or_clear_bad(pmd_t *pmd)
{
  if (pmd_none ( * pmd ) != 0)
    return 1;
  if (__builtin_expect ( pmd_bad ( * pmd ) != 0 , 0L ) != 0L)
  {
# 313 "include/asm-generic/pgtable.h"
    pmd_clear_bad ( pmd );
    return 1;
  }
  return 0;
}
# 319 "include/asm-generic/pgtable.h"
static inline pte_t __ptep_modify_prot_start(struct mm_struct *mm, long unsigned int addr, pte_t *ptep)
{
# 328 "include/asm-generic/pgtable.h"
  return ptep_get_and_clear ( mm , addr , ptep );
}
# 331 "include/asm-generic/pgtable.h"
static inline void __ptep_modify_prot_commit(struct mm_struct *mm, long unsigned int addr, pte_t *ptep, pte_t pte)
{
# 339 "include/asm-generic/pgtable.h"
  set_pte_at ( mm , addr , ptep , pte );
}
# 512 "include/asm-generic/pgtable.h"
int track_pfn_remap(struct vm_area_struct *, pgprot_t *, long unsigned int, long unsigned int, long unsigned int);
# 515 "include/asm-generic/pgtable.h"
int track_pfn_insert(struct vm_area_struct *, pgprot_t *, long unsigned int);
# 517 "include/asm-generic/pgtable.h"
int track_pfn_copy(struct vm_area_struct *);
void untrack_pfn(struct vm_area_struct *, long unsigned int, long unsigned int);
# 535 "include/asm-generic/pgtable.h"
extern long unsigned int zero_pfn;
# 533 "include/asm-generic/pgtable.h"
static inline int is_zero_pfn(long unsigned int pfn)
{
  long unsigned int zero_pfn;
  return pfn == zero_pfn;
}
# 541 "include/asm-generic/pgtable.h"
extern long unsigned int zero_pfn;
# 539 "include/asm-generic/pgtable.h"
static inline long unsigned int my_zero_pfn(long unsigned int addr)
{
  long unsigned int zero_pfn;
  return zero_pfn;
}
# 567 "include/asm-generic/pgtable.h"
static inline pmd_t pmd_read_atomic(pmd_t *pmdp)
{
# 574 "include/asm-generic/pgtable.h"
  return * pmdp;
}
# 579 "include/asm-generic/pgtable.h"
static inline int pmd_move_must_withdraw(spinlock_t *new_pmd_ptl, spinlock_t *old_pmd_ptl)
{
# 586 "include/asm-generic/pgtable.h"
  return new_pmd_ptl != old_pmd_ptl;
}
# 611 "include/asm-generic/pgtable.h"
static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)
{
  pmd_t pmdval = pmd_read_atomic ( pmd );
# 629 "include/asm-generic/pgtable.h"
  asm volatile ( "" : : : "memory" ) ;
# 631 "include/asm-generic/pgtable.h"
  if (pmd_none ( pmdval ) != 0 || pmd_trans_huge ( pmdval ) != 0)
    return 1;
  if (__builtin_expect ( pmd_bad ( pmdval ) != 0 , 0L ) != 0L)
  {
# 634 "include/asm-generic/pgtable.h"
    pmd_clear_bad ( pmd );
    return 1;
  }
  return 0;
}
# 653 "include/asm-generic/pgtable.h"
static inline int pmd_trans_unstable(pmd_t *pmd)
{
# 656 "include/asm-generic/pgtable.h"
  return pmd_none_or_trans_huge_or_clear_bad ( pmd );
}
# 674 "include/asm-generic/pgtable.h"
static inline int pte_numa(pte_t pte)
{
  return ( ( long unsigned int ) pte_flags ( pte ) & 769UL )
# 677 "include/asm-generic/pgtable.h"
  == 512UL;
}
# 682 "include/asm-generic/pgtable.h"
static inline int pmd_numa(pmd_t pmd)
{
  return ( ( long unsigned int ) pmd_flags ( pmd ) & 769UL )
# 685 "include/asm-generic/pgtable.h"
  == 512UL;
}
# 698 "include/asm-generic/pgtable.h"
static inline pte_t pte_mknonnuma(pte_t pte)
{
  pteval_t val = pte_val ( pte );
# 702 "include/asm-generic/pgtable.h"
  val = ( long unsigned int ) val & 18446744073709551103UL;
  val = ( long unsigned int ) val | 33UL;
  return __pte ( val );
}
# 709 "include/asm-generic/pgtable.h"
static inline pmd_t pmd_mknonnuma(pmd_t pmd)
{
  pmdval_t val = pmd_val ( pmd );
# 713 "include/asm-generic/pgtable.h"
  val = ( long unsigned int ) val & 18446744073709551103UL;
  val = ( long unsigned int ) val | 33UL;
# 716 "include/asm-generic/pgtable.h"
  return __pmd ( val );
}
# 721 "include/asm-generic/pgtable.h"
static inline pte_t pte_mknuma(pte_t pte)
{
  pteval_t val = pte_val ( pte );
# 725 "include/asm-generic/pgtable.h"
  val = ( long unsigned int ) val & 18446744073709551614UL;
  val = ( long unsigned int ) val | 512UL;
# 728 "include/asm-generic/pgtable.h"
  return __pte ( val );
}
# 733 "include/asm-generic/pgtable.h"
static inline void ptep_set_numa(struct mm_struct *mm, long unsigned int addr, pte_t *ptep)
{
# 736 "include/asm-generic/pgtable.h"
  pte_t ptent = * ptep;
# 738 "include/asm-generic/pgtable.h"
  ptent = pte_mknuma ( ptent );
  set_pte_at ( mm , addr , ptep , ptent );
  return;
}
# 745 "include/asm-generic/pgtable.h"
static inline pmd_t pmd_mknuma(pmd_t pmd)
{
  pmdval_t val = pmd_val ( pmd );
# 749 "include/asm-generic/pgtable.h"
  val = ( long unsigned int ) val & 18446744073709551614UL;
  val = ( long unsigned int ) val | 512UL;
# 752 "include/asm-generic/pgtable.h"
  return __pmd ( val );
}
# 757 "include/asm-generic/pgtable.h"
static inline void pmdp_set_numa(struct mm_struct *mm, long unsigned int addr, pmd_t *pmdp)
{
# 760 "include/asm-generic/pgtable.h"
  pmd_t pmd = * pmdp;
# 762 "include/asm-generic/pgtable.h"
  pmd = pmd_mknuma ( pmd );
  set_pmd_at ( mm , addr , pmdp , pmd );
  return;
}
# 58 "include/linux/mm.h"
extern long unsigned int sysctl_user_reserve_kbytes;
extern long unsigned int sysctl_admin_reserve_kbytes;
# 61 "include/linux/mm.h"
extern int sysctl_overcommit_memory;
extern int sysctl_overcommit_ratio;
extern long unsigned int sysctl_overcommit_kbytes;
# 65 "include/linux/mm.h"
int overcommit_ratio_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 67 "include/linux/mm.h"
int overcommit_kbytes_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 87 "include/linux/mm.h"
extern struct kmem_cache *vm_area_cachep;
# 187 "include/linux/mm.h"
extern pgprot_t protection_map[16U];
struct vm_fault
{
# 207 "include/linux/mm.h"
  unsigned int flags;
  long unsigned int pgoff;
  void *virtual_address;
# 211 "include/linux/mm.h"
  struct page *page;
# 217 "include/linux/mm.h"
  long unsigned int max_pgoff;
# 219 "include/linux/mm.h"
  pte_t *pte;
};
struct vm_operations_struct
{
# 228 "include/linux/mm.h"
  void (*open)(struct vm_area_struct *);
  void (*close)(struct vm_area_struct *);
  int (*fault)(struct vm_area_struct *, struct vm_fault *);
  void (*map_pages)(struct vm_area_struct *, struct vm_fault *);
# 235 "include/linux/mm.h"
  int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *);
# 240 "include/linux/mm.h"
  int (*access)(struct vm_area_struct *, long unsigned int, void *, int, int);
# 246 "include/linux/mm.h"
  char const *(*name)(struct vm_area_struct *);
# 256 "include/linux/mm.h"
  int (*set_policy)(struct vm_area_struct *, struct mempolicy *);
# 268 "include/linux/mm.h"
  struct mempolicy *(*get_policy)(struct vm_area_struct *, long unsigned int);
# 270 "include/linux/mm.h"
  int (*migrate)(struct vm_area_struct *, nodemask_t const *, nodemask_t const *, long unsigned int);
# 274 "include/linux/mm.h"
  int (*remap_pages)(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int);
};
struct mmu_gather;
# 285 "include/linux/mm.h"
static inline void set_freepage_migratetype(struct page *page, int migratetype)
{
  ( * page ) . ldv_14284 . ldv_14267 . index = ( long unsigned int ) migratetype;
}
# 291 "include/linux/mm.h"
static inline int get_freepage_migratetype(struct page *page)
{
  return ( int ) ( * page ) . ldv_14284 . ldv_14267 . index;
}
enum pageflags
{
  PG_locked = 0,
  PG_error = 1,
  PG_referenced = 2,
  PG_uptodate = 3,
  PG_dirty = 4,
  PG_lru = 5,
  PG_active = 6,
  PG_slab = 7,
  PG_owner_priv_1 = 8,
  PG_arch_1 = 9,
  PG_reserved = 10,
  PG_private = 11,
  PG_private_2 = 12,
  PG_writeback = 13,
  PG_head = 14,
  PG_tail = 15,
  PG_swapcache = 16,
  PG_mappedtodisk = 17,
  PG_reclaim = 18,
  PG_swapbacked = 19,
  PG_unevictable = 20,
  PG_mlocked = 21,
  PG_uncached = 22,
  PG_hwpoison = 23,
  PG_compound_lock = 24,
  __NR_PAGEFLAGS = 25,
  PG_checked = 8,
  PG_fscache = 12,
  PG_pinned = 8,
  PG_savepinned = 4,
  PG_slob_free = 11
};
# 206 "include/linux/page-flags.h"
static inline int PageLocked(struct page const *page)
{
# 206 "include/linux/page-flags.h"
  return constant_test_bit ( 0L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 207 "include/linux/page-flags.h"
static inline int PageError(struct page const *page)
{
# 207 "include/linux/page-flags.h"
  return constant_test_bit ( 1L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 207 "include/linux/page-flags.h"
static inline void SetPageError(struct page *page)
{
# 207 "include/linux/page-flags.h"
  set_bit ( 1L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 207 "include/linux/page-flags.h"
static inline void ClearPageError(struct page *page)
{
# 207 "include/linux/page-flags.h"
  clear_bit ( 1L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 207 "include/linux/page-flags.h"
static inline int TestClearPageError(struct page *page)
{
# 207 "include/linux/page-flags.h"
  return test_and_clear_bit ( 1L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 208 "include/linux/page-flags.h"
static inline int PageReferenced(struct page const *page)
{
# 208 "include/linux/page-flags.h"
  return constant_test_bit ( 2L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 208 "include/linux/page-flags.h"
static inline void SetPageReferenced(struct page *page)
{
# 208 "include/linux/page-flags.h"
  set_bit ( 2L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 208 "include/linux/page-flags.h"
static inline void ClearPageReferenced(struct page *page)
{
# 208 "include/linux/page-flags.h"
  clear_bit ( 2L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 208 "include/linux/page-flags.h"
static inline int TestClearPageReferenced(struct page *page)
{
# 208 "include/linux/page-flags.h"
  return test_and_clear_bit ( 2L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 209 "include/linux/page-flags.h"
static inline void __SetPageReferenced(struct page *page)
{
# 209 "include/linux/page-flags.h"
  __set_bit ( 2L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 210 "include/linux/page-flags.h"
static inline int PageDirty(struct page const *page)
{
# 210 "include/linux/page-flags.h"
  return constant_test_bit ( 4L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 210 "include/linux/page-flags.h"
static inline void SetPageDirty(struct page *page)
{
# 210 "include/linux/page-flags.h"
  set_bit ( 4L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 210 "include/linux/page-flags.h"
static inline void ClearPageDirty(struct page *page)
{
# 210 "include/linux/page-flags.h"
  clear_bit ( 4L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 210 "include/linux/page-flags.h"
static inline int TestSetPageDirty(struct page *page)
{
# 210 "include/linux/page-flags.h"
  return test_and_set_bit ( 4L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 210 "include/linux/page-flags.h"
static inline int TestClearPageDirty(struct page *page)
{
# 210 "include/linux/page-flags.h"
  return test_and_clear_bit ( 4L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 210 "include/linux/page-flags.h"
static inline void __ClearPageDirty(struct page *page)
{
# 210 "include/linux/page-flags.h"
  __clear_bit ( 4L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 211 "include/linux/page-flags.h"
static inline int PageLRU(struct page const *page)
{
# 211 "include/linux/page-flags.h"
  return constant_test_bit ( 5L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 211 "include/linux/page-flags.h"
static inline void SetPageLRU(struct page *page)
{
# 211 "include/linux/page-flags.h"
  set_bit ( 5L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 211 "include/linux/page-flags.h"
static inline void ClearPageLRU(struct page *page)
{
# 211 "include/linux/page-flags.h"
  clear_bit ( 5L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 211 "include/linux/page-flags.h"
static inline void __ClearPageLRU(struct page *page)
{
# 211 "include/linux/page-flags.h"
  __clear_bit ( 5L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 212 "include/linux/page-flags.h"
static inline int PageActive(struct page const *page)
{
# 212 "include/linux/page-flags.h"
  return constant_test_bit ( 6L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 212 "include/linux/page-flags.h"
static inline void SetPageActive(struct page *page)
{
# 212 "include/linux/page-flags.h"
  set_bit ( 6L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 212 "include/linux/page-flags.h"
static inline void ClearPageActive(struct page *page)
{
# 212 "include/linux/page-flags.h"
  clear_bit ( 6L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 212 "include/linux/page-flags.h"
static inline void __ClearPageActive(struct page *page)
{
# 212 "include/linux/page-flags.h"
  __clear_bit ( 6L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 213 "include/linux/page-flags.h"
static inline int TestClearPageActive(struct page *page)
{
# 213 "include/linux/page-flags.h"
  return test_and_clear_bit ( 6L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 214 "include/linux/page-flags.h"
static inline int PageSlab(struct page const *page)
{
# 214 "include/linux/page-flags.h"
  return constant_test_bit ( 7L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 214 "include/linux/page-flags.h"
static inline void __SetPageSlab(struct page *page)
{
# 214 "include/linux/page-flags.h"
  __set_bit ( 7L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 214 "include/linux/page-flags.h"
static inline void __ClearPageSlab(struct page *page)
{
# 214 "include/linux/page-flags.h"
  __clear_bit ( 7L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 215 "include/linux/page-flags.h"
static inline int PageChecked(struct page const *page)
{
# 215 "include/linux/page-flags.h"
  return constant_test_bit ( 8L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 215 "include/linux/page-flags.h"
static inline void SetPageChecked(struct page *page)
{
# 215 "include/linux/page-flags.h"
  set_bit ( 8L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 215 "include/linux/page-flags.h"
static inline void ClearPageChecked(struct page *page)
{
# 215 "include/linux/page-flags.h"
  clear_bit ( 8L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 216 "include/linux/page-flags.h"
static inline int PagePinned(struct page const *page)
{
# 216 "include/linux/page-flags.h"
  return constant_test_bit ( 8L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 216 "include/linux/page-flags.h"
static inline void SetPagePinned(struct page *page)
{
# 216 "include/linux/page-flags.h"
  set_bit ( 8L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 216 "include/linux/page-flags.h"
static inline void ClearPagePinned(struct page *page)
{
# 216 "include/linux/page-flags.h"
  clear_bit ( 8L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 216 "include/linux/page-flags.h"
static inline int TestSetPagePinned(struct page *page)
{
# 216 "include/linux/page-flags.h"
  return test_and_set_bit ( 8L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 216 "include/linux/page-flags.h"
static inline int TestClearPagePinned(struct page *page)
{
# 216 "include/linux/page-flags.h"
  return test_and_clear_bit ( 8L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 217 "include/linux/page-flags.h"
static inline int PageSavePinned(struct page const *page)
{
# 217 "include/linux/page-flags.h"
  return constant_test_bit ( 4L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 217 "include/linux/page-flags.h"
static inline void SetPageSavePinned(struct page *page)
{
# 217 "include/linux/page-flags.h"
  set_bit ( 4L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 217 "include/linux/page-flags.h"
static inline void ClearPageSavePinned(struct page *page)
{
# 217 "include/linux/page-flags.h"
  clear_bit ( 4L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 218 "include/linux/page-flags.h"
static inline int PageReserved(struct page const *page)
{
# 218 "include/linux/page-flags.h"
  return constant_test_bit ( 10L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 218 "include/linux/page-flags.h"
static inline void SetPageReserved(struct page *page)
{
# 218 "include/linux/page-flags.h"
  set_bit ( 10L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 218 "include/linux/page-flags.h"
static inline void ClearPageReserved(struct page *page)
{
# 218 "include/linux/page-flags.h"
  clear_bit ( 10L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 218 "include/linux/page-flags.h"
static inline void __ClearPageReserved(struct page *page)
{
# 218 "include/linux/page-flags.h"
  __clear_bit ( 10L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 219 "include/linux/page-flags.h"
static inline int PageSwapBacked(struct page const *page)
{
# 219 "include/linux/page-flags.h"
  return constant_test_bit ( 19L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 219 "include/linux/page-flags.h"
static inline void SetPageSwapBacked(struct page *page)
{
# 219 "include/linux/page-flags.h"
  set_bit ( 19L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 219 "include/linux/page-flags.h"
static inline void ClearPageSwapBacked(struct page *page)
{
# 219 "include/linux/page-flags.h"
  clear_bit ( 19L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 219 "include/linux/page-flags.h"
static inline void __ClearPageSwapBacked(struct page *page)
{
# 219 "include/linux/page-flags.h"
  __clear_bit ( 19L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 220 "include/linux/page-flags.h"
static inline void __SetPageSwapBacked(struct page *page)
{
# 220 "include/linux/page-flags.h"
  __set_bit ( 19L , ( long unsigned int volatile *) & ( * page ) . flags );
}
static inline int PageSlobFree(struct page const *page)
{
# 222 "include/linux/page-flags.h"
  return constant_test_bit ( 11L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 222 "include/linux/page-flags.h"
static inline void __SetPageSlobFree(struct page *page)
{
# 222 "include/linux/page-flags.h"
  __set_bit ( 11L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 222 "include/linux/page-flags.h"
static inline void __ClearPageSlobFree(struct page *page)
{
# 222 "include/linux/page-flags.h"
  __clear_bit ( 11L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 229 "include/linux/page-flags.h"
static inline int PagePrivate(struct page const *page)
{
# 229 "include/linux/page-flags.h"
  return constant_test_bit ( 11L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 229 "include/linux/page-flags.h"
static inline void SetPagePrivate(struct page *page)
{
# 229 "include/linux/page-flags.h"
  set_bit ( 11L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 229 "include/linux/page-flags.h"
static inline void ClearPagePrivate(struct page *page)
{
# 229 "include/linux/page-flags.h"
  clear_bit ( 11L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 229 "include/linux/page-flags.h"
static inline void __SetPagePrivate(struct page *page)
{
# 229 "include/linux/page-flags.h"
  __set_bit ( 11L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 230 "include/linux/page-flags.h"
static inline void __ClearPagePrivate(struct page *page)
{
# 230 "include/linux/page-flags.h"
  __clear_bit ( 11L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 231 "include/linux/page-flags.h"
static inline int PagePrivate2(struct page const *page)
{
# 231 "include/linux/page-flags.h"
  return constant_test_bit ( 12L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 231 "include/linux/page-flags.h"
static inline void SetPagePrivate2(struct page *page)
{
# 231 "include/linux/page-flags.h"
  set_bit ( 12L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 231 "include/linux/page-flags.h"
static inline void ClearPagePrivate2(struct page *page)
{
# 231 "include/linux/page-flags.h"
  clear_bit ( 12L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 231 "include/linux/page-flags.h"
static inline int TestSetPagePrivate2(struct page *page)
{
# 231 "include/linux/page-flags.h"
  return test_and_set_bit ( 12L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 231 "include/linux/page-flags.h"
static inline int TestClearPagePrivate2(struct page *page)
{
# 231 "include/linux/page-flags.h"
  return test_and_clear_bit ( 12L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 232 "include/linux/page-flags.h"
static inline int PageOwnerPriv1(struct page const *page)
{
# 232 "include/linux/page-flags.h"
  return constant_test_bit ( 8L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 232 "include/linux/page-flags.h"
static inline void SetPageOwnerPriv1(struct page *page)
{
# 232 "include/linux/page-flags.h"
  set_bit ( 8L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 232 "include/linux/page-flags.h"
static inline void ClearPageOwnerPriv1(struct page *page)
{
# 232 "include/linux/page-flags.h"
  clear_bit ( 8L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 232 "include/linux/page-flags.h"
static inline int TestClearPageOwnerPriv1(struct page *page)
{
# 232 "include/linux/page-flags.h"
  return test_and_clear_bit ( 8L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 238 "include/linux/page-flags.h"
static inline int PageWriteback(struct page const *page)
{
# 238 "include/linux/page-flags.h"
  return constant_test_bit ( 13L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 238 "include/linux/page-flags.h"
static inline int TestSetPageWriteback(struct page *page)
{
# 238 "include/linux/page-flags.h"
  return test_and_set_bit ( 13L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 238 "include/linux/page-flags.h"
static inline int TestClearPageWriteback(struct page *page)
{
# 238 "include/linux/page-flags.h"
  return test_and_clear_bit ( 13L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 239 "include/linux/page-flags.h"
static inline int PageMappedToDisk(struct page const *page)
{
# 239 "include/linux/page-flags.h"
  return constant_test_bit ( 17L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 239 "include/linux/page-flags.h"
static inline void SetPageMappedToDisk(struct page *page)
{
# 239 "include/linux/page-flags.h"
  set_bit ( 17L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 239 "include/linux/page-flags.h"
static inline void ClearPageMappedToDisk(struct page *page)
{
# 239 "include/linux/page-flags.h"
  clear_bit ( 17L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 242 "include/linux/page-flags.h"
static inline int PageReclaim(struct page const *page)
{
# 242 "include/linux/page-flags.h"
  return constant_test_bit ( 18L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 242 "include/linux/page-flags.h"
static inline void SetPageReclaim(struct page *page)
{
# 242 "include/linux/page-flags.h"
  set_bit ( 18L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 242 "include/linux/page-flags.h"
static inline void ClearPageReclaim(struct page *page)
{
# 242 "include/linux/page-flags.h"
  clear_bit ( 18L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 242 "include/linux/page-flags.h"
static inline int TestClearPageReclaim(struct page *page)
{
# 242 "include/linux/page-flags.h"
  return test_and_clear_bit ( 18L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 243 "include/linux/page-flags.h"
static inline int PageReadahead(struct page const *page)
{
# 243 "include/linux/page-flags.h"
  return constant_test_bit ( 18L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 243 "include/linux/page-flags.h"
static inline void SetPageReadahead(struct page *page)
{
# 243 "include/linux/page-flags.h"
  set_bit ( 18L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 243 "include/linux/page-flags.h"
static inline void ClearPageReadahead(struct page *page)
{
# 243 "include/linux/page-flags.h"
  clear_bit ( 18L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 243 "include/linux/page-flags.h"
static inline int TestClearPageReadahead(struct page *page)
{
# 243 "include/linux/page-flags.h"
  return test_and_clear_bit ( 18L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 252 "include/linux/page-flags.h"
static inline int PageHighMem(struct page const *page)
{
# 252 "include/linux/page-flags.h"
  return 0;
}
# 252 "include/linux/page-flags.h"
static inline void SetPageHighMem(struct page *page)
{
}
# 252 "include/linux/page-flags.h"
static inline void ClearPageHighMem(struct page *page)
{
}
# 256 "include/linux/page-flags.h"
static inline int PageSwapCache(struct page const *page)
{
# 256 "include/linux/page-flags.h"
  return constant_test_bit ( 16L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 256 "include/linux/page-flags.h"
static inline void SetPageSwapCache(struct page *page)
{
# 256 "include/linux/page-flags.h"
  set_bit ( 16L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 256 "include/linux/page-flags.h"
static inline void ClearPageSwapCache(struct page *page)
{
# 256 "include/linux/page-flags.h"
  clear_bit ( 16L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 261 "include/linux/page-flags.h"
static inline int PageUnevictable(struct page const *page)
{
# 261 "include/linux/page-flags.h"
  return constant_test_bit ( 20L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 261 "include/linux/page-flags.h"
static inline void SetPageUnevictable(struct page *page)
{
# 261 "include/linux/page-flags.h"
  set_bit ( 20L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 261 "include/linux/page-flags.h"
static inline void ClearPageUnevictable(struct page *page)
{
# 261 "include/linux/page-flags.h"
  clear_bit ( 20L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 261 "include/linux/page-flags.h"
static inline void __ClearPageUnevictable(struct page *page)
{
# 261 "include/linux/page-flags.h"
  __clear_bit ( 20L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 262 "include/linux/page-flags.h"
static inline int TestClearPageUnevictable(struct page *page)
{
# 262 "include/linux/page-flags.h"
  return test_and_clear_bit ( 20L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 265 "include/linux/page-flags.h"
static inline int PageMlocked(struct page const *page)
{
# 265 "include/linux/page-flags.h"
  return constant_test_bit ( 21L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 265 "include/linux/page-flags.h"
static inline void SetPageMlocked(struct page *page)
{
# 265 "include/linux/page-flags.h"
  set_bit ( 21L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 265 "include/linux/page-flags.h"
static inline void ClearPageMlocked(struct page *page)
{
# 265 "include/linux/page-flags.h"
  clear_bit ( 21L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 265 "include/linux/page-flags.h"
static inline void __ClearPageMlocked(struct page *page)
{
# 265 "include/linux/page-flags.h"
  __clear_bit ( 21L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 266 "include/linux/page-flags.h"
static inline int TestSetPageMlocked(struct page *page)
{
# 266 "include/linux/page-flags.h"
  return test_and_set_bit ( 21L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 266 "include/linux/page-flags.h"
static inline int TestClearPageMlocked(struct page *page)
{
# 266 "include/linux/page-flags.h"
  return test_and_clear_bit ( 21L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 266 "include/linux/page-flags.h"
static inline int __TestClearPageMlocked(struct page *page)
{
# 266 "include/linux/page-flags.h"
  return __test_and_clear_bit ( 21L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 273 "include/linux/page-flags.h"
static inline int PageUncached(struct page const *page)
{
# 273 "include/linux/page-flags.h"
  return constant_test_bit ( 22L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 273 "include/linux/page-flags.h"
static inline void SetPageUncached(struct page *page)
{
# 273 "include/linux/page-flags.h"
  set_bit ( 22L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 273 "include/linux/page-flags.h"
static inline void ClearPageUncached(struct page *page)
{
# 273 "include/linux/page-flags.h"
  clear_bit ( 22L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 279 "include/linux/page-flags.h"
static inline int PageHWPoison(struct page const *page)
{
# 279 "include/linux/page-flags.h"
  return constant_test_bit ( 23L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 279 "include/linux/page-flags.h"
static inline void SetPageHWPoison(struct page *page)
{
# 279 "include/linux/page-flags.h"
  set_bit ( 23L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 279 "include/linux/page-flags.h"
static inline void ClearPageHWPoison(struct page *page)
{
# 279 "include/linux/page-flags.h"
  clear_bit ( 23L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 280 "include/linux/page-flags.h"
static inline int TestSetPageHWPoison(struct page *page)
{
# 280 "include/linux/page-flags.h"
  return test_and_set_bit ( 23L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 280 "include/linux/page-flags.h"
static inline int TestClearPageHWPoison(struct page *page)
{
# 280 "include/linux/page-flags.h"
  return test_and_clear_bit ( 23L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 287 "include/linux/page-flags.h"
u64 stable_page_flags(struct page *);
# 289 "include/linux/page-flags.h"
static inline int PageUptodate(struct page *page)
{
  int ret = constant_test_bit ( 3L , ( long unsigned int const volatile *) & ( * page ) . flags );
# 301 "include/linux/page-flags.h"
  if (ret != 0)
    asm volatile ( "" : : : "memory" ) ;
# 304 "include/linux/page-flags.h"
  return ret;
}
# 307 "include/linux/page-flags.h"
static inline void __SetPageUptodate(struct page *page)
{
  asm volatile ( "" : : : "memory" ) ;
  __set_bit ( 3L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 313 "include/linux/page-flags.h"
static inline void SetPageUptodate(struct page *page)
{
# 320 "include/linux/page-flags.h"
  asm volatile ( "" : : : "memory" ) ;
  set_bit ( 3L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 324 "include/linux/page-flags.h"
static inline void ClearPageUptodate(struct page *page)
{
# 324 "include/linux/page-flags.h"
  clear_bit ( 3L , ( long unsigned int volatile *) & ( * page ) . flags );
}
void cancel_dirty_page(struct page *, unsigned int);
# 328 "include/linux/page-flags.h"
int test_clear_page_writeback(struct page *);
int __test_set_page_writeback(struct page *, bool);
# 336 "include/linux/page-flags.h"
static inline void set_page_writeback(struct page *page)
{
  __test_set_page_writeback ( page , 0 );
}
# 341 "include/linux/page-flags.h"
static inline void set_page_writeback_keepwrite(struct page *page)
{
  __test_set_page_writeback ( page , 1 );
}
# 355 "include/linux/page-flags.h"
static inline int PageHead(struct page const *page)
{
# 355 "include/linux/page-flags.h"
  return constant_test_bit ( 14L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 355 "include/linux/page-flags.h"
static inline void __SetPageHead(struct page *page)
{
# 355 "include/linux/page-flags.h"
  __set_bit ( 14L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 355 "include/linux/page-flags.h"
static inline void __ClearPageHead(struct page *page)
{
# 355 "include/linux/page-flags.h"
  __clear_bit ( 14L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 355 "include/linux/page-flags.h"
static inline void ClearPageHead(struct page *page)
{
# 355 "include/linux/page-flags.h"
  clear_bit ( 14L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 356 "include/linux/page-flags.h"
static inline int PageTail(struct page const *page)
{
# 356 "include/linux/page-flags.h"
  return constant_test_bit ( 15L , ( long unsigned int const volatile *) & ( * page ) . flags );
}
# 356 "include/linux/page-flags.h"
static inline void __SetPageTail(struct page *page)
{
# 356 "include/linux/page-flags.h"
  __set_bit ( 15L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 356 "include/linux/page-flags.h"
static inline void __ClearPageTail(struct page *page)
{
# 356 "include/linux/page-flags.h"
  __clear_bit ( 15L , ( long unsigned int volatile *) & ( * page ) . flags );
}
static inline int PageCompound(struct page *page)
{
  return ( int ) ( * page ) . flags & 49152;
}
# 364 "include/linux/page-flags.h"
static inline void ClearPageCompound(struct page *page)
{
  if (__builtin_expect ( PageHead ( ( struct page const *) page ) == 0 , 0L ) != 0L)
  {
# 366 "include/linux/page-flags.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/page-flags.h" ) , "i" ( 366 ) , "i" ( 12UL ) ) ;
    ldv_25546:;
# 366 "include/linux/page-flags.h"
    goto ldv_25546;
  }
# 367 "include/linux/page-flags.h"
  ClearPageHead ( page );
}
# 435 "include/linux/page-flags.h"
static inline int PageTransHuge(struct page *page)
{
  if (__builtin_expect ( PageTail ( ( struct page const *) page ) != 0 , 0L ) != 0L)
  {
# 437 "include/linux/page-flags.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(PageTail(page))" );
# 437 "include/linux/page-flags.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/page-flags.h" ) , "i" ( 437 ) , "i" ( 12UL ) ) ;
    ldv_25550:;
# 437 "include/linux/page-flags.h"
    goto ldv_25550;
  }
# 438 "include/linux/page-flags.h"
  return PageHead ( ( struct page const *) page );
}
# 446 "include/linux/page-flags.h"
static inline int PageTransCompound(struct page *page)
{
  return PageCompound ( page );
}
# 456 "include/linux/page-flags.h"
static inline int PageTransTail(struct page *page)
{
  return PageTail ( ( struct page const *) page );
}
# 483 "include/linux/page-flags.h"
static inline int PageSlabPfmemalloc(struct page *page)
{
  if (__builtin_expect ( PageSlab ( ( struct page const *) page ) == 0 , 0L ) != 0L)
  {
# 485 "include/linux/page-flags.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(!PageSlab(page))" );
# 485 "include/linux/page-flags.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/page-flags.h" ) , "i" ( 485 ) , "i" ( 12UL ) ) ;
    ldv_25560:;
# 485 "include/linux/page-flags.h"
    goto ldv_25560;
  }
# 486 "include/linux/page-flags.h"
  return PageActive ( ( struct page const *) page );
}
# 489 "include/linux/page-flags.h"
static inline void SetPageSlabPfmemalloc(struct page *page)
{
  if (__builtin_expect ( PageSlab ( ( struct page const *) page ) == 0 , 0L ) != 0L)
  {
# 491 "include/linux/page-flags.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(!PageSlab(page))" );
# 491 "include/linux/page-flags.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/page-flags.h" ) , "i" ( 491 ) , "i" ( 12UL ) ) ;
    ldv_25564:;
# 491 "include/linux/page-flags.h"
    goto ldv_25564;
  }
# 492 "include/linux/page-flags.h"
  SetPageActive ( page );
}
# 495 "include/linux/page-flags.h"
static inline void __ClearPageSlabPfmemalloc(struct page *page)
{
  if (__builtin_expect ( PageSlab ( ( struct page const *) page ) == 0 , 0L ) != 0L)
  {
# 497 "include/linux/page-flags.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(!PageSlab(page))" );
# 497 "include/linux/page-flags.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/page-flags.h" ) , "i" ( 497 ) , "i" ( 12UL ) ) ;
    ldv_25568:;
# 497 "include/linux/page-flags.h"
    goto ldv_25568;
  }
# 498 "include/linux/page-flags.h"
  __ClearPageActive ( page );
}
# 501 "include/linux/page-flags.h"
static inline void ClearPageSlabPfmemalloc(struct page *page)
{
  if (__builtin_expect ( PageSlab ( ( struct page const *) page ) == 0 , 0L ) != 0L)
  {
# 503 "include/linux/page-flags.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(!PageSlab(page))" );
# 503 "include/linux/page-flags.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/page-flags.h" ) , "i" ( 503 ) , "i" ( 12UL ) ) ;
    ldv_25572:;
# 503 "include/linux/page-flags.h"
    goto ldv_25572;
  }
# 504 "include/linux/page-flags.h"
  ClearPageActive ( page );
}
# 547 "include/linux/page-flags.h"
static inline int page_has_private(struct page *page)
{
  return ( ( * page ) . flags & 6144UL ) != 0UL;
}
# 4 "include/linux/huge_mm.h"
int do_huge_pmd_anonymous_page(struct mm_struct *, struct vm_area_struct *, long unsigned int, pmd_t *, unsigned int);
# 8 "include/linux/huge_mm.h"
int copy_huge_pmd(struct mm_struct *, struct mm_struct *, pmd_t *, pmd_t *, long unsigned int, struct vm_area_struct *);
# 11 "include/linux/huge_mm.h"
void huge_pmd_set_accessed(struct mm_struct *, struct vm_area_struct *, long unsigned int, pmd_t *, pmd_t, int);
# 15 "include/linux/huge_mm.h"
int do_huge_pmd_wp_page(struct mm_struct *, struct vm_area_struct *, long unsigned int, pmd_t *, pmd_t);
# 18 "include/linux/huge_mm.h"
struct page *follow_trans_huge_pmd(struct vm_area_struct *, long unsigned int, pmd_t *, unsigned int);
# 22 "include/linux/huge_mm.h"
int zap_huge_pmd(struct mmu_gather *, struct vm_area_struct *, pmd_t *, long unsigned int);
# 25 "include/linux/huge_mm.h"
int mincore_huge_pmd(struct vm_area_struct *, pmd_t *, long unsigned int, long unsigned int, unsigned char *);
# 28 "include/linux/huge_mm.h"
int move_huge_pmd(struct vm_area_struct *, struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int, pmd_t *, pmd_t *);
# 33 "include/linux/huge_mm.h"
int change_huge_pmd(struct vm_area_struct *, pmd_t *, long unsigned int, pgprot_t, int);
enum transparent_hugepage_flag
{
  TRANSPARENT_HUGEPAGE_FLAG = 0,
  TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG = 1,
  TRANSPARENT_HUGEPAGE_DEFRAG_FLAG = 2,
  TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG = 3,
  TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG = 4,
  TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG = 5,
  TRANSPARENT_HUGEPAGE_DEBUG_COW_FLAG = 6
};
enum page_check_address_pmd_flag
{
  PAGE_CHECK_ADDRESS_PMD_FLAG = 0,
  PAGE_CHECK_ADDRESS_PMD_NOTSPLITTING_FLAG = 1,
  PAGE_CHECK_ADDRESS_PMD_SPLITTING_FLAG = 2
};
# 54 "include/linux/huge_mm.h"
pmd_t *page_check_address_pmd(struct page *, struct mm_struct *, long unsigned int, enum page_check_address_pmd_flag, spinlock_t **);
# 68 "include/linux/huge_mm.h"
bool is_vma_temporary_stack(struct vm_area_struct *);
# 95 "include/linux/huge_mm.h"
extern long unsigned int transparent_hugepage_flags;
int split_huge_page_to_list(struct page *, struct list_head *);
static inline int split_huge_page(struct page *page)
{
  return split_huge_page_to_list ( page , ( ( struct list_head *) 0 ) );
}
void __split_huge_page_pmd(struct vm_area_struct *, long unsigned int, pmd_t *);
# 118 "include/linux/huge_mm.h"
void split_huge_page_pmd_mm(struct mm_struct *, long unsigned int, pmd_t *);
# 123 "include/linux/huge_mm.h"
int hugepage_madvise(struct vm_area_struct *, long unsigned int *, int);
# 125 "include/linux/huge_mm.h"
void __vma_adjust_trans_huge(struct vm_area_struct *, long unsigned int, long unsigned int, long int);
# 129 "include/linux/huge_mm.h"
int __pmd_trans_huge_lock(pmd_t *, struct vm_area_struct *, spinlock_t **);
# 132 "include/linux/huge_mm.h"
static inline int pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma, spinlock_t **ptl)
{
# 135 "include/linux/huge_mm.h"
  if (__builtin_expect ( rwsem_is_locked ( & ( * ( * vma ) . vm_mm ) . mmap_sem ) == 0 , 0L ) != 0L)
  {
# 135 "include/linux/huge_mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/huge_mm.h" ) , "i" ( 135 ) , "i" ( 12UL ) ) ;
    ldv_25685:;
# 135 "include/linux/huge_mm.h"
    goto ldv_25685;
  }
# 136 "include/linux/huge_mm.h"
  if (pmd_trans_huge ( * pmd ) != 0)
  {
# 137 "include/linux/huge_mm.h"
    return __pmd_trans_huge_lock ( pmd , vma , ptl );
  }
  else
# 139 "include/linux/huge_mm.h"
    return 0;
}
static inline void vma_adjust_trans_huge(struct vm_area_struct *vma, long unsigned int start, long unsigned int end, long int adjust_next)
{
# 146 "include/linux/huge_mm.h"
  if (( * vma ) . anon_vma == ( ( struct anon_vma *) 0 ) || ( * vma ) . vm_ops != ( ( struct vm_operations_struct const *) 0 ))
    return;
  __vma_adjust_trans_huge ( vma , start , end , adjust_next );
}
static inline int hpage_nr_pages(struct page *page)
{
  if (__builtin_expect ( PageTransHuge ( page ) != 0 , 0L ) != 0L)
    return 512;
  return 1;
}
# 157 "include/linux/huge_mm.h"
int do_huge_pmd_numa_page(struct mm_struct *, struct vm_area_struct *, long unsigned int, pmd_t, pmd_t *);
# 319 "include/linux/mm.h"
static inline int put_page_testzero(struct page *page)
{
  if (__builtin_expect ( atomic_read ( ( atomic_t const *) & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . _count ) == 0 , 0L ) != 0L)
  {
# 321 "include/linux/mm.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(atomic_read(&page->_count) == 0)" );
# 321 "include/linux/mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/mm.h" ) , "i" ( 321 ) , "i" ( 12UL ) ) ;
    ldv_25704:;
# 321 "include/linux/mm.h"
    goto ldv_25704;
  }
# 322 "include/linux/mm.h"
  return atomic_dec_and_test ( & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . _count );
}
# 331 "include/linux/mm.h"
static inline int get_page_unless_zero(struct page *page)
{
  return atomic_add_unless ( & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . _count , 1 , 0 );
}
# 343 "include/linux/mm.h"
static inline int put_page_unless_one(struct page *page)
{
  return atomic_add_unless ( & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . _count , -1 , 1 );
}
# 348 "include/linux/mm.h"
int page_is_ram(long unsigned int);
# 351 "include/linux/mm.h"
struct page *vmalloc_to_page(void const *);
long unsigned int vmalloc_to_pfn(void const *);
# 360 "include/linux/mm.h"
static inline int is_vmalloc_addr(void const *x)
{
# 363 "include/linux/mm.h"
  long unsigned int addr = ( long unsigned int ) x;
# 365 "include/linux/mm.h"
  return addr > 18446683600570023935UL && addr <= 18446718784942112766UL;
}
# 371 "include/linux/mm.h"
int is_vmalloc_or_module_addr(void const *);
# 379 "include/linux/mm.h"
void kvfree(void const *);
# 381 "include/linux/mm.h"
static inline void compound_lock(struct page *page)
{
# 384 "include/linux/mm.h"
  if (__builtin_expect ( PageSlab ( ( struct page const *) page ) != 0 , 0L ) != 0L)
  {
# 384 "include/linux/mm.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(PageSlab(page))" );
# 384 "include/linux/mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/mm.h" ) , "i" ( 384 ) , "i" ( 12UL ) ) ;
    ldv_25728:;
# 384 "include/linux/mm.h"
    goto ldv_25728;
  }
# 385 "include/linux/mm.h"
  bit_spin_lock ( 24 , & ( * page ) . flags );
}
# 389 "include/linux/mm.h"
static inline void compound_unlock(struct page *page)
{
# 392 "include/linux/mm.h"
  if (__builtin_expect ( PageSlab ( ( struct page const *) page ) != 0 , 0L ) != 0L)
  {
# 392 "include/linux/mm.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(PageSlab(page))" );
# 392 "include/linux/mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/mm.h" ) , "i" ( 392 ) , "i" ( 12UL ) ) ;
    ldv_25732:;
# 392 "include/linux/mm.h"
    goto ldv_25732;
  }
# 393 "include/linux/mm.h"
  bit_spin_unlock ( 24 , & ( * page ) . flags );
}
# 397 "include/linux/mm.h"
static inline long unsigned int compound_lock_irqsave(struct page *page)
{
  long unsigned int flags = flags;
# 401 "include/linux/mm.h"
  ({
# 401 "include/linux/mm.h"
    long unsigned int __dummy;
# 401 "include/linux/mm.h"
    long unsigned int __dummy2;
# 401 "include/linux/mm.h"
    ( void ) 0;
# 401 "include/linux/mm.h"
    1;
  } );
# 401 "include/linux/mm.h"
  flags = arch_local_irq_save ( );
# 401 "include/linux/mm.h"
  trace_hardirqs_off ( );
  compound_lock ( page );
# 404 "include/linux/mm.h"
  return flags;
}
# 407 "include/linux/mm.h"
static inline void compound_unlock_irqrestore(struct page *page, long unsigned int flags)
{
# 411 "include/linux/mm.h"
  compound_unlock ( page );
  if (({
# 412 "include/linux/mm.h"
    ({
# 412 "include/linux/mm.h"
      long unsigned int __dummy;
# 412 "include/linux/mm.h"
      long unsigned int __dummy2;
# 412 "include/linux/mm.h"
      ( void ) 0;
# 412 "include/linux/mm.h"
      1;
    } );
# 412 "include/linux/mm.h"
    arch_irqs_disabled_flags ( flags );
  } )
# 412 "include/linux/mm.h"
  != 0)
  {
# 412 "include/linux/mm.h"
    ({
# 412 "include/linux/mm.h"
      long unsigned int __dummy;
# 412 "include/linux/mm.h"
      long unsigned int __dummy2;
# 412 "include/linux/mm.h"
      ( void ) 0;
# 412 "include/linux/mm.h"
      1;
    } );
# 412 "include/linux/mm.h"
    arch_local_irq_restore ( flags );
# 412 "include/linux/mm.h"
    trace_hardirqs_off ( );
  }
  else
  {
# 412 "include/linux/mm.h"
    trace_hardirqs_on ( );
# 412 "include/linux/mm.h"
    ({
# 412 "include/linux/mm.h"
      long unsigned int __dummy;
# 412 "include/linux/mm.h"
      long unsigned int __dummy2;
# 412 "include/linux/mm.h"
      ( void ) 0;
# 412 "include/linux/mm.h"
      1;
    } );
# 412 "include/linux/mm.h"
    arch_local_irq_restore ( flags );
  }
}
# 416 "include/linux/mm.h"
static inline struct page *compound_head_by_tail(struct page *tail)
{
  struct page *head = ( * tail ) . ldv_14302 . first_page;
# 425 "include/linux/mm.h"
  asm volatile ( "" : : : "memory" ) ;
  if (__builtin_expect ( PageTail ( ( struct page const *) tail ) != 0 , 1L ) != 0L)
    return head;
  return tail;
}
# 431 "include/linux/mm.h"
static inline struct page *compound_head(struct page *page)
{
  if (__builtin_expect ( PageTail ( ( struct page const *) page ) != 0 , 0L ) != 0L)
    return compound_head_by_tail ( page );
  return page;
}
# 443 "include/linux/mm.h"
static inline void page_mapcount_reset(struct page *page)
{
  atomic_set ( & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . ldv_14279 . _mapcount , -1 );
}
# 448 "include/linux/mm.h"
static inline int page_mapcount(struct page *page)
{
  return atomic_read ( ( atomic_t const *) & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . ldv_14279 . _mapcount ) + 1;
}
# 453 "include/linux/mm.h"
static inline int page_count(struct page *page)
{
  return atomic_read ( ( atomic_t const *) & ( * compound_head ( page ) ) . ldv_14284 . ldv_14283 . ldv_14281 . _count );
}
# 459 "include/linux/mm.h"
int PageHeadHuge(struct page *);
# 467 "include/linux/mm.h"
static inline bool __compound_tail_refcounted(struct page *page)
{
  return ( bool ) ( PageSlab ( ( struct page const *) page ) == 0 && PageHeadHuge ( page ) == 0 );
}
# 480 "include/linux/mm.h"
static inline bool compound_tail_refcounted(struct page *page)
{
  if (__builtin_expect ( PageHead ( ( struct page const *) page ) == 0 , 0L ) != 0L)
  {
# 482 "include/linux/mm.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(!PageHead(page))" );
# 482 "include/linux/mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/mm.h" ) , "i" ( 482 ) , "i" ( 12UL ) ) ;
    ldv_25778:;
# 482 "include/linux/mm.h"
    goto ldv_25778;
  }
# 483 "include/linux/mm.h"
  return __compound_tail_refcounted ( page );
}
# 486 "include/linux/mm.h"
static inline void get_huge_page_tail(struct page *page)
{
# 491 "include/linux/mm.h"
  if (__builtin_expect ( PageTail ( ( struct page const *) page ) == 0 , 0L ) != 0L)
  {
# 491 "include/linux/mm.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(!PageTail(page))" );
# 491 "include/linux/mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/mm.h" ) , "i" ( 491 ) , "i" ( 12UL ) ) ;
    ldv_25782:;
# 491 "include/linux/mm.h"
    goto ldv_25782;
  }
# 492 "include/linux/mm.h"
  if (__builtin_expect ( page_mapcount ( page ) < 0 , 0L ) != 0L)
  {
# 492 "include/linux/mm.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(page_mapcount(page) < 0)" );
# 492 "include/linux/mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/mm.h" ) , "i" ( 492 ) , "i" ( 12UL ) ) ;
    ldv_25783:;
# 492 "include/linux/mm.h"
    goto ldv_25783;
  }
# 493 "include/linux/mm.h"
  if (__builtin_expect ( atomic_read ( ( atomic_t const *) & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . _count ) != 0 , 0L ) != 0L)
  {
# 493 "include/linux/mm.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(atomic_read(&page->_count) != 0)" );
# 493 "include/linux/mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/mm.h" ) , "i" ( 493 ) , "i" ( 12UL ) ) ;
    ldv_25784:;
# 493 "include/linux/mm.h"
    goto ldv_25784;
  }
# 494 "include/linux/mm.h"
  if (( int ) compound_tail_refcounted ( ( * page ) . ldv_14302 . first_page ))
    atomic_inc ( & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . ldv_14279 . _mapcount );
}
# 498 "include/linux/mm.h"
bool __get_page_tail(struct page *);
# 500 "include/linux/mm.h"
static inline void get_page(struct page *page)
{
  if (__builtin_expect ( PageTail ( ( struct page const *) page ) != 0 , 0L ) != 0L)
    if (__builtin_expect ( ( long int ) __get_page_tail ( page ) , 1L ) != 0L)
      return;
# 509 "include/linux/mm.h"
  if (__builtin_expect ( atomic_read ( ( atomic_t const *) & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . _count ) <= 0 , 0L ) != 0L)
  {
# 509 "include/linux/mm.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(atomic_read(&page->_count) <= 0)" );
# 509 "include/linux/mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/mm.h" ) , "i" ( 509 ) , "i" ( 12UL ) ) ;
    ldv_25790:;
# 509 "include/linux/mm.h"
    goto ldv_25790;
  }
# 510 "include/linux/mm.h"
  atomic_inc ( & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . _count );
}
# 513 "include/linux/mm.h"
static inline struct page *virt_to_head_page(void const *x)
{
  struct page *page = ( ( struct page *) -24189255811072 ) + ( __phys_addr ( ( long unsigned int ) x ) >> 12 );
  return compound_head ( page );
}
# 523 "include/linux/mm.h"
static inline void init_page_count(struct page *page)
{
  atomic_set ( & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . _count , 1 );
}
# 539 "include/linux/mm.h"
static inline int PageBuddy(struct page *page)
{
  return atomic_read ( ( atomic_t const *) & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . ldv_14279 . _mapcount ) == -128;
}
# 544 "include/linux/mm.h"
static inline void __SetPageBuddy(struct page *page)
{
  if (__builtin_expect ( atomic_read ( ( atomic_t const *) & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . ldv_14279 . _mapcount ) != -1 , 0L ) != 0L)
  {
# 546 "include/linux/mm.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(atomic_read(&page->_mapcount) != -1)" );
# 546 "include/linux/mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/mm.h" ) , "i" ( 546 ) , "i" ( 12UL ) ) ;
    ldv_25804:;
# 546 "include/linux/mm.h"
    goto ldv_25804;
  }
# 547 "include/linux/mm.h"
  atomic_set ( & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . ldv_14279 . _mapcount , -128 );
}
# 550 "include/linux/mm.h"
static inline void __ClearPageBuddy(struct page *page)
{
  if (__builtin_expect ( PageBuddy ( page ) == 0 , 0L ) != 0L)
  {
# 552 "include/linux/mm.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(!PageBuddy(page))" );
# 552 "include/linux/mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/mm.h" ) , "i" ( 552 ) , "i" ( 12UL ) ) ;
    ldv_25808:;
# 552 "include/linux/mm.h"
    goto ldv_25808;
  }
# 553 "include/linux/mm.h"
  atomic_set ( & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . ldv_14279 . _mapcount , -1 );
}
# 556 "include/linux/mm.h"
void put_page(struct page *);
void put_pages_list(struct list_head *);
# 559 "include/linux/mm.h"
void split_page(struct page *, unsigned int);
int split_free_page(struct page *);
# 567 "include/linux/mm.h"
typedef void compound_page_dtor(struct page *);
# 569 "include/linux/mm.h"
static inline void set_compound_page_dtor(struct page *page, compound_page_dtor *dtor)
{
# 572 "include/linux/mm.h"
  ( * ( page + 1UL ) ) . ldv_14296 . lru . next = ( struct list_head *) dtor;
}
# 575 "include/linux/mm.h"
static inline compound_page_dtor *get_compound_page_dtor(struct page *page)
{
  return ( compound_page_dtor *) ( * ( page + 1UL ) ) . ldv_14296 . lru . next;
}
# 580 "include/linux/mm.h"
static inline int compound_order(struct page *page)
{
  if (PageHead ( ( struct page const *) page ) == 0)
    return 0;
  return ( int ) ( long int ) ( * ( page + 1UL ) ) . ldv_14296 . lru . prev;
}
# 587 "include/linux/mm.h"
static inline void set_compound_order(struct page *page, long unsigned int order)
{
  ( * ( page + 1UL ) ) . ldv_14296 . lru . prev = ( struct list_head *) order;
}
# 599 "include/linux/mm.h"
static inline pte_t maybe_mkwrite(pte_t pte, struct vm_area_struct *vma)
{
  if (__builtin_expect ( ( ( * vma ) . vm_flags & 2UL ) != 0UL , 1L ) != 0L)
    pte = pte_mkwrite ( pte );
  return pte;
}
# 606 "include/linux/mm.h"
void do_set_pte(struct vm_area_struct *, long unsigned int, struct page *, pte_t *, bool, bool);
# 714 "include/linux/mm.h"
static inline enum zone_type page_zonenum(struct page const *page)
{
  return ( enum zone_type ) ( ( unsigned int ) ( ( * page ) . flags >> 52 ) & 3U );
}
# 731 "include/linux/mm.h"
static inline int page_zone_id(struct page *page)
{
  return ( int ) ( ( * page ) . flags >> 52 );
}
# 736 "include/linux/mm.h"
static inline int zone_to_nid(struct zone *zone)
{
# 739 "include/linux/mm.h"
  return ( * zone ) . node;
}
# 748 "include/linux/mm.h"
static inline int page_to_nid(struct page const *page)
{
  return ( int ) ( ( * page ) . flags >> 54 );
}
# 755 "include/linux/mm.h"
static inline int cpu_pid_to_cpupid(int cpu, int pid)
{
  return ( cpu & 8191 ) << 8 | pid & 255;
}
# 760 "include/linux/mm.h"
static inline int cpupid_to_pid(int cpupid)
{
  return cpupid & 255;
}
# 765 "include/linux/mm.h"
static inline int cpupid_to_cpu(int cpupid)
{
  return cpupid >> 8 & 8191;
}
# 770 "include/linux/mm.h"
static inline int cpupid_to_nid(int cpupid)
{
  return __cpu_to_node ( cpupid_to_cpu ( cpupid ) );
}
# 775 "include/linux/mm.h"
static inline bool cpupid_pid_unset(int cpupid)
{
  return cpupid_to_pid ( cpupid ) == 255;
}
# 780 "include/linux/mm.h"
static inline bool cpupid_cpu_unset(int cpupid)
{
  return cpupid_to_cpu ( cpupid ) == 8191;
}
# 785 "include/linux/mm.h"
static inline bool __cpupid_match_pid(pid_t task_pid, int cpupid)
{
  return ( ( int ) task_pid & 255 ) == cpupid_to_pid ( cpupid );
}
# 806 "include/linux/mm.h"
static inline int page_cpupid_last(struct page *page)
{
  return ( int ) ( ( * page ) . flags >> 31 ) & 2097151;
}
# 811 "include/linux/mm.h"
int page_cpupid_xchg_last(struct page *, int);
# 813 "include/linux/mm.h"
static inline void page_cpupid_reset_last(struct page *page)
{
  int cpupid = 2097151;
# 817 "include/linux/mm.h"
  ( * page ) . flags &= 18442240476229664767UL;
  ( * page ) . flags |= ( ( long unsigned int ) cpupid & 2097151UL ) << 31;
}
# 867 "include/linux/mm.h"
static inline struct zone *page_zone(struct page const *page)
{
  return ( struct zone *) & ( * node_data [ page_to_nid ( page ) ] ) . node_zones + ( long unsigned int ) page_zonenum ( page );
}
# 885 "include/linux/mm.h"
static inline void set_page_zone(struct page *page, enum zone_type zone)
{
  ( * page ) . flags &= 18433233274827440127UL;
  ( * page ) . flags |= ( ( long unsigned int ) zone & 3UL ) << 52;
}
# 891 "include/linux/mm.h"
static inline void set_page_node(struct page *page, long unsigned int node)
{
  ( * page ) . flags &= 18014398509481983UL;
  ( * page ) . flags |= node << 54;
}
# 897 "include/linux/mm.h"
static inline void set_page_links(struct page *page, enum zone_type zone, long unsigned int node, long unsigned int pfn)
{
# 900 "include/linux/mm.h"
  set_page_zone ( page , zone );
  set_page_node ( page , node );
}
enum vm_event_item
{
  PGPGIN = 0,
  PGPGOUT = 1,
  PSWPIN = 2,
  PSWPOUT = 3,
  PGALLOC_DMA = 4,
  PGALLOC_DMA32 = 5,
  PGALLOC_NORMAL = 6,
  PGALLOC_MOVABLE = 7,
  PGFREE = 8,
  PGACTIVATE = 9,
  PGDEACTIVATE = 10,
  PGFAULT = 11,
  PGMAJFAULT = 12,
  PGREFILL_DMA = 13,
  PGREFILL_DMA32 = 14,
  PGREFILL_NORMAL = 15,
  PGREFILL_MOVABLE = 16,
  PGSTEAL_KSWAPD_DMA = 17,
  PGSTEAL_KSWAPD_DMA32 = 18,
  PGSTEAL_KSWAPD_NORMAL = 19,
  PGSTEAL_KSWAPD_MOVABLE = 20,
  PGSTEAL_DIRECT_DMA = 21,
  PGSTEAL_DIRECT_DMA32 = 22,
  PGSTEAL_DIRECT_NORMAL = 23,
  PGSTEAL_DIRECT_MOVABLE = 24,
  PGSCAN_KSWAPD_DMA = 25,
  PGSCAN_KSWAPD_DMA32 = 26,
  PGSCAN_KSWAPD_NORMAL = 27,
  PGSCAN_KSWAPD_MOVABLE = 28,
  PGSCAN_DIRECT_DMA = 29,
  PGSCAN_DIRECT_DMA32 = 30,
  PGSCAN_DIRECT_NORMAL = 31,
  PGSCAN_DIRECT_MOVABLE = 32,
  PGSCAN_DIRECT_THROTTLE = 33,
  PGSCAN_ZONE_RECLAIM_FAILED = 34,
  PGINODESTEAL = 35,
  SLABS_SCANNED = 36,
  KSWAPD_INODESTEAL = 37,
  KSWAPD_LOW_WMARK_HIT_QUICKLY = 38,
  KSWAPD_HIGH_WMARK_HIT_QUICKLY = 39,
  PAGEOUTRUN = 40,
  ALLOCSTALL = 41,
  PGROTATED = 42,
  DROP_PAGECACHE = 43,
  DROP_SLAB = 44,
  NUMA_PTE_UPDATES = 45,
  NUMA_HUGE_PTE_UPDATES = 46,
  NUMA_HINT_FAULTS = 47,
  NUMA_HINT_FAULTS_LOCAL = 48,
  NUMA_PAGE_MIGRATE = 49,
  PGMIGRATE_SUCCESS = 50,
  PGMIGRATE_FAIL = 51,
  COMPACTMIGRATE_SCANNED = 52,
  COMPACTFREE_SCANNED = 53,
  COMPACTISOLATED = 54,
  COMPACTSTALL = 55,
  COMPACTFAIL = 56,
  COMPACTSUCCESS = 57,
  HTLB_BUDDY_PGALLOC = 58,
  HTLB_BUDDY_PGALLOC_FAIL = 59,
  UNEVICTABLE_PGCULLED = 60,
  UNEVICTABLE_PGSCANNED = 61,
  UNEVICTABLE_PGRESCUED = 62,
  UNEVICTABLE_PGMLOCKED = 63,
  UNEVICTABLE_PGMUNLOCKED = 64,
  UNEVICTABLE_PGCLEARED = 65,
  UNEVICTABLE_PGSTRANDED = 66,
  THP_FAULT_ALLOC = 67,
  THP_FAULT_FALLBACK = 68,
  THP_COLLAPSE_ALLOC = 69,
  THP_COLLAPSE_ALLOC_FAILED = 70,
  THP_SPLIT = 71,
  THP_ZERO_PAGE_ALLOC = 72,
  THP_ZERO_PAGE_ALLOC_FAILED = 73,
  NR_TLB_REMOTE_FLUSH = 74,
  NR_TLB_REMOTE_FLUSH_RECEIVED = 75,
  NR_TLB_LOCAL_FLUSH_ALL = 76,
  NR_TLB_LOCAL_FLUSH_ONE = 77,
  VMACACHE_FIND_CALLS = 78,
  VMACACHE_FIND_HITS = 79,
  NR_VM_EVENT_ITEMS = 80
};
# 11 "include/linux/vmstat.h"
extern int sysctl_stat_interval;
struct vm_event_state
{
# 25 "include/linux/vmstat.h"
  long unsigned int event[80U];
};
# 28 "include/linux/vmstat.h"
extern char __pcpu_scope_vm_event_states;
# 28 "include/linux/vmstat.h"
extern struct vm_event_state vm_event_states;
# 34 "include/linux/vmstat.h"
static inline void __count_vm_event(enum vm_event_item item)
{
  {
# 36 "include/linux/vmstat.h"
    void const *__vpp_verify = ( ( void const *) 0 );
# 36 "include/linux/vmstat.h"
    ( void ) __vpp_verify;
  }
# 36 "include/linux/vmstat.h"
  switch (8UL)
  {
# 36 "include/linux/vmstat.h"
    case 1:;
    {
# 36 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 36 "include/linux/vmstat.h"
      int const pao_ID__ = 1;
# 36 "include/linux/vmstat.h"
      if (0)
      {
# 36 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 36 "include/linux/vmstat.h"
        pao_tmp__ = 1UL;
# 36 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 36 "include/linux/vmstat.h"
      switch (8UL)
      {
# 36 "include/linux/vmstat.h"
        case 1:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26003;
# 36 "include/linux/vmstat.h"
        case 2:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26003;
# 36 "include/linux/vmstat.h"
        case 4:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26003;
# 36 "include/linux/vmstat.h"
        case 8:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26003;
# 36 "include/linux/vmstat.h"
        default:;
# 36 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 36 "include/linux/vmstat.h"
      ldv_26003:;
    }
# 36 "include/linux/vmstat.h"
    goto ldv_26008;
# 36 "include/linux/vmstat.h"
    case 2:;
    {
# 36 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 36 "include/linux/vmstat.h"
      int const pao_ID__ = 1;
# 36 "include/linux/vmstat.h"
      if (0)
      {
# 36 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 36 "include/linux/vmstat.h"
        pao_tmp__ = 1UL;
# 36 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 36 "include/linux/vmstat.h"
      switch (8UL)
      {
# 36 "include/linux/vmstat.h"
        case 1:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26014;
# 36 "include/linux/vmstat.h"
        case 2:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26014;
# 36 "include/linux/vmstat.h"
        case 4:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26014;
# 36 "include/linux/vmstat.h"
        case 8:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26014;
# 36 "include/linux/vmstat.h"
        default:;
# 36 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 36 "include/linux/vmstat.h"
      ldv_26014:;
    }
# 36 "include/linux/vmstat.h"
    goto ldv_26008;
# 36 "include/linux/vmstat.h"
    case 4:;
    {
# 36 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 36 "include/linux/vmstat.h"
      int const pao_ID__ = 1;
# 36 "include/linux/vmstat.h"
      if (0)
      {
# 36 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 36 "include/linux/vmstat.h"
        pao_tmp__ = 1UL;
# 36 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 36 "include/linux/vmstat.h"
      switch (8UL)
      {
# 36 "include/linux/vmstat.h"
        case 1:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26024;
# 36 "include/linux/vmstat.h"
        case 2:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26024;
# 36 "include/linux/vmstat.h"
        case 4:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26024;
# 36 "include/linux/vmstat.h"
        case 8:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26024;
# 36 "include/linux/vmstat.h"
        default:;
# 36 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 36 "include/linux/vmstat.h"
      ldv_26024:;
    }
# 36 "include/linux/vmstat.h"
    goto ldv_26008;
# 36 "include/linux/vmstat.h"
    case 8:;
    {
# 36 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 36 "include/linux/vmstat.h"
      int const pao_ID__ = 1;
# 36 "include/linux/vmstat.h"
      if (0)
      {
# 36 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 36 "include/linux/vmstat.h"
        pao_tmp__ = 1UL;
# 36 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 36 "include/linux/vmstat.h"
      switch (8UL)
      {
# 36 "include/linux/vmstat.h"
        case 1:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26034;
# 36 "include/linux/vmstat.h"
        case 2:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26034;
# 36 "include/linux/vmstat.h"
        case 4:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26034;
# 36 "include/linux/vmstat.h"
        case 8:;
# 36 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 36 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 36 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 36 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 36 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( 1UL ) ) ;
# 36 "include/linux/vmstat.h"
        goto ldv_26034;
# 36 "include/linux/vmstat.h"
        default:;
# 36 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 36 "include/linux/vmstat.h"
      ldv_26034:;
    }
# 36 "include/linux/vmstat.h"
    goto ldv_26008;
# 36 "include/linux/vmstat.h"
    default:;
# 36 "include/linux/vmstat.h"
    __bad_size_call_parameter ( );
# 36 "include/linux/vmstat.h"
    goto ldv_26008;
  }
# 36 "include/linux/vmstat.h"
  ldv_26008:;
}
# 39 "include/linux/vmstat.h"
static inline void count_vm_event(enum vm_event_item item)
{
  {
# 41 "include/linux/vmstat.h"
    void const *__vpp_verify = ( ( void const *) 0 );
# 41 "include/linux/vmstat.h"
    ( void ) __vpp_verify;
  }
# 41 "include/linux/vmstat.h"
  switch (8UL)
  {
# 41 "include/linux/vmstat.h"
    case 1:;
    {
# 41 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 41 "include/linux/vmstat.h"
      int const pao_ID__ = 1;
# 41 "include/linux/vmstat.h"
      if (0)
      {
# 41 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 41 "include/linux/vmstat.h"
        pao_tmp__ = 1UL;
# 41 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 41 "include/linux/vmstat.h"
      switch (8UL)
      {
# 41 "include/linux/vmstat.h"
        case 1:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26049;
# 41 "include/linux/vmstat.h"
        case 2:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26049;
# 41 "include/linux/vmstat.h"
        case 4:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26049;
# 41 "include/linux/vmstat.h"
        case 8:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26049;
# 41 "include/linux/vmstat.h"
        default:;
# 41 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 41 "include/linux/vmstat.h"
      ldv_26049:;
    }
# 41 "include/linux/vmstat.h"
    goto ldv_26054;
# 41 "include/linux/vmstat.h"
    case 2:;
    {
# 41 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 41 "include/linux/vmstat.h"
      int const pao_ID__ = 1;
# 41 "include/linux/vmstat.h"
      if (0)
      {
# 41 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 41 "include/linux/vmstat.h"
        pao_tmp__ = 1UL;
# 41 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 41 "include/linux/vmstat.h"
      switch (8UL)
      {
# 41 "include/linux/vmstat.h"
        case 1:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26060;
# 41 "include/linux/vmstat.h"
        case 2:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26060;
# 41 "include/linux/vmstat.h"
        case 4:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26060;
# 41 "include/linux/vmstat.h"
        case 8:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26060;
# 41 "include/linux/vmstat.h"
        default:;
# 41 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 41 "include/linux/vmstat.h"
      ldv_26060:;
    }
# 41 "include/linux/vmstat.h"
    goto ldv_26054;
# 41 "include/linux/vmstat.h"
    case 4:;
    {
# 41 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 41 "include/linux/vmstat.h"
      int const pao_ID__ = 1;
# 41 "include/linux/vmstat.h"
      if (0)
      {
# 41 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 41 "include/linux/vmstat.h"
        pao_tmp__ = 1UL;
# 41 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 41 "include/linux/vmstat.h"
      switch (8UL)
      {
# 41 "include/linux/vmstat.h"
        case 1:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26070;
# 41 "include/linux/vmstat.h"
        case 2:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26070;
# 41 "include/linux/vmstat.h"
        case 4:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26070;
# 41 "include/linux/vmstat.h"
        case 8:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26070;
# 41 "include/linux/vmstat.h"
        default:;
# 41 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 41 "include/linux/vmstat.h"
      ldv_26070:;
    }
# 41 "include/linux/vmstat.h"
    goto ldv_26054;
# 41 "include/linux/vmstat.h"
    case 8:;
    {
# 41 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 41 "include/linux/vmstat.h"
      int const pao_ID__ = 1;
# 41 "include/linux/vmstat.h"
      if (0)
      {
# 41 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 41 "include/linux/vmstat.h"
        pao_tmp__ = 1UL;
# 41 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 41 "include/linux/vmstat.h"
      switch (8UL)
      {
# 41 "include/linux/vmstat.h"
        case 1:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26080;
# 41 "include/linux/vmstat.h"
        case 2:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26080;
# 41 "include/linux/vmstat.h"
        case 4:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26080;
# 41 "include/linux/vmstat.h"
        case 8:;
# 41 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 41 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 41 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 41 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 41 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( 1UL ) ) ;
# 41 "include/linux/vmstat.h"
        goto ldv_26080;
# 41 "include/linux/vmstat.h"
        default:;
# 41 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 41 "include/linux/vmstat.h"
      ldv_26080:;
    }
# 41 "include/linux/vmstat.h"
    goto ldv_26054;
# 41 "include/linux/vmstat.h"
    default:;
# 41 "include/linux/vmstat.h"
    __bad_size_call_parameter ( );
# 41 "include/linux/vmstat.h"
    goto ldv_26054;
  }
# 41 "include/linux/vmstat.h"
  ldv_26054:;
}
# 44 "include/linux/vmstat.h"
static inline void __count_vm_events(enum vm_event_item item, long int delta)
{
  {
# 46 "include/linux/vmstat.h"
    void const *__vpp_verify = ( ( void const *) 0 );
# 46 "include/linux/vmstat.h"
    ( void ) __vpp_verify;
  }
# 46 "include/linux/vmstat.h"
  switch (8UL)
  {
# 46 "include/linux/vmstat.h"
    case 1:;
    {
# 46 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 46 "include/linux/vmstat.h"
      int const pao_ID__ = 0;
# 46 "include/linux/vmstat.h"
      if (0)
      {
# 46 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 46 "include/linux/vmstat.h"
        pao_tmp__ = ( pao_T__ ) delta;
# 46 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 46 "include/linux/vmstat.h"
      switch (8UL)
      {
# 46 "include/linux/vmstat.h"
        case 1:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26096;
# 46 "include/linux/vmstat.h"
        case 2:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26096;
# 46 "include/linux/vmstat.h"
        case 4:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26096;
# 46 "include/linux/vmstat.h"
        case 8:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26096;
# 46 "include/linux/vmstat.h"
        default:;
# 46 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 46 "include/linux/vmstat.h"
      ldv_26096:;
    }
# 46 "include/linux/vmstat.h"
    goto ldv_26101;
# 46 "include/linux/vmstat.h"
    case 2:;
    {
# 46 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 46 "include/linux/vmstat.h"
      int const pao_ID__ = 0;
# 46 "include/linux/vmstat.h"
      if (0)
      {
# 46 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 46 "include/linux/vmstat.h"
        pao_tmp__ = ( pao_T__ ) delta;
# 46 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 46 "include/linux/vmstat.h"
      switch (8UL)
      {
# 46 "include/linux/vmstat.h"
        case 1:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26107;
# 46 "include/linux/vmstat.h"
        case 2:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26107;
# 46 "include/linux/vmstat.h"
        case 4:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26107;
# 46 "include/linux/vmstat.h"
        case 8:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26107;
# 46 "include/linux/vmstat.h"
        default:;
# 46 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 46 "include/linux/vmstat.h"
      ldv_26107:;
    }
# 46 "include/linux/vmstat.h"
    goto ldv_26101;
# 46 "include/linux/vmstat.h"
    case 4:;
    {
# 46 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 46 "include/linux/vmstat.h"
      int const pao_ID__ = 0;
# 46 "include/linux/vmstat.h"
      if (0)
      {
# 46 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 46 "include/linux/vmstat.h"
        pao_tmp__ = ( pao_T__ ) delta;
# 46 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 46 "include/linux/vmstat.h"
      switch (8UL)
      {
# 46 "include/linux/vmstat.h"
        case 1:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26117;
# 46 "include/linux/vmstat.h"
        case 2:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26117;
# 46 "include/linux/vmstat.h"
        case 4:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26117;
# 46 "include/linux/vmstat.h"
        case 8:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26117;
# 46 "include/linux/vmstat.h"
        default:;
# 46 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 46 "include/linux/vmstat.h"
      ldv_26117:;
    }
# 46 "include/linux/vmstat.h"
    goto ldv_26101;
# 46 "include/linux/vmstat.h"
    case 8:;
    {
# 46 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 46 "include/linux/vmstat.h"
      int const pao_ID__ = 0;
# 46 "include/linux/vmstat.h"
      if (0)
      {
# 46 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 46 "include/linux/vmstat.h"
        pao_tmp__ = ( pao_T__ ) delta;
# 46 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 46 "include/linux/vmstat.h"
      switch (8UL)
      {
# 46 "include/linux/vmstat.h"
        case 1:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26127;
# 46 "include/linux/vmstat.h"
        case 2:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26127;
# 46 "include/linux/vmstat.h"
        case 4:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26127;
# 46 "include/linux/vmstat.h"
        case 8:;
# 46 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 46 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 46 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 46 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 46 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( ( long unsigned int ) delta ) ) ;
# 46 "include/linux/vmstat.h"
        goto ldv_26127;
# 46 "include/linux/vmstat.h"
        default:;
# 46 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 46 "include/linux/vmstat.h"
      ldv_26127:;
    }
# 46 "include/linux/vmstat.h"
    goto ldv_26101;
# 46 "include/linux/vmstat.h"
    default:;
# 46 "include/linux/vmstat.h"
    __bad_size_call_parameter ( );
# 46 "include/linux/vmstat.h"
    goto ldv_26101;
  }
# 46 "include/linux/vmstat.h"
  ldv_26101:;
}
# 49 "include/linux/vmstat.h"
static inline void count_vm_events(enum vm_event_item item, long int delta)
{
  {
# 51 "include/linux/vmstat.h"
    void const *__vpp_verify = ( ( void const *) 0 );
# 51 "include/linux/vmstat.h"
    ( void ) __vpp_verify;
  }
# 51 "include/linux/vmstat.h"
  switch (8UL)
  {
# 51 "include/linux/vmstat.h"
    case 1:;
    {
# 51 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 51 "include/linux/vmstat.h"
      int const pao_ID__ = 0;
# 51 "include/linux/vmstat.h"
      if (0)
      {
# 51 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 51 "include/linux/vmstat.h"
        pao_tmp__ = ( pao_T__ ) delta;
# 51 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 51 "include/linux/vmstat.h"
      switch (8UL)
      {
# 51 "include/linux/vmstat.h"
        case 1:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26143;
# 51 "include/linux/vmstat.h"
        case 2:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26143;
# 51 "include/linux/vmstat.h"
        case 4:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26143;
# 51 "include/linux/vmstat.h"
        case 8:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26143;
# 51 "include/linux/vmstat.h"
        default:;
# 51 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 51 "include/linux/vmstat.h"
      ldv_26143:;
    }
# 51 "include/linux/vmstat.h"
    goto ldv_26148;
# 51 "include/linux/vmstat.h"
    case 2:;
    {
# 51 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 51 "include/linux/vmstat.h"
      int const pao_ID__ = 0;
# 51 "include/linux/vmstat.h"
      if (0)
      {
# 51 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 51 "include/linux/vmstat.h"
        pao_tmp__ = ( pao_T__ ) delta;
# 51 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 51 "include/linux/vmstat.h"
      switch (8UL)
      {
# 51 "include/linux/vmstat.h"
        case 1:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26154;
# 51 "include/linux/vmstat.h"
        case 2:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26154;
# 51 "include/linux/vmstat.h"
        case 4:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26154;
# 51 "include/linux/vmstat.h"
        case 8:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26154;
# 51 "include/linux/vmstat.h"
        default:;
# 51 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 51 "include/linux/vmstat.h"
      ldv_26154:;
    }
# 51 "include/linux/vmstat.h"
    goto ldv_26148;
# 51 "include/linux/vmstat.h"
    case 4:;
    {
# 51 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 51 "include/linux/vmstat.h"
      int const pao_ID__ = 0;
# 51 "include/linux/vmstat.h"
      if (0)
      {
# 51 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 51 "include/linux/vmstat.h"
        pao_tmp__ = ( pao_T__ ) delta;
# 51 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 51 "include/linux/vmstat.h"
      switch (8UL)
      {
# 51 "include/linux/vmstat.h"
        case 1:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26164;
# 51 "include/linux/vmstat.h"
        case 2:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26164;
# 51 "include/linux/vmstat.h"
        case 4:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26164;
# 51 "include/linux/vmstat.h"
        case 8:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26164;
# 51 "include/linux/vmstat.h"
        default:;
# 51 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 51 "include/linux/vmstat.h"
      ldv_26164:;
    }
# 51 "include/linux/vmstat.h"
    goto ldv_26148;
# 51 "include/linux/vmstat.h"
    case 8:;
    {
# 51 "include/linux/vmstat.h"
      typedef long unsigned int pao_T__;
# 51 "include/linux/vmstat.h"
      int const pao_ID__ = 0;
# 51 "include/linux/vmstat.h"
      if (0)
      {
# 51 "include/linux/vmstat.h"
        pao_T__ pao_tmp__;
# 51 "include/linux/vmstat.h"
        pao_tmp__ = ( pao_T__ ) delta;
# 51 "include/linux/vmstat.h"
        ( void ) pao_tmp__;
      }
# 51 "include/linux/vmstat.h"
      switch (8UL)
      {
# 51 "include/linux/vmstat.h"
        case 1:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decb %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addb %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "qi" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26174;
# 51 "include/linux/vmstat.h"
        case 2:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decw %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addw %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26174;
# 51 "include/linux/vmstat.h"
        case 4:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decl %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addl %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "ri" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26174;
# 51 "include/linux/vmstat.h"
        case 8:;
# 51 "include/linux/vmstat.h"
        if (( int ) pao_ID__ == 1)
        {
# 51 "include/linux/vmstat.h"
          asm ( "incq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
        }
        else
# 51 "include/linux/vmstat.h"
          if (( int ) pao_ID__ == -1)
          {
# 51 "include/linux/vmstat.h"
            asm ( "decq %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) ) ;
          }
          else
# 51 "include/linux/vmstat.h"
            asm ( "addq %1, %%gs:%P0" : "+m" ( vm_event_states . event [ ( unsigned int ) item ] ) : "re" ( ( long unsigned int ) delta ) ) ;
# 51 "include/linux/vmstat.h"
        goto ldv_26174;
# 51 "include/linux/vmstat.h"
        default:;
# 51 "include/linux/vmstat.h"
        __bad_percpu_size ( );
      }
# 51 "include/linux/vmstat.h"
      ldv_26174:;
    }
# 51 "include/linux/vmstat.h"
    goto ldv_26148;
# 51 "include/linux/vmstat.h"
    default:;
# 51 "include/linux/vmstat.h"
    __bad_size_call_parameter ( );
# 51 "include/linux/vmstat.h"
    goto ldv_26148;
  }
# 51 "include/linux/vmstat.h"
  ldv_26148:;
}
# 54 "include/linux/vmstat.h"
void all_vm_events(long unsigned int *);
# 56 "include/linux/vmstat.h"
void vm_events_fold_cpu(int);
# 111 "include/linux/vmstat.h"
extern atomic_long_t vm_stat[39U];
# 113 "include/linux/vmstat.h"
static inline void zone_page_state_add(long int x, struct zone *zone, enum zone_stat_item item)
{
# 116 "include/linux/vmstat.h"
  atomic_long_add ( x , ( atomic_long_t *) & ( * zone ) . vm_stat + ( long unsigned int ) item );
  atomic_long_add ( x , ( atomic_long_t *) & vm_stat + ( long unsigned int ) item );
}
# 120 "include/linux/vmstat.h"
static inline long unsigned int global_page_state(enum zone_stat_item item)
{
  long int x = atomic_long_read ( ( atomic_long_t *) & vm_stat + ( long unsigned int ) item );
# 124 "include/linux/vmstat.h"
  if (x < 0L)
    x = 0L;
# 127 "include/linux/vmstat.h"
  return ( long unsigned int ) x;
}
# 130 "include/linux/vmstat.h"
static inline long unsigned int zone_page_state(struct zone *zone, enum zone_stat_item item)
{
# 133 "include/linux/vmstat.h"
  long int x = atomic_long_read ( ( atomic_long_t *) & ( * zone ) . vm_stat + ( long unsigned int ) item );
# 135 "include/linux/vmstat.h"
  if (x < 0L)
    x = 0L;
# 138 "include/linux/vmstat.h"
  return ( long unsigned int ) x;
}
# 147 "include/linux/vmstat.h"
static inline long unsigned int zone_page_state_snapshot(struct zone *zone, enum zone_stat_item item)
{
# 150 "include/linux/vmstat.h"
  long int x = atomic_long_read ( ( atomic_long_t *) & ( * zone ) . vm_stat + ( long unsigned int ) item );
# 153 "include/linux/vmstat.h"
  int cpu;
  cpu = -1;
# 154 "include/linux/vmstat.h"
  goto ldv_26210;
  ldv_26209:;
# 155 "include/linux/vmstat.h"
  x = ( long int ) ( * ({
    {
# 155 "include/linux/vmstat.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 155 "include/linux/vmstat.h"
      ( void ) __vpp_verify;
    }
# 155 "include/linux/vmstat.h"
    ({
# 155 "include/linux/vmstat.h"
      long unsigned int __ptr;
# 155 "include/linux/vmstat.h"
      asm ( "" : "=r" ( __ptr ) : "0" ( ( * zone ) . pageset ) ) ;
# 155 "include/linux/vmstat.h"
      ( struct per_cpu_pageset *) ( __per_cpu_offset [ cpu ] + __ptr );
    } );
  } ) )
# 155 "include/linux/vmstat.h"
  . vm_stat_diff [ ( unsigned int ) item ] + x;
  ldv_26210:;
# 154 "include/linux/vmstat.h"
  if (cpu = ( int ) cpumask_next ( cpu , cpu_online_mask ), cpu < nr_cpu_ids)
  {
    goto ldv_26209;
  }
  else
    goto ldv_26211;
  ldv_26211:;
# 157 "include/linux/vmstat.h"
  if (x < 0L)
    x = 0L;
# 160 "include/linux/vmstat.h"
  return ( long unsigned int ) x;
}
# 169 "include/linux/vmstat.h"
static inline long unsigned int node_page_state(int node, enum zone_stat_item item)
{
# 172 "include/linux/vmstat.h"
  struct zone *zones = ( struct zone *) & ( * node_data [ node ] ) . node_zones;
# 174 "include/linux/vmstat.h"
  return zone_page_state
# 176 "include/linux/vmstat.h"
  ( zones , item ) + zone_page_state
# 179 "include/linux/vmstat.h"
  ( zones + 1UL , item ) + zone_page_state
# 184 "include/linux/vmstat.h"
  ( zones + 2UL , item ) + zone_page_state
# 185 "include/linux/vmstat.h"
  ( zones + 3UL , item );
}
# 188 "include/linux/vmstat.h"
void zone_statistics(struct zone *, struct zone *, gfp_t);
# 201 "include/linux/vmstat.h"
void __mod_zone_page_state(struct zone *, enum zone_stat_item, int);
void __inc_zone_page_state(struct page *, enum zone_stat_item);
void __dec_zone_page_state(struct page *, enum zone_stat_item);
# 205 "include/linux/vmstat.h"
void mod_zone_page_state(struct zone *, enum zone_stat_item, int);
void inc_zone_page_state(struct page *, enum zone_stat_item);
void dec_zone_page_state(struct page *, enum zone_stat_item);
# 209 "include/linux/vmstat.h"
void inc_zone_state(struct zone *, enum zone_stat_item);
void __inc_zone_state(struct zone *, enum zone_stat_item);
void dec_zone_state(struct zone *, enum zone_stat_item);
void __dec_zone_state(struct zone *, enum zone_stat_item);
# 214 "include/linux/vmstat.h"
void cpu_vm_stats_fold(int);
void refresh_zone_stat_thresholds(void);
# 217 "include/linux/vmstat.h"
void drain_zonestat(struct zone *, struct per_cpu_pageset *);
# 219 "include/linux/vmstat.h"
int calculate_pressure_threshold(struct zone *);
int calculate_normal_threshold(struct zone *);
void set_pgdat_percpu_threshold(pg_data_t *, int (*)(struct zone *));
# 280 "include/linux/vmstat.h"
static inline void __mod_zone_freepage_state(struct zone *zone, int nr_pages, int migratetype)
{
# 283 "include/linux/vmstat.h"
  __mod_zone_page_state ( zone , NR_FREE_PAGES , nr_pages );
  if (__builtin_expect ( migratetype == 4 , 0L ) != 0L)
    __mod_zone_page_state ( zone , NR_FREE_CMA_PAGES , nr_pages );
}
# 288 "include/linux/vmstat.h"
extern char const *const vmstat_text[];
# 912 "include/linux/mm.h"
static inline void *lowmem_page_address(struct page const *page)
{
  return ( void *) ( ( long unsigned int ) ( ( long long unsigned int ) ( ( ( long int ) page + 24189255811072L ) / 64L ) << 12 ) + 18446612132314218496UL );
}
# 965 "include/linux/mm.h"
struct address_space *page_mapping(struct page *);
# 968 "include/linux/mm.h"
static inline void *page_rmapping(struct page *page)
{
  return ( void *) ( ( long unsigned int ) ( * page ) . ldv_14261 . mapping & 18446744073709551612UL );
}
# 973 "include/linux/mm.h"
struct address_space *__page_file_mapping(struct page *);
# 976 "include/linux/mm.h"
static inline struct address_space *page_file_mapping(struct page *page)
{
  if (__builtin_expect ( PageSwapCache ( ( struct page const *) page ) != 0 , 0L ) != 0L)
    return __page_file_mapping ( page );
# 981 "include/linux/mm.h"
  return ( * page ) . ldv_14261 . mapping;
}
# 984 "include/linux/mm.h"
static inline int PageAnon(struct page *page)
{
  return ( int ) ( long unsigned int ) ( * page ) . ldv_14261 . mapping & 1;
}
# 993 "include/linux/mm.h"
static inline long unsigned int page_index(struct page *page)
{
  if (__builtin_expect ( PageSwapCache ( ( struct page const *) page ) != 0 , 0L ) != 0L)
    return ( * page ) . ldv_14302 . private;
  return ( * page ) . ldv_14284 . ldv_14267 . index;
}
# 1000 "include/linux/mm.h"
long unsigned int __page_file_index(struct page *);
# 1006 "include/linux/mm.h"
static inline long unsigned int page_file_index(struct page *page)
{
  if (__builtin_expect ( PageSwapCache ( ( struct page const *) page ) != 0 , 0L ) != 0L)
    return __page_file_index ( page );
# 1011 "include/linux/mm.h"
  return ( * page ) . ldv_14284 . ldv_14267 . index;
}
# 1017 "include/linux/mm.h"
static inline int page_mapped(struct page *page)
{
  return atomic_read ( ( atomic_t const *) & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . ldv_14279 . _mapcount ) >= 0;
}
# 1054 "include/linux/mm.h"
void pagefault_out_of_memory(void);
# 1064 "include/linux/mm.h"
void show_free_areas(unsigned int);
bool skip_free_areas_node(unsigned int, int);
# 1067 "include/linux/mm.h"
int shmem_zero_setup(struct vm_area_struct *);
# 1069 "include/linux/mm.h"
bool shmem_mapping(struct address_space *);
# 1077 "include/linux/mm.h"
int can_do_mlock(void);
int user_shm_lock(size_t, struct user_struct *);
void user_shm_unlock(size_t, struct user_struct *);
struct zap_details
{
# 1085 "include/linux/mm.h"
  struct vm_area_struct *nonlinear_vma;
  struct address_space *check_mapping;
  long unsigned int first_index;
  long unsigned int last_index;
};
# 1091 "include/linux/mm.h"
struct page *vm_normal_page(struct vm_area_struct *, long unsigned int, pte_t);
# 1094 "include/linux/mm.h"
int zap_vma_ptes(struct vm_area_struct *, long unsigned int, long unsigned int);
# 1096 "include/linux/mm.h"
void zap_page_range(struct vm_area_struct *, long unsigned int, long unsigned int, struct zap_details *);
# 1098 "include/linux/mm.h"
void unmap_vmas(struct mmu_gather *, struct vm_area_struct *, long unsigned int, long unsigned int);
struct mm_walk
{
# 1118 "include/linux/mm.h"
  int (*pgd_entry)(pgd_t *, long unsigned int, long unsigned int, struct mm_walk *);
# 1120 "include/linux/mm.h"
  int (*pud_entry)(pud_t *, long unsigned int, long unsigned int, struct mm_walk *);
# 1122 "include/linux/mm.h"
  int (*pmd_entry)(pmd_t *, long unsigned int, long unsigned int, struct mm_walk *);
# 1124 "include/linux/mm.h"
  int (*pte_entry)(pte_t *, long unsigned int, long unsigned int, struct mm_walk *);
# 1126 "include/linux/mm.h"
  int (*pte_hole)(long unsigned int, long unsigned int, struct mm_walk *);
# 1128 "include/linux/mm.h"
  int (*hugetlb_entry)(pte_t *, long unsigned int, long unsigned int, long unsigned int, struct mm_walk *);
# 1131 "include/linux/mm.h"
  struct mm_struct *mm;
  void *private;
};
# 1135 "include/linux/mm.h"
int walk_page_range(long unsigned int, long unsigned int, struct mm_walk *);
# 1137 "include/linux/mm.h"
void free_pgd_range(struct mmu_gather *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
# 1139 "include/linux/mm.h"
int copy_page_range(struct mm_struct *, struct mm_struct *, struct vm_area_struct *);
# 1141 "include/linux/mm.h"
void unmap_mapping_range(struct address_space *, loff_t const, loff_t const, int);
# 1143 "include/linux/mm.h"
int follow_pfn(struct vm_area_struct *, long unsigned int, long unsigned int *);
# 1145 "include/linux/mm.h"
int follow_phys(struct vm_area_struct *, long unsigned int, unsigned int, long unsigned int *, resource_size_t *);
# 1147 "include/linux/mm.h"
int generic_access_phys(struct vm_area_struct *, long unsigned int, void *, int, int);
# 1150 "include/linux/mm.h"
static inline void unmap_shared_mapping_range(struct address_space *mapping, loff_t const holebegin, loff_t const holelen)
{
# 1153 "include/linux/mm.h"
  unmap_mapping_range ( mapping , holebegin , holelen , 0 );
}
# 1156 "include/linux/mm.h"
void truncate_pagecache(struct inode *, loff_t);
void truncate_setsize(struct inode *, loff_t);
void truncate_pagecache_range(struct inode *, loff_t, loff_t);
int truncate_inode_page(struct address_space *, struct page *);
int generic_error_remove_page(struct address_space *, struct page *);
int invalidate_inode_page(struct page *);
# 1164 "include/linux/mm.h"
int handle_mm_fault(struct mm_struct *, struct vm_area_struct *, long unsigned int, unsigned int);
# 1166 "include/linux/mm.h"
int fixup_user_fault(struct task_struct *, struct mm_struct *, long unsigned int, unsigned int);
# 1187 "include/linux/mm.h"
int access_process_vm(struct task_struct *, long unsigned int, void *, int, int);
int access_remote_vm(struct mm_struct *, long unsigned int, void *, int, int);
# 1191 "include/linux/mm.h"
long int __get_user_pages(struct task_struct *, struct mm_struct *, long unsigned int, long unsigned int, unsigned int, struct page **, struct vm_area_struct **, int *);
# 1195 "include/linux/mm.h"
long int get_user_pages(struct task_struct *, struct mm_struct *, long unsigned int, long unsigned int, int, int, struct page **, struct vm_area_struct **);
# 1199 "include/linux/mm.h"
int get_user_pages_fast(long unsigned int, int, int, struct page **);
struct kvec;
# 1202 "include/linux/mm.h"
int get_kernel_pages(struct kvec const *, int, int, struct page **);
# 1204 "include/linux/mm.h"
int get_kernel_page(long unsigned int, int, struct page **);
struct page *get_dump_page(long unsigned int);
# 1207 "include/linux/mm.h"
int try_to_release_page(struct page *, gfp_t);
void do_invalidatepage(struct page *, unsigned int, unsigned int);
# 1211 "include/linux/mm.h"
int __set_page_dirty_nobuffers(struct page *);
int __set_page_dirty_no_writeback(struct page *);
int redirty_page_for_writepage(struct writeback_control *, struct page *);
# 1215 "include/linux/mm.h"
void account_page_dirtied(struct page *, struct address_space *);
void account_page_writeback(struct page *);
int set_page_dirty(struct page *);
int set_page_dirty_lock(struct page *);
int clear_page_dirty_for_io(struct page *);
int get_cmdline(struct task_struct *, char *, int);
# 1223 "include/linux/mm.h"
static inline int vma_growsdown(struct vm_area_struct *vma, long unsigned int addr)
{
  return vma != ( ( struct vm_area_struct *) 0 ) && ( * vma ) . vm_end == addr && ( ( * vma ) . vm_flags & 256UL ) != 0UL;
}
# 1228 "include/linux/mm.h"
static inline int stack_guard_page_start(struct vm_area_struct *vma, long unsigned int addr)
{
# 1231 "include/linux/mm.h"
  return ( ( * vma ) . vm_flags & 256UL ) != 0UL && (
# 1232 "include/linux/mm.h"
  * vma ) . vm_start == addr && vma_growsdown
# 1233 "include/linux/mm.h"
  ( ( * vma ) . vm_prev , addr ) == 0;
}
# 1237 "include/linux/mm.h"
static inline int vma_growsup(struct vm_area_struct *vma, long unsigned int addr)
{
  return 0;
}
# 1242 "include/linux/mm.h"
static inline int stack_guard_page_end(struct vm_area_struct *vma, long unsigned int addr)
{
# 1245 "include/linux/mm.h"
  return 0;
}
# 1251 "include/linux/mm.h"
pid_t vm_is_stack(struct task_struct *, struct vm_area_struct *, int);
# 1253 "include/linux/mm.h"
long unsigned int move_page_tables(struct vm_area_struct *, long unsigned int, struct vm_area_struct *, long unsigned int, long unsigned int, bool);
# 1257 "include/linux/mm.h"
long unsigned int change_protection(struct vm_area_struct *, long unsigned int, long unsigned int, pgprot_t, int, int);
# 1260 "include/linux/mm.h"
int mprotect_fixup(struct vm_area_struct *, struct vm_area_struct **, long unsigned int, long unsigned int, long unsigned int);
# 1267 "include/linux/mm.h"
int __get_user_pages_fast(long unsigned int, int, int, struct page **);
# 1272 "include/linux/mm.h"
static inline long unsigned int get_mm_counter(struct mm_struct *mm, int member)
{
  long int val = atomic_long_read ( ( atomic_long_t *) & ( * mm ) . rss_stat . count + ( long unsigned int ) member );
# 1281 "include/linux/mm.h"
  if (val < 0L)
    val = 0L;
# 1284 "include/linux/mm.h"
  return ( long unsigned int ) val;
}
# 1287 "include/linux/mm.h"
static inline void add_mm_counter(struct mm_struct *mm, int member, long int value)
{
  atomic_long_add ( value , ( atomic_long_t *) & ( * mm ) . rss_stat . count + ( long unsigned int ) member );
}
# 1292 "include/linux/mm.h"
static inline void inc_mm_counter(struct mm_struct *mm, int member)
{
  atomic_long_inc ( ( atomic_long_t *) & ( * mm ) . rss_stat . count + ( long unsigned int ) member );
}
# 1297 "include/linux/mm.h"
static inline void dec_mm_counter(struct mm_struct *mm, int member)
{
  atomic_long_dec ( ( atomic_long_t *) & ( * mm ) . rss_stat . count + ( long unsigned int ) member );
}
# 1302 "include/linux/mm.h"
static inline long unsigned int get_mm_rss(struct mm_struct *mm)
{
  return get_mm_counter ( mm , 0 ) + get_mm_counter
# 1305 "include/linux/mm.h"
  ( mm , 1 );
}
# 1308 "include/linux/mm.h"
static inline long unsigned int get_mm_hiwater_rss(struct mm_struct *mm)
{
  return ({
# 1310 "include/linux/mm.h"
    long unsigned int _max1 = ( * mm ) . hiwater_rss;
# 1310 "include/linux/mm.h"
    long unsigned int _max2 = get_mm_rss ( mm );
# 1310 "include/linux/mm.h"
    ( void ) 0;
# 1310 "include/linux/mm.h"
    ((_max1) > (_max2) ? (_max1) : (_max2));
  } );
}
static inline long unsigned int get_mm_hiwater_vm(struct mm_struct *mm)
{
  return ({
# 1315 "include/linux/mm.h"
    long unsigned int _max1 = ( * mm ) . hiwater_vm;
# 1315 "include/linux/mm.h"
    long unsigned int _max2 = ( * mm ) . total_vm;
# 1315 "include/linux/mm.h"
    ( void ) 0;
# 1315 "include/linux/mm.h"
    ((_max1) > (_max2) ? (_max1) : (_max2));
  } );
}
static inline void update_hiwater_rss(struct mm_struct *mm)
{
  long unsigned int _rss = get_mm_rss ( mm );
# 1322 "include/linux/mm.h"
  if (( * mm ) . hiwater_rss < _rss)
    ( * mm ) . hiwater_rss = _rss;
}
# 1326 "include/linux/mm.h"
static inline void update_hiwater_vm(struct mm_struct *mm)
{
  if (( * mm ) . hiwater_vm < ( * mm ) . total_vm)
    ( * mm ) . hiwater_vm = ( * mm ) . total_vm;
}
# 1332 "include/linux/mm.h"
static inline void setmax_mm_hiwater_rss(long unsigned int *maxrss, struct mm_struct *mm)
{
# 1335 "include/linux/mm.h"
  long unsigned int hiwater_rss = get_mm_hiwater_rss ( mm );
# 1337 "include/linux/mm.h"
  if (* maxrss < hiwater_rss)
    * maxrss = hiwater_rss;
}
# 1342 "include/linux/mm.h"
void sync_mm_rss(struct mm_struct *);
# 1349 "include/linux/mm.h"
int vma_wants_writenotify(struct vm_area_struct *);
# 1351 "include/linux/mm.h"
pte_t *__get_locked_pte(struct mm_struct *, long unsigned int, spinlock_t **);
# 1353 "include/linux/mm.h"
static inline pte_t *get_locked_pte(struct mm_struct *mm, long unsigned int addr, spinlock_t **ptl)
{
# 1356 "include/linux/mm.h"
  pte_t *ptep;
  ptep = __get_locked_pte ( mm , addr , ptl );
  return ptep;
}
# 1368 "include/linux/mm.h"
int __pud_alloc(struct mm_struct *, pgd_t *, long unsigned int);
# 1378 "include/linux/mm.h"
int __pmd_alloc(struct mm_struct *, pud_t *, long unsigned int);
# 1381 "include/linux/mm.h"
int __pte_alloc(struct mm_struct *, struct vm_area_struct *, pmd_t *, long unsigned int);
# 1383 "include/linux/mm.h"
int __pte_alloc_kernel(pmd_t *, long unsigned int);
# 1390 "include/linux/mm.h"
static inline pud_t *pud_alloc(struct mm_struct *mm, pgd_t *pgd, long unsigned int address)
{
  return __builtin_expect ( pgd_none ( * pgd ) != 0 , 0L ) == 0L
# 1393 "include/linux/mm.h"
  || __pud_alloc
# 1392 "include/linux/mm.h"
  ( mm , pgd , address ) == 0 ? pud_offset
# 1393 "include/linux/mm.h"
  ( pgd , address ) : ( ( pud_t *) 0 );
}
# 1396 "include/linux/mm.h"
static inline pmd_t *pmd_alloc(struct mm_struct *mm, pud_t *pud, long unsigned int address)
{
  return __builtin_expect ( pud_none ( * pud ) != 0 , 0L ) == 0L
# 1399 "include/linux/mm.h"
  || __pmd_alloc
# 1398 "include/linux/mm.h"
  ( mm , pud , address ) == 0 ? pmd_offset
# 1399 "include/linux/mm.h"
  ( pud , address ) : ( ( pmd_t *) 0 );
}
# 1405 "include/linux/mm.h"
void ptlock_cache_init(void);
bool ptlock_alloc(struct page *);
void ptlock_free(struct page *);
# 1409 "include/linux/mm.h"
static inline spinlock_t *ptlock_ptr(struct page *page)
{
  return ( * page ) . ldv_14302 . ptl;
}
# 1433 "include/linux/mm.h"
static inline spinlock_t *pte_lockptr(struct mm_struct *mm, pmd_t *pmd)
{
  return ptlock_ptr ( ( ( struct page *) -24189255811072 ) + ( ( ( long unsigned int ) pmd_val ( * pmd ) & 70368744173568UL ) >> 12 ) );
}
# 1438 "include/linux/mm.h"
static inline bool ptlock_init(struct page *page)
{
# 1448 "include/linux/mm.h"
  if (__builtin_expect ( * ( long unsigned int *) & ( * page ) . ldv_14302 . ptl != 0UL , 0L ) != 0L)
  {
# 1448 "include/linux/mm.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(*(unsigned long *)&page->ptl)" );
# 1448 "include/linux/mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/mm.h" ) , "i" ( 1448 ) , "i" ( 12UL ) ) ;
    ldv_26666:;
# 1448 "include/linux/mm.h"
    goto ldv_26666;
  }
# 1449 "include/linux/mm.h"
  if (( int ) ! ( _Bool ) ptlock_alloc ( page ))
    return 0;
  spinlock_check ( ptlock_ptr ( page ) );
  {
# 1451 "include/linux/mm.h"
    struct lock_class_key __key;
# 1451 "include/linux/mm.h"
    __raw_spin_lock_init ( ( raw_spinlock_t *) & ( * ptlock_ptr ( page ) ) . ldv_6073 . rlock , ( char const *) "&(ptlock_ptr(page))->rlock" , & __key );
  }
# 1452 "include/linux/mm.h"
  return 1;
}
# 1456 "include/linux/mm.h"
static inline void pte_lock_deinit(struct page *page)
{
  ( * page ) . ldv_14261 . mapping = ( ( struct address_space *) 0 );
  ptlock_free ( page );
}
# 1475 "include/linux/mm.h"
static inline void pgtable_init(void)
{
  ptlock_cache_init ( );
}
# 1481 "include/linux/mm.h"
static inline bool pgtable_page_ctor(struct page *page)
{
  inc_zone_page_state ( page , NR_PAGETABLE );
  return ptlock_init ( page );
}
# 1487 "include/linux/mm.h"
static inline void pgtable_page_dtor(struct page *page)
{
  pte_lock_deinit ( page );
  dec_zone_page_state ( page , NR_PAGETABLE );
}
# 1523 "include/linux/mm.h"
static struct page *pmd_to_page(pmd_t *pmd)
{
  long unsigned int mask = 18446744073709547520UL;
  return ( ( struct page *) -24189255811072 ) + ( __phys_addr ( ( long unsigned int ) pmd & mask ) >> 12 );
}
# 1529 "include/linux/mm.h"
static inline spinlock_t *pmd_lockptr(struct mm_struct *mm, pmd_t *pmd)
{
  return ptlock_ptr ( pmd_to_page ( pmd ) );
}
# 1534 "include/linux/mm.h"
static inline bool pgtable_pmd_page_ctor(struct page *page)
{
# 1537 "include/linux/mm.h"
  ( * page ) . ldv_14296 . pmd_huge_pte = ( ( pgtable_t ) 0 );
# 1539 "include/linux/mm.h"
  return ptlock_init ( page );
}
# 1542 "include/linux/mm.h"
static inline void pgtable_pmd_page_dtor(struct page *page)
{
# 1545 "include/linux/mm.h"
  if (__builtin_expect ( ( * page ) . ldv_14296 . pmd_huge_pte != ( ( pgtable_t ) 0 ) , 0L ) != 0L)
  {
# 1545 "include/linux/mm.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(page->pmd_huge_pte)" );
# 1545 "include/linux/mm.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/mm.h" ) , "i" ( 1545 ) , "i" ( 12UL ) ) ;
    ldv_26694:;
# 1545 "include/linux/mm.h"
    goto ldv_26694;
  }
  ptlock_free ( page );
}
# 1566 "include/linux/mm.h"
static inline spinlock_t *pmd_lock(struct mm_struct *mm, pmd_t *pmd)
{
  spinlock_t *ptl = pmd_lockptr ( mm , pmd );
  spin_lock ( ptl );
  return ptl;
}
# 1573 "include/linux/mm.h"
void free_area_init(long unsigned int *);
void free_area_init_node(int, long unsigned int *, long unsigned int, long unsigned int *);
# 1576 "include/linux/mm.h"
void free_initmem(void);
# 1584 "include/linux/mm.h"
long unsigned int free_reserved_area(void *, void *, int, char *);
# 1595 "include/linux/mm.h"
void adjust_managed_page_count(struct page *, long int);
void mem_init_print_info(char const *);
# 1599 "include/linux/mm.h"
static inline void __free_reserved_page(struct page *page)
{
  ClearPageReserved ( page );
  init_page_count ( page );
  __free_pages ( page , 0U );
}
# 1606 "include/linux/mm.h"
static inline void free_reserved_page(struct page *page)
{
  __free_reserved_page ( page );
  adjust_managed_page_count ( page , 1L );
}
# 1612 "include/linux/mm.h"
static inline void mark_page_reserved(struct page *page)
{
  SetPageReserved ( page );
  adjust_managed_page_count ( page , -1L );
}
# 1626 "include/linux/mm.h"
extern char __init_begin[];
# 1626 "include/linux/mm.h"
extern char __init_end[];
# 1624 "include/linux/mm.h"
static inline long unsigned int free_initmem_default(int poison)
{
  char __init_begin[];
# 1626 "include/linux/mm.h"
  char __init_end[];
# 1628 "include/linux/mm.h"
  return free_reserved_area ( ( void *) & __init_begin , ( void *) & __init_end , poison ,
# 1629 "include/linux/mm.h"
  ( char *) "unused kernel" );
}
# 1632 "include/linux/mm.h"
static inline long unsigned int get_num_physpages(void)
{
  int nid;
  long unsigned int phys_pages = 0UL;
# 1637 "include/linux/mm.h"
  nid = __first_node ( ( nodemask_t const *) & node_states + 1U );
# 1637 "include/linux/mm.h"
  goto ldv_26741;
  ldv_26740:;
# 1638 "include/linux/mm.h"
  phys_pages = ( * node_data [ nid ] ) . node_present_pages + phys_pages;
# 1637 "include/linux/mm.h"
  nid = __next_node ( nid , ( nodemask_t const *) & node_states + 1U );
  ldv_26741:;
# 1637 "include/linux/mm.h"
  if (nid <= 1023)
  {
    goto ldv_26740;
  }
  else
    goto ldv_26742;
  ldv_26742:;
# 1640 "include/linux/mm.h"
  return phys_pages;
}
# 1670 "include/linux/mm.h"
void free_area_init_nodes(long unsigned int *);
long unsigned int node_map_pfn_alignment(void);
long unsigned int __absent_pages_in_range(int, long unsigned int, long unsigned int);
# 1674 "include/linux/mm.h"
long unsigned int absent_pages_in_range(long unsigned int, long unsigned int);
# 1676 "include/linux/mm.h"
void get_pfn_range_for_nid(unsigned int, long unsigned int *, long unsigned int *);
# 1678 "include/linux/mm.h"
long unsigned int find_min_pfn_with_active_regions(void);
void free_bootmem_with_active_regions(int, long unsigned int);
# 1681 "include/linux/mm.h"
void sparse_memory_present_with_active_regions(int);
# 1693 "include/linux/mm.h"
int early_pfn_to_nid(long unsigned int);
# 1695 "include/linux/mm.h"
int __early_pfn_to_nid(long unsigned int);
# 1698 "include/linux/mm.h"
void set_dma_reserve(long unsigned int);
void memmap_init_zone(long unsigned int, int, long unsigned int, long unsigned int, enum memmap_context);
# 1701 "include/linux/mm.h"
void setup_per_zone_wmarks(void);
int init_per_zone_wmark_min(void);
void mem_init(void);
void mmap_init(void);
void show_mem(unsigned int);
void si_meminfo(struct sysinfo *);
void si_meminfo_node(struct sysinfo *, int);
# 1710 "include/linux/mm.h"
void warn_alloc_failed(gfp_t, int, char const *, ...);
# 1712 "include/linux/mm.h"
void setup_per_cpu_pageset(void);
# 1714 "include/linux/mm.h"
void zone_pcp_update(struct zone *);
void zone_pcp_reset(struct zone *);
# 1718 "include/linux/mm.h"
extern int min_free_kbytes;
# 1721 "include/linux/mm.h"
extern atomic_long_t mmap_pages_allocated;
int nommu_shrink_inode_mappings(struct inode *, size_t, size_t);
# 1725 "include/linux/mm.h"
void vma_interval_tree_insert(struct vm_area_struct *, struct rb_root *);
# 1727 "include/linux/mm.h"
void vma_interval_tree_insert_after(struct vm_area_struct *, struct vm_area_struct *, struct rb_root *);
# 1730 "include/linux/mm.h"
void vma_interval_tree_remove(struct vm_area_struct *, struct rb_root *);
# 1732 "include/linux/mm.h"
struct vm_area_struct *vma_interval_tree_iter_first(struct rb_root *, long unsigned int, long unsigned int);
# 1734 "include/linux/mm.h"
struct vm_area_struct *vma_interval_tree_iter_next(struct vm_area_struct *, long unsigned int, long unsigned int);
# 1741 "include/linux/mm.h"
static inline void vma_nonlinear_insert(struct vm_area_struct *vma, struct list_head *list)
{
# 1744 "include/linux/mm.h"
  list_add_tail ( & ( * vma ) . shared . nonlinear , list );
}
# 1747 "include/linux/mm.h"
void anon_vma_interval_tree_insert(struct anon_vma_chain *, struct rb_root *);
# 1749 "include/linux/mm.h"
void anon_vma_interval_tree_remove(struct anon_vma_chain *, struct rb_root *);
# 1751 "include/linux/mm.h"
struct anon_vma_chain *anon_vma_interval_tree_iter_first(struct rb_root *, long unsigned int, long unsigned int);
# 1753 "include/linux/mm.h"
struct anon_vma_chain *anon_vma_interval_tree_iter_next(struct anon_vma_chain *, long unsigned int, long unsigned int);
# 1756 "include/linux/mm.h"
void anon_vma_interval_tree_verify(struct anon_vma_chain *);
# 1764 "include/linux/mm.h"
int __vm_enough_memory(struct mm_struct *, long int, int);
int vma_adjust(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int, struct vm_area_struct *);
# 1767 "include/linux/mm.h"
struct vm_area_struct *vma_merge(struct mm_struct *, struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int, struct anon_vma *, struct file *, long unsigned int, struct mempolicy *);
# 1771 "include/linux/mm.h"
struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *);
int split_vma(struct mm_struct *, struct vm_area_struct *, long unsigned int, int);
# 1774 "include/linux/mm.h"
int insert_vm_struct(struct mm_struct *, struct vm_area_struct *);
void __vma_link_rb(struct mm_struct *, struct vm_area_struct *, struct rb_node **, struct rb_node *);
# 1777 "include/linux/mm.h"
void unlink_file_vma(struct vm_area_struct *);
struct vm_area_struct *copy_vma(struct vm_area_struct **, long unsigned int, long unsigned int, long unsigned int, bool *);
# 1781 "include/linux/mm.h"
void exit_mmap(struct mm_struct *);
# 1783 "include/linux/mm.h"
int mm_take_all_locks(struct mm_struct *);
void mm_drop_all_locks(struct mm_struct *);
# 1786 "include/linux/mm.h"
void set_mm_exe_file(struct mm_struct *, struct file *);
struct file *get_mm_exe_file(struct mm_struct *);
# 1789 "include/linux/mm.h"
int may_expand_vm(struct mm_struct *, long unsigned int);
struct vm_area_struct *_install_special_mapping(struct mm_struct *, long unsigned int, long unsigned int, long unsigned int, struct vm_special_mapping const *);
# 1795 "include/linux/mm.h"
int install_special_mapping(struct mm_struct *, long unsigned int, long unsigned int, long unsigned int, struct page **);
# 1799 "include/linux/mm.h"
long unsigned int get_unmapped_area(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
# 1801 "include/linux/mm.h"
long unsigned int mmap_region(struct file *, long unsigned int, long unsigned int, vm_flags_t, long unsigned int);
# 1803 "include/linux/mm.h"
long unsigned int do_mmap_pgoff(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int *);
# 1806 "include/linux/mm.h"
int do_munmap(struct mm_struct *, long unsigned int, size_t);
# 1809 "include/linux/mm.h"
int __mm_populate(long unsigned int, long unsigned int, int);
# 1811 "include/linux/mm.h"
static inline void mm_populate(long unsigned int addr, long unsigned int len)
{
# 1814 "include/linux/mm.h"
  ( void ) __mm_populate ( addr , len , 1 );
}
# 1821 "include/linux/mm.h"
long unsigned int vm_brk(long unsigned int, long unsigned int);
int vm_munmap(long unsigned int, size_t);
long unsigned int vm_mmap(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
struct vm_unmapped_area_info
{
# 1829 "include/linux/mm.h"
  long unsigned int flags;
  long unsigned int length;
  long unsigned int low_limit;
  long unsigned int high_limit;
  long unsigned int align_mask;
  long unsigned int align_offset;
};
# 1837 "include/linux/mm.h"
long unsigned int unmapped_area(struct vm_unmapped_area_info *);
long unsigned int unmapped_area_topdown(struct vm_unmapped_area_info *);
# 1850 "include/linux/mm.h"
static inline long unsigned int vm_unmapped_area(struct vm_unmapped_area_info *info)
{
  if (( ( * info ) . flags & 1UL ) == 0UL)
  {
# 1853 "include/linux/mm.h"
    return unmapped_area ( info );
  }
  else
# 1855 "include/linux/mm.h"
    return unmapped_area_topdown ( info );
}
# 1859 "include/linux/mm.h"
void truncate_inode_pages(struct address_space *, loff_t);
void truncate_inode_pages_range(struct address_space *, loff_t, loff_t);
# 1862 "include/linux/mm.h"
void truncate_inode_pages_final(struct address_space *);
# 1865 "include/linux/mm.h"
int filemap_fault(struct vm_area_struct *, struct vm_fault *);
void filemap_map_pages(struct vm_area_struct *, struct vm_fault *);
int filemap_page_mkwrite(struct vm_area_struct *, struct vm_fault *);
# 1870 "include/linux/mm.h"
int write_one_page(struct page *, int);
void task_dirty_inc(struct task_struct *);
# 1877 "include/linux/mm.h"
int force_page_cache_readahead(struct address_space *, struct file *, long unsigned int, long unsigned int);
# 1880 "include/linux/mm.h"
void page_cache_sync_readahead(struct address_space *, struct file_ra_state *, struct file *, long unsigned int, long unsigned int);
# 1886 "include/linux/mm.h"
void page_cache_async_readahead(struct address_space *, struct file_ra_state *, struct file *, struct page *, long unsigned int, long unsigned int);
# 1893 "include/linux/mm.h"
long unsigned int max_sane_readahead(long unsigned int);
# 1896 "include/linux/mm.h"
int expand_stack(struct vm_area_struct *, long unsigned int);
# 1899 "include/linux/mm.h"
int expand_downwards(struct vm_area_struct *, long unsigned int);
# 1908 "include/linux/mm.h"
struct vm_area_struct *find_vma(struct mm_struct *, long unsigned int);
struct vm_area_struct *find_vma_prev(struct mm_struct *, long unsigned int, struct vm_area_struct **);
# 1914 "include/linux/mm.h"
static inline struct vm_area_struct *find_vma_intersection(struct mm_struct *mm, long unsigned int start_addr, long unsigned int end_addr)
{
  struct vm_area_struct *vma = find_vma ( mm , start_addr );
# 1918 "include/linux/mm.h"
  if (vma != ( ( struct vm_area_struct *) 0 ) && ( * vma ) . vm_start >= end_addr)
    vma = ( ( struct vm_area_struct *) 0 );
  return vma;
}
# 1923 "include/linux/mm.h"
static inline long unsigned int vma_pages(struct vm_area_struct *vma)
{
  return ( * vma ) . vm_end - ( * vma ) . vm_start >> 12;
}
# 1929 "include/linux/mm.h"
static inline struct vm_area_struct *find_exact_vma(struct mm_struct *mm, long unsigned int vm_start, long unsigned int vm_end)
{
# 1932 "include/linux/mm.h"
  struct vm_area_struct *vma = find_vma ( mm , vm_start );
# 1934 "include/linux/mm.h"
  if (vma != ( ( struct vm_area_struct *) 0 ) && ( ( * vma ) . vm_start != vm_start || ( * vma ) . vm_end != vm_end ))
    vma = ( ( struct vm_area_struct *) 0 );
# 1937 "include/linux/mm.h"
  return vma;
}
# 1941 "include/linux/mm.h"
pgprot_t vm_get_page_prot(long unsigned int);
# 1950 "include/linux/mm.h"
long unsigned int change_prot_numa(struct vm_area_struct *, long unsigned int, long unsigned int);
# 1954 "include/linux/mm.h"
struct vm_area_struct *find_extend_vma(struct mm_struct *, long unsigned int);
int remap_pfn_range(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int, pgprot_t);
# 1957 "include/linux/mm.h"
int vm_insert_page(struct vm_area_struct *, long unsigned int, struct page *);
int vm_insert_pfn(struct vm_area_struct *, long unsigned int, long unsigned int);
# 1960 "include/linux/mm.h"
int vm_insert_mixed(struct vm_area_struct *, long unsigned int, long unsigned int);
# 1962 "include/linux/mm.h"
int vm_iomap_memory(struct vm_area_struct *, phys_addr_t, long unsigned int);
# 1965 "include/linux/mm.h"
struct page *follow_page_mask(struct vm_area_struct *, long unsigned int, unsigned int, unsigned int *);
# 1969 "include/linux/mm.h"
static inline struct page *follow_page(struct vm_area_struct *vma, long unsigned int address, unsigned int foll_flags)
{
# 1972 "include/linux/mm.h"
  unsigned int unused_page_mask;
  return follow_page_mask ( vma , address , foll_flags , & unused_page_mask );
}
# 1989 "include/linux/mm.h"
typedef int (*pte_fn_t)(pte_t *, pgtable_t, long unsigned int, void *);
# 1991 "include/linux/mm.h"
int apply_to_page_range(struct mm_struct *, long unsigned int, long unsigned int, pte_fn_t, void *);
# 1995 "include/linux/mm.h"
void vm_stat_account(struct mm_struct *, long unsigned int, struct file *, long int);
# 2005 "include/linux/mm.h"
void kernel_map_pages(struct page *, int, int);
# 2007 "include/linux/mm.h"
bool kernel_page_present(struct page *);
# 2018 "include/linux/mm.h"
struct vm_area_struct *get_gate_vma(struct mm_struct *);
int in_gate_area_no_mm(long unsigned int);
int in_gate_area(struct mm_struct *, long unsigned int);
# 2034 "include/linux/mm.h"
extern int sysctl_drop_caches;
int drop_caches_sysctl_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 2039 "include/linux/mm.h"
long unsigned int shrink_slab(struct shrink_control *, long unsigned int, long unsigned int);
# 2046 "include/linux/mm.h"
extern int randomize_va_space;
# 2049 "include/linux/mm.h"
char const *arch_vma_name(struct vm_area_struct *);
void print_vma_addr(char *, long unsigned int);
# 2052 "include/linux/mm.h"
void sparse_mem_maps_populate_node(struct page **, long unsigned int, long unsigned int, long unsigned int, int);
# 2058 "include/linux/mm.h"
struct page *sparse_mem_map_populate(long unsigned int, int);
pgd_t *vmemmap_pgd_populate(long unsigned int, int);
pud_t *vmemmap_pud_populate(pgd_t *, long unsigned int, int);
pmd_t *vmemmap_pmd_populate(pud_t *, long unsigned int, int);
pte_t *vmemmap_pte_populate(pmd_t *, long unsigned int, int);
void *vmemmap_alloc_block(long unsigned int, int);
void *vmemmap_alloc_block_buf(long unsigned int, int);
void vmemmap_verify(pte_t *, int, long unsigned int, long unsigned int);
int vmemmap_populate_basepages(long unsigned int, long unsigned int, int);
# 2068 "include/linux/mm.h"
int vmemmap_populate(long unsigned int, long unsigned int, int);
void vmemmap_populate_print_last(void);
# 2071 "include/linux/mm.h"
void vmemmap_free(long unsigned int, long unsigned int);
# 2073 "include/linux/mm.h"
void register_page_bootmem_memmap(long unsigned int, struct page *, long unsigned int);
enum mf_flags
{
  MF_COUNT_INCREASED = 1,
  MF_ACTION_REQUIRED = 2,
  MF_MUST_KILL = 4,
  MF_SOFT_OFFLINE = 8
};
# 2082 "include/linux/mm.h"
int memory_failure(long unsigned int, int, int);
void memory_failure_queue(long unsigned int, int, int);
int unpoison_memory(long unsigned int);
extern int sysctl_memory_failure_early_kill;
extern int sysctl_memory_failure_recovery;
void shake_page(struct page *, int);
extern atomic_long_t num_poisoned_pages;
int soft_offline_page(struct page *, int);
# 2092 "include/linux/mm.h"
void clear_huge_page(struct page *, long unsigned int, unsigned int);
# 2095 "include/linux/mm.h"
void copy_user_huge_page(struct page *, struct page *, long unsigned int, struct vm_area_struct *, unsigned int);
# 2101 "include/linux/mm.h"
extern unsigned int _debug_guardpage_minorder;
# 2103 "include/linux/mm.h"
static inline unsigned int debug_guardpage_minorder(void)
{
  return _debug_guardpage_minorder;
}
# 2108 "include/linux/mm.h"
static inline bool page_is_guard(struct page *page)
{
  return constant_test_bit ( 1L , ( long unsigned int const volatile *) & ( * page ) . debug_flags ) != 0;
}
# 2118 "include/linux/mm.h"
void setup_nr_node_ids(void);
# 61 "./arch/x86/include/asm/smap.h"
static inline void clac(void)
{
# 64 "./arch/x86/include/asm/smap.h"
  asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection" : : : "memory" ) ;
}
# 67 "./arch/x86/include/asm/smap.h"
static inline void stac(void)
{
# 70 "./arch/x86/include/asm/smap.h"
  asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection" : : : "memory" ) ;
}
# 44 "./arch/x86/include/asm/uaccess.h"
static inline bool __chk_range_not_ok(long unsigned int addr, long unsigned int size, long unsigned int limit)
{
# 53 "./arch/x86/include/asm/uaccess.h"
  if (0)
    return limit - size < addr;
# 57 "./arch/x86/include/asm/uaccess.h"
  addr += size;
  if (addr < size)
    return 1;
  return addr > limit;
}
struct exception_table_entry
{
# 106 "./arch/x86/include/asm/uaccess.h"
  int insn;
# 106 "./arch/x86/include/asm/uaccess.h"
  int fixup;
};
# 112 "./arch/x86/include/asm/uaccess.h"
int fixup_exception(struct pt_regs *);
int early_fixup_exception(long unsigned int *);
# 130 "./arch/x86/include/asm/uaccess.h"
int __get_user_1(void);
int __get_user_2(void);
int __get_user_4(void);
int __get_user_8(void);
int __get_user_bad(void);
# 227 "./arch/x86/include/asm/uaccess.h"
void __put_user_bad(void);
# 233 "./arch/x86/include/asm/uaccess.h"
void __put_user_1(void);
void __put_user_2(void);
void __put_user_4(void);
void __put_user_8(void);
struct __large_struct
{
# 414 "./arch/x86/include/asm/uaccess.h"
  long unsigned int buf[100U];
};
# 526 "./arch/x86/include/asm/uaccess.h"
long unsigned int copy_from_user_nmi(void *, void const *, long unsigned int);
# 528 "./arch/x86/include/asm/uaccess.h"
long int strncpy_from_user(char *, char const *, long int);
# 530 "./arch/x86/include/asm/uaccess.h"
long int strlen_user(char const *);
long int strnlen_user(char const *, long int);
# 533 "./arch/x86/include/asm/uaccess.h"
long unsigned int clear_user(void *, long unsigned int);
long unsigned int __clear_user(void *, long unsigned int);
# 536 "./arch/x86/include/asm/uaccess.h"
void __cmpxchg_wrong_size(void);
# 20 "./arch/x86/include/asm/uaccess_64.h"
long unsigned int copy_user_enhanced_fast_string(void *, void const *, unsigned int);
# 22 "./arch/x86/include/asm/uaccess_64.h"
long unsigned int copy_user_generic_string(void *, void const *, unsigned int);
# 24 "./arch/x86/include/asm/uaccess_64.h"
long unsigned int copy_user_generic_unrolled(void *, void const *, unsigned int);
# 27 "./arch/x86/include/asm/uaccess_64.h"
static inline long unsigned int copy_user_generic(void *to, void const *from, unsigned int len)
{
  unsigned int ret;
# 36 "./arch/x86/include/asm/uaccess_64.h"
  asm volatile ( "661:\n\tcall %P4\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 3*32+16)\n .byte 662b-661b\n .byte 6641f-6631f\n .long 661b - .\n .long 6632f - .\n .word ( 9*32+ 9)\n .byte 662b-661b\n .byte 6642f-6632f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n .byte 0xff + (6642f-6632f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\tcall %P5\n6641:\n\t6632:\n\tcall %P6\n6642:\n\t.popsection" : "=a" ( ret ) , "=D" ( to ) , "=S" ( from ) , "=d" ( len ) : [ old ] "i" ( & copy_user_generic_unrolled ) , [ new1 ] "i" ( & copy_user_generic_string ) , [ new2 ] "i" ( & copy_user_enhanced_fast_string ) , "1" ( to ) , "2" ( from ) , "3" ( len ) : "memory" , "rcx" , "r8" , "r9" , "r10" , "r11" ) ;
# 45 "./arch/x86/include/asm/uaccess_64.h"
  return ( long unsigned int ) ret;
}
# 49 "./arch/x86/include/asm/uaccess_64.h"
long unsigned int copy_in_user(void *, void const *, unsigned int);
# 52 "./arch/x86/include/asm/uaccess_64.h"
static inline int __copy_from_user_nocheck(void *dst, void const *src, unsigned int size)
{
  int ret = 0;
# 56 "./arch/x86/include/asm/uaccess_64.h"
  if (1)
    return ( int ) copy_user_generic ( dst , src , size );
  switch (size)
  {
# 59 "./arch/x86/include/asm/uaccess_64.h"
    case 1:;
# 59 "./arch/x86/include/asm/uaccess_64.h"
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovb %2,%b1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorb %b1,%b1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) , "=q" ( * ( u8 *) dst ) : "m" ( * ( struct __large_struct *) src ) , "i" ( 1 ) , "0" ( ret ) ) ;
# 61 "./arch/x86/include/asm/uaccess_64.h"
    return ret;
    case 2:;
# 62 "./arch/x86/include/asm/uaccess_64.h"
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %2,%w1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorw %w1,%w1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) , "=r" ( * ( u16 *) dst ) : "m" ( * ( struct __large_struct *) src ) , "i" ( 2 ) , "0" ( ret ) ) ;
# 64 "./arch/x86/include/asm/uaccess_64.h"
    return ret;
    case 4:;
# 65 "./arch/x86/include/asm/uaccess_64.h"
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovl %2,%k1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorl %k1,%k1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) , "=r" ( * ( u32 *) dst ) : "m" ( * ( struct __large_struct *) src ) , "i" ( 4 ) , "0" ( ret ) ) ;
# 67 "./arch/x86/include/asm/uaccess_64.h"
    return ret;
    case 8:;
# 68 "./arch/x86/include/asm/uaccess_64.h"
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %2,%1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorq %1,%1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) , "=r" ( * ( u64 *) dst ) : "m" ( * ( struct __large_struct *) src ) , "i" ( 8 ) , "0" ( ret ) ) ;
# 70 "./arch/x86/include/asm/uaccess_64.h"
    return ret;
    case 10:;
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %2,%1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorq %1,%1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) , "=r" ( * ( u64 *) dst ) : "m" ( * ( struct __large_struct *) src ) , "i" ( 10 ) , "0" ( ret ) ) ;
# 74 "./arch/x86/include/asm/uaccess_64.h"
    if (__builtin_expect ( ret != 0 , 0L ) != 0L)
      return ret;
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %2,%w1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorw %w1,%w1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) , "=r" ( * ( ( u16 *) dst + 8U ) ) : "m" ( * ( ( struct __large_struct *) src + 8U ) ) , "i" ( 2 ) , "0" ( ret ) ) ;
# 79 "./arch/x86/include/asm/uaccess_64.h"
    return ret;
    case 16:;
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %2,%1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorq %1,%1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) , "=r" ( * ( u64 *) dst ) : "m" ( * ( struct __large_struct *) src ) , "i" ( 16 ) , "0" ( ret ) ) ;
# 83 "./arch/x86/include/asm/uaccess_64.h"
    if (__builtin_expect ( ret != 0 , 0L ) != 0L)
      return ret;
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %2,%1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorq %1,%1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) , "=r" ( * ( ( u64 *) dst + 8U ) ) : "m" ( * ( ( struct __large_struct *) src + 8U ) ) , "i" ( 8 ) , "0" ( ret ) ) ;
# 88 "./arch/x86/include/asm/uaccess_64.h"
    return ret;
    default:;
    return ( int ) copy_user_generic ( dst , src , size );
  }
}
# 95 "./arch/x86/include/asm/uaccess_64.h"
static inline int __copy_from_user(void *dst, void const *src, unsigned int size)
{
  might_fault ( );
  return __copy_from_user_nocheck ( dst , src , size );
}
# 102 "./arch/x86/include/asm/uaccess_64.h"
static inline int __copy_to_user_nocheck(void *dst, void const *src, unsigned int size)
{
  int ret = 0;
# 106 "./arch/x86/include/asm/uaccess_64.h"
  if (1)
    return ( int ) copy_user_generic ( dst , src , size );
  switch (size)
  {
# 109 "./arch/x86/include/asm/uaccess_64.h"
    case 1:;
# 109 "./arch/x86/include/asm/uaccess_64.h"
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovb %b1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) : "iq" ( * ( u8 *) src ) , "m" ( * ( struct __large_struct *) dst ) , "i" ( 1 ) , "0" ( ret ) ) ;
# 111 "./arch/x86/include/asm/uaccess_64.h"
    return ret;
    case 2:;
# 112 "./arch/x86/include/asm/uaccess_64.h"
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %w1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) : "ir" ( * ( u16 *) src ) , "m" ( * ( struct __large_struct *) dst ) , "i" ( 2 ) , "0" ( ret ) ) ;
# 114 "./arch/x86/include/asm/uaccess_64.h"
    return ret;
    case 4:;
# 115 "./arch/x86/include/asm/uaccess_64.h"
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovl %k1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) : "ir" ( * ( u32 *) src ) , "m" ( * ( struct __large_struct *) dst ) , "i" ( 4 ) , "0" ( ret ) ) ;
# 117 "./arch/x86/include/asm/uaccess_64.h"
    return ret;
    case 8:;
# 118 "./arch/x86/include/asm/uaccess_64.h"
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) : "er" ( * ( u64 *) src ) , "m" ( * ( struct __large_struct *) dst ) , "i" ( 8 ) , "0" ( ret ) ) ;
# 120 "./arch/x86/include/asm/uaccess_64.h"
    return ret;
    case 10:;
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) : "er" ( * ( u64 *) src ) , "m" ( * ( struct __large_struct *) dst ) , "i" ( 10 ) , "0" ( ret ) ) ;
# 124 "./arch/x86/include/asm/uaccess_64.h"
    if (__builtin_expect ( ret != 0 , 0L ) != 0L)
      return ret;
    asm volatile ( "" : : : "memory" ) ;
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %w1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) : "ir" ( * ( ( u16 *) src + 4UL ) ) , "m" ( * ( ( struct __large_struct *) dst + 4U ) ) , "i" ( 2 ) , "0" ( ret ) ) ;
# 129 "./arch/x86/include/asm/uaccess_64.h"
    return ret;
    case 16:;
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) : "er" ( * ( u64 *) src ) , "m" ( * ( struct __large_struct *) dst ) , "i" ( 16 ) , "0" ( ret ) ) ;
# 133 "./arch/x86/include/asm/uaccess_64.h"
    if (__builtin_expect ( ret != 0 , 0L ) != 0L)
      return ret;
    asm volatile ( "" : : : "memory" ) ;
    asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) : "er" ( * ( ( u64 *) src + 1UL ) ) , "m" ( * ( ( struct __large_struct *) dst + 1U ) ) , "i" ( 8 ) , "0" ( ret ) ) ;
# 138 "./arch/x86/include/asm/uaccess_64.h"
    return ret;
    default:;
    return ( int ) copy_user_generic ( dst , src , size );
  }
}
# 145 "./arch/x86/include/asm/uaccess_64.h"
static inline int __copy_to_user(void *dst, void const *src, unsigned int size)
{
  might_fault ( );
  return __copy_to_user_nocheck ( dst , src , size );
}
# 152 "./arch/x86/include/asm/uaccess_64.h"
static inline int __copy_in_user(void *dst, void const *src, unsigned int size)
{
  int ret = 0;
# 156 "./arch/x86/include/asm/uaccess_64.h"
  might_fault ( );
  if (1)
    return ( int ) copy_user_generic ( dst , src , size );
# 160 "./arch/x86/include/asm/uaccess_64.h"
  switch (size)
  {
# 161 "./arch/x86/include/asm/uaccess_64.h"
    case 1:;
    {
# 162 "./arch/x86/include/asm/uaccess_64.h"
      u8 tmp;
      asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovb %2,%b1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorb %b1,%b1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) , "=q" ( tmp ) : "m" ( * ( struct __large_struct *) src ) , "i" ( 1 ) , "0" ( ret ) ) ;
# 165 "./arch/x86/include/asm/uaccess_64.h"
      if (__builtin_expect ( ret == 0 , 1L ) != 0L)
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovb %b1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) : "iq" ( tmp ) , "m" ( * ( struct __large_struct *) dst ) , "i" ( 1 ) , "0" ( ret ) ) ;
# 168 "./arch/x86/include/asm/uaccess_64.h"
      return ret;
    }
    case 2:;
    {
# 171 "./arch/x86/include/asm/uaccess_64.h"
      u16 tmp;
      asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %2,%w1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorw %w1,%w1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) , "=r" ( tmp ) : "m" ( * ( struct __large_struct *) src ) , "i" ( 2 ) , "0" ( ret ) ) ;
# 174 "./arch/x86/include/asm/uaccess_64.h"
      if (__builtin_expect ( ret == 0 , 1L ) != 0L)
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %w1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) : "ir" ( tmp ) , "m" ( * ( struct __large_struct *) dst ) , "i" ( 2 ) , "0" ( ret ) ) ;
# 177 "./arch/x86/include/asm/uaccess_64.h"
      return ret;
    }
# 180 "./arch/x86/include/asm/uaccess_64.h"
    case 4:;
    {
# 181 "./arch/x86/include/asm/uaccess_64.h"
      u32 tmp;
      asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovl %2,%k1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorl %k1,%k1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) , "=r" ( tmp ) : "m" ( * ( struct __large_struct *) src ) , "i" ( 4 ) , "0" ( ret ) ) ;
# 184 "./arch/x86/include/asm/uaccess_64.h"
      if (__builtin_expect ( ret == 0 , 1L ) != 0L)
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovl %k1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) : "ir" ( tmp ) , "m" ( * ( struct __large_struct *) dst ) , "i" ( 4 ) , "0" ( ret ) ) ;
# 187 "./arch/x86/include/asm/uaccess_64.h"
      return ret;
    }
    case 8:;
    {
# 190 "./arch/x86/include/asm/uaccess_64.h"
      u64 tmp;
      asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %2,%1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorq %1,%1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) , "=r" ( tmp ) : "m" ( * ( struct __large_struct *) src ) , "i" ( 8 ) , "0" ( ret ) ) ;
# 193 "./arch/x86/include/asm/uaccess_64.h"
      if (__builtin_expect ( ret == 0 , 1L ) != 0L)
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( ret ) : "er" ( tmp ) , "m" ( * ( struct __large_struct *) dst ) , "i" ( 8 ) , "0" ( ret ) ) ;
# 196 "./arch/x86/include/asm/uaccess_64.h"
      return ret;
    }
    default:;
    return ( int ) copy_user_generic ( dst , src , size );
  }
}
# 205 "./arch/x86/include/asm/uaccess_64.h"
static inline int __copy_from_user_inatomic(void *dst, void const *src, unsigned int size)
{
  return __copy_from_user_nocheck ( dst , src , size );
}
# 211 "./arch/x86/include/asm/uaccess_64.h"
static inline int __copy_to_user_inatomic(void *dst, void const *src, unsigned int size)
{
  return __copy_to_user_nocheck ( dst , src , size );
}
# 216 "./arch/x86/include/asm/uaccess_64.h"
long int __copy_user_nocache(void *, void const *, unsigned int, int);
# 220 "./arch/x86/include/asm/uaccess_64.h"
static inline int __copy_from_user_nocache(void *dst, void const *src, unsigned int size)
{
  might_fault ( );
  return ( int ) __copy_user_nocache ( dst , src , size , 1 );
}
# 227 "./arch/x86/include/asm/uaccess_64.h"
static inline int __copy_from_user_inatomic_nocache(void *dst, void const *src, unsigned int size)
{
# 230 "./arch/x86/include/asm/uaccess_64.h"
  return ( int ) __copy_user_nocache ( dst , src , size , 0 );
}
# 234 "./arch/x86/include/asm/uaccess_64.h"
long unsigned int copy_user_handle_tail(char *, char *, unsigned int, unsigned int);
# 645 "./arch/x86/include/asm/uaccess.h"
long unsigned int _copy_from_user(void *, void const *, unsigned int);
# 647 "./arch/x86/include/asm/uaccess.h"
long unsigned int _copy_to_user(void *, void const *, unsigned int);
# 657 "./arch/x86/include/asm/uaccess.h"
void copy_from_user_overflow(void);
# 659 "./arch/x86/include/asm/uaccess.h"
void copy_to_user_overflow(void);
# 667 "./arch/x86/include/asm/uaccess.h"
void __copy_from_user_overflow(void);
# 672 "./arch/x86/include/asm/uaccess.h"
void __copy_to_user_overflow(void);
# 688 "./arch/x86/include/asm/uaccess.h"
static inline long unsigned int copy_from_user(void *to, void const *from, long unsigned int n)
{
  int sz = ( int ) __builtin_object_size ( ( void const *) to , 0 );
# 692 "./arch/x86/include/asm/uaccess.h"
  might_fault ( );
# 712 "./arch/x86/include/asm/uaccess.h"
  if (__builtin_expect ( sz < 0 , 1L ) != 0L || __builtin_expect ( ( long unsigned int ) sz >= n , 1L ) != 0L)
  {
# 713 "./arch/x86/include/asm/uaccess.h"
    n = _copy_from_user ( to , from , ( unsigned int ) n );
  }
  else
# 714 "./arch/x86/include/asm/uaccess.h"
    if (0)
    {
# 715 "./arch/x86/include/asm/uaccess.h"
      copy_from_user_overflow ( );
    }
    else
# 717 "./arch/x86/include/asm/uaccess.h"
      __copy_from_user_overflow ( );
# 719 "./arch/x86/include/asm/uaccess.h"
  return n;
}
# 723 "./arch/x86/include/asm/uaccess.h"
static inline long unsigned int copy_to_user(void *to, void const *from, long unsigned int n)
{
  int sz = ( int ) __builtin_object_size ( from , 0 );
# 727 "./arch/x86/include/asm/uaccess.h"
  might_fault ( );
# 730 "./arch/x86/include/asm/uaccess.h"
  if (__builtin_expect ( sz < 0 , 1L ) != 0L || __builtin_expect ( ( long unsigned int ) sz >= n , 1L ) != 0L)
  {
# 731 "./arch/x86/include/asm/uaccess.h"
    n = _copy_to_user ( to , from , ( unsigned int ) n );
  }
  else
# 732 "./arch/x86/include/asm/uaccess.h"
    if (0)
    {
# 733 "./arch/x86/include/asm/uaccess.h"
      copy_to_user_overflow ( );
    }
    else
# 735 "./arch/x86/include/asm/uaccess.h"
      __copy_to_user_overflow ( );
# 737 "./arch/x86/include/asm/uaccess.h"
  return n;
}
# 16 "include/linux/uaccess.h"
static inline void pagefault_disable(void)
{
  __preempt_count_add ( 1 );
# 23 "include/linux/uaccess.h"
  asm volatile ( "" : : : "memory" ) ;
}
# 26 "include/linux/uaccess.h"
static inline void pagefault_enable(void)
{
# 33 "include/linux/uaccess.h"
  asm volatile ( "" : : : "memory" ) ;
  __preempt_count_sub ( 1 );
}
# 95 "include/linux/uaccess.h"
long int probe_kernel_read(void *, void const *, size_t);
long int __probe_kernel_read(void *, void const *, size_t);
# 107 "include/linux/uaccess.h"
long int probe_kernel_write(void *, void const *, size_t);
long int __probe_kernel_write(void *, void const *, size_t);
# 9 "include/linux/ftrace_irq.h"
static inline void ftrace_nmi_enter(void)
{
}
# 10 "include/linux/ftrace_irq.h"
static inline void ftrace_nmi_exit(void)
{
}
enum ctx_state
{
  IN_KERNEL = 0,
  IN_USER = 1
};
struct context_tracking
{
# 14 "include/linux/context_tracking_state.h"
  bool active;
# 18 "include/linux/context_tracking_state.h"
  enum ctx_state state;
};
# 22 "include/linux/context_tracking_state.h"
extern struct static_key context_tracking_enabled;
extern char __pcpu_scope_context_tracking;
# 23 "include/linux/context_tracking_state.h"
extern struct context_tracking context_tracking;
# 25 "include/linux/context_tracking_state.h"
static inline bool context_tracking_is_enabled(void)
{
  return static_key_false ( & context_tracking_enabled );
}
# 30 "include/linux/context_tracking_state.h"
static inline bool context_tracking_cpu_is_enabled(void)
{
  return ({
# 32 "include/linux/context_tracking_state.h"
    __this_cpu_preempt_check ( ( char const *) "read" );
# 32 "include/linux/context_tracking_state.h"
    ({
# 32 "include/linux/context_tracking_state.h"
      bool pscr_ret__;
      {
# 32 "include/linux/context_tracking_state.h"
        void const *__vpp_verify = ( ( void const *) 0 );
# 32 "include/linux/context_tracking_state.h"
        ( void ) __vpp_verify;
      }
      {
# 32 "include/linux/context_tracking_state.h"
        switch (1UL)
        {
# 32 "include/linux/context_tracking_state.h"
          case 1:;
# 32 "include/linux/context_tracking_state.h"
          pscr_ret__ = ({
# 32 "include/linux/context_tracking_state.h"
            bool pfo_ret__;
            {
# 32 "include/linux/context_tracking_state.h"
              switch (1UL)
              {
# 32 "include/linux/context_tracking_state.h"
                case 1:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27467;
# 32 "include/linux/context_tracking_state.h"
                case 2:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27467;
# 32 "include/linux/context_tracking_state.h"
                case 4:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27467;
# 32 "include/linux/context_tracking_state.h"
                case 8:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27467;
# 32 "include/linux/context_tracking_state.h"
                default:;
# 32 "include/linux/context_tracking_state.h"
                __bad_percpu_size ( );
              }
# 32 "include/linux/context_tracking_state.h"
              ldv_27467:;
            }
# 32 "include/linux/context_tracking_state.h"
            pfo_ret__;
          } );
# 32 "include/linux/context_tracking_state.h"
          goto ldv_27473;
# 32 "include/linux/context_tracking_state.h"
          case 2:;
# 32 "include/linux/context_tracking_state.h"
          pscr_ret__ = ({
# 32 "include/linux/context_tracking_state.h"
            bool pfo_ret__;
            {
# 32 "include/linux/context_tracking_state.h"
              switch (1UL)
              {
# 32 "include/linux/context_tracking_state.h"
                case 1:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27477;
# 32 "include/linux/context_tracking_state.h"
                case 2:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27477;
# 32 "include/linux/context_tracking_state.h"
                case 4:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27477;
# 32 "include/linux/context_tracking_state.h"
                case 8:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27477;
# 32 "include/linux/context_tracking_state.h"
                default:;
# 32 "include/linux/context_tracking_state.h"
                __bad_percpu_size ( );
              }
# 32 "include/linux/context_tracking_state.h"
              ldv_27477:;
            }
# 32 "include/linux/context_tracking_state.h"
            pfo_ret__;
          } );
# 32 "include/linux/context_tracking_state.h"
          goto ldv_27473;
# 32 "include/linux/context_tracking_state.h"
          case 4:;
# 32 "include/linux/context_tracking_state.h"
          pscr_ret__ = ({
# 32 "include/linux/context_tracking_state.h"
            bool pfo_ret__;
            {
# 32 "include/linux/context_tracking_state.h"
              switch (1UL)
              {
# 32 "include/linux/context_tracking_state.h"
                case 1:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27486;
# 32 "include/linux/context_tracking_state.h"
                case 2:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27486;
# 32 "include/linux/context_tracking_state.h"
                case 4:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27486;
# 32 "include/linux/context_tracking_state.h"
                case 8:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27486;
# 32 "include/linux/context_tracking_state.h"
                default:;
# 32 "include/linux/context_tracking_state.h"
                __bad_percpu_size ( );
              }
# 32 "include/linux/context_tracking_state.h"
              ldv_27486:;
            }
# 32 "include/linux/context_tracking_state.h"
            pfo_ret__;
          } );
# 32 "include/linux/context_tracking_state.h"
          goto ldv_27473;
# 32 "include/linux/context_tracking_state.h"
          case 8:;
# 32 "include/linux/context_tracking_state.h"
          pscr_ret__ = ({
# 32 "include/linux/context_tracking_state.h"
            bool pfo_ret__;
            {
# 32 "include/linux/context_tracking_state.h"
              switch (1UL)
              {
# 32 "include/linux/context_tracking_state.h"
                case 1:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27495;
# 32 "include/linux/context_tracking_state.h"
                case 2:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27495;
# 32 "include/linux/context_tracking_state.h"
                case 4:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27495;
# 32 "include/linux/context_tracking_state.h"
                case 8:;
# 32 "include/linux/context_tracking_state.h"
                asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . active ) ) ;
# 32 "include/linux/context_tracking_state.h"
                goto ldv_27495;
# 32 "include/linux/context_tracking_state.h"
                default:;
# 32 "include/linux/context_tracking_state.h"
                __bad_percpu_size ( );
              }
# 32 "include/linux/context_tracking_state.h"
              ldv_27495:;
            }
# 32 "include/linux/context_tracking_state.h"
            pfo_ret__;
          } );
# 32 "include/linux/context_tracking_state.h"
          goto ldv_27473;
# 32 "include/linux/context_tracking_state.h"
          default:;
# 32 "include/linux/context_tracking_state.h"
          __bad_size_call_parameter ( );
# 32 "include/linux/context_tracking_state.h"
          goto ldv_27473;
        }
# 32 "include/linux/context_tracking_state.h"
        ldv_27473:;
      }
# 32 "include/linux/context_tracking_state.h"
      pscr_ret__;
    } );
  } );
}
# 35 "include/linux/context_tracking_state.h"
static inline bool context_tracking_in_user(void)
{
  return ( unsigned int ) ({
# 37 "include/linux/context_tracking_state.h"
    __this_cpu_preempt_check ( ( char const *) "read" );
# 37 "include/linux/context_tracking_state.h"
    ({
# 37 "include/linux/context_tracking_state.h"
      enum ctx_state pscr_ret__;
      {
# 37 "include/linux/context_tracking_state.h"
        void const *__vpp_verify = ( ( void const *) 0 );
# 37 "include/linux/context_tracking_state.h"
        ( void ) __vpp_verify;
      }
      {
# 37 "include/linux/context_tracking_state.h"
        switch (4UL)
        {
# 37 "include/linux/context_tracking_state.h"
          case 1:;
# 37 "include/linux/context_tracking_state.h"
          pscr_ret__ = ({
# 37 "include/linux/context_tracking_state.h"
            enum ctx_state pfo_ret__;
            {
# 37 "include/linux/context_tracking_state.h"
              switch (4UL)
              {
# 37 "include/linux/context_tracking_state.h"
                case 1:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27512;
# 37 "include/linux/context_tracking_state.h"
                case 2:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27512;
# 37 "include/linux/context_tracking_state.h"
                case 4:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27512;
# 37 "include/linux/context_tracking_state.h"
                case 8:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27512;
# 37 "include/linux/context_tracking_state.h"
                default:;
# 37 "include/linux/context_tracking_state.h"
                __bad_percpu_size ( );
              }
# 37 "include/linux/context_tracking_state.h"
              ldv_27512:;
            }
# 37 "include/linux/context_tracking_state.h"
            pfo_ret__;
          } );
# 37 "include/linux/context_tracking_state.h"
          goto ldv_27518;
# 37 "include/linux/context_tracking_state.h"
          case 2:;
# 37 "include/linux/context_tracking_state.h"
          pscr_ret__ = ({
# 37 "include/linux/context_tracking_state.h"
            enum ctx_state pfo_ret__;
            {
# 37 "include/linux/context_tracking_state.h"
              switch (4UL)
              {
# 37 "include/linux/context_tracking_state.h"
                case 1:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27522;
# 37 "include/linux/context_tracking_state.h"
                case 2:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27522;
# 37 "include/linux/context_tracking_state.h"
                case 4:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27522;
# 37 "include/linux/context_tracking_state.h"
                case 8:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27522;
# 37 "include/linux/context_tracking_state.h"
                default:;
# 37 "include/linux/context_tracking_state.h"
                __bad_percpu_size ( );
              }
# 37 "include/linux/context_tracking_state.h"
              ldv_27522:;
            }
# 37 "include/linux/context_tracking_state.h"
            pfo_ret__;
          } );
# 37 "include/linux/context_tracking_state.h"
          goto ldv_27518;
# 37 "include/linux/context_tracking_state.h"
          case 4:;
# 37 "include/linux/context_tracking_state.h"
          pscr_ret__ = ({
# 37 "include/linux/context_tracking_state.h"
            enum ctx_state pfo_ret__;
            {
# 37 "include/linux/context_tracking_state.h"
              switch (4UL)
              {
# 37 "include/linux/context_tracking_state.h"
                case 1:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27531;
# 37 "include/linux/context_tracking_state.h"
                case 2:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27531;
# 37 "include/linux/context_tracking_state.h"
                case 4:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27531;
# 37 "include/linux/context_tracking_state.h"
                case 8:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27531;
# 37 "include/linux/context_tracking_state.h"
                default:;
# 37 "include/linux/context_tracking_state.h"
                __bad_percpu_size ( );
              }
# 37 "include/linux/context_tracking_state.h"
              ldv_27531:;
            }
# 37 "include/linux/context_tracking_state.h"
            pfo_ret__;
          } );
# 37 "include/linux/context_tracking_state.h"
          goto ldv_27518;
# 37 "include/linux/context_tracking_state.h"
          case 8:;
# 37 "include/linux/context_tracking_state.h"
          pscr_ret__ = ({
# 37 "include/linux/context_tracking_state.h"
            enum ctx_state pfo_ret__;
            {
# 37 "include/linux/context_tracking_state.h"
              switch (4UL)
              {
# 37 "include/linux/context_tracking_state.h"
                case 1:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27540;
# 37 "include/linux/context_tracking_state.h"
                case 2:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27540;
# 37 "include/linux/context_tracking_state.h"
                case 4:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27540;
# 37 "include/linux/context_tracking_state.h"
                case 8:;
# 37 "include/linux/context_tracking_state.h"
                asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( context_tracking . state ) ) ;
# 37 "include/linux/context_tracking_state.h"
                goto ldv_27540;
# 37 "include/linux/context_tracking_state.h"
                default:;
# 37 "include/linux/context_tracking_state.h"
                __bad_percpu_size ( );
              }
# 37 "include/linux/context_tracking_state.h"
              ldv_27540:;
            }
# 37 "include/linux/context_tracking_state.h"
            pfo_ret__;
          } );
# 37 "include/linux/context_tracking_state.h"
          goto ldv_27518;
# 37 "include/linux/context_tracking_state.h"
          default:;
# 37 "include/linux/context_tracking_state.h"
          __bad_size_call_parameter ( );
# 37 "include/linux/context_tracking_state.h"
          goto ldv_27518;
        }
# 37 "include/linux/context_tracking_state.h"
        ldv_27518:;
      }
# 37 "include/linux/context_tracking_state.h"
      pscr_ret__;
    } );
  } )
# 37 "include/linux/context_tracking_state.h"
  == 1U;
}
# 32 "include/linux/vtime.h"
static inline bool vtime_accounting_enabled(void)
{
# 32 "include/linux/vtime.h"
  return 0;
}
# 69 "include/linux/vtime.h"
static inline void vtime_task_switch(struct task_struct *prev)
{
}
# 70 "include/linux/vtime.h"
static inline void vtime_account_system(struct task_struct *tsk)
{
}
# 71 "include/linux/vtime.h"
static inline void vtime_account_user(struct task_struct *tsk)
{
}
# 72 "include/linux/vtime.h"
static inline void vtime_account_irq_enter(struct task_struct *tsk)
{
}
# 95 "include/linux/vtime.h"
static inline void vtime_account_irq_exit(struct task_struct *tsk)
{
# 98 "include/linux/vtime.h"
  vtime_account_system ( tsk );
}
static inline void vtime_user_enter(struct task_struct *tsk)
{
}
# 101 "include/linux/vtime.h"
static inline void vtime_user_exit(struct task_struct *tsk)
{
}
# 102 "include/linux/vtime.h"
static inline void vtime_guest_enter(struct task_struct *tsk)
{
}
# 103 "include/linux/vtime.h"
static inline void vtime_guest_exit(struct task_struct *tsk)
{
}
# 104 "include/linux/vtime.h"
static inline void vtime_init_idle(struct task_struct *tsk, int cpu)
{
}
# 110 "include/linux/vtime.h"
static inline void irqtime_account_irq(struct task_struct *tsk)
{
}
static inline void account_irq_enter_time(struct task_struct *tsk)
{
  vtime_account_irq_enter ( tsk );
  irqtime_account_irq ( tsk );
}
# 119 "include/linux/vtime.h"
static inline void account_irq_exit_time(struct task_struct *tsk)
{
  vtime_account_irq_exit ( tsk );
  irqtime_account_irq ( tsk );
}
enum irqreturn
{
  IRQ_NONE = 0,
  IRQ_HANDLED = 1,
  IRQ_WAKE_THREAD = 2
};
# 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
# 7 "include/linux/irqnr.h"
extern int nr_irqs;
struct irq_desc *irq_to_desc(unsigned int);
unsigned int irq_get_next_irq(unsigned int);
# 13 "./arch/x86/include/asm/irq.h"
static inline int irq_canonicalize(int irq)
{
  return irq != 2 ? irq : 9;
}
# 28 "./arch/x86/include/asm/irq.h"
int check_irq_vectors_for_cpu_disable(void);
void fixup_irqs(void);
void irq_force_complete_move(int);
# 33 "./arch/x86/include/asm/irq.h"
extern void (*x86_platform_ipi_callback)(void);
void native_init_IRQ(void);
bool handle_irq(unsigned int, struct pt_regs *);
# 37 "./arch/x86/include/asm/irq.h"
unsigned int do_IRQ(struct pt_regs *);
# 40 "./arch/x86/include/asm/irq.h"
extern long unsigned int used_vectors[4U];
int vector_used_by_percpu_irq(unsigned int);
# 43 "./arch/x86/include/asm/irq.h"
void init_ISA_irqs(void);
# 46 "./arch/x86/include/asm/irq.h"
void arch_trigger_all_cpu_backtrace(bool);
# 14 "./arch/x86/include/asm/irq_regs.h"
extern char __pcpu_scope_irq_regs;
# 14 "./arch/x86/include/asm/irq_regs.h"
extern struct pt_regs *irq_regs;
# 16 "./arch/x86/include/asm/irq_regs.h"
static inline struct pt_regs *get_irq_regs(void)
{
  return ({
# 18 "./arch/x86/include/asm/irq_regs.h"
    struct pt_regs *pscr_ret__;
    {
# 18 "./arch/x86/include/asm/irq_regs.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 18 "./arch/x86/include/asm/irq_regs.h"
      ( void ) __vpp_verify;
    }
    {
# 18 "./arch/x86/include/asm/irq_regs.h"
      switch (8UL)
      {
# 18 "./arch/x86/include/asm/irq_regs.h"
        case 1:;
# 18 "./arch/x86/include/asm/irq_regs.h"
        pscr_ret__ = ({
# 18 "./arch/x86/include/asm/irq_regs.h"
          struct pt_regs *pfo_ret__;
          {
# 18 "./arch/x86/include/asm/irq_regs.h"
            switch (8UL)
            {
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 1:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27638;
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 2:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27638;
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 4:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27638;
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 8:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27638;
# 18 "./arch/x86/include/asm/irq_regs.h"
              default:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              __bad_percpu_size ( );
            }
# 18 "./arch/x86/include/asm/irq_regs.h"
            ldv_27638:;
          }
# 18 "./arch/x86/include/asm/irq_regs.h"
          pfo_ret__;
        } );
# 18 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27644;
# 18 "./arch/x86/include/asm/irq_regs.h"
        case 2:;
# 18 "./arch/x86/include/asm/irq_regs.h"
        pscr_ret__ = ({
# 18 "./arch/x86/include/asm/irq_regs.h"
          struct pt_regs *pfo_ret__;
          {
# 18 "./arch/x86/include/asm/irq_regs.h"
            switch (8UL)
            {
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 1:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27648;
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 2:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27648;
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 4:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27648;
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 8:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27648;
# 18 "./arch/x86/include/asm/irq_regs.h"
              default:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              __bad_percpu_size ( );
            }
# 18 "./arch/x86/include/asm/irq_regs.h"
            ldv_27648:;
          }
# 18 "./arch/x86/include/asm/irq_regs.h"
          pfo_ret__;
        } );
# 18 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27644;
# 18 "./arch/x86/include/asm/irq_regs.h"
        case 4:;
# 18 "./arch/x86/include/asm/irq_regs.h"
        pscr_ret__ = ({
# 18 "./arch/x86/include/asm/irq_regs.h"
          struct pt_regs *pfo_ret__;
          {
# 18 "./arch/x86/include/asm/irq_regs.h"
            switch (8UL)
            {
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 1:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27657;
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 2:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27657;
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 4:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27657;
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 8:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27657;
# 18 "./arch/x86/include/asm/irq_regs.h"
              default:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              __bad_percpu_size ( );
            }
# 18 "./arch/x86/include/asm/irq_regs.h"
            ldv_27657:;
          }
# 18 "./arch/x86/include/asm/irq_regs.h"
          pfo_ret__;
        } );
# 18 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27644;
# 18 "./arch/x86/include/asm/irq_regs.h"
        case 8:;
# 18 "./arch/x86/include/asm/irq_regs.h"
        pscr_ret__ = ({
# 18 "./arch/x86/include/asm/irq_regs.h"
          struct pt_regs *pfo_ret__;
          {
# 18 "./arch/x86/include/asm/irq_regs.h"
            switch (8UL)
            {
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 1:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movb %%gs:%P1,%0" : "=q" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27666;
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 2:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movw %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27666;
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 4:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movl %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27666;
# 18 "./arch/x86/include/asm/irq_regs.h"
              case 8:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              asm ( "movq %%gs:%P1,%0" : "=r" ( pfo_ret__ ) : "m" ( irq_regs ) ) ;
# 18 "./arch/x86/include/asm/irq_regs.h"
              goto ldv_27666;
# 18 "./arch/x86/include/asm/irq_regs.h"
              default:;
# 18 "./arch/x86/include/asm/irq_regs.h"
              __bad_percpu_size ( );
            }
# 18 "./arch/x86/include/asm/irq_regs.h"
            ldv_27666:;
          }
# 18 "./arch/x86/include/asm/irq_regs.h"
          pfo_ret__;
        } );
# 18 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27644;
# 18 "./arch/x86/include/asm/irq_regs.h"
        default:;
# 18 "./arch/x86/include/asm/irq_regs.h"
        __bad_size_call_parameter ( );
# 18 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27644;
      }
# 18 "./arch/x86/include/asm/irq_regs.h"
      ldv_27644:;
    }
# 18 "./arch/x86/include/asm/irq_regs.h"
    pscr_ret__;
  } );
}
static inline struct pt_regs *set_irq_regs(struct pt_regs *new_regs)
{
  struct pt_regs *old_regs;
# 25 "./arch/x86/include/asm/irq_regs.h"
  old_regs = get_irq_regs ( );
  {
# 26 "./arch/x86/include/asm/irq_regs.h"
    void const *__vpp_verify = ( ( void const *) 0 );
# 26 "./arch/x86/include/asm/irq_regs.h"
    ( void ) __vpp_verify;
  }
# 26 "./arch/x86/include/asm/irq_regs.h"
  switch (8UL)
  {
# 26 "./arch/x86/include/asm/irq_regs.h"
    case 1:;
    {
# 26 "./arch/x86/include/asm/irq_regs.h"
      typedef struct pt_regs *pto_T__;
# 26 "./arch/x86/include/asm/irq_regs.h"
      if (0)
      {
# 26 "./arch/x86/include/asm/irq_regs.h"
        pto_T__ pto_tmp__;
# 26 "./arch/x86/include/asm/irq_regs.h"
        pto_tmp__ = new_regs;
# 26 "./arch/x86/include/asm/irq_regs.h"
        ( void ) pto_tmp__;
      }
# 26 "./arch/x86/include/asm/irq_regs.h"
      switch (8UL)
      {
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 1:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movb %1,%%gs:%P0" : "+m" ( irq_regs ) : "qi" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27683;
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 2:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movw %1,%%gs:%P0" : "+m" ( irq_regs ) : "ri" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27683;
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 4:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movl %1,%%gs:%P0" : "+m" ( irq_regs ) : "ri" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27683;
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 8:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movq %1,%%gs:%P0" : "+m" ( irq_regs ) : "re" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27683;
# 26 "./arch/x86/include/asm/irq_regs.h"
        default:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        __bad_percpu_size ( );
      }
# 26 "./arch/x86/include/asm/irq_regs.h"
      ldv_27683:;
    }
# 26 "./arch/x86/include/asm/irq_regs.h"
    goto ldv_27688;
# 26 "./arch/x86/include/asm/irq_regs.h"
    case 2:;
    {
# 26 "./arch/x86/include/asm/irq_regs.h"
      typedef struct pt_regs *pto_T__;
# 26 "./arch/x86/include/asm/irq_regs.h"
      if (0)
      {
# 26 "./arch/x86/include/asm/irq_regs.h"
        pto_T__ pto_tmp__;
# 26 "./arch/x86/include/asm/irq_regs.h"
        pto_tmp__ = new_regs;
# 26 "./arch/x86/include/asm/irq_regs.h"
        ( void ) pto_tmp__;
      }
# 26 "./arch/x86/include/asm/irq_regs.h"
      switch (8UL)
      {
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 1:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movb %1,%%gs:%P0" : "+m" ( irq_regs ) : "qi" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27693;
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 2:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movw %1,%%gs:%P0" : "+m" ( irq_regs ) : "ri" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27693;
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 4:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movl %1,%%gs:%P0" : "+m" ( irq_regs ) : "ri" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27693;
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 8:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movq %1,%%gs:%P0" : "+m" ( irq_regs ) : "re" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27693;
# 26 "./arch/x86/include/asm/irq_regs.h"
        default:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        __bad_percpu_size ( );
      }
# 26 "./arch/x86/include/asm/irq_regs.h"
      ldv_27693:;
    }
# 26 "./arch/x86/include/asm/irq_regs.h"
    goto ldv_27688;
# 26 "./arch/x86/include/asm/irq_regs.h"
    case 4:;
    {
# 26 "./arch/x86/include/asm/irq_regs.h"
      typedef struct pt_regs *pto_T__;
# 26 "./arch/x86/include/asm/irq_regs.h"
      if (0)
      {
# 26 "./arch/x86/include/asm/irq_regs.h"
        pto_T__ pto_tmp__;
# 26 "./arch/x86/include/asm/irq_regs.h"
        pto_tmp__ = new_regs;
# 26 "./arch/x86/include/asm/irq_regs.h"
        ( void ) pto_tmp__;
      }
# 26 "./arch/x86/include/asm/irq_regs.h"
      switch (8UL)
      {
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 1:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movb %1,%%gs:%P0" : "+m" ( irq_regs ) : "qi" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27702;
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 2:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movw %1,%%gs:%P0" : "+m" ( irq_regs ) : "ri" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27702;
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 4:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movl %1,%%gs:%P0" : "+m" ( irq_regs ) : "ri" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27702;
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 8:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movq %1,%%gs:%P0" : "+m" ( irq_regs ) : "re" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27702;
# 26 "./arch/x86/include/asm/irq_regs.h"
        default:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        __bad_percpu_size ( );
      }
# 26 "./arch/x86/include/asm/irq_regs.h"
      ldv_27702:;
    }
# 26 "./arch/x86/include/asm/irq_regs.h"
    goto ldv_27688;
# 26 "./arch/x86/include/asm/irq_regs.h"
    case 8:;
    {
# 26 "./arch/x86/include/asm/irq_regs.h"
      typedef struct pt_regs *pto_T__;
# 26 "./arch/x86/include/asm/irq_regs.h"
      if (0)
      {
# 26 "./arch/x86/include/asm/irq_regs.h"
        pto_T__ pto_tmp__;
# 26 "./arch/x86/include/asm/irq_regs.h"
        pto_tmp__ = new_regs;
# 26 "./arch/x86/include/asm/irq_regs.h"
        ( void ) pto_tmp__;
      }
# 26 "./arch/x86/include/asm/irq_regs.h"
      switch (8UL)
      {
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 1:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movb %1,%%gs:%P0" : "+m" ( irq_regs ) : "qi" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27711;
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 2:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movw %1,%%gs:%P0" : "+m" ( irq_regs ) : "ri" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27711;
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 4:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movl %1,%%gs:%P0" : "+m" ( irq_regs ) : "ri" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27711;
# 26 "./arch/x86/include/asm/irq_regs.h"
        case 8:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        asm ( "movq %1,%%gs:%P0" : "+m" ( irq_regs ) : "re" ( new_regs ) ) ;
# 26 "./arch/x86/include/asm/irq_regs.h"
        goto ldv_27711;
# 26 "./arch/x86/include/asm/irq_regs.h"
        default:;
# 26 "./arch/x86/include/asm/irq_regs.h"
        __bad_percpu_size ( );
      }
# 26 "./arch/x86/include/asm/irq_regs.h"
      ldv_27711:;
    }
# 26 "./arch/x86/include/asm/irq_regs.h"
    goto ldv_27688;
# 26 "./arch/x86/include/asm/irq_regs.h"
    default:;
# 26 "./arch/x86/include/asm/irq_regs.h"
    __bad_size_call_parameter ( );
# 26 "./arch/x86/include/asm/irq_regs.h"
    goto ldv_27688;
  }
# 26 "./arch/x86/include/asm/irq_regs.h"
  ldv_27688:;
# 28 "./arch/x86/include/asm/irq_regs.h"
  return old_regs;
}
# 32 "include/linux/irq.h"
typedef void (*irq_flow_handler_t)(unsigned int, struct irq_desc *);
# 34 "include/linux/irq.h"
typedef void (*irq_preflow_handler_t)(struct irq_data *);
enum ldv_22137
{
  IRQ_TYPE_NONE = 0,
  IRQ_TYPE_EDGE_RISING = 1,
  IRQ_TYPE_EDGE_FALLING = 2,
  IRQ_TYPE_EDGE_BOTH = 3,
  IRQ_TYPE_LEVEL_HIGH = 4,
  IRQ_TYPE_LEVEL_LOW = 8,
  IRQ_TYPE_LEVEL_MASK = 12,
  IRQ_TYPE_SENSE_MASK = 15,
  IRQ_TYPE_DEFAULT = 15,
  IRQ_TYPE_PROBE = 16,
  IRQ_LEVEL = 256,
  IRQ_PER_CPU = 512,
  IRQ_NOPROBE = 1024,
  IRQ_NOREQUEST = 2048,
  IRQ_NOAUTOEN = 4096,
  IRQ_NO_BALANCING = 8192,
  IRQ_MOVE_PCNTXT = 16384,
  IRQ_NESTED_THREAD = 32768,
  IRQ_NOTHREAD = 65536,
  IRQ_PER_CPU_DEVID = 131072,
  IRQ_IS_POLLED = 262144
};
enum ldv_22138
{
  IRQ_SET_MASK_OK = 0,
  IRQ_SET_MASK_OK_NOCOPY = 1
};
struct irq_data
{
# 147 "include/linux/irq.h"
  u32 mask;
  unsigned int irq;
  long unsigned int hwirq;
  unsigned int node;
  unsigned int state_use_accessors;
  struct irq_chip *chip;
  struct irq_domain *domain;
  void *handler_data;
  void *chip_data;
  struct msi_desc *msi_desc;
  cpumask_var_t affinity;
};
enum ldv_22141
{
  IRQD_TRIGGER_MASK = 15,
  IRQD_SETAFFINITY_PENDING = 256,
  IRQD_NO_BALANCING = 1024,
  IRQD_PER_CPU = 2048,
  IRQD_AFFINITY_SET = 4096,
  IRQD_LEVEL = 8192,
  IRQD_WAKEUP_STATE = 16384,
  IRQD_MOVE_PCNTXT = 32768,
  IRQD_IRQ_DISABLED = 65536,
  IRQD_IRQ_MASKED = 131072,
  IRQD_IRQ_INPROGRESS = 262144
};
# 191 "include/linux/irq.h"
static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
{
  return ( ( * d ) . state_use_accessors & 256U ) != 0U;
}
# 196 "include/linux/irq.h"
static inline bool irqd_is_per_cpu(struct irq_data *d)
{
  return ( ( * d ) . state_use_accessors & 2048U ) != 0U;
}
# 201 "include/linux/irq.h"
static inline bool irqd_can_balance(struct irq_data *d)
{
  return ( ( * d ) . state_use_accessors & 3072U ) == 0U;
}
# 206 "include/linux/irq.h"
static inline bool irqd_affinity_was_set(struct irq_data *d)
{
  return ( ( * d ) . state_use_accessors & 4096U ) != 0U;
}
# 211 "include/linux/irq.h"
static inline void irqd_mark_affinity_was_set(struct irq_data *d)
{
  ( * d ) . state_use_accessors |= 4096U;
}
# 216 "include/linux/irq.h"
static inline u32 irqd_get_trigger_type(struct irq_data *d)
{
  return ( u32 ) ( * d ) . state_use_accessors & 15U;
}
# 224 "include/linux/irq.h"
static inline void irqd_set_trigger_type(struct irq_data *d, u32 type)
{
  ( * d ) . state_use_accessors &= 4294967280U;
  ( * d ) . state_use_accessors |= ( unsigned int ) type & 15U;
}
# 230 "include/linux/irq.h"
static inline bool irqd_is_level_type(struct irq_data *d)
{
  return ( ( * d ) . state_use_accessors & 8192U ) != 0U;
}
# 235 "include/linux/irq.h"
static inline bool irqd_is_wakeup_set(struct irq_data *d)
{
  return ( ( * d ) . state_use_accessors & 16384U ) != 0U;
}
# 240 "include/linux/irq.h"
static inline bool irqd_can_move_in_process_context(struct irq_data *d)
{
  return ( ( * d ) . state_use_accessors & 32768U ) != 0U;
}
# 245 "include/linux/irq.h"
static inline bool irqd_irq_disabled(struct irq_data *d)
{
  return ( ( * d ) . state_use_accessors & 65536U ) != 0U;
}
# 250 "include/linux/irq.h"
static inline bool irqd_irq_masked(struct irq_data *d)
{
  return ( ( * d ) . state_use_accessors & 131072U ) != 0U;
}
# 255 "include/linux/irq.h"
static inline bool irqd_irq_inprogress(struct irq_data *d)
{
  return ( ( * d ) . state_use_accessors & 262144U ) != 0U;
}
# 265 "include/linux/irq.h"
static inline void irqd_set_chained_irq_inprogress(struct irq_data *d)
{
  ( * d ) . state_use_accessors |= 262144U;
}
# 270 "include/linux/irq.h"
static inline void irqd_clr_chained_irq_inprogress(struct irq_data *d)
{
  ( * d ) . state_use_accessors &= 4294705151U;
}
# 275 "include/linux/irq.h"
static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
{
  return ( irq_hw_number_t ) ( * d ) . hwirq;
}
struct irq_chip
{
# 313 "include/linux/irq.h"
  char const *name;
  unsigned int (*irq_startup)(struct irq_data *);
  void (*irq_shutdown)(struct irq_data *);
  void (*irq_enable)(struct irq_data *);
  void (*irq_disable)(struct irq_data *);
# 319 "include/linux/irq.h"
  void (*irq_ack)(struct irq_data *);
  void (*irq_mask)(struct irq_data *);
  void (*irq_mask_ack)(struct irq_data *);
  void (*irq_unmask)(struct irq_data *);
  void (*irq_eoi)(struct irq_data *);
# 325 "include/linux/irq.h"
  int (*irq_set_affinity)(struct irq_data *, struct cpumask const *, bool);
  int (*irq_retrigger)(struct irq_data *);
  int (*irq_set_type)(struct irq_data *, unsigned int);
  int (*irq_set_wake)(struct irq_data *, unsigned int);
# 330 "include/linux/irq.h"
  void (*irq_bus_lock)(struct irq_data *);
  void (*irq_bus_sync_unlock)(struct irq_data *);
# 333 "include/linux/irq.h"
  void (*irq_cpu_online)(struct irq_data *);
  void (*irq_cpu_offline)(struct irq_data *);
# 336 "include/linux/irq.h"
  void (*irq_suspend)(struct irq_data *);
  void (*irq_resume)(struct irq_data *);
  void (*irq_pm_shutdown)(struct irq_data *);
# 340 "include/linux/irq.h"
  void (*irq_calc_mask)(struct irq_data *);
# 342 "include/linux/irq.h"
  void (*irq_print_chip)(struct irq_data *, struct seq_file *);
  int (*irq_request_resources)(struct irq_data *);
  void (*irq_release_resources)(struct irq_data *);
# 346 "include/linux/irq.h"
  long unsigned int flags;
};
enum ldv_22200
{
  IRQCHIP_SET_TYPE_MASKED = 1,
  IRQCHIP_EOI_IF_HANDLED = 2,
  IRQCHIP_MASK_ON_SUSPEND = 4,
  IRQCHIP_ONOFFLINE_ENABLED = 8,
  IRQCHIP_SKIP_SET_WAKE = 16,
  IRQCHIP_ONESHOT_SAFE = 32,
  IRQCHIP_EOI_THREADED = 64
};
struct irq_affinity_notify;
struct proc_dir_entry;
struct irq_desc
{
# 43 "include/linux/irqdesc.h"
  struct irq_data irq_data;
  unsigned int *kstat_irqs;
  irq_flow_handler_t handle_irq;
# 49 "include/linux/irqdesc.h"
  struct irqaction *action;
  unsigned int status_use_accessors;
  unsigned int core_internal_state__do_not_mess_with_it;
  unsigned int depth;
  unsigned int wake_depth;
  unsigned int irq_count;
  long unsigned int last_unhandled;
  unsigned int irqs_unhandled;
  atomic_t threads_handled;
  int threads_handled_last;
  raw_spinlock_t lock;
  struct cpumask *percpu_enabled;
# 62 "include/linux/irqdesc.h"
  struct cpumask const *affinity_hint;
  struct irq_affinity_notify *affinity_notify;
# 65 "include/linux/irqdesc.h"
  cpumask_var_t pending_mask;
# 68 "include/linux/irqdesc.h"
  long unsigned int threads_oneshot;
  atomic_t threads_active;
  wait_queue_head_t wait_for_threads;
# 72 "include/linux/irqdesc.h"
  struct proc_dir_entry *dir;
# 74 "include/linux/irqdesc.h"
  int parent_irq;
  struct module *owner;
  char const *name;
};
# 83 "include/linux/irqdesc.h"
static inline struct irq_data *irq_desc_get_irq_data(struct irq_desc *desc)
{
  return & ( * desc ) . irq_data;
}
# 88 "include/linux/irqdesc.h"
static inline struct irq_chip *irq_desc_get_chip(struct irq_desc *desc)
{
  return ( * desc ) . irq_data . chip;
}
# 93 "include/linux/irqdesc.h"
static inline void *irq_desc_get_chip_data(struct irq_desc *desc)
{
  return ( * desc ) . irq_data . chip_data;
}
# 98 "include/linux/irqdesc.h"
static inline void *irq_desc_get_handler_data(struct irq_desc *desc)
{
  return ( * desc ) . irq_data . handler_data;
}
# 103 "include/linux/irqdesc.h"
static inline struct msi_desc *irq_desc_get_msi_desc(struct irq_desc *desc)
{
  return ( * desc ) . irq_data . msi_desc;
}
# 114 "include/linux/irqdesc.h"
static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *desc)
{
  ( * desc ) . handle_irq ( irq , desc );
}
# 119 "include/linux/irqdesc.h"
int generic_handle_irq(unsigned int);
# 122 "include/linux/irqdesc.h"
static inline int irq_has_action(unsigned int irq)
{
  struct irq_desc *desc = irq_to_desc ( irq );
  return ( * desc ) . action != ( ( struct irqaction *) 0 );
}
# 129 "include/linux/irqdesc.h"
static inline void __irq_set_handler_locked(unsigned int irq, irq_flow_handler_t handler)
{
# 132 "include/linux/irqdesc.h"
  struct irq_desc *desc;
# 134 "include/linux/irqdesc.h"
  desc = irq_to_desc ( irq );
  ( * desc ) . handle_irq = handler;
}
# 140 "include/linux/irqdesc.h"
static inline void __irq_set_chip_handler_name_locked(unsigned int irq, struct irq_chip *chip, irq_flow_handler_t handler, char const *name)
{
# 143 "include/linux/irqdesc.h"
  struct irq_desc *desc;
# 145 "include/linux/irqdesc.h"
  desc = irq_to_desc ( irq );
  ( * irq_desc_get_irq_data ( desc ) ) . chip = chip;
  ( * desc ) . handle_irq = handler;
  ( * desc ) . name = name;
}
# 151 "include/linux/irqdesc.h"
static inline int irq_balancing_disabled(unsigned int irq)
{
  struct irq_desc *desc;
# 155 "include/linux/irqdesc.h"
  desc = irq_to_desc ( irq );
  return ( int ) ( * desc ) . status_use_accessors & 8704;
}
# 159 "include/linux/irqdesc.h"
static inline int irq_is_percpu(unsigned int irq)
{
  struct irq_desc *desc;
# 163 "include/linux/irqdesc.h"
  desc = irq_to_desc ( irq );
  return ( int ) ( * desc ) . status_use_accessors & 512;
}
# 168 "include/linux/irqdesc.h"
static inline void irq_set_lockdep_class(unsigned int irq, struct lock_class_key *class)
{
  struct irq_desc *desc = irq_to_desc ( irq );
# 172 "include/linux/irqdesc.h"
  if (desc != ( ( struct irq_desc *) 0 ))
    lockdep_init_map ( & ( * desc ) . lock . dep_map , ( char const *) "class" , class , 0 );
}
# 21 "include/linux/profile.h"
void create_prof_cpu_mask(void);
int create_proc_profile(void);
enum profile_type
{
  PROFILE_TASK_EXIT = 0,
  PROFILE_MUNMAP = 1
};
# 41 "include/linux/profile.h"
extern int prof_on;
# 44 "include/linux/profile.h"
int profile_init(void);
int profile_setup(char *);
void profile_tick(int);
int setup_profiling_timer(unsigned int);
# 52 "include/linux/profile.h"
void profile_hits(int, void *, unsigned int);
# 57 "include/linux/profile.h"
static inline void profile_hit(int type, void *ip)
{
# 62 "include/linux/profile.h"
  if (__builtin_expect ( prof_on == type , 0L ) != 0L)
    profile_hits ( type , ip , 1U );
}
# 70 "include/linux/profile.h"
void profile_task_exit(struct task_struct *);
# 75 "include/linux/profile.h"
int profile_handoff_task(struct task_struct *);
# 78 "include/linux/profile.h"
void profile_munmap(long unsigned int);
# 80 "include/linux/profile.h"
int task_handoff_register(struct notifier_block *);
int task_handoff_unregister(struct notifier_block *);
# 83 "include/linux/profile.h"
int profile_event_register(enum profile_type, struct notifier_block *);
int profile_event_unregister(enum profile_type, struct notifier_block *);
# 26 "include/asm-generic/sections.h"
extern char _text[];
# 26 "include/asm-generic/sections.h"
extern char _stext[];
# 26 "include/asm-generic/sections.h"
extern char _etext[];
extern char _data[];
# 27 "include/asm-generic/sections.h"
extern char _sdata[];
# 27 "include/asm-generic/sections.h"
extern char _edata[];
extern char __bss_start[];
# 28 "include/asm-generic/sections.h"
extern char __bss_stop[];
extern char __init_begin[];
# 29 "include/asm-generic/sections.h"
extern char __init_end[];
extern char _sinittext[];
# 30 "include/asm-generic/sections.h"
extern char _einittext[];
extern char _end[];
extern char __per_cpu_load[];
# 32 "include/asm-generic/sections.h"
extern char __per_cpu_start[];
# 32 "include/asm-generic/sections.h"
extern char __per_cpu_end[];
extern char __kprobes_text_start[];
# 33 "include/asm-generic/sections.h"
extern char __kprobes_text_end[];
extern char __entry_text_start[];
# 34 "include/asm-generic/sections.h"
extern char __entry_text_end[];
extern char __start_rodata[];
# 35 "include/asm-generic/sections.h"
extern char __end_rodata[];
# 38 "include/asm-generic/sections.h"
extern char __ctors_start[];
# 38 "include/asm-generic/sections.h"
extern char __ctors_end[];
# 49 "include/asm-generic/sections.h"
static inline int arch_is_kernel_text(long unsigned int addr)
{
  return 0;
}
# 56 "include/asm-generic/sections.h"
static inline int arch_is_kernel_data(long unsigned int addr)
{
  return 0;
}
# 7 "./arch/x86/include/asm/sections.h"
extern char __brk_base[];
# 7 "./arch/x86/include/asm/sections.h"
extern char __brk_limit[];
extern struct exception_table_entry __stop___ex_table[];
# 11 "./arch/x86/include/asm/sections.h"
extern char __end_rodata_hpage_align[];
# 29 "./arch/x86/include/asm/hw_irq.h"
void apic_timer_interrupt(void);
void x86_platform_ipi(void);
void kvm_posted_intr_ipi(void);
void error_interrupt(void);
void irq_work_interrupt(void);
# 35 "./arch/x86/include/asm/hw_irq.h"
void spurious_interrupt(void);
void thermal_interrupt(void);
void reschedule_interrupt(void);
# 39 "./arch/x86/include/asm/hw_irq.h"
void invalidate_interrupt(void);
void invalidate_interrupt0(void);
void invalidate_interrupt1(void);
void invalidate_interrupt2(void);
void invalidate_interrupt3(void);
void invalidate_interrupt4(void);
void invalidate_interrupt5(void);
void invalidate_interrupt6(void);
void invalidate_interrupt7(void);
void invalidate_interrupt8(void);
void invalidate_interrupt9(void);
void invalidate_interrupt10(void);
void invalidate_interrupt11(void);
void invalidate_interrupt12(void);
void invalidate_interrupt13(void);
void invalidate_interrupt14(void);
void invalidate_interrupt15(void);
void invalidate_interrupt16(void);
void invalidate_interrupt17(void);
void invalidate_interrupt18(void);
void invalidate_interrupt19(void);
void invalidate_interrupt20(void);
void invalidate_interrupt21(void);
void invalidate_interrupt22(void);
void invalidate_interrupt23(void);
void invalidate_interrupt24(void);
void invalidate_interrupt25(void);
void invalidate_interrupt26(void);
void invalidate_interrupt27(void);
void invalidate_interrupt28(void);
void invalidate_interrupt29(void);
void invalidate_interrupt30(void);
void invalidate_interrupt31(void);
# 73 "./arch/x86/include/asm/hw_irq.h"
void irq_move_cleanup_interrupt(void);
void reboot_interrupt(void);
void threshold_interrupt(void);
# 77 "./arch/x86/include/asm/hw_irq.h"
void call_function_interrupt(void);
void call_function_single_interrupt(void);
# 82 "./arch/x86/include/asm/hw_irq.h"
void trace_apic_timer_interrupt(void);
void trace_x86_platform_ipi(void);
void trace_error_interrupt(void);
void trace_irq_work_interrupt(void);
void trace_spurious_interrupt(void);
void trace_thermal_interrupt(void);
void trace_reschedule_interrupt(void);
void trace_threshold_interrupt(void);
void trace_call_function_interrupt(void);
void trace_call_function_single_interrupt(void);
# 99 "./arch/x86/include/asm/hw_irq.h"
extern long unsigned int io_apic_irqs;
# 101 "./arch/x86/include/asm/hw_irq.h"
void setup_IO_APIC(void);
void disable_IO_APIC(void);
struct io_apic_irq_attr
{
  int ioapic;
  int ioapic_pin;
  int trigger;
  int polarity;
};
# 111 "./arch/x86/include/asm/hw_irq.h"
static inline void set_io_apic_irq_attr(struct io_apic_irq_attr *irq_attr, int ioapic, int ioapic_pin, int trigger, int polarity)
{
# 115 "./arch/x86/include/asm/hw_irq.h"
  ( * irq_attr ) . ioapic = ioapic;
  ( * irq_attr ) . ioapic_pin = ioapic_pin;
  ( * irq_attr ) . trigger = trigger;
  ( * irq_attr ) . polarity = polarity;
}
struct irq_2_iommu
{
# 123 "./arch/x86/include/asm/hw_irq.h"
  struct intel_iommu *iommu;
  u16 irte_index;
  u16 sub_handle;
  u8 irte_mask;
};
struct irq_2_irte
{
# 131 "./arch/x86/include/asm/hw_irq.h"
  u16 devid;
  u16 index;
};
struct irq_cfg
{
# 141 "./arch/x86/include/asm/hw_irq.h"
  struct irq_pin_list *irq_2_pin;
  cpumask_var_t domain;
  cpumask_var_t old_domain;
  u8 vector;
  unsigned char move_in_progress : 1;
# 147 "./arch/x86/include/asm/hw_irq.h"
  unsigned char remapped : 1;
# 151 "./arch/x86/include/asm/hw_irq.h"
  union
  {
# 149 "./arch/x86/include/asm/hw_irq.h"
    struct irq_2_iommu irq_2_iommu;
    struct irq_2_irte irq_2_irte;
  } ldv_28182;
};
# 155 "./arch/x86/include/asm/hw_irq.h"
int assign_irq_vector(int, struct irq_cfg *, struct cpumask const *);
void send_cleanup_vector(struct irq_cfg *);
# 159 "./arch/x86/include/asm/hw_irq.h"
int __ioapic_set_affinity(struct irq_data *, struct cpumask const *, unsigned int *);
# 161 "./arch/x86/include/asm/hw_irq.h"
int IO_APIC_get_PCI_irq_vector(int, int, int, struct io_apic_irq_attr *);
void setup_ioapic_dest(void);
# 164 "./arch/x86/include/asm/hw_irq.h"
void enable_IO_APIC(void);
# 167 "./arch/x86/include/asm/hw_irq.h"
extern atomic_t irq_err_count;
extern atomic_t irq_mis_count;
# 171 "./arch/x86/include/asm/hw_irq.h"
void eisa_set_level_irq(unsigned int);
# 174 "./arch/x86/include/asm/hw_irq.h"
void smp_apic_timer_interrupt(struct pt_regs *);
void smp_spurious_interrupt(struct pt_regs *);
void smp_x86_platform_ipi(struct pt_regs *);
void smp_error_interrupt(struct pt_regs *);
# 179 "./arch/x86/include/asm/hw_irq.h"
void smp_irq_move_cleanup_interrupt(void);
# 182 "./arch/x86/include/asm/hw_irq.h"
void smp_reschedule_interrupt(struct pt_regs *);
void smp_call_function_interrupt(struct pt_regs *);
void smp_call_function_single_interrupt(struct pt_regs *);
void smp_invalidate_interrupt(struct pt_regs *);
# 188 "./arch/x86/include/asm/hw_irq.h"
extern void (*interrupt[224U])(void);
# 196 "./arch/x86/include/asm/hw_irq.h"
typedef int vector_irq_t[256U];
extern char __pcpu_scope_vector_irq;
# 197 "./arch/x86/include/asm/hw_irq.h"
extern vector_irq_t vector_irq;
void setup_vector_irq(int);
# 201 "./arch/x86/include/asm/hw_irq.h"
void lock_vector_lock(void);
void unlock_vector_lock(void);
void __setup_vector_irq(int);
# 390 "include/linux/irq.h"
int setup_irq(unsigned int, struct irqaction *);
void remove_irq(unsigned int, struct irqaction *);
int setup_percpu_irq(unsigned int, struct irqaction *);
void remove_percpu_irq(unsigned int, struct irqaction *);
# 395 "include/linux/irq.h"
void irq_cpu_online(void);
void irq_cpu_offline(void);
int irq_set_affinity_locked(struct irq_data *, struct cpumask const *, bool);
# 401 "include/linux/irq.h"
void irq_move_irq(struct irq_data *);
void irq_move_masked_irq(struct irq_data *);
# 408 "include/linux/irq.h"
extern int no_irq_affinity;
# 413 "include/linux/irq.h"
static inline int irq_set_parent(int irq, int parent_irq)
{
  return 0;
}
# 423 "include/linux/irq.h"
void handle_level_irq(unsigned int, struct irq_desc *);
void handle_fasteoi_irq(unsigned int, struct irq_desc *);
void handle_edge_irq(unsigned int, struct irq_desc *);
void handle_edge_eoi_irq(unsigned int, struct irq_desc *);
void handle_simple_irq(unsigned int, struct irq_desc *);
void handle_percpu_irq(unsigned int, struct irq_desc *);
void handle_percpu_devid_irq(unsigned int, struct irq_desc *);
void handle_bad_irq(unsigned int, struct irq_desc *);
void handle_nested_irq(unsigned int);
# 434 "include/linux/irq.h"
void note_interrupt(unsigned int, struct irq_desc *, irqreturn_t);
# 439 "include/linux/irq.h"
int noirqdebug_setup(char *);
# 442 "include/linux/irq.h"
int can_request_irq(unsigned int, long unsigned int);
# 445 "include/linux/irq.h"
extern struct irq_chip no_irq_chip;
extern struct irq_chip dummy_irq_chip;
# 449 "include/linux/irq.h"
void irq_set_chip_and_handler_name(unsigned int, struct irq_chip *, irq_flow_handler_t, char const *);
# 452 "include/linux/irq.h"
static inline void irq_set_chip_and_handler(unsigned int irq, struct irq_chip *chip, irq_flow_handler_t handle)
{
# 455 "include/linux/irq.h"
  irq_set_chip_and_handler_name ( irq , chip , handle , ( ( char const *) 0 ) );
}
# 458 "include/linux/irq.h"
int irq_set_percpu_devid(unsigned int);
# 461 "include/linux/irq.h"
void __irq_set_handler(unsigned int, irq_flow_handler_t, int, char const *);
# 465 "include/linux/irq.h"
static inline void irq_set_handler(unsigned int irq, irq_flow_handler_t handle)
{
  __irq_set_handler ( irq , handle , 0 , ( ( char const *) 0 ) );
}
# 476 "include/linux/irq.h"
static inline void irq_set_chained_handler(unsigned int irq, irq_flow_handler_t handle)
{
  __irq_set_handler ( irq , handle , 1 , ( ( char const *) 0 ) );
}
# 481 "include/linux/irq.h"
void irq_modify_status(unsigned int, long unsigned int, long unsigned int);
# 483 "include/linux/irq.h"
static inline void irq_set_status_flags(unsigned int irq, long unsigned int set)
{
  irq_modify_status ( irq , 0UL , set );
}
# 488 "include/linux/irq.h"
static inline void irq_clear_status_flags(unsigned int irq, long unsigned int clr)
{
  irq_modify_status ( irq , clr , 0UL );
}
# 493 "include/linux/irq.h"
static inline void irq_set_noprobe(unsigned int irq)
{
  irq_modify_status ( irq , 0UL , 1024UL );
}
# 498 "include/linux/irq.h"
static inline void irq_set_probe(unsigned int irq)
{
  irq_modify_status ( irq , 1024UL , 0UL );
}
# 503 "include/linux/irq.h"
static inline void irq_set_nothread(unsigned int irq)
{
  irq_modify_status ( irq , 0UL , 65536UL );
}
# 508 "include/linux/irq.h"
static inline void irq_set_thread(unsigned int irq)
{
  irq_modify_status ( irq , 65536UL , 0UL );
}
# 513 "include/linux/irq.h"
static inline void irq_set_nested_thread(unsigned int irq, bool nest)
{
  if (( int ) nest)
  {
# 516 "include/linux/irq.h"
    irq_set_status_flags ( irq , 32768UL );
  }
  else
# 518 "include/linux/irq.h"
    irq_clear_status_flags ( irq , 32768UL );
}
# 521 "include/linux/irq.h"
static inline void irq_set_percpu_devid_flags(unsigned int irq)
{
  irq_set_status_flags ( irq , 202240UL );
}
# 529 "include/linux/irq.h"
int irq_set_chip(unsigned int, struct irq_chip *);
int irq_set_handler_data(unsigned int, void *);
int irq_set_chip_data(unsigned int, void *);
int irq_set_irq_type(unsigned int, unsigned int);
int irq_set_msi_desc(unsigned int, struct msi_desc *);
int irq_set_msi_desc_off(unsigned int, unsigned int, struct msi_desc *);
# 536 "include/linux/irq.h"
struct irq_data *irq_get_irq_data(unsigned int);
# 538 "include/linux/irq.h"
static inline struct irq_chip *irq_get_chip(unsigned int irq)
{
  struct irq_data *d = irq_get_irq_data ( irq );
  return d != ( ( struct irq_data *) 0 ) ? ( * d ) . chip : ( ( struct irq_chip *) 0 );
}
# 544 "include/linux/irq.h"
static inline struct irq_chip *irq_data_get_irq_chip(struct irq_data *d)
{
  return ( * d ) . chip;
}
# 549 "include/linux/irq.h"
static inline void *irq_get_chip_data(unsigned int irq)
{
  struct irq_data *d = irq_get_irq_data ( irq );
  return d != ( ( struct irq_data *) 0 ) ? ( * d ) . chip_data : ( ( void *) 0 );
}
# 555 "include/linux/irq.h"
static inline void *irq_data_get_irq_chip_data(struct irq_data *d)
{
  return ( * d ) . chip_data;
}
# 560 "include/linux/irq.h"
static inline void *irq_get_handler_data(unsigned int irq)
{
  struct irq_data *d = irq_get_irq_data ( irq );
  return d != ( ( struct irq_data *) 0 ) ? ( * d ) . handler_data : ( ( void *) 0 );
}
# 566 "include/linux/irq.h"
static inline void *irq_data_get_irq_handler_data(struct irq_data *d)
{
  return ( * d ) . handler_data;
}
# 571 "include/linux/irq.h"
static inline struct msi_desc *irq_get_msi_desc(unsigned int irq)
{
  struct irq_data *d = irq_get_irq_data ( irq );
  return d != ( ( struct irq_data *) 0 ) ? ( * d ) . msi_desc : ( ( struct msi_desc *) 0 );
}
# 577 "include/linux/irq.h"
static inline struct msi_desc *irq_data_get_msi(struct irq_data *d)
{
  return ( * d ) . msi_desc;
}
# 582 "include/linux/irq.h"
static inline u32 irq_get_trigger_type(unsigned int irq)
{
  struct irq_data *d = irq_get_irq_data ( irq );
  return d != ( ( struct irq_data *) 0 ) ? irqd_get_trigger_type ( d ) : 0U;
}
# 588 "include/linux/irq.h"
unsigned int arch_dynirq_lower_bound(unsigned int);
# 590 "include/linux/irq.h"
int __irq_alloc_descs(int, unsigned int, unsigned int, int, struct module *);
# 609 "include/linux/irq.h"
void irq_free_descs(unsigned int, unsigned int);
static inline void irq_free_desc(unsigned int irq)
{
  irq_free_descs ( irq , 1U );
}
# 616 "include/linux/irq.h"
unsigned int irq_alloc_hwirqs(int, int);
static inline unsigned int irq_alloc_hwirq(int node)
{
  return irq_alloc_hwirqs ( 1 , node );
}
void irq_free_hwirqs(unsigned int, int);
static inline void irq_free_hwirq(unsigned int irq)
{
  return & irq_free_hwirqs;
}
int arch_setup_hwirq(unsigned int, int);
void arch_teardown_hwirq(unsigned int);
struct irq_chip_regs
{
# 652 "include/linux/irq.h"
  long unsigned int enable;
  long unsigned int disable;
  long unsigned int mask;
  long unsigned int ack;
  long unsigned int eoi;
  long unsigned int type;
  long unsigned int polarity;
};
struct irq_chip_type
{
# 675 "include/linux/irq.h"
  struct irq_chip chip;
  struct irq_chip_regs regs;
  irq_flow_handler_t handler;
  u32 type;
  u32 mask_cache_priv;
  u32 *mask_cache;
};
struct irq_chip_generic
{
# 709 "include/linux/irq.h"
  raw_spinlock_t lock;
  void *reg_base;
  unsigned int irq_base;
  unsigned int irq_cnt;
  u32 mask_cache;
  u32 type_cache;
  u32 polarity_cache;
  u32 wake_enabled;
  u32 wake_active;
  unsigned int num_ct;
  void *private;
  long unsigned int installed;
  long unsigned int unused;
  struct irq_domain *domain;
  struct list_head list;
  struct irq_chip_type chip_types[0U];
};
enum irq_gc_flags
{
  IRQ_GC_INIT_MASK_CACHE = 1,
  IRQ_GC_INIT_NESTED_LOCK = 2,
  IRQ_GC_MASK_CACHE_PER_TYPE = 4,
  IRQ_GC_NO_MASK = 8
};
struct irq_domain_chip_generic
{
# 753 "include/linux/irq.h"
  unsigned int irqs_per_chip;
  unsigned int num_chips;
  unsigned int irq_flags_to_clear;
  unsigned int irq_flags_to_set;
  enum irq_gc_flags gc_flags;
  struct irq_chip_generic *gc[0U];
};
# 762 "include/linux/irq.h"
void irq_gc_noop(struct irq_data *);
void irq_gc_mask_disable_reg(struct irq_data *);
void irq_gc_mask_set_bit(struct irq_data *);
void irq_gc_mask_clr_bit(struct irq_data *);
void irq_gc_unmask_enable_reg(struct irq_data *);
void irq_gc_ack_set_bit(struct irq_data *);
void irq_gc_ack_clr_bit(struct irq_data *);
void irq_gc_mask_disable_reg_and_ack(struct irq_data *);
void irq_gc_eoi(struct irq_data *);
int irq_gc_set_wake(struct irq_data *, unsigned int);
# 774 "include/linux/irq.h"
int irq_map_generic_chip(struct irq_domain *, unsigned int, irq_hw_number_t);
# 777 "include/linux/irq.h"
struct irq_chip_generic *irq_alloc_generic_chip(char const *, int, unsigned int, void *, irq_flow_handler_t);
# 779 "include/linux/irq.h"
void irq_setup_generic_chip(struct irq_chip_generic *, u32, enum irq_gc_flags, unsigned int, unsigned int);
# 782 "include/linux/irq.h"
int irq_setup_alt_chip(struct irq_data *, unsigned int);
void irq_remove_generic_chip(struct irq_chip_generic *, u32, unsigned int, unsigned int);
# 786 "include/linux/irq.h"
struct irq_chip_generic *irq_get_domain_generic_chip(struct irq_domain *, unsigned int);
int irq_alloc_domain_generic_chips(struct irq_domain *, int, int, char const *, irq_flow_handler_t, unsigned int, unsigned int, enum irq_gc_flags);
# 794 "include/linux/irq.h"
static inline struct irq_chip_type *irq_data_get_chip_type(struct irq_data *d)
{
  return ({
# 796 "include/linux/irq.h"
    struct irq_chip const *__mptr = ( struct irq_chip const *) ( * d ) . chip;
# 796 "include/linux/irq.h"
    ( struct irq_chip_type *) __mptr;
  } );
}
# 802 "include/linux/irq.h"
static inline void irq_gc_lock(struct irq_chip_generic *gc)
{
  _raw_spin_lock ( & ( * gc ) . lock );
}
# 807 "include/linux/irq.h"
static inline void irq_gc_unlock(struct irq_chip_generic *gc)
{
  _raw_spin_unlock ( & ( * gc ) . lock );
}
# 39 "./arch/x86/include/asm/hardirq.h"
typedef struct
{
# 8 "./arch/x86/include/asm/hardirq.h"
  unsigned int __softirq_pending;
  unsigned int __nmi_count;
# 11 "./arch/x86/include/asm/hardirq.h"
  unsigned int apic_timer_irqs;
  unsigned int irq_spurious_count;
  unsigned int icr_read_retry_count;
# 16 "./arch/x86/include/asm/hardirq.h"
  unsigned int kvm_posted_intr_ipis;
# 18 "./arch/x86/include/asm/hardirq.h"
  unsigned int x86_platform_ipis;
  unsigned int apic_perf_irqs;
  unsigned int apic_irq_work_irqs;
# 22 "./arch/x86/include/asm/hardirq.h"
  unsigned int irq_resched_count;
  unsigned int irq_call_count;
# 28 "./arch/x86/include/asm/hardirq.h"
  unsigned int irq_tlb_count;
# 31 "./arch/x86/include/asm/hardirq.h"
  unsigned int irq_thermal_count;
# 34 "./arch/x86/include/asm/hardirq.h"
  unsigned int irq_threshold_count;
# 37 "./arch/x86/include/asm/hardirq.h"
  unsigned int irq_hv_callback_count;
} irq_cpustat_t;
# 41 "./arch/x86/include/asm/hardirq.h"
extern char __pcpu_scope_irq_stat;
# 41 "./arch/x86/include/asm/hardirq.h"
extern irq_cpustat_t irq_stat;
# 55 "./arch/x86/include/asm/hardirq.h"
void ack_bad_irq(unsigned int);
# 57 "./arch/x86/include/asm/hardirq.h"
u64 arch_irq_stat_cpu(unsigned int);
# 60 "./arch/x86/include/asm/hardirq.h"
u64 arch_irq_stat(void);
# 11 "include/linux/hardirq.h"
void synchronize_irq(unsigned int);
void synchronize_hardirq(unsigned int);
# 25 "include/linux/hardirq.h"
void rcu_nmi_enter(void);
void rcu_nmi_exit(void);
# 45 "include/linux/hardirq.h"
void irq_enter(void);
# 60 "include/linux/hardirq.h"
void irq_exit(void);
# 25 "./arch/x86/include/asm/cacheflush.h"
static inline long unsigned int get_page_memtype(struct page *pg)
{
  long unsigned int pg_flags = ( * pg ) . flags & 4194816UL;
# 29 "./arch/x86/include/asm/cacheflush.h"
  if (pg_flags == 0UL)
  {
# 30 "./arch/x86/include/asm/cacheflush.h"
    return 18446744073709551615UL;
  }
  else
# 31 "./arch/x86/include/asm/cacheflush.h"
    if (pg_flags == 512UL)
    {
# 32 "./arch/x86/include/asm/cacheflush.h"
      return 8UL;
    }
    else
# 33 "./arch/x86/include/asm/cacheflush.h"
      if (pg_flags == 4194304UL)
      {
# 34 "./arch/x86/include/asm/cacheflush.h"
        return 16UL;
      }
      else
# 36 "./arch/x86/include/asm/cacheflush.h"
        return 0UL;
}
# 39 "./arch/x86/include/asm/cacheflush.h"
static inline void set_page_memtype(struct page *pg, long unsigned int memtype)
{
  long unsigned int memtype_flags = 0UL;
  long unsigned int old_flags;
  long unsigned int new_flags;
# 45 "./arch/x86/include/asm/cacheflush.h"
  switch (memtype)
  {
# 46 "./arch/x86/include/asm/cacheflush.h"
    case 8:;
    memtype_flags = 512UL;
    goto ldv_28604;
    case 16:;
    memtype_flags = 4194304UL;
    goto ldv_28604;
    case 0:;
    memtype_flags = 4194816UL;
    goto ldv_28604;
  }
# 57 "./arch/x86/include/asm/cacheflush.h"
  ldv_28604:;
  ldv_28621:;
# 58 "./arch/x86/include/asm/cacheflush.h"
  old_flags = ( * pg ) . flags;
  new_flags = old_flags & 18446744073705356799UL | memtype_flags;
  if (({
# 60 "./arch/x86/include/asm/cacheflush.h"
    long unsigned int __ret;
# 60 "./arch/x86/include/asm/cacheflush.h"
    long unsigned int __old = old_flags;
# 60 "./arch/x86/include/asm/cacheflush.h"
    long unsigned int __new = new_flags;
    {
# 60 "./arch/x86/include/asm/cacheflush.h"
      switch (8UL)
      {
# 60 "./arch/x86/include/asm/cacheflush.h"
        case 1:;
        {
# 60 "./arch/x86/include/asm/cacheflush.h"
          u8 volatile *__ptr = ( u8 volatile *) & ( * pg ) . flags;
# 60 "./arch/x86/include/asm/cacheflush.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "q" ( __new ) , "0" ( __old ) : "memory" ) ;
# 60 "./arch/x86/include/asm/cacheflush.h"
          goto ldv_28612;
        }
# 60 "./arch/x86/include/asm/cacheflush.h"
        case 2:;
        {
# 60 "./arch/x86/include/asm/cacheflush.h"
          u16 volatile *__ptr = ( u16 volatile *) & ( * pg ) . flags;
# 60 "./arch/x86/include/asm/cacheflush.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 60 "./arch/x86/include/asm/cacheflush.h"
          goto ldv_28612;
        }
# 60 "./arch/x86/include/asm/cacheflush.h"
        case 4:;
        {
# 60 "./arch/x86/include/asm/cacheflush.h"
          u32 volatile *__ptr = ( u32 volatile *) & ( * pg ) . flags;
# 60 "./arch/x86/include/asm/cacheflush.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 60 "./arch/x86/include/asm/cacheflush.h"
          goto ldv_28612;
        }
# 60 "./arch/x86/include/asm/cacheflush.h"
        case 8:;
        {
# 60 "./arch/x86/include/asm/cacheflush.h"
          u64 volatile *__ptr = ( u64 volatile *) & ( * pg ) . flags;
# 60 "./arch/x86/include/asm/cacheflush.h"
          asm volatile ( ".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1" : "=a" ( __ret ) , "+m" ( * __ptr ) : "r" ( __new ) , "0" ( __old ) : "memory" ) ;
# 60 "./arch/x86/include/asm/cacheflush.h"
          goto ldv_28612;
        }
# 60 "./arch/x86/include/asm/cacheflush.h"
        default:;
# 60 "./arch/x86/include/asm/cacheflush.h"
        __cmpxchg_wrong_size ( );
      }
# 60 "./arch/x86/include/asm/cacheflush.h"
      ldv_28612:;
    }
# 60 "./arch/x86/include/asm/cacheflush.h"
    __ret;
  } )
# 60 "./arch/x86/include/asm/cacheflush.h"
  != old_flags)
  {
    goto ldv_28621;
  }
  else
    goto ldv_28622;
  ldv_28622:;
}
# 95 "./arch/x86/include/asm/cacheflush.h"
int _set_memory_uc(long unsigned int, int);
int _set_memory_wc(long unsigned int, int);
int _set_memory_wb(long unsigned int, int);
int set_memory_uc(long unsigned int, int);
int set_memory_wc(long unsigned int, int);
int set_memory_wb(long unsigned int, int);
int set_memory_x(long unsigned int, int);
int set_memory_nx(long unsigned int, int);
int set_memory_ro(long unsigned int, int);
int set_memory_rw(long unsigned int, int);
int set_memory_np(long unsigned int, int);
int set_memory_4k(long unsigned int, int);
# 108 "./arch/x86/include/asm/cacheflush.h"
int set_memory_array_uc(long unsigned int *, int);
int set_memory_array_wc(long unsigned int *, int);
int set_memory_array_wb(long unsigned int *, int);
# 112 "./arch/x86/include/asm/cacheflush.h"
int set_pages_array_uc(struct page **, int);
int set_pages_array_wc(struct page **, int);
int set_pages_array_wb(struct page **, int);
# 136 "./arch/x86/include/asm/cacheflush.h"
int set_pages_uc(struct page *, int);
int set_pages_wb(struct page *, int);
int set_pages_x(struct page *, int);
int set_pages_nx(struct page *, int);
int set_pages_ro(struct page *, int);
int set_pages_rw(struct page *, int);
# 144 "./arch/x86/include/asm/cacheflush.h"
void clflush_cache_range(void *, unsigned int);
# 147 "./arch/x86/include/asm/cacheflush.h"
void mark_rodata_ro(void);
extern int const rodata_test_data;
extern int kernel_set_to_readonly;
void set_kernel_text_rw(void);
void set_kernel_text_ro(void);
# 158 "./arch/x86/include/asm/cacheflush.h"
int rodata_test(void);
# 14 "include/linux/highmem.h"
static inline void flush_anon_page(struct vm_area_struct *vma, struct page *page, long unsigned int vmaddr)
{
}
# 20 "include/linux/highmem.h"
static inline void flush_kernel_dcache_page(struct page *page)
{
}
static inline void flush_kernel_vmap_range(void *vaddr, int size)
{
}
static inline void invalidate_kernel_vmap_range(void *vaddr, int size)
{
}
# 46 "include/linux/highmem.h"
static inline unsigned int nr_free_highpages(void)
{
# 46 "include/linux/highmem.h"
  return 0U;
}
static inline struct page *kmap_to_page(void *addr)
{
  return ( ( struct page *) -24189255811072 ) + ( __phys_addr ( ( long unsigned int ) addr ) >> 12 );
}
# 56 "include/linux/highmem.h"
static inline void *kmap(struct page *page)
{
  __might_sleep ( ( char const *) "include/linux/highmem.h" , 58 , 0 );
  return lowmem_page_address ( ( struct page const *) page );
}
# 62 "include/linux/highmem.h"
static inline void kunmap(struct page *page)
{
}
# 66 "include/linux/highmem.h"
static inline void *kmap_atomic(struct page *page)
{
  pagefault_disable ( );
  return lowmem_page_address ( ( struct page const *) page );
}
# 73 "include/linux/highmem.h"
static inline void __kunmap_atomic(void *addr)
{
  pagefault_enable ( );
}
# 132 "include/linux/highmem.h"
static inline void clear_user_highpage(struct page *page, long unsigned int vaddr)
{
  void *addr = kmap_atomic ( page );
  clear_user_page ( addr , vaddr , page );
  __kunmap_atomic ( addr );
}
# 179 "include/linux/highmem.h"
static inline struct page *alloc_zeroed_user_highpage_movable(struct vm_area_struct *vma, long unsigned int vaddr)
{
# 182 "include/linux/highmem.h"
  return alloc_pages_vma ( 164058U , 0 , vma , vaddr , numa_node_id ( ) );
}
# 185 "include/linux/highmem.h"
static inline void clear_highpage(struct page *page)
{
  void *kaddr = kmap_atomic ( page );
  clear_page ( kaddr );
  __kunmap_atomic ( kaddr );
}
# 192 "include/linux/highmem.h"
static inline void zero_user_segments(struct page *page, unsigned int start1, unsigned int end1, unsigned int start2, unsigned int end2)
{
# 196 "include/linux/highmem.h"
  void *kaddr = kmap_atomic ( page );
# 198 "include/linux/highmem.h"
  if (__builtin_expect ( end1 > 4096U , 0L ) != 0L || __builtin_expect ( end2 > 4096U , 0L ) != 0L)
  {
# 198 "include/linux/highmem.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/highmem.h" ) , "i" ( 198 ) , "i" ( 12UL ) ) ;
    ldv_28763:;
# 198 "include/linux/highmem.h"
    goto ldv_28763;
  }
  if (end1 > start1)
    memset ( kaddr + ( long unsigned int ) start1 , 0 , ( size_t ) ( end1 - start1 ) );
# 203 "include/linux/highmem.h"
  if (end2 > start2)
    memset ( kaddr + ( long unsigned int ) start2 , 0 , ( size_t ) ( end2 - start2 ) );
# 206 "include/linux/highmem.h"
  __kunmap_atomic ( kaddr );
}
# 210 "include/linux/highmem.h"
static inline void zero_user_segment(struct page *page, unsigned int start, unsigned int end)
{
# 213 "include/linux/highmem.h"
  zero_user_segments ( page , start , end , 0U , 0U );
}
# 216 "include/linux/highmem.h"
static inline void zero_user(struct page *page, unsigned int start, unsigned int size)
{
# 219 "include/linux/highmem.h"
  zero_user_segments ( page , start , start + size , 0U , 0U );
}
# 224 "include/linux/highmem.h"
static inline void copy_user_highpage(struct page *to, struct page *from, long unsigned int vaddr, struct vm_area_struct *vma)
{
# 227 "include/linux/highmem.h"
  char *vfrom;
# 227 "include/linux/highmem.h"
  char *vto;
# 229 "include/linux/highmem.h"
  vfrom = ( char *) kmap_atomic ( from );
  vto = ( char *) kmap_atomic ( to );
  copy_user_page ( ( void *) vto , ( void *) vfrom , vaddr , to );
  __kunmap_atomic ( ( void *) vto );
  __kunmap_atomic ( ( void *) vfrom );
}
# 238 "include/linux/highmem.h"
static inline void copy_highpage(struct page *to, struct page *from)
{
  char *vfrom;
# 240 "include/linux/highmem.h"
  char *vto;
# 242 "include/linux/highmem.h"
  vfrom = ( char *) kmap_atomic ( from );
  vto = ( char *) kmap_atomic ( to );
  copy_page ( ( void *) vto , ( void *) vfrom );
  __kunmap_atomic ( ( void *) vto );
  __kunmap_atomic ( ( void *) vfrom );
}
# 8 "include/linux/hugetlb_inline.h"
static inline int is_vm_hugetlb_page(struct vm_area_struct *vma)
{
  return ( ( * vma ) . vm_flags & 4194304UL ) != 0UL;
}
enum mapping_flags
{
  AS_EIO = 25,
  AS_ENOSPC = 26,
  AS_MM_ALL_LOCKS = 27,
  AS_UNEVICTABLE = 28,
  AS_BALLOON_MAP = 29,
  AS_EXITING = 30
};
# 31 "include/linux/pagemap.h"
static inline void mapping_set_error(struct address_space *mapping, int error)
{
  if (__builtin_expect ( error != 0 , 0L ) != 0L)
    if (error == -28)
    {
# 35 "include/linux/pagemap.h"
      set_bit ( 26L , ( long unsigned int volatile *) & ( * mapping ) . flags );
    }
    else
# 37 "include/linux/pagemap.h"
      set_bit ( 25L , ( long unsigned int volatile *) & ( * mapping ) . flags );
}
# 41 "include/linux/pagemap.h"
static inline void mapping_set_unevictable(struct address_space *mapping)
{
  set_bit ( 28L , ( long unsigned int volatile *) & ( * mapping ) . flags );
}
# 46 "include/linux/pagemap.h"
static inline void mapping_clear_unevictable(struct address_space *mapping)
{
  clear_bit ( 28L , ( long unsigned int volatile *) & ( * mapping ) . flags );
}
# 51 "include/linux/pagemap.h"
static inline int mapping_unevictable(struct address_space *mapping)
{
  if (mapping != ( ( struct address_space *) 0 ))
    return constant_test_bit ( 28L , ( long unsigned int const volatile *) & ( * mapping ) . flags );
  return mapping != ( ( struct address_space *) 0 );
}
# 58 "include/linux/pagemap.h"
static inline void mapping_set_balloon(struct address_space *mapping)
{
  set_bit ( 29L , ( long unsigned int volatile *) & ( * mapping ) . flags );
}
# 63 "include/linux/pagemap.h"
static inline void mapping_clear_balloon(struct address_space *mapping)
{
  clear_bit ( 29L , ( long unsigned int volatile *) & ( * mapping ) . flags );
}
# 68 "include/linux/pagemap.h"
static inline int mapping_balloon(struct address_space *mapping)
{
  return mapping != ( ( struct address_space *) 0 ) && constant_test_bit ( 29L , ( long unsigned int const volatile *) & ( * mapping ) . flags ) != 0;
}
# 73 "include/linux/pagemap.h"
static inline void mapping_set_exiting(struct address_space *mapping)
{
  set_bit ( 30L , ( long unsigned int volatile *) & ( * mapping ) . flags );
}
# 78 "include/linux/pagemap.h"
static inline int mapping_exiting(struct address_space *mapping)
{
  return constant_test_bit ( 30L , ( long unsigned int const volatile *) & ( * mapping ) . flags );
}
# 83 "include/linux/pagemap.h"
static inline gfp_t mapping_gfp_mask(struct address_space *mapping)
{
  return ( gfp_t ) ( * mapping ) . flags & 33554431U;
}
# 92 "include/linux/pagemap.h"
static inline void mapping_set_gfp_mask(struct address_space *m, gfp_t mask)
{
  ( * m ) . flags = ( * m ) . flags & 18446744073675997184UL |
# 95 "include/linux/pagemap.h"
  ( long unsigned int ) mask;
}
# 113 "include/linux/pagemap.h"
void release_pages(struct page **, int, bool);
# 159 "include/linux/pagemap.h"
static inline int page_cache_get_speculative(struct page *page)
{
  if (__builtin_expect ( ( ( long unsigned int ) preempt_count ( ) & 2096896UL ) != 0UL , 0L ) != 0L)
  {
# 161 "include/linux/pagemap.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/pagemap.h" ) , "i" ( 161 ) , "i" ( 12UL ) ) ;
    ldv_28840:;
# 161 "include/linux/pagemap.h"
    goto ldv_28840;
  }
# 180 "include/linux/pagemap.h"
  if (__builtin_expect ( get_page_unless_zero ( page ) == 0 , 0L ) != 0L)
# 186 "include/linux/pagemap.h"
    return 0;
# 189 "include/linux/pagemap.h"
  if (__builtin_expect ( PageTail ( ( struct page const *) page ) != 0 , 0L ) != 0L)
  {
# 189 "include/linux/pagemap.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(PageTail(page))" );
# 189 "include/linux/pagemap.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/pagemap.h" ) , "i" ( 189 ) , "i" ( 12UL ) ) ;
    ldv_28841:;
# 189 "include/linux/pagemap.h"
    goto ldv_28841;
  }
  return 1;
}
# 197 "include/linux/pagemap.h"
static inline int page_cache_add_speculative(struct page *page, int count)
{
  if (__builtin_expect ( ( ( long unsigned int ) preempt_count ( ) & 2096896UL ) != 0UL , 0L ) != 0L)
  {
# 199 "include/linux/pagemap.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/pagemap.h" ) , "i" ( 199 ) , "i" ( 12UL ) ) ;
    ldv_28846:;
# 199 "include/linux/pagemap.h"
    goto ldv_28846;
  }
# 209 "include/linux/pagemap.h"
  if (__builtin_expect ( atomic_add_unless ( & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . _count , count , 0 ) == 0 , 0L ) != 0L)
    return 0;
# 212 "include/linux/pagemap.h"
  if (__builtin_expect ( PageCompound ( page ) != 0 , 0L ) != 0L && __builtin_expect ( compound_head ( page ) != page , 0L ) != 0L)
  {
# 212 "include/linux/pagemap.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(PageCompound(page) && page != compound_head(page))" );
# 212 "include/linux/pagemap.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/pagemap.h" ) , "i" ( 212 ) , "i" ( 12UL ) ) ;
    ldv_28847:;
# 212 "include/linux/pagemap.h"
    goto ldv_28847;
  }
  return 1;
}
# 217 "include/linux/pagemap.h"
static inline int page_freeze_refs(struct page *page, int count)
{
  return ( int ) __builtin_expect ( atomic_cmpxchg ( & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . _count , count , 0 ) == count , 1L );
}
# 222 "include/linux/pagemap.h"
static inline void page_unfreeze_refs(struct page *page, int count)
{
  if (__builtin_expect ( page_count ( page ) != 0 , 0L ) != 0L)
  {
# 224 "include/linux/pagemap.h"
    dump_page ( page , ( char const *) "VM_BUG_ON_PAGE(page_count(page) != 0)" );
# 224 "include/linux/pagemap.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/pagemap.h" ) , "i" ( 224 ) , "i" ( 12UL ) ) ;
    ldv_28856:;
# 224 "include/linux/pagemap.h"
    goto ldv_28856;
  }
# 225 "include/linux/pagemap.h"
  if (__builtin_expect ( count == 0 , 0L ) != 0L)
  {
# 225 "include/linux/pagemap.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/pagemap.h" ) , "i" ( 225 ) , "i" ( 12UL ) ) ;
    ldv_28857:;
# 225 "include/linux/pagemap.h"
    goto ldv_28857;
  }
  atomic_set ( & ( * page ) . ldv_14284 . ldv_14283 . ldv_14281 . _count , count );
}
# 231 "include/linux/pagemap.h"
struct page *__page_cache_alloc(gfp_t);
# 239 "include/linux/pagemap.h"
static inline struct page *page_cache_alloc(struct address_space *x)
{
  return __page_cache_alloc ( mapping_gfp_mask ( x ) );
}
# 244 "include/linux/pagemap.h"
static inline struct page *page_cache_alloc_cold(struct address_space *x)
{
  return __page_cache_alloc ( mapping_gfp_mask ( x ) | 256U );
}
# 249 "include/linux/pagemap.h"
static inline struct page *page_cache_alloc_readahead(struct address_space *x)
{
  return __page_cache_alloc ( mapping_gfp_mask ( x )
# 252 "include/linux/pagemap.h"
  | 4864U );
}
# 255 "include/linux/pagemap.h"
typedef int filler_t(void *, struct page *);
# 257 "include/linux/pagemap.h"
long unsigned int page_cache_next_hole(struct address_space *, long unsigned int, long unsigned int);
# 259 "include/linux/pagemap.h"
long unsigned int page_cache_prev_hole(struct address_space *, long unsigned int, long unsigned int);
# 269 "include/linux/pagemap.h"
struct page *pagecache_get_page(struct address_space *, long unsigned int, int, gfp_t, gfp_t);
# 282 "include/linux/pagemap.h"
static inline struct page *find_get_page(struct address_space *mapping, long unsigned int offset)
{
# 285 "include/linux/pagemap.h"
  return pagecache_get_page ( mapping , offset , 0 , 0U , 0U );
}
# 288 "include/linux/pagemap.h"
static inline struct page *find_get_page_flags(struct address_space *mapping, long unsigned int offset, int fgp_flags)
{
# 291 "include/linux/pagemap.h"
  return pagecache_get_page ( mapping , offset , fgp_flags , 0U , 0U );
}
# 308 "include/linux/pagemap.h"
static inline struct page *find_lock_page(struct address_space *mapping, long unsigned int offset)
{
# 311 "include/linux/pagemap.h"
  return pagecache_get_page ( mapping , offset , 2 , 0U , 0U );
}
# 333 "include/linux/pagemap.h"
static inline struct page *find_or_create_page(struct address_space *mapping, long unsigned int offset, gfp_t gfp_mask)
{
# 336 "include/linux/pagemap.h"
  return pagecache_get_page ( mapping , offset , 7 , gfp_mask , gfp_mask
# 338 "include/linux/pagemap.h"
  & 81648U );
}
# 354 "include/linux/pagemap.h"
static inline struct page *grab_cache_page_nowait(struct address_space *mapping, long unsigned int index)
{
# 357 "include/linux/pagemap.h"
  return pagecache_get_page ( mapping , index , 54 , mapping_gfp_mask
# 359 "include/linux/pagemap.h"
  ( mapping ) , 80U );
}
# 363 "include/linux/pagemap.h"
struct page *find_get_entry(struct address_space *, long unsigned int);
struct page *find_lock_entry(struct address_space *, long unsigned int);
unsigned int find_get_entries(struct address_space *, long unsigned int, unsigned int, struct page **, long unsigned int *);
# 368 "include/linux/pagemap.h"
unsigned int find_get_pages(struct address_space *, long unsigned int, unsigned int, struct page **);
# 370 "include/linux/pagemap.h"
unsigned int find_get_pages_contig(struct address_space *, long unsigned int, unsigned int, struct page **);
# 372 "include/linux/pagemap.h"
unsigned int find_get_pages_tag(struct address_space *, long unsigned int *, int, unsigned int, struct page **);
# 375 "include/linux/pagemap.h"
struct page *grab_cache_page_write_begin(struct address_space *, long unsigned int, unsigned int);
# 381 "include/linux/pagemap.h"
static inline struct page *grab_cache_page(struct address_space *mapping, long unsigned int index)
{
# 384 "include/linux/pagemap.h"
  return find_or_create_page ( mapping , index , mapping_gfp_mask ( mapping ) );
}
# 387 "include/linux/pagemap.h"
struct page *read_cache_page(struct address_space *, long unsigned int, filler_t *, void *);
# 389 "include/linux/pagemap.h"
struct page *read_cache_page_gfp(struct address_space *, long unsigned int, gfp_t);
# 391 "include/linux/pagemap.h"
int read_cache_pages(struct address_space *, struct list_head *, filler_t *, void *);
# 394 "include/linux/pagemap.h"
static inline struct page *read_mapping_page(struct address_space *mapping, long unsigned int index, void *data)
{
# 397 "include/linux/pagemap.h"
  filler_t *filler = ( filler_t *) ( * ( * mapping ) . a_ops ) . readpage;
  return read_cache_page ( mapping , index , filler , data );
}
# 405 "include/linux/pagemap.h"
static inline long unsigned int page_to_pgoff(struct page *page)
{
  if (__builtin_expect ( PageHeadHuge ( page ) != 0 , 0L ) != 0L)
  {
# 408 "include/linux/pagemap.h"
    return ( * page ) . ldv_14284 . ldv_14267 . index << compound_order ( page );
  }
  else
# 410 "include/linux/pagemap.h"
    return ( * page ) . ldv_14284 . ldv_14267 . index;
}
# 416 "include/linux/pagemap.h"
static inline loff_t page_offset(struct page *page)
{
  return ( loff_t ) ( ( long long int ) ( * page ) . ldv_14284 . ldv_14267 . index << 12 );
}
# 421 "include/linux/pagemap.h"
static inline loff_t page_file_offset(struct page *page)
{
  return ( loff_t ) ( ( long long int ) page_file_index ( page ) << 12 );
}
# 426 "include/linux/pagemap.h"
long unsigned int linear_hugepage_index(struct vm_area_struct *, long unsigned int);
# 429 "include/linux/pagemap.h"
static inline long unsigned int linear_page_index(struct vm_area_struct *vma, long unsigned int address)
{
# 432 "include/linux/pagemap.h"
  long unsigned int pgoff;
  if (__builtin_expect ( is_vm_hugetlb_page ( vma ) != 0 , 0L ) != 0L)
    return linear_hugepage_index ( vma , address );
  pgoff = address - ( * vma ) . vm_start >> 12;
  pgoff = ( * vma ) . vm_pgoff + pgoff;
  return pgoff;
}
# 440 "include/linux/pagemap.h"
void __lock_page(struct page *);
int __lock_page_killable(struct page *);
int __lock_page_or_retry(struct page *, struct mm_struct *, unsigned int);
# 444 "include/linux/pagemap.h"
void unlock_page(struct page *);
# 446 "include/linux/pagemap.h"
static inline void __set_page_locked(struct page *page)
{
  __set_bit ( 0L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 451 "include/linux/pagemap.h"
static inline void __clear_page_locked(struct page *page)
{
  __clear_bit ( 0L , ( long unsigned int volatile *) & ( * page ) . flags );
}
# 456 "include/linux/pagemap.h"
static inline int trylock_page(struct page *page)
{
  return ( int ) __builtin_expect ( test_and_set_bit_lock ( 0L , ( long unsigned int volatile *) & ( * page ) . flags ) == 0 , 1L );
}
# 464 "include/linux/pagemap.h"
static inline void lock_page(struct page *page)
{
  __might_sleep ( ( char const *) "include/linux/pagemap.h" , 466 , 0 );
  if (trylock_page ( page ) == 0)
    __lock_page ( page );
}
# 476 "include/linux/pagemap.h"
static inline int lock_page_killable(struct page *page)
{
  __might_sleep ( ( char const *) "include/linux/pagemap.h" , 478 , 0 );
  if (trylock_page ( page ) == 0)
    return __lock_page_killable ( page );
  return 0;
}
# 491 "include/linux/pagemap.h"
static inline int lock_page_or_retry(struct page *page, struct mm_struct *mm, unsigned int flags)
{
# 494 "include/linux/pagemap.h"
  __might_sleep ( ( char const *) "include/linux/pagemap.h" , 494 , 0 );
  return trylock_page ( page ) != 0 || __lock_page_or_retry ( page , mm , flags ) != 0;
}
# 502 "include/linux/pagemap.h"
void wait_on_page_bit(struct page *, int);
# 504 "include/linux/pagemap.h"
int wait_on_page_bit_killable(struct page *, int);
# 506 "include/linux/pagemap.h"
static inline int wait_on_page_locked_killable(struct page *page)
{
  if (PageLocked ( ( struct page const *) page ) != 0)
    return wait_on_page_bit_killable ( page , 0 );
  return 0;
}
# 520 "include/linux/pagemap.h"
static inline void wait_on_page_locked(struct page *page)
{
  if (PageLocked ( ( struct page const *) page ) != 0)
    wait_on_page_bit ( page , 0 );
}
# 529 "include/linux/pagemap.h"
static inline void wait_on_page_writeback(struct page *page)
{
  if (PageWriteback ( ( struct page const *) page ) != 0)
    wait_on_page_bit ( page , 13 );
}
# 535 "include/linux/pagemap.h"
void end_page_writeback(struct page *);
void wait_for_stable_page(struct page *);
# 538 "include/linux/pagemap.h"
void page_endio(struct page *, int, int);
# 543 "include/linux/pagemap.h"
void add_page_wait_queue(struct page *, wait_queue_t *);
# 551 "include/linux/pagemap.h"
static inline int fault_in_pages_writeable(char *uaddr, int size)
{
  int ret;
# 555 "include/linux/pagemap.h"
  if (__builtin_expect ( size == 0 , 0L ) != 0L)
    return 0;
# 562 "include/linux/pagemap.h"
  ret = ({
# 562 "include/linux/pagemap.h"
    int __pu_err;
    {
# 562 "include/linux/pagemap.h"
      __pu_err = 0;
# 562 "include/linux/pagemap.h"
      ( void ) 0;
# 562 "include/linux/pagemap.h"
      switch (1UL)
      {
# 562 "include/linux/pagemap.h"
        case 1:;
# 562 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovb %b1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "iq" ( 0 ) , "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 562 "include/linux/pagemap.h"
        goto ldv_29044;
# 562 "include/linux/pagemap.h"
        case 2:;
# 562 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %w1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "ir" ( 0 ) , "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 562 "include/linux/pagemap.h"
        goto ldv_29044;
# 562 "include/linux/pagemap.h"
        case 4:;
# 562 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovl %k1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "ir" ( 0 ) , "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 562 "include/linux/pagemap.h"
        goto ldv_29044;
# 562 "include/linux/pagemap.h"
        case 8:;
# 562 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "er" ( 0 ) , "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 562 "include/linux/pagemap.h"
        goto ldv_29044;
# 562 "include/linux/pagemap.h"
        default:;
# 562 "include/linux/pagemap.h"
        __put_user_bad ( );
      }
# 562 "include/linux/pagemap.h"
      ldv_29044:;
    }
# 562 "include/linux/pagemap.h"
    __pu_err;
  } );
# 563 "include/linux/pagemap.h"
  if (ret == 0)
  {
# 564 "include/linux/pagemap.h"
    char *end = uaddr + ( ( long unsigned int ) ( long unsigned int ) size + 18446744073709551615U );
# 570 "include/linux/pagemap.h"
    if (( ( ( long unsigned int ) uaddr ^
# 571 "include/linux/pagemap.h"
    ( long unsigned int ) end )
# 570 "include/linux/pagemap.h"
    & 18446744073709547520UL ) != 0UL)
# 572 "include/linux/pagemap.h"
      ret = ({
# 572 "include/linux/pagemap.h"
        int __pu_err;
        {
# 572 "include/linux/pagemap.h"
          __pu_err = 0;
# 572 "include/linux/pagemap.h"
          ( void ) 0;
# 572 "include/linux/pagemap.h"
          switch (1UL)
          {
# 572 "include/linux/pagemap.h"
            case 1:;
# 572 "include/linux/pagemap.h"
            asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovb %b1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "iq" ( 0 ) , "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 572 "include/linux/pagemap.h"
            goto ldv_29053;
# 572 "include/linux/pagemap.h"
            case 2:;
# 572 "include/linux/pagemap.h"
            asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %w1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "ir" ( 0 ) , "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 572 "include/linux/pagemap.h"
            goto ldv_29053;
# 572 "include/linux/pagemap.h"
            case 4:;
# 572 "include/linux/pagemap.h"
            asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovl %k1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "ir" ( 0 ) , "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 572 "include/linux/pagemap.h"
            goto ldv_29053;
# 572 "include/linux/pagemap.h"
            case 8:;
# 572 "include/linux/pagemap.h"
            asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "er" ( 0 ) , "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 572 "include/linux/pagemap.h"
            goto ldv_29053;
# 572 "include/linux/pagemap.h"
            default:;
# 572 "include/linux/pagemap.h"
            __put_user_bad ( );
          }
# 572 "include/linux/pagemap.h"
          ldv_29053:;
        }
# 572 "include/linux/pagemap.h"
        __pu_err;
      } );
  }
# 574 "include/linux/pagemap.h"
  return ret;
}
# 577 "include/linux/pagemap.h"
static inline int fault_in_pages_readable(char const *uaddr, int size)
{
  char volatile c;
  int ret;
# 582 "include/linux/pagemap.h"
  if (__builtin_expect ( size == 0 , 0L ) != 0L)
    return 0;
# 585 "include/linux/pagemap.h"
  ret = ({
# 585 "include/linux/pagemap.h"
    int __gu_err;
# 585 "include/linux/pagemap.h"
    long unsigned int __gu_val;
    {
# 585 "include/linux/pagemap.h"
      __gu_err = 0;
# 585 "include/linux/pagemap.h"
      ( void ) 0;
# 585 "include/linux/pagemap.h"
      switch (1UL)
      {
# 585 "include/linux/pagemap.h"
        case 1:;
# 585 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovb %2,%b1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorb %b1,%b1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=q" ( __gu_val ) : "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 585 "include/linux/pagemap.h"
        goto ldv_29068;
# 585 "include/linux/pagemap.h"
        case 2:;
# 585 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %2,%w1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorw %w1,%w1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=r" ( __gu_val ) : "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 585 "include/linux/pagemap.h"
        goto ldv_29068;
# 585 "include/linux/pagemap.h"
        case 4:;
# 585 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovl %2,%k1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorl %k1,%k1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=r" ( __gu_val ) : "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 585 "include/linux/pagemap.h"
        goto ldv_29068;
# 585 "include/linux/pagemap.h"
        case 8:;
# 585 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %2,%1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorq %1,%1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=r" ( __gu_val ) : "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 585 "include/linux/pagemap.h"
        goto ldv_29068;
# 585 "include/linux/pagemap.h"
        default:;
# 585 "include/linux/pagemap.h"
        __gu_val = ( long unsigned int ) __get_user_bad ( );
      }
# 585 "include/linux/pagemap.h"
      ldv_29068:;
    }
# 585 "include/linux/pagemap.h"
    c = ( char ) __gu_val;
# 585 "include/linux/pagemap.h"
    __gu_err;
  } );
# 586 "include/linux/pagemap.h"
  if (ret == 0)
  {
# 587 "include/linux/pagemap.h"
    char const *end = uaddr + ( ( long unsigned int ) ( long unsigned int ) size + 18446744073709551615U );
# 589 "include/linux/pagemap.h"
    if (( ( ( long unsigned int ) uaddr ^
# 590 "include/linux/pagemap.h"
    ( long unsigned int ) end )
# 589 "include/linux/pagemap.h"
    & 18446744073709547520UL ) != 0UL)
    {
      ret = ({
# 591 "include/linux/pagemap.h"
        int __gu_err;
# 591 "include/linux/pagemap.h"
        long unsigned int __gu_val;
        {
# 591 "include/linux/pagemap.h"
          __gu_err = 0;
# 591 "include/linux/pagemap.h"
          ( void ) 0;
# 591 "include/linux/pagemap.h"
          switch (1UL)
          {
# 591 "include/linux/pagemap.h"
            case 1:;
# 591 "include/linux/pagemap.h"
            asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovb %2,%b1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorb %b1,%b1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=q" ( __gu_val ) : "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 591 "include/linux/pagemap.h"
            goto ldv_29078;
# 591 "include/linux/pagemap.h"
            case 2:;
# 591 "include/linux/pagemap.h"
            asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %2,%w1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorw %w1,%w1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=r" ( __gu_val ) : "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 591 "include/linux/pagemap.h"
            goto ldv_29078;
# 591 "include/linux/pagemap.h"
            case 4:;
# 591 "include/linux/pagemap.h"
            asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovl %2,%k1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorl %k1,%k1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=r" ( __gu_val ) : "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 591 "include/linux/pagemap.h"
            goto ldv_29078;
# 591 "include/linux/pagemap.h"
            case 8:;
# 591 "include/linux/pagemap.h"
            asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %2,%1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorq %1,%1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=r" ( __gu_val ) : "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 591 "include/linux/pagemap.h"
            goto ldv_29078;
# 591 "include/linux/pagemap.h"
            default:;
# 591 "include/linux/pagemap.h"
            __gu_val = ( long unsigned int ) __get_user_bad ( );
          }
# 591 "include/linux/pagemap.h"
          ldv_29078:;
        }
# 591 "include/linux/pagemap.h"
        c = ( char ) __gu_val;
# 591 "include/linux/pagemap.h"
        __gu_err;
      } );
# 592 "include/linux/pagemap.h"
      ( void ) c;
    }
  }
  return ret;
}
# 604 "include/linux/pagemap.h"
static inline int fault_in_multipages_writeable(char *uaddr, int size)
{
  int ret = 0;
  char *end = uaddr + ( ( long unsigned int ) ( long unsigned int ) size + 18446744073709551615U );
# 609 "include/linux/pagemap.h"
  if (__builtin_expect ( size == 0 , 0L ) != 0L)
    return ret;
# 616 "include/linux/pagemap.h"
  goto ldv_29099;
  ldv_29098:;
# 617 "include/linux/pagemap.h"
  ret = ({
# 617 "include/linux/pagemap.h"
    int __pu_err;
    {
# 617 "include/linux/pagemap.h"
      __pu_err = 0;
# 617 "include/linux/pagemap.h"
      ( void ) 0;
# 617 "include/linux/pagemap.h"
      switch (1UL)
      {
# 617 "include/linux/pagemap.h"
        case 1:;
# 617 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovb %b1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "iq" ( 0 ) , "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 617 "include/linux/pagemap.h"
        goto ldv_29092;
# 617 "include/linux/pagemap.h"
        case 2:;
# 617 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %w1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "ir" ( 0 ) , "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 617 "include/linux/pagemap.h"
        goto ldv_29092;
# 617 "include/linux/pagemap.h"
        case 4:;
# 617 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovl %k1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "ir" ( 0 ) , "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 617 "include/linux/pagemap.h"
        goto ldv_29092;
# 617 "include/linux/pagemap.h"
        case 8:;
# 617 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "er" ( 0 ) , "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 617 "include/linux/pagemap.h"
        goto ldv_29092;
# 617 "include/linux/pagemap.h"
        default:;
# 617 "include/linux/pagemap.h"
        __put_user_bad ( );
      }
# 617 "include/linux/pagemap.h"
      ldv_29092:;
    }
# 617 "include/linux/pagemap.h"
    __pu_err;
  } );
# 618 "include/linux/pagemap.h"
  if (ret != 0)
    return ret;
  uaddr += 4096UL;
  ldv_29099:;
# 616 "include/linux/pagemap.h"
  if (uaddr <= end)
  {
    goto ldv_29098;
  }
  else
    goto ldv_29100;
  ldv_29100:;
# 624 "include/linux/pagemap.h"
  if (( ( ( long unsigned int ) uaddr ^
# 625 "include/linux/pagemap.h"
  ( long unsigned int ) end )
# 624 "include/linux/pagemap.h"
  & 18446744073709547520UL ) == 0UL)
# 626 "include/linux/pagemap.h"
    ret = ({
# 626 "include/linux/pagemap.h"
      int __pu_err;
      {
# 626 "include/linux/pagemap.h"
        __pu_err = 0;
# 626 "include/linux/pagemap.h"
        ( void ) 0;
# 626 "include/linux/pagemap.h"
        switch (1UL)
        {
# 626 "include/linux/pagemap.h"
          case 1:;
# 626 "include/linux/pagemap.h"
          asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovb %b1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "iq" ( 0 ) , "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 626 "include/linux/pagemap.h"
          goto ldv_29103;
# 626 "include/linux/pagemap.h"
          case 2:;
# 626 "include/linux/pagemap.h"
          asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %w1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "ir" ( 0 ) , "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 626 "include/linux/pagemap.h"
          goto ldv_29103;
# 626 "include/linux/pagemap.h"
          case 4:;
# 626 "include/linux/pagemap.h"
          asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovl %k1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "ir" ( 0 ) , "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 626 "include/linux/pagemap.h"
          goto ldv_29103;
# 626 "include/linux/pagemap.h"
          case 8:;
# 626 "include/linux/pagemap.h"
          asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %1,%2\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __pu_err ) : "er" ( 0 ) , "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __pu_err ) ) ;
# 626 "include/linux/pagemap.h"
          goto ldv_29103;
# 626 "include/linux/pagemap.h"
          default:;
# 626 "include/linux/pagemap.h"
          __put_user_bad ( );
        }
# 626 "include/linux/pagemap.h"
        ldv_29103:;
      }
# 626 "include/linux/pagemap.h"
      __pu_err;
    } );
  return ret;
}
# 631 "include/linux/pagemap.h"
static inline int fault_in_multipages_readable(char const *uaddr, int size)
{
# 634 "include/linux/pagemap.h"
  char volatile c;
  int ret = 0;
  char const *end = uaddr + ( ( long unsigned int ) ( long unsigned int ) size + 18446744073709551615U );
# 638 "include/linux/pagemap.h"
  if (__builtin_expect ( size == 0 , 0L ) != 0L)
    return ret;
# 641 "include/linux/pagemap.h"
  goto ldv_29126;
  ldv_29125:;
# 642 "include/linux/pagemap.h"
  ret = ({
# 642 "include/linux/pagemap.h"
    int __gu_err;
# 642 "include/linux/pagemap.h"
    long unsigned int __gu_val;
    {
# 642 "include/linux/pagemap.h"
      __gu_err = 0;
# 642 "include/linux/pagemap.h"
      ( void ) 0;
# 642 "include/linux/pagemap.h"
      switch (1UL)
      {
# 642 "include/linux/pagemap.h"
        case 1:;
# 642 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovb %2,%b1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorb %b1,%b1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=q" ( __gu_val ) : "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 642 "include/linux/pagemap.h"
        goto ldv_29119;
# 642 "include/linux/pagemap.h"
        case 2:;
# 642 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %2,%w1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorw %w1,%w1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=r" ( __gu_val ) : "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 642 "include/linux/pagemap.h"
        goto ldv_29119;
# 642 "include/linux/pagemap.h"
        case 4:;
# 642 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovl %2,%k1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorl %k1,%k1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=r" ( __gu_val ) : "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 642 "include/linux/pagemap.h"
        goto ldv_29119;
# 642 "include/linux/pagemap.h"
        case 8:;
# 642 "include/linux/pagemap.h"
        asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %2,%1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorq %1,%1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=r" ( __gu_val ) : "m" ( * ( struct __large_struct *) uaddr ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 642 "include/linux/pagemap.h"
        goto ldv_29119;
# 642 "include/linux/pagemap.h"
        default:;
# 642 "include/linux/pagemap.h"
        __gu_val = ( long unsigned int ) __get_user_bad ( );
      }
# 642 "include/linux/pagemap.h"
      ldv_29119:;
    }
# 642 "include/linux/pagemap.h"
    c = ( char ) __gu_val;
# 642 "include/linux/pagemap.h"
    __gu_err;
  } );
# 643 "include/linux/pagemap.h"
  if (ret != 0)
    return ret;
  uaddr += 4096UL;
  ldv_29126:;
# 641 "include/linux/pagemap.h"
  if (uaddr <= end)
  {
    goto ldv_29125;
  }
  else
    goto ldv_29127;
  ldv_29127:;
# 649 "include/linux/pagemap.h"
  if (( ( ( long unsigned int ) uaddr ^
# 650 "include/linux/pagemap.h"
  ( long unsigned int ) end )
# 649 "include/linux/pagemap.h"
  & 18446744073709547520UL ) == 0UL)
  {
    ret = ({
# 651 "include/linux/pagemap.h"
      int __gu_err;
# 651 "include/linux/pagemap.h"
      long unsigned int __gu_val;
      {
# 651 "include/linux/pagemap.h"
        __gu_err = 0;
# 651 "include/linux/pagemap.h"
        ( void ) 0;
# 651 "include/linux/pagemap.h"
        switch (1UL)
        {
# 651 "include/linux/pagemap.h"
          case 1:;
# 651 "include/linux/pagemap.h"
          asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovb %2,%b1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorb %b1,%b1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=q" ( __gu_val ) : "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 651 "include/linux/pagemap.h"
          goto ldv_29131;
# 651 "include/linux/pagemap.h"
          case 2:;
# 651 "include/linux/pagemap.h"
          asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovw %2,%w1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorw %w1,%w1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=r" ( __gu_val ) : "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 651 "include/linux/pagemap.h"
          goto ldv_29131;
# 651 "include/linux/pagemap.h"
          case 4:;
# 651 "include/linux/pagemap.h"
          asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovl %2,%k1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorl %k1,%k1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=r" ( __gu_val ) : "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 651 "include/linux/pagemap.h"
          goto ldv_29131;
# 651 "include/linux/pagemap.h"
          case 8:;
# 651 "include/linux/pagemap.h"
          asm volatile ( "661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xcb\n6641:\n\t.popsection\n1:\tmovq %2,%1\n2: 661:\n\t.byte 0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+20)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0x01,0xca\n6641:\n\t.popsection\n.section .fixup,\"ax\"\n3:\tmov %3,%0\n\txorq %1,%1\n\tjmp 2b\n.previous\n .pushsection \"__ex_table\",\"a\"\n .balign 8\n .long (1b) - .\n .long (3b) - .\n .popsection\n" : "=r" ( __gu_err ) , "=r" ( __gu_val ) : "m" ( * ( struct __large_struct *) end ) , "i" ( -14 ) , "0" ( __gu_err ) ) ;
# 651 "include/linux/pagemap.h"
          goto ldv_29131;
# 651 "include/linux/pagemap.h"
          default:;
# 651 "include/linux/pagemap.h"
          __gu_val = ( long unsigned int ) __get_user_bad ( );
        }
# 651 "include/linux/pagemap.h"
        ldv_29131:;
      }
# 651 "include/linux/pagemap.h"
      c = ( char ) __gu_val;
# 651 "include/linux/pagemap.h"
      __gu_err;
    } );
# 652 "include/linux/pagemap.h"
    ( void ) c;
  }
# 655 "include/linux/pagemap.h"
  return ret;
}
# 658 "include/linux/pagemap.h"
int add_to_page_cache_locked(struct page *, struct address_space *, long unsigned int, gfp_t);
# 660 "include/linux/pagemap.h"
int add_to_page_cache_lru(struct page *, struct address_space *, long unsigned int, gfp_t);
# 662 "include/linux/pagemap.h"
void delete_from_page_cache(struct page *);
void __delete_from_page_cache(struct page *, void *);
int replace_page_cache_page(struct page *, struct page *, gfp_t);
# 670 "include/linux/pagemap.h"
static inline int add_to_page_cache(struct page *page, struct address_space *mapping, long unsigned int offset, gfp_t gfp_mask)
{
# 673 "include/linux/pagemap.h"
  int error;
# 675 "include/linux/pagemap.h"
  __set_page_locked ( page );
  error = add_to_page_cache_locked ( page , mapping , offset , gfp_mask );
  if (__builtin_expect ( error != 0 , 0L ) != 0L)
    __clear_page_locked ( page );
  return error;
}
struct fprop_global
{
# 28 "include/linux/flex_proportions.h"
  struct percpu_counter events;
# 30 "include/linux/flex_proportions.h"
  unsigned int period;
# 32 "include/linux/flex_proportions.h"
  seqcount_t sequence;
};
# 35 "include/linux/flex_proportions.h"
int fprop_global_init(struct fprop_global *);
void fprop_global_destroy(struct fprop_global *);
bool fprop_new_period(struct fprop_global *, int);
struct fprop_local_single
{
# 44 "include/linux/flex_proportions.h"
  long unsigned int events;
# 46 "include/linux/flex_proportions.h"
  unsigned int period;
  raw_spinlock_t lock;
};
# 54 "include/linux/flex_proportions.h"
int fprop_local_init_single(struct fprop_local_single *);
void fprop_local_destroy_single(struct fprop_local_single *);
void __fprop_inc_single(struct fprop_global *, struct fprop_local_single *);
void fprop_fraction_single(struct fprop_global *, struct fprop_local_single *, long unsigned int *, long unsigned int *);
# 62 "include/linux/flex_proportions.h"
static inline void fprop_inc_single(struct fprop_global *p, struct fprop_local_single *pl)
{
  long unsigned int flags;
# 66 "include/linux/flex_proportions.h"
  ({
# 66 "include/linux/flex_proportions.h"
    long unsigned int __dummy;
# 66 "include/linux/flex_proportions.h"
    long unsigned int __dummy2;
# 66 "include/linux/flex_proportions.h"
    ( void ) 0;
# 66 "include/linux/flex_proportions.h"
    1;
  } );
# 66 "include/linux/flex_proportions.h"
  flags = arch_local_irq_save ( );
# 66 "include/linux/flex_proportions.h"
  trace_hardirqs_off ( );
  __fprop_inc_single ( p , pl );
  if (({
# 68 "include/linux/flex_proportions.h"
    ({
# 68 "include/linux/flex_proportions.h"
      long unsigned int __dummy;
# 68 "include/linux/flex_proportions.h"
      long unsigned int __dummy2;
# 68 "include/linux/flex_proportions.h"
      ( void ) 0;
# 68 "include/linux/flex_proportions.h"
      1;
    } );
# 68 "include/linux/flex_proportions.h"
    arch_irqs_disabled_flags ( flags );
  } )
# 68 "include/linux/flex_proportions.h"
  != 0)
  {
# 68 "include/linux/flex_proportions.h"
    ({
# 68 "include/linux/flex_proportions.h"
      long unsigned int __dummy;
# 68 "include/linux/flex_proportions.h"
      long unsigned int __dummy2;
# 68 "include/linux/flex_proportions.h"
      ( void ) 0;
# 68 "include/linux/flex_proportions.h"
      1;
    } );
# 68 "include/linux/flex_proportions.h"
    arch_local_irq_restore ( flags );
# 68 "include/linux/flex_proportions.h"
    trace_hardirqs_off ( );
  }
  else
  {
# 68 "include/linux/flex_proportions.h"
    trace_hardirqs_on ( );
# 68 "include/linux/flex_proportions.h"
    ({
# 68 "include/linux/flex_proportions.h"
      long unsigned int __dummy;
# 68 "include/linux/flex_proportions.h"
      long unsigned int __dummy2;
# 68 "include/linux/flex_proportions.h"
      ( void ) 0;
# 68 "include/linux/flex_proportions.h"
      1;
    } );
# 68 "include/linux/flex_proportions.h"
    arch_local_irq_restore ( flags );
  }
}
struct fprop_local_percpu
{
# 76 "include/linux/flex_proportions.h"
  struct percpu_counter events;
# 78 "include/linux/flex_proportions.h"
  unsigned int period;
  raw_spinlock_t lock;
};
# 82 "include/linux/flex_proportions.h"
int fprop_local_init_percpu(struct fprop_local_percpu *);
void fprop_local_destroy_percpu(struct fprop_local_percpu *);
void __fprop_inc_percpu(struct fprop_global *, struct fprop_local_percpu *);
void __fprop_inc_percpu_max(struct fprop_global *, struct fprop_local_percpu *, int);
# 87 "include/linux/flex_proportions.h"
void fprop_fraction_percpu(struct fprop_global *, struct fprop_local_percpu *, long unsigned int *, long unsigned int *);
# 92 "include/linux/flex_proportions.h"
static inline void fprop_inc_percpu(struct fprop_global *p, struct fprop_local_percpu *pl)
{
  long unsigned int flags;
# 96 "include/linux/flex_proportions.h"
  ({
# 96 "include/linux/flex_proportions.h"
    long unsigned int __dummy;
# 96 "include/linux/flex_proportions.h"
    long unsigned int __dummy2;
# 96 "include/linux/flex_proportions.h"
    ( void ) 0;
# 96 "include/linux/flex_proportions.h"
    1;
  } );
# 96 "include/linux/flex_proportions.h"
  flags = arch_local_irq_save ( );
# 96 "include/linux/flex_proportions.h"
  trace_hardirqs_off ( );
  __fprop_inc_percpu ( p , pl );
  if (({
# 98 "include/linux/flex_proportions.h"
    ({
# 98 "include/linux/flex_proportions.h"
      long unsigned int __dummy;
# 98 "include/linux/flex_proportions.h"
      long unsigned int __dummy2;
# 98 "include/linux/flex_proportions.h"
      ( void ) 0;
# 98 "include/linux/flex_proportions.h"
      1;
    } );
# 98 "include/linux/flex_proportions.h"
    arch_irqs_disabled_flags ( flags );
  } )
# 98 "include/linux/flex_proportions.h"
  != 0)
  {
# 98 "include/linux/flex_proportions.h"
    ({
# 98 "include/linux/flex_proportions.h"
      long unsigned int __dummy;
# 98 "include/linux/flex_proportions.h"
      long unsigned int __dummy2;
# 98 "include/linux/flex_proportions.h"
      ( void ) 0;
# 98 "include/linux/flex_proportions.h"
      1;
    } );
# 98 "include/linux/flex_proportions.h"
    arch_local_irq_restore ( flags );
# 98 "include/linux/flex_proportions.h"
    trace_hardirqs_off ( );
  }
  else
  {
# 98 "include/linux/flex_proportions.h"
    trace_hardirqs_on ( );
# 98 "include/linux/flex_proportions.h"
    ({
# 98 "include/linux/flex_proportions.h"
      long unsigned int __dummy;
# 98 "include/linux/flex_proportions.h"
      long unsigned int __dummy2;
# 98 "include/linux/flex_proportions.h"
      ( void ) 0;
# 98 "include/linux/flex_proportions.h"
      1;
    } );
# 98 "include/linux/flex_proportions.h"
    arch_local_irq_restore ( flags );
  }
}
# 11 "include/linux/writeback.h"
extern char __pcpu_scope_dirty_throttle_leaks;
# 11 "include/linux/writeback.h"
extern int dirty_throttle_leaks;
enum writeback_sync_modes
{
  WB_SYNC_NONE = 0,
  WB_SYNC_ALL = 1
};
enum wb_reason
{
  WB_REASON_BACKGROUND = 0,
  WB_REASON_TRY_TO_FREE_PAGES = 1,
  WB_REASON_SYNC = 2,
  WB_REASON_PERIODIC = 3,
  WB_REASON_LAPTOP_TIMER = 4,
  WB_REASON_FREE_MORE_MEM = 5,
  WB_REASON_FS_FREE_SPACE = 6,
  WB_REASON_FORKER_THREAD = 7,
  WB_REASON_MAX = 8
};
struct writeback_control
{
# 67 "include/linux/writeback.h"
  long int nr_to_write;
# 69 "include/linux/writeback.h"
  long int pages_skipped;
# 76 "include/linux/writeback.h"
  loff_t range_start;
  loff_t range_end;
# 79 "include/linux/writeback.h"
  enum writeback_sync_modes sync_mode;
# 81 "include/linux/writeback.h"
  unsigned char for_kupdate : 1;
  unsigned char for_background : 1;
  unsigned char tagged_writepages : 1;
  unsigned char for_reclaim : 1;
  unsigned char range_cyclic : 1;
  unsigned char for_sync : 1;
};
struct bdi_writeback;
# 93 "include/linux/writeback.h"
void writeback_inodes_sb(struct super_block *, enum wb_reason);
void writeback_inodes_sb_nr(struct super_block *, long unsigned int, enum wb_reason);
# 96 "include/linux/writeback.h"
int try_to_writeback_inodes_sb(struct super_block *, enum wb_reason);
int try_to_writeback_inodes_sb_nr(struct super_block *, long unsigned int, enum wb_reason);
# 99 "include/linux/writeback.h"
void sync_inodes_sb(struct super_block *);
void wakeup_flusher_threads(long int, enum wb_reason);
void inode_wait_for_writeback(struct inode *);
# 104 "include/linux/writeback.h"
static inline void wait_on_inode(struct inode *inode)
{
  __might_sleep ( ( char const *) "include/linux/writeback.h" , 106 , 0 );
  wait_on_bit ( ( void *) & ( * inode ) . i_state , 3 , 2U );
}
# 114 "include/linux/writeback.h"
void laptop_io_completion(struct backing_dev_info *);
void laptop_sync_completion(void);
void laptop_mode_sync(struct work_struct *);
void laptop_mode_timer_fn(long unsigned int);
# 121 "include/linux/writeback.h"
void throttle_vm_writeout(gfp_t);
bool zone_dirty_ok(struct zone *);
# 124 "include/linux/writeback.h"
extern long unsigned int global_dirty_limit;
# 127 "include/linux/writeback.h"
extern int dirty_background_ratio;
extern long unsigned int dirty_background_bytes;
extern int vm_dirty_ratio;
extern long unsigned int vm_dirty_bytes;
extern unsigned int dirty_writeback_interval;
extern unsigned int dirty_expire_interval;
extern int vm_highmem_is_dirtyable;
extern int block_dump;
extern int laptop_mode;
# 137 "include/linux/writeback.h"
int dirty_background_ratio_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 140 "include/linux/writeback.h"
int dirty_background_bytes_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 143 "include/linux/writeback.h"
int dirty_ratio_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 146 "include/linux/writeback.h"
int dirty_bytes_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 151 "include/linux/writeback.h"
int dirty_writeback_centisecs_handler(struct ctl_table *, int, void *, size_t *, loff_t *);
# 154 "include/linux/writeback.h"
void global_dirty_limits(long unsigned int *, long unsigned int *);
long unsigned int bdi_dirty_limit(struct backing_dev_info *, long unsigned int);
# 158 "include/linux/writeback.h"
void __bdi_update_bandwidth(struct backing_dev_info *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
# 166 "include/linux/writeback.h"
void page_writeback_init(void);
void balance_dirty_pages_ratelimited(struct address_space *);
# 169 "include/linux/writeback.h"
typedef int (*writepage_t)(struct page *, struct writeback_control *, void *);
# 172 "include/linux/writeback.h"
int generic_writepages(struct address_space *, struct writeback_control *);
# 174 "include/linux/writeback.h"
void tag_pages_for_writeback(struct address_space *, long unsigned int, long unsigned int);
# 176 "include/linux/writeback.h"
int write_cache_pages(struct address_space *, struct writeback_control *, writepage_t, void *);
# 179 "include/linux/writeback.h"
int do_writepages(struct address_space *, struct writeback_control *);
void set_page_dirty_balance(struct page *);
void writeback_set_ratelimit(void);
void tag_pages_for_writeback(struct address_space *, long unsigned int, long unsigned int);
# 185 "include/linux/writeback.h"
void account_page_redirty(struct page *);
enum bdi_state
{
  BDI_wb_alloc = 0,
  BDI_async_congested = 1,
  BDI_sync_congested = 2,
  BDI_registered = 3,
  BDI_writeback_running = 4,
  BDI_unused = 5
};
# 39 "include/linux/backing-dev.h"
typedef int congested_fn(void *, int);
enum bdi_stat_item
{
  BDI_RECLAIMABLE = 0,
  BDI_WRITEBACK = 1,
  BDI_DIRTIED = 2,
  BDI_WRITTEN = 3,
  NR_BDI_STAT_ITEMS = 4
};
struct bdi_writeback
{
# 52 "include/linux/backing-dev.h"
  struct backing_dev_info *bdi;
  unsigned int nr;
# 55 "include/linux/backing-dev.h"
  long unsigned int last_old_flush;
# 57 "include/linux/backing-dev.h"
  struct delayed_work dwork;
  struct list_head b_dirty;
  struct list_head b_io;
  struct list_head b_more_io;
  spinlock_t list_lock;
};
struct backing_dev_info
{
  struct list_head bdi_list;
  long unsigned int ra_pages;
  long unsigned int state;
  unsigned int capabilities;
  congested_fn *congested_fn;
  void *congested_data;
# 72 "include/linux/backing-dev.h"
  char *name;
# 74 "include/linux/backing-dev.h"
  struct percpu_counter bdi_stat[4U];
# 76 "include/linux/backing-dev.h"
  long unsigned int bw_time_stamp;
  long unsigned int dirtied_stamp;
  long unsigned int written_stamp;
  long unsigned int write_bandwidth;
  long unsigned int avg_write_bandwidth;
# 88 "include/linux/backing-dev.h"
  long unsigned int dirty_ratelimit;
  long unsigned int balanced_dirty_ratelimit;
# 91 "include/linux/backing-dev.h"
  struct fprop_local_percpu completions;
  int dirty_exceeded;
# 94 "include/linux/backing-dev.h"
  unsigned int min_ratio;
  unsigned int max_ratio;
# 95 "include/linux/backing-dev.h"
  unsigned int max_prop_frac;
# 97 "include/linux/backing-dev.h"
  struct bdi_writeback wb;
  spinlock_t wb_lock;
# 100 "include/linux/backing-dev.h"
  struct list_head work_list;
# 102 "include/linux/backing-dev.h"
  struct device *dev;
# 104 "include/linux/backing-dev.h"
  struct timer_list laptop_mode_wb_timer;
# 107 "include/linux/backing-dev.h"
  struct dentry *debug_dir;
  struct dentry *debug_stats;
};
# 112 "include/linux/backing-dev.h"
int bdi_init(struct backing_dev_info *);
void bdi_destroy(struct backing_dev_info *);
# 116 "include/linux/backing-dev.h"
int bdi_register(struct backing_dev_info *, struct device *, char const *, ...);
# 118 "include/linux/backing-dev.h"
int bdi_register_dev(struct backing_dev_info *, dev_t);
void bdi_unregister(struct backing_dev_info *);
int bdi_setup_and_register(struct backing_dev_info *, char *, unsigned int);
void bdi_start_writeback(struct backing_dev_info *, long int, enum wb_reason);
# 123 "include/linux/backing-dev.h"
void bdi_start_background_writeback(struct backing_dev_info *);
void bdi_writeback_workfn(struct work_struct *);
int bdi_has_dirty_io(struct backing_dev_info *);
void bdi_wakeup_thread_delayed(struct backing_dev_info *);
void bdi_lock_two(struct bdi_writeback *, struct bdi_writeback *);
# 129 "include/linux/backing-dev.h"
extern spinlock_t bdi_lock;
extern struct list_head bdi_list;
# 132 "include/linux/backing-dev.h"
extern struct workqueue_struct *bdi_wq;
# 134 "include/linux/backing-dev.h"
static inline int wb_has_dirty_io(struct bdi_writeback *wb)
{
  return list_empty ( ( struct list_head const *) & ( * wb ) . b_dirty ) == 0 || list_empty
# 137 "include/linux/backing-dev.h"
  ( ( struct list_head const *) & ( * wb ) . b_io ) == 0 || list_empty
# 138 "include/linux/backing-dev.h"
  ( ( struct list_head const *) & ( * wb ) . b_more_io ) == 0;
}
# 141 "include/linux/backing-dev.h"
static inline void __add_bdi_stat(struct backing_dev_info *bdi, enum bdi_stat_item item, s64 amount)
{
# 144 "include/linux/backing-dev.h"
  __percpu_counter_add ( ( struct percpu_counter *) & ( * bdi ) . bdi_stat + ( long unsigned int ) item , amount , ( __ilog2_u32 ( ( u32 ) nr_cpu_ids ) + 1 ) * 8 );
}
# 147 "include/linux/backing-dev.h"
static inline void __inc_bdi_stat(struct backing_dev_info *bdi, enum bdi_stat_item item)
{
# 150 "include/linux/backing-dev.h"
  __add_bdi_stat ( bdi , item , 1LL );
}
# 153 "include/linux/backing-dev.h"
static inline void inc_bdi_stat(struct backing_dev_info *bdi, enum bdi_stat_item item)
{
# 156 "include/linux/backing-dev.h"
  long unsigned int flags;
# 158 "include/linux/backing-dev.h"
  ({
# 158 "include/linux/backing-dev.h"
    long unsigned int __dummy;
# 158 "include/linux/backing-dev.h"
    long unsigned int __dummy2;
# 158 "include/linux/backing-dev.h"
    ( void ) 0;
# 158 "include/linux/backing-dev.h"
    1;
  } );
# 158 "include/linux/backing-dev.h"
  flags = arch_local_irq_save ( );
# 158 "include/linux/backing-dev.h"
  trace_hardirqs_off ( );
  __inc_bdi_stat ( bdi , item );
  if (({
# 160 "include/linux/backing-dev.h"
    ({
# 160 "include/linux/backing-dev.h"
      long unsigned int __dummy;
# 160 "include/linux/backing-dev.h"
      long unsigned int __dummy2;
# 160 "include/linux/backing-dev.h"
      ( void ) 0;
# 160 "include/linux/backing-dev.h"
      1;
    } );
# 160 "include/linux/backing-dev.h"
    arch_irqs_disabled_flags ( flags );
  } )
# 160 "include/linux/backing-dev.h"
  != 0)
  {
# 160 "include/linux/backing-dev.h"
    ({
# 160 "include/linux/backing-dev.h"
      long unsigned int __dummy;
# 160 "include/linux/backing-dev.h"
      long unsigned int __dummy2;
# 160 "include/linux/backing-dev.h"
      ( void ) 0;
# 160 "include/linux/backing-dev.h"
      1;
    } );
# 160 "include/linux/backing-dev.h"
    arch_local_irq_restore ( flags );
# 160 "include/linux/backing-dev.h"
    trace_hardirqs_off ( );
  }
  else
  {
# 160 "include/linux/backing-dev.h"
    trace_hardirqs_on ( );
# 160 "include/linux/backing-dev.h"
    ({
# 160 "include/linux/backing-dev.h"
      long unsigned int __dummy;
# 160 "include/linux/backing-dev.h"
      long unsigned int __dummy2;
# 160 "include/linux/backing-dev.h"
      ( void ) 0;
# 160 "include/linux/backing-dev.h"
      1;
    } );
# 160 "include/linux/backing-dev.h"
    arch_local_irq_restore ( flags );
  }
}
static inline void __dec_bdi_stat(struct backing_dev_info *bdi, enum bdi_stat_item item)
{
# 166 "include/linux/backing-dev.h"
  __add_bdi_stat ( bdi , item , -1LL );
}
# 169 "include/linux/backing-dev.h"
static inline void dec_bdi_stat(struct backing_dev_info *bdi, enum bdi_stat_item item)
{
# 172 "include/linux/backing-dev.h"
  long unsigned int flags;
# 174 "include/linux/backing-dev.h"
  ({
# 174 "include/linux/backing-dev.h"
    long unsigned int __dummy;
# 174 "include/linux/backing-dev.h"
    long unsigned int __dummy2;
# 174 "include/linux/backing-dev.h"
    ( void ) 0;
# 174 "include/linux/backing-dev.h"
    1;
  } );
# 174 "include/linux/backing-dev.h"
  flags = arch_local_irq_save ( );
# 174 "include/linux/backing-dev.h"
  trace_hardirqs_off ( );
  __dec_bdi_stat ( bdi , item );
  if (({
# 176 "include/linux/backing-dev.h"
    ({
# 176 "include/linux/backing-dev.h"
      long unsigned int __dummy;
# 176 "include/linux/backing-dev.h"
      long unsigned int __dummy2;
# 176 "include/linux/backing-dev.h"
      ( void ) 0;
# 176 "include/linux/backing-dev.h"
      1;
    } );
# 176 "include/linux/backing-dev.h"
    arch_irqs_disabled_flags ( flags );
  } )
# 176 "include/linux/backing-dev.h"
  != 0)
  {
# 176 "include/linux/backing-dev.h"
    ({
# 176 "include/linux/backing-dev.h"
      long unsigned int __dummy;
# 176 "include/linux/backing-dev.h"
      long unsigned int __dummy2;
# 176 "include/linux/backing-dev.h"
      ( void ) 0;
# 176 "include/linux/backing-dev.h"
      1;
    } );
# 176 "include/linux/backing-dev.h"
    arch_local_irq_restore ( flags );
# 176 "include/linux/backing-dev.h"
    trace_hardirqs_off ( );
  }
  else
  {
# 176 "include/linux/backing-dev.h"
    trace_hardirqs_on ( );
# 176 "include/linux/backing-dev.h"
    ({
# 176 "include/linux/backing-dev.h"
      long unsigned int __dummy;
# 176 "include/linux/backing-dev.h"
      long unsigned int __dummy2;
# 176 "include/linux/backing-dev.h"
      ( void ) 0;
# 176 "include/linux/backing-dev.h"
      1;
    } );
# 176 "include/linux/backing-dev.h"
    arch_local_irq_restore ( flags );
  }
}
static inline s64 bdi_stat(struct backing_dev_info *bdi, enum bdi_stat_item item)
{
# 182 "include/linux/backing-dev.h"
  return percpu_counter_read_positive ( ( struct percpu_counter *) & ( * bdi ) . bdi_stat + ( long unsigned int ) item );
}
# 185 "include/linux/backing-dev.h"
static inline s64 __bdi_stat_sum(struct backing_dev_info *bdi, enum bdi_stat_item item)
{
# 188 "include/linux/backing-dev.h"
  return percpu_counter_sum_positive ( ( struct percpu_counter *) & ( * bdi ) . bdi_stat + ( long unsigned int ) item );
}
# 191 "include/linux/backing-dev.h"
static inline s64 bdi_stat_sum(struct backing_dev_info *bdi, enum bdi_stat_item item)
{
# 194 "include/linux/backing-dev.h"
  s64 sum;
  long unsigned int flags;
# 197 "include/linux/backing-dev.h"
  ({
# 197 "include/linux/backing-dev.h"
    long unsigned int __dummy;
# 197 "include/linux/backing-dev.h"
    long unsigned int __dummy2;
# 197 "include/linux/backing-dev.h"
    ( void ) 0;
# 197 "include/linux/backing-dev.h"
    1;
  } );
# 197 "include/linux/backing-dev.h"
  flags = arch_local_irq_save ( );
# 197 "include/linux/backing-dev.h"
  trace_hardirqs_off ( );
  sum = __bdi_stat_sum ( bdi , item );
  if (({
# 199 "include/linux/backing-dev.h"
    ({
# 199 "include/linux/backing-dev.h"
      long unsigned int __dummy;
# 199 "include/linux/backing-dev.h"
      long unsigned int __dummy2;
# 199 "include/linux/backing-dev.h"
      ( void ) 0;
# 199 "include/linux/backing-dev.h"
      1;
    } );
# 199 "include/linux/backing-dev.h"
    arch_irqs_disabled_flags ( flags );
  } )
# 199 "include/linux/backing-dev.h"
  != 0)
  {
# 199 "include/linux/backing-dev.h"
    ({
# 199 "include/linux/backing-dev.h"
      long unsigned int __dummy;
# 199 "include/linux/backing-dev.h"
      long unsigned int __dummy2;
# 199 "include/linux/backing-dev.h"
      ( void ) 0;
# 199 "include/linux/backing-dev.h"
      1;
    } );
# 199 "include/linux/backing-dev.h"
    arch_local_irq_restore ( flags );
# 199 "include/linux/backing-dev.h"
    trace_hardirqs_off ( );
  }
  else
  {
# 199 "include/linux/backing-dev.h"
    trace_hardirqs_on ( );
# 199 "include/linux/backing-dev.h"
    ({
# 199 "include/linux/backing-dev.h"
      long unsigned int __dummy;
# 199 "include/linux/backing-dev.h"
      long unsigned int __dummy2;
# 199 "include/linux/backing-dev.h"
      ( void ) 0;
# 199 "include/linux/backing-dev.h"
      1;
    } );
# 199 "include/linux/backing-dev.h"
    arch_local_irq_restore ( flags );
  }
  return sum;
}
# 204 "include/linux/backing-dev.h"
void bdi_writeout_inc(struct backing_dev_info *);
# 209 "include/linux/backing-dev.h"
static inline long unsigned int bdi_stat_error(struct backing_dev_info *bdi)
{
# 212 "include/linux/backing-dev.h"
  return ( long unsigned int ) ( ( __ilog2_u32 ( ( u32 ) nr_cpu_ids ) + 1 ) * 8 * nr_cpu_ids );
}
# 218 "include/linux/backing-dev.h"
int bdi_set_min_ratio(struct backing_dev_info *, unsigned int);
int bdi_set_max_ratio(struct backing_dev_info *, unsigned int);
# 274 "include/linux/backing-dev.h"
extern struct backing_dev_info default_backing_dev_info;
extern struct backing_dev_info noop_backing_dev_info;
# 277 "include/linux/backing-dev.h"
int writeback_in_progress(struct backing_dev_info *);
# 279 "include/linux/backing-dev.h"
static inline int bdi_congested(struct backing_dev_info *bdi, int bdi_bits)
{
  if (( * bdi ) . congested_fn != ( ( congested_fn *) 0 ))
    return ( * bdi ) . congested_fn ( ( * bdi ) . congested_data , bdi_bits );
  return ( int ) ( ( unsigned int ) ( * bdi ) . state & ( unsigned int ) bdi_bits );
}
# 286 "include/linux/backing-dev.h"
static inline int bdi_read_congested(struct backing_dev_info *bdi)
{
  return bdi_congested ( bdi , 4 );
}
# 291 "include/linux/backing-dev.h"
static inline int bdi_write_congested(struct backing_dev_info *bdi)
{
  return bdi_congested ( bdi , 2 );
}
# 296 "include/linux/backing-dev.h"
static inline int bdi_rw_congested(struct backing_dev_info *bdi)
{
  return bdi_congested ( bdi , 6 );
}
enum ldv_23332
{
  BLK_RW_ASYNC = 0,
  BLK_RW_SYNC = 1
};
# 307 "include/linux/backing-dev.h"
void clear_bdi_congested(struct backing_dev_info *, int);
void set_bdi_congested(struct backing_dev_info *, int);
long int congestion_wait(int, long int);
long int wait_iff_congested(struct zone *, int, long int);
int pdflush_proc_obsolete(struct ctl_table *, int, void *, size_t *, loff_t *);
# 314 "include/linux/backing-dev.h"
static inline bool bdi_cap_stable_pages_required(struct backing_dev_info *bdi)
{
  return ( ( * bdi ) . capabilities & 512U ) != 0U;
}
# 319 "include/linux/backing-dev.h"
static inline bool bdi_cap_writeback_dirty(struct backing_dev_info *bdi)
{
  return ( ( * bdi ) . capabilities & 2U ) == 0U;
}
# 324 "include/linux/backing-dev.h"
static inline bool bdi_cap_account_dirty(struct backing_dev_info *bdi)
{
  return ( ( * bdi ) . capabilities & 1U ) == 0U;
}
# 329 "include/linux/backing-dev.h"
static inline bool bdi_cap_account_writeback(struct backing_dev_info *bdi)
{
# 332 "include/linux/backing-dev.h"
  return ( ( * bdi ) . capabilities & 130U ) == 0U;
}
# 336 "include/linux/backing-dev.h"
static inline bool bdi_cap_swap_backed(struct backing_dev_info *bdi)
{
  return ( ( * bdi ) . capabilities & 256U ) != 0U;
}
# 341 "include/linux/backing-dev.h"
static inline bool mapping_cap_writeback_dirty(struct address_space *mapping)
{
  return bdi_cap_writeback_dirty ( ( * mapping ) . backing_dev_info );
}
# 346 "include/linux/backing-dev.h"
static inline bool mapping_cap_account_dirty(struct address_space *mapping)
{
  return bdi_cap_account_dirty ( ( * mapping ) . backing_dev_info );
}
# 351 "include/linux/backing-dev.h"
static inline bool mapping_cap_swap_backed(struct address_space *mapping)
{
  return bdi_cap_swap_backed ( ( * mapping ) . backing_dev_info );
}
# 356 "include/linux/backing-dev.h"
static inline int bdi_sched_wait(void *word)
{
  schedule ( );
  return 0;
}
# 11 "include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t, void *);
typedef void mempool_free_t(void *, void *);
struct mempool_s
{
  spinlock_t lock;
  int min_nr;
  int curr_nr;
  void **elements;
# 20 "include/linux/mempool.h"
  void *pool_data;
  mempool_alloc_t *alloc;
  mempool_free_t *free;
  wait_queue_head_t wait;
};
# 24 "include/linux/mempool.h"
typedef struct mempool_s mempool_t;
# 26 "include/linux/mempool.h"
mempool_t *mempool_create(int, mempool_alloc_t *, mempool_free_t *, void *);
# 28 "include/linux/mempool.h"
mempool_t *mempool_create_node(int, mempool_alloc_t *, mempool_free_t *, void *, gfp_t, int);
# 32 "include/linux/mempool.h"
int mempool_resize(mempool_t *, int, gfp_t);
void mempool_destroy(mempool_t *);
void *mempool_alloc(mempool_t *, gfp_t);
void mempool_free(void *, mempool_t *);
# 41 "include/linux/mempool.h"
void *mempool_alloc_slab(gfp_t, void *);
void mempool_free_slab(void *, void *);
# 44 "include/linux/mempool.h"
static inline mempool_t *mempool_create_slab_pool(int min_nr, struct kmem_cache *kc)
{
  return mempool_create ( min_nr , ( mempool_alloc_t *) & mempool_alloc_slab , ( mempool_free_t *) & mempool_free_slab ,
# 47 "include/linux/mempool.h"
  ( void *) kc );
}
# 54 "include/linux/mempool.h"
void *mempool_kmalloc(gfp_t, void *);
void mempool_kfree(void *, void *);
static inline mempool_t *mempool_create_kmalloc_pool(int min_nr, size_t size)
{
  return mempool_create ( min_nr , ( mempool_alloc_t *) & mempool_kmalloc , ( mempool_free_t *) & mempool_kfree ,
# 59 "include/linux/mempool.h"
  ( void *) size );
}
# 66 "include/linux/mempool.h"
void *mempool_alloc_pages(gfp_t, void *);
void mempool_free_pages(void *, void *);
static inline mempool_t *mempool_create_page_pool(int min_nr, int order)
{
  return mempool_create ( min_nr , ( mempool_alloc_t *) & mempool_alloc_pages , ( mempool_free_t *) & mempool_free_pages ,
# 71 "include/linux/mempool.h"
  ( void *) ( long int ) order );
}
enum ldv_23400
{
  ICQ_EXITED = 4
};
struct io_cq
{
# 72 "include/linux/iocontext.h"
  struct request_queue *q;
  struct io_context *ioc;
# 84 "include/linux/iocontext.h"
  union
  {
# 82 "include/linux/iocontext.h"
    struct list_head q_node;
    struct kmem_cache *__rcu_icq_cache;
  } ldv_29716;
# 88 "include/linux/iocontext.h"
  union
  {
# 86 "include/linux/iocontext.h"
    struct hlist_node ioc_node;
    struct callback_head __rcu_head;
  } ldv_29720;
# 90 "include/linux/iocontext.h"
  unsigned int flags;
};
struct io_context
{
# 98 "include/linux/iocontext.h"
  atomic_long_t refcount;
  atomic_t active_ref;
  atomic_t nr_tasks;
# 103 "include/linux/iocontext.h"
  spinlock_t lock;
# 105 "include/linux/iocontext.h"
  short unsigned int ioprio;
# 110 "include/linux/iocontext.h"
  int nr_batch_requests;
  long unsigned int last_waited;
# 113 "include/linux/iocontext.h"
  struct radix_tree_root icq_tree;
  struct io_cq *icq_hint;
  struct hlist_head icq_list;
# 117 "include/linux/iocontext.h"
  struct work_struct release_work;
};
# 128 "include/linux/iocontext.h"
static inline void get_io_context_active(struct io_context *ioc)
{
  ({
# 130 "include/linux/iocontext.h"
    bool __warned;
# 130 "include/linux/iocontext.h"
    int __ret_warn_once = atomic_long_read ( & ( * ioc ) . refcount ) <= 0L;
    {
# 130 "include/linux/iocontext.h"
      if (__builtin_expect ( __ret_warn_once != 0 , 0L ) != 0L)
# 130 "include/linux/iocontext.h"
        if (({
# 130 "include/linux/iocontext.h"
          int __ret_warn_on = ( int ) ! ( _Bool ) __warned;
          {
# 130 "include/linux/iocontext.h"
            if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 130 "include/linux/iocontext.h"
              warn_slowpath_null ( ( char const *) "include/linux/iocontext.h" , 130 );
          }
# 130 "include/linux/iocontext.h"
          __builtin_expect ( __ret_warn_on != 0 , 0L );
        } )
# 130 "include/linux/iocontext.h"
        != 0L)
# 130 "include/linux/iocontext.h"
          __warned = 1;
    }
# 130 "include/linux/iocontext.h"
    __builtin_expect ( __ret_warn_once != 0 , 0L );
  } );
# 131 "include/linux/iocontext.h"
  ({
# 131 "include/linux/iocontext.h"
    bool __warned;
# 131 "include/linux/iocontext.h"
    int __ret_warn_once = atomic_read ( ( atomic_t const *) & ( * ioc ) . active_ref ) <= 0;
    {
# 131 "include/linux/iocontext.h"
      if (__builtin_expect ( __ret_warn_once != 0 , 0L ) != 0L)
# 131 "include/linux/iocontext.h"
        if (({
# 131 "include/linux/iocontext.h"
          int __ret_warn_on = ( int ) ! ( _Bool ) __warned;
          {
# 131 "include/linux/iocontext.h"
            if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 131 "include/linux/iocontext.h"
              warn_slowpath_null ( ( char const *) "include/linux/iocontext.h" , 131 );
          }
# 131 "include/linux/iocontext.h"
          __builtin_expect ( __ret_warn_on != 0 , 0L );
        } )
# 131 "include/linux/iocontext.h"
        != 0L)
# 131 "include/linux/iocontext.h"
          __warned = 1;
    }
# 131 "include/linux/iocontext.h"
    __builtin_expect ( __ret_warn_once != 0 , 0L );
  } );
# 132 "include/linux/iocontext.h"
  atomic_long_inc ( & ( * ioc ) . refcount );
  atomic_inc ( & ( * ioc ) . active_ref );
}
# 136 "include/linux/iocontext.h"
static inline void ioc_task_link(struct io_context *ioc)
{
  get_io_context_active ( ioc );
# 140 "include/linux/iocontext.h"
  ({
# 140 "include/linux/iocontext.h"
    bool __warned;
# 140 "include/linux/iocontext.h"
    int __ret_warn_once = atomic_read ( ( atomic_t const *) & ( * ioc ) . nr_tasks ) <= 0;
    {
# 140 "include/linux/iocontext.h"
      if (__builtin_expect ( __ret_warn_once != 0 , 0L ) != 0L)
# 140 "include/linux/iocontext.h"
        if (({
# 140 "include/linux/iocontext.h"
          int __ret_warn_on = ( int ) ! ( _Bool ) __warned;
          {
# 140 "include/linux/iocontext.h"
            if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 140 "include/linux/iocontext.h"
              warn_slowpath_null ( ( char const *) "include/linux/iocontext.h" , 140 );
          }
# 140 "include/linux/iocontext.h"
          __builtin_expect ( __ret_warn_on != 0 , 0L );
        } )
# 140 "include/linux/iocontext.h"
        != 0L)
# 140 "include/linux/iocontext.h"
          __warned = 1;
    }
# 140 "include/linux/iocontext.h"
    __builtin_expect ( __ret_warn_once != 0 , 0L );
  } );
# 141 "include/linux/iocontext.h"
  atomic_inc ( & ( * ioc ) . nr_tasks );
}
# 146 "include/linux/iocontext.h"
void put_io_context(struct io_context *);
void put_io_context_active(struct io_context *);
void exit_io_context(struct task_struct *);
struct io_context *get_task_io_context(struct task_struct *, gfp_t, int);
enum ldv_23425
{
  IOPRIO_CLASS_NONE = 0,
  IOPRIO_CLASS_RT = 1,
  IOPRIO_CLASS_BE = 2,
  IOPRIO_CLASS_IDLE = 3
};
enum ldv_23426
{
  IOPRIO_WHO_PROCESS = 1,
  IOPRIO_WHO_PGRP = 2,
  IOPRIO_WHO_USER = 3
};
# 53 "include/linux/ioprio.h"
static inline int task_nice_ioprio(struct task_struct *task)
{
  return ( task_nice ( ( struct task_struct const *) task ) + 20 ) / 5;
}
# 62 "include/linux/ioprio.h"
static inline int task_nice_ioclass(struct task_struct *task)
{
  if (( * task ) . policy == 5U)
  {
# 65 "include/linux/ioprio.h"
    return 3;
  }
  else
# 66 "include/linux/ioprio.h"
    if (( * task ) . policy == 1U || ( * task ) . policy == 2U)
    {
# 67 "include/linux/ioprio.h"
      return 1;
    }
    else
# 69 "include/linux/ioprio.h"
      return 2;
}
# 75 "include/linux/ioprio.h"
int ioprio_best(short unsigned int, short unsigned int);
# 77 "include/linux/ioprio.h"
int set_task_ioprio(struct task_struct *, int);
# 105 "include/linux/bio.h"
static inline bool bio_has_data(struct bio *bio)
{
  if (bio != ( ( struct bio *) 0 ) && (
# 108 "include/linux/bio.h"
  * bio ) . bi_iter . bi_size
# 107 "include/linux/bio.h"
  != 0U
# 108 "include/linux/bio.h"
  && ( ( long long unsigned int ) (
# 109 "include/linux/bio.h"
  * bio ) . bi_rw & 128ULL ) == 0ULL)
    return 1;
# 112 "include/linux/bio.h"
  return 0;
}
# 115 "include/linux/bio.h"
static inline bool bio_is_rw(struct bio *bio)
{
  if (( int ) ! ( _Bool ) bio_has_data ( bio ))
    return 0;
# 120 "include/linux/bio.h"
  if (( ( long long unsigned int ) ( * bio ) . bi_rw & 640ULL ) != 0ULL)
    return 0;
# 123 "include/linux/bio.h"
  return 1;
}
# 126 "include/linux/bio.h"
static inline bool bio_mergeable(struct bio *bio)
{
  if (( ( long long unsigned int ) ( * bio ) . bi_rw & 464896ULL ) != 0ULL)
    return 0;
# 131 "include/linux/bio.h"
  return 1;
}
# 134 "include/linux/bio.h"
static inline unsigned int bio_cur_bytes(struct bio *bio)
{
  if (( int ) bio_has_data ( bio ))
  {
# 137 "include/linux/bio.h"
    return ( struct bio_vec ) { . bv_page = ( * ( ( * bio ) . bi_io_vec + ( long unsigned int ) ( * bio ) . bi_iter . bi_idx ) ) . bv_page , . bv_len = ({
# 137 "include/linux/bio.h"
      unsigned int _min1 = ( * bio ) . bi_iter . bi_size;
# 137 "include/linux/bio.h"
      unsigned int _min2 = ( * ( ( * bio ) . bi_io_vec + ( long unsigned int ) ( * bio ) . bi_iter . bi_idx ) ) . bv_len - ( * bio ) . bi_iter . bi_bvec_done;
# 137 "include/linux/bio.h"
      ( void ) 0;
# 137 "include/linux/bio.h"
      ((_min1) < (_min2) ? (_min1) : (_min2));
    } ) , . bv_offset = (
# 137 "include/linux/bio.h"
    * ( ( * bio ) . bi_io_vec + ( long unsigned int ) ( * bio ) . bi_iter . bi_idx ) ) . bv_offset + ( * bio ) . bi_iter . bi_bvec_done } . bv_len;
  }
  else
# 139 "include/linux/bio.h"
    return ( * bio ) . bi_iter . bi_size;
}
# 142 "include/linux/bio.h"
static inline void *bio_data(struct bio *bio)
{
  if (( int ) bio_has_data ( bio ))
    return lowmem_page_address ( ( struct page const *) ( * ( ( * bio ) . bi_io_vec + ( long unsigned int ) ( * bio ) . bi_iter . bi_idx ) ) . bv_page ) + ( long unsigned int ) ( ( * ( ( * bio ) . bi_io_vec + ( long unsigned int ) ( * bio ) . bi_iter . bi_idx ) ) . bv_offset + ( * bio ) . bi_iter . bi_bvec_done );
# 147 "include/linux/bio.h"
  return ( ( void *) 0 );
}
# 193 "include/linux/bio.h"
static inline bool bvec_gap_to_prev(struct bio_vec *bprv, unsigned int offset)
{
  return ( bool ) ( offset != 0U || ( ( long unsigned int ) ( ( * bprv ) . bv_offset + ( * bprv ) . bv_len ) & 4095UL ) != 0UL );
}
# 207 "include/linux/bio.h"
static inline void bvec_iter_advance(struct bio_vec *bv, struct bvec_iter *iter, unsigned int bytes)
{
# 210 "include/linux/bio.h"
  ({
# 210 "include/linux/bio.h"
    bool __warned;
# 210 "include/linux/bio.h"
    int __ret_warn_once = ( * iter ) . bi_size < bytes;
    {
# 210 "include/linux/bio.h"
      if (__builtin_expect ( __ret_warn_once != 0 , 0L ) != 0L)
# 210 "include/linux/bio.h"
        if (({
# 210 "include/linux/bio.h"
          int __ret_warn_on = ( int ) ! ( _Bool ) __warned;
          {
# 210 "include/linux/bio.h"
            if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 210 "include/linux/bio.h"
              warn_slowpath_fmt (
# 211 "include/linux/bio.h"
              ( char const *) "include/linux/bio.h" , 211 ,
# 210 "include/linux/bio.h"
              ( char const *) "Attempted to advance past end of bvec iter\n" );
          }
# 210 "include/linux/bio.h"
          __builtin_expect ( __ret_warn_on != 0 , 0L );
        } )
# 210 "include/linux/bio.h"
        != 0L)
# 210 "include/linux/bio.h"
          __warned = 1;
    }
# 210 "include/linux/bio.h"
    __builtin_expect ( __ret_warn_once != 0 , 0L );
  } );
# 213 "include/linux/bio.h"
  goto ldv_29829;
  ldv_29828:;
  {
# 214 "include/linux/bio.h"
    unsigned int len = ({
# 214 "include/linux/bio.h"
      unsigned int _min1 = bytes;
# 214 "include/linux/bio.h"
      unsigned int _min2 = ({
# 214 "include/linux/bio.h"
        unsigned int _min1 = ( * iter ) . bi_size;
# 214 "include/linux/bio.h"
        unsigned int _min2 = ( * ( bv + ( long unsigned int ) ( * iter ) . bi_idx ) ) . bv_len - ( * iter ) . bi_bvec_done;
# 214 "include/linux/bio.h"
        ( void ) 0;
# 214 "include/linux/bio.h"
        ((_min1) < (_min2) ? (_min1) : (_min2));
      } );
# 214 "include/linux/bio.h"
      ( void ) 0;
# 214 "include/linux/bio.h"
      ((_min1) < (_min2) ? (_min1) : (_min2));
    } );
    bytes -= len;
    ( * iter ) . bi_size -= len;
    ( * iter ) . bi_bvec_done += len;
# 220 "include/linux/bio.h"
    if (( * iter ) . bi_bvec_done == ( * ( bv + ( long unsigned int ) ( * iter ) . bi_idx ) ) . bv_len)
    {
# 221 "include/linux/bio.h"
      ( * iter ) . bi_bvec_done = 0U;
      ( * iter ) . bi_idx ++;
    }
  }
  ldv_29829:;
# 213 "include/linux/bio.h"
  if (bytes != 0U)
  {
    goto ldv_29828;
  }
  else
    goto ldv_29830;
  ldv_29830:;
}
# 234 "include/linux/bio.h"
static inline void bio_advance_iter(struct bio *bio, struct bvec_iter *iter, unsigned int bytes)
{
# 237 "include/linux/bio.h"
  ( * iter ) . bi_sector += ( sector_t ) ( bytes >> 9 );
# 239 "include/linux/bio.h"
  if (( ( long long unsigned int ) ( * bio ) . bi_rw & 640ULL ) != 0ULL)
  {
# 240 "include/linux/bio.h"
    ( * iter ) . bi_size -= bytes;
  }
  else
# 242 "include/linux/bio.h"
    bvec_iter_advance ( ( * bio ) . bi_io_vec , iter , bytes );
}
# 256 "include/linux/bio.h"
static inline unsigned int bio_segments(struct bio *bio)
{
  unsigned int segs = 0U;
  struct bio_vec bv;
  struct bvec_iter iter;
# 267 "include/linux/bio.h"
  if (( ( long long unsigned int ) ( * bio ) . bi_rw & 128ULL ) != 0ULL)
    return 1U;
# 270 "include/linux/bio.h"
  if (( ( long long unsigned int ) ( * bio ) . bi_rw & 512ULL ) != 0ULL)
    return 1U;
# 273 "include/linux/bio.h"
  iter = ( * bio ) . bi_iter;
# 273 "include/linux/bio.h"
  goto ldv_29847;
  ldv_29846:;
# 274 "include/linux/bio.h"
  segs ++;
# 273 "include/linux/bio.h"
  bio_advance_iter ( bio , & iter , bv . bv_len );
  ldv_29847:;
# 273 "include/linux/bio.h"
  if (iter . bi_size != 0U && ( bv = ( struct bio_vec ) { . bv_page = ( * ( ( * bio ) . bi_io_vec + ( long unsigned int ) iter . bi_idx ) ) . bv_page , . bv_len = ({
# 273 "include/linux/bio.h"
    unsigned int _min1 = iter . bi_size;
# 273 "include/linux/bio.h"
    unsigned int _min2 = ( * ( ( * bio ) . bi_io_vec + ( long unsigned int ) iter . bi_idx ) ) . bv_len - iter . bi_bvec_done;
# 273 "include/linux/bio.h"
    ( void ) 0;
# 273 "include/linux/bio.h"
    ((_min1) < (_min2) ? (_min1) : (_min2));
  } ) , . bv_offset = (
# 273 "include/linux/bio.h"
  * ( ( * bio ) . bi_io_vec + ( long unsigned int ) iter . bi_idx ) ) . bv_offset + iter . bi_bvec_done }, 1 ))
  {
    goto ldv_29846;
  }
  else
    goto ldv_29848;
  ldv_29848:;
# 276 "include/linux/bio.h"
  return segs;
}
struct bio_integrity_payload
{
# 300 "include/linux/bio.h"
  struct bio *bip_bio;
# 302 "include/linux/bio.h"
  struct bvec_iter bip_iter;
# 305 "include/linux/bio.h"
  void *bip_buf;
# 307 "include/linux/bio.h"
  bio_end_io_t *bip_end_io;
# 309 "include/linux/bio.h"
  short unsigned int bip_slab;
  short unsigned int bip_vcnt;
  short unsigned int bip_max_vcnt;
  unsigned char bip_owns_buf : 1;
# 314 "include/linux/bio.h"
  struct work_struct bip_work;
# 316 "include/linux/bio.h"
  struct bio_vec *bip_vec;
  struct bio_vec bip_inline_vecs[0U];
};
# 321 "include/linux/bio.h"
void bio_trim(struct bio *, int, int);
struct bio *bio_split(struct bio *, int, gfp_t, struct bio_set *);
# 335 "include/linux/bio.h"
static inline struct bio *bio_next_split(struct bio *bio, int sectors, gfp_t gfp, struct bio_set *bs)
{
# 338 "include/linux/bio.h"
  if (( unsigned int ) sectors >= ( * bio ) . bi_iter . bi_size >> 9)
    return bio;
# 341 "include/linux/bio.h"
  return bio_split ( bio , sectors , gfp , bs );
}
# 344 "include/linux/bio.h"
struct bio_set *bioset_create(unsigned int, unsigned int);
void bioset_free(struct bio_set *);
mempool_t *biovec_create_pool(int);
# 348 "include/linux/bio.h"
struct bio *bio_alloc_bioset(gfp_t, int, struct bio_set *);
void bio_put(struct bio *);
# 351 "include/linux/bio.h"
void __bio_clone_fast(struct bio *, struct bio *);
struct bio *bio_clone_fast(struct bio *, gfp_t, struct bio_set *);
struct bio *bio_clone_bioset(struct bio *, gfp_t, struct bio_set *);
# 355 "include/linux/bio.h"
extern struct bio_set *fs_bio_set;
unsigned int bio_integrity_tag_size(struct bio *);
# 358 "include/linux/bio.h"
static inline struct bio *bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)
{
  return bio_alloc_bioset ( gfp_mask , ( int ) nr_iovecs , fs_bio_set );
}
# 363 "include/linux/bio.h"
static inline struct bio *bio_clone(struct bio *bio, gfp_t gfp_mask)
{
  return bio_clone_bioset ( bio , gfp_mask , fs_bio_set );
}
# 368 "include/linux/bio.h"
static inline struct bio *bio_kmalloc(gfp_t gfp_mask, unsigned int nr_iovecs)
{
  return bio_alloc_bioset ( gfp_mask , ( int ) nr_iovecs , ( ( struct bio_set *) 0 ) );
}
# 373 "include/linux/bio.h"
static inline struct bio *bio_clone_kmalloc(struct bio *bio, gfp_t gfp_mask)
{
  return bio_clone_bioset ( bio , gfp_mask , ( ( struct bio_set *) 0 ) );
}
# 379 "include/linux/bio.h"
void bio_endio(struct bio *, int);
void bio_endio_nodec(struct bio *, int);
# 382 "include/linux/bio.h"
int bio_phys_segments(struct request_queue *, struct bio *);
# 384 "include/linux/bio.h"
int submit_bio_wait(int, struct bio *);
void bio_advance(struct bio *, unsigned int);
# 387 "include/linux/bio.h"
void bio_init(struct bio *);
void bio_reset(struct bio *);
void bio_chain(struct bio *, struct bio *);
# 391 "include/linux/bio.h"
int bio_add_page(struct bio *, struct page *, unsigned int, unsigned int);
int bio_add_pc_page(struct request_queue *, struct bio *, struct page *, unsigned int, unsigned int);
# 394 "include/linux/bio.h"
int bio_get_nr_vecs(struct block_device *);
struct bio *bio_map_user(struct request_queue *, struct block_device *, long unsigned int, unsigned int, int, gfp_t);
struct sg_iovec;
struct rq_map_data;
# 399 "include/linux/bio.h"
struct bio *bio_map_user_iov(struct request_queue *, struct block_device *, struct sg_iovec const *, int, int, gfp_t);
# 402 "include/linux/bio.h"
void bio_unmap_user(struct bio *);
struct bio *bio_map_kern(struct request_queue *, void *, unsigned int, gfp_t);
# 405 "include/linux/bio.h"
struct bio *bio_copy_kern(struct request_queue *, void *, unsigned int, gfp_t, int);
# 407 "include/linux/bio.h"
void bio_set_pages_dirty(struct bio *);
void bio_check_pages_dirty(struct bio *);
# 416 "include/linux/bio.h"
static inline void bio_flush_dcache_pages(struct bio *bi)
{
}
# 421 "include/linux/bio.h"
void bio_copy_data(struct bio *, struct bio *);
int bio_alloc_pages(struct bio *, gfp_t);
# 424 "include/linux/bio.h"
struct bio *bio_copy_user(struct request_queue *, struct rq_map_data *, long unsigned int, unsigned int, int, gfp_t);
# 426 "include/linux/bio.h"
struct bio *bio_copy_user_iov(struct request_queue *, struct rq_map_data *, struct sg_iovec const *, int, int, gfp_t);
# 430 "include/linux/bio.h"
int bio_uncopy_user(struct bio *);
void zero_fill_bio(struct bio *);
struct bio_vec *bvec_alloc(gfp_t, int, long unsigned int *, mempool_t *);
void bvec_free(mempool_t *, struct bio_vec *, unsigned int);
unsigned int bvec_nr_vecs(short unsigned int);
# 437 "include/linux/bio.h"
int bio_associate_current(struct bio *);
void bio_disassociate_task(struct bio *);
# 474 "include/linux/bio.h"
static inline char *bvec_kmap_irq(struct bio_vec *bvec, long unsigned int *flags)
{
  return ( char *) lowmem_page_address ( ( struct page const *) ( * bvec ) . bv_page ) + ( long unsigned int ) ( * bvec ) . bv_offset;
}
# 479 "include/linux/bio.h"
static inline void bvec_kunmap_irq(char *buffer, long unsigned int *flags)
{
  * flags = 0UL;
}
# 485 "include/linux/bio.h"
static inline char *__bio_kmap_irq(struct bio *bio, struct bvec_iter iter, long unsigned int *flags)
{
# 488 "include/linux/bio.h"
  return bvec_kmap_irq ( & ( struct bio_vec ) { . bv_page = ( * ( ( * bio ) . bi_io_vec + ( long unsigned int ) iter . bi_idx ) ) . bv_page , . bv_len = ({
# 488 "include/linux/bio.h"
    unsigned int _min1 = iter . bi_size;
# 488 "include/linux/bio.h"
    unsigned int _min2 = ( * ( ( * bio ) . bi_io_vec + ( long unsigned int ) iter . bi_idx ) ) . bv_len - iter . bi_bvec_done;
# 488 "include/linux/bio.h"
    ( void ) 0;
# 488 "include/linux/bio.h"
    ((_min1) < (_min2) ? (_min1) : (_min2));
  } ) , . bv_offset = (
# 488 "include/linux/bio.h"
  * ( ( * bio ) . bi_io_vec + ( long unsigned int ) iter . bi_idx ) ) . bv_offset + iter . bi_bvec_done } , flags );
}
struct bio_list
{
# 504 "include/linux/bio.h"
  struct bio *head;
  struct bio *tail;
};
# 508 "include/linux/bio.h"
static inline int bio_list_empty(struct bio_list const *bl)
{
  return ( * bl ) . head == ( ( struct bio *const ) 0 );
}
# 513 "include/linux/bio.h"
static inline void bio_list_init(struct bio_list *bl)
{
  ( * bl ) . head = ( * bl ) . tail = ( ( struct bio *) 0 );
}
# 523 "include/linux/bio.h"
static inline unsigned int bio_list_size(struct bio_list const *bl)
{
  unsigned int sz = 0U;
  struct bio *bio;
# 528 "include/linux/bio.h"
  bio = ( * bl ) . head;
# 528 "include/linux/bio.h"
  goto ldv_30059;
  ldv_30058:;
# 529 "include/linux/bio.h"
  sz ++;
# 528 "include/linux/bio.h"
  bio = ( * bio ) . bi_next;
  ldv_30059:;
# 528 "include/linux/bio.h"
  if (bio != ( ( struct bio *) 0 ))
  {
    goto ldv_30058;
  }
  else
    goto ldv_30060;
  ldv_30060:;
# 531 "include/linux/bio.h"
  return sz;
}
# 534 "include/linux/bio.h"
static inline void bio_list_add(struct bio_list *bl, struct bio *bio)
{
  ( * bio ) . bi_next = ( ( struct bio *) 0 );
# 538 "include/linux/bio.h"
  if (( * bl ) . tail != ( ( struct bio *) 0 ))
  {
# 539 "include/linux/bio.h"
    ( * ( * bl ) . tail ) . bi_next = bio;
  }
  else
# 541 "include/linux/bio.h"
    ( * bl ) . head = bio;
# 543 "include/linux/bio.h"
  ( * bl ) . tail = bio;
}
# 546 "include/linux/bio.h"
static inline void bio_list_add_head(struct bio_list *bl, struct bio *bio)
{
  ( * bio ) . bi_next = ( * bl ) . head;
# 550 "include/linux/bio.h"
  ( * bl ) . head = bio;
# 552 "include/linux/bio.h"
  if (( * bl ) . tail == ( ( struct bio *) 0 ))
    ( * bl ) . tail = bio;
}
# 556 "include/linux/bio.h"
static inline void bio_list_merge(struct bio_list *bl, struct bio_list *bl2)
{
  if (( * bl2 ) . head == ( ( struct bio *) 0 ))
    return;
# 561 "include/linux/bio.h"
  if (( * bl ) . tail != ( ( struct bio *) 0 ))
  {
# 562 "include/linux/bio.h"
    ( * ( * bl ) . tail ) . bi_next = ( * bl2 ) . head;
  }
  else
# 564 "include/linux/bio.h"
    ( * bl ) . head = ( * bl2 ) . head;
# 566 "include/linux/bio.h"
  ( * bl ) . tail = ( * bl2 ) . tail;
}
# 569 "include/linux/bio.h"
static inline void bio_list_merge_head(struct bio_list *bl, struct bio_list *bl2)
{
# 572 "include/linux/bio.h"
  if (( * bl2 ) . head == ( ( struct bio *) 0 ))
    return;
# 575 "include/linux/bio.h"
  if (( * bl ) . head != ( ( struct bio *) 0 ))
  {
# 576 "include/linux/bio.h"
    ( * ( * bl2 ) . tail ) . bi_next = ( * bl ) . head;
  }
  else
# 578 "include/linux/bio.h"
    ( * bl ) . tail = ( * bl2 ) . tail;
# 580 "include/linux/bio.h"
  ( * bl ) . head = ( * bl2 ) . head;
}
# 583 "include/linux/bio.h"
static inline struct bio *bio_list_peek(struct bio_list *bl)
{
  return ( * bl ) . head;
}
# 588 "include/linux/bio.h"
static inline struct bio *bio_list_pop(struct bio_list *bl)
{
  struct bio *bio = ( * bl ) . head;
# 592 "include/linux/bio.h"
  if (bio != ( ( struct bio *) 0 ))
  {
# 593 "include/linux/bio.h"
    ( * bl ) . head = ( * ( * bl ) . head ) . bi_next;
    if (( * bl ) . head == ( ( struct bio *) 0 ))
      ( * bl ) . tail = ( ( struct bio *) 0 );
# 597 "include/linux/bio.h"
    ( * bio ) . bi_next = ( ( struct bio *) 0 );
  }
# 600 "include/linux/bio.h"
  return bio;
}
# 603 "include/linux/bio.h"
static inline struct bio *bio_list_get(struct bio_list *bl)
{
  struct bio *bio = ( * bl ) . head;
# 607 "include/linux/bio.h"
  ( * bl ) . head = ( * bl ) . tail = ( ( struct bio *) 0 );
# 609 "include/linux/bio.h"
  return bio;
}
struct bio_set
{
# 623 "include/linux/bio.h"
  struct kmem_cache *bio_slab;
  unsigned int front_pad;
# 626 "include/linux/bio.h"
  mempool_t *bio_pool;
  mempool_t *bvec_pool;
# 629 "include/linux/bio.h"
  mempool_t *bio_integrity_pool;
  mempool_t *bvec_integrity_pool;
# 637 "include/linux/bio.h"
  spinlock_t rescue_lock;
  struct bio_list rescue_list;
  struct work_struct rescue_work;
  struct workqueue_struct *rescue_workqueue;
};
struct biovec_slab
{
  int nr_vecs;
  char *name;
  struct kmem_cache *slab;
};
# 666 "include/linux/bio.h"
struct bio_integrity_payload *bio_integrity_alloc(struct bio *, gfp_t, unsigned int);
void bio_integrity_free(struct bio *);
int bio_integrity_add_page(struct bio *, struct page *, unsigned int, unsigned int);
int bio_integrity_enabled(struct bio *);
int bio_integrity_set_tag(struct bio *, void *, unsigned int);
int bio_integrity_get_tag(struct bio *, void *, unsigned int);
int bio_integrity_prep(struct bio *);
void bio_integrity_endio(struct bio *, int);
void bio_integrity_advance(struct bio *, unsigned int);
void bio_integrity_trim(struct bio *, unsigned int, unsigned int);
int bio_integrity_clone(struct bio *, struct bio *, gfp_t);
int bioset_integrity_create(struct bio_set *, int);
void bioset_integrity_free(struct bio_set *);
void bio_integrity_init(void);
struct sg_io_v4
{
# 22 "include/uapi/linux/bsg.h"
  __s32 guard;
  __u32 protocol;
  __u32 subprotocol;
# 27 "include/uapi/linux/bsg.h"
  __u32 request_len;
  __u64 request;
  __u64 request_tag;
  __u32 request_attr;
  __u32 request_priority;
  __u32 request_extra;
  __u32 max_response_len;
  __u64 response;
# 37 "include/uapi/linux/bsg.h"
  __u32 dout_iovec_count;
# 39 "include/uapi/linux/bsg.h"
  __u32 dout_xfer_len;
  __u32 din_iovec_count;
  __u32 din_xfer_len;
  __u64 dout_xferp;
  __u64 din_xferp;
# 45 "include/uapi/linux/bsg.h"
  __u32 timeout;
  __u32 flags;
  __u64 usr_ptr;
  __u32 spare_in;
# 50 "include/uapi/linux/bsg.h"
  __u32 driver_status;
  __u32 transport_status;
  __u32 device_status;
  __u32 retry_delay;
  __u32 info;
  __u32 duration;
  __u32 response_len;
  __s32 din_resid;
  __s32 dout_resid;
  __u64 generated_tag;
  __u32 spare_out;
# 62 "include/uapi/linux/bsg.h"
  __u32 padding;
};
struct bsg_class_device
{
# 9 "include/linux/bsg.h"
  struct device *class_dev;
  struct device *parent;
  int minor;
  struct request_queue *queue;
  struct kref ref;
  void (*release)(struct device *);
};
# 17 "include/linux/bsg.h"
int bsg_register_queue(struct request_queue *, struct device *, char const *, void (*)(struct device *));
# 20 "include/linux/bsg.h"
void bsg_unregister_queue(struct request_queue *);
struct percpu_ref;
# 54 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);
struct percpu_ref
{
  atomic_t count;
# 62 "include/linux/percpu-refcount.h"
  long unsigned int pcpu_count_ptr;
  percpu_ref_func_t *release;
  percpu_ref_func_t *confirm_kill;
  struct callback_head rcu;
};
# 68 "include/linux/percpu-refcount.h"
int percpu_ref_init(struct percpu_ref *, percpu_ref_func_t *);
# 70 "include/linux/percpu-refcount.h"
void percpu_ref_reinit(struct percpu_ref *);
void percpu_ref_exit(struct percpu_ref *);
void percpu_ref_kill_and_confirm(struct percpu_ref *, percpu_ref_func_t *);
# 85 "include/linux/percpu-refcount.h"
static inline void percpu_ref_kill(struct percpu_ref *ref)
{
  return & percpu_ref_kill_and_confirm;
}
# 98 "include/linux/percpu-refcount.h"
static inline bool __pcpu_ref_alive(struct percpu_ref *ref, unsigned int **pcpu_countp)
{
# 101 "include/linux/percpu-refcount.h"
  long unsigned int pcpu_ptr = * ( long unsigned int volatile *) & ( * ref ) . pcpu_count_ptr;
# 106 "include/linux/percpu-refcount.h"
  if (__builtin_expect ( ( long int ) ( int ) pcpu_ptr & 1L , 0L ) != 0L)
    return 0;
# 109 "include/linux/percpu-refcount.h"
  * pcpu_countp = ( unsigned int *) pcpu_ptr;
  return 1;
}
# 119 "include/linux/percpu-refcount.h"
static inline void percpu_ref_get(struct percpu_ref *ref)
{
  unsigned int *pcpu_count;
# 123 "include/linux/percpu-refcount.h"
  rcu_read_lock_sched ( );
# 125 "include/linux/percpu-refcount.h"
  if (( int ) __pcpu_ref_alive ( ref , & pcpu_count ))
  {
    {
# 126 "include/linux/percpu-refcount.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 126 "include/linux/percpu-refcount.h"
      ( void ) __vpp_verify;
    }
# 126 "include/linux/percpu-refcount.h"
    switch (4UL)
    {
# 126 "include/linux/percpu-refcount.h"
      case 1:;
      {
# 126 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 126 "include/linux/percpu-refcount.h"
        int const pao_ID__ = 1;
# 126 "include/linux/percpu-refcount.h"
        if (0)
        {
# 126 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 126 "include/linux/percpu-refcount.h"
          pao_tmp__ = 1U;
# 126 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 126 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 126 "include/linux/percpu-refcount.h"
          case 1:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30232;
# 126 "include/linux/percpu-refcount.h"
          case 2:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30232;
# 126 "include/linux/percpu-refcount.h"
          case 4:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30232;
# 126 "include/linux/percpu-refcount.h"
          case 8:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30232;
# 126 "include/linux/percpu-refcount.h"
          default:;
# 126 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 126 "include/linux/percpu-refcount.h"
        ldv_30232:;
      }
# 126 "include/linux/percpu-refcount.h"
      goto ldv_30237;
# 126 "include/linux/percpu-refcount.h"
      case 2:;
      {
# 126 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 126 "include/linux/percpu-refcount.h"
        int const pao_ID__ = 1;
# 126 "include/linux/percpu-refcount.h"
        if (0)
        {
# 126 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 126 "include/linux/percpu-refcount.h"
          pao_tmp__ = 1U;
# 126 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 126 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 126 "include/linux/percpu-refcount.h"
          case 1:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30243;
# 126 "include/linux/percpu-refcount.h"
          case 2:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30243;
# 126 "include/linux/percpu-refcount.h"
          case 4:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30243;
# 126 "include/linux/percpu-refcount.h"
          case 8:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30243;
# 126 "include/linux/percpu-refcount.h"
          default:;
# 126 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 126 "include/linux/percpu-refcount.h"
        ldv_30243:;
      }
# 126 "include/linux/percpu-refcount.h"
      goto ldv_30237;
# 126 "include/linux/percpu-refcount.h"
      case 4:;
      {
# 126 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 126 "include/linux/percpu-refcount.h"
        int const pao_ID__ = 1;
# 126 "include/linux/percpu-refcount.h"
        if (0)
        {
# 126 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 126 "include/linux/percpu-refcount.h"
          pao_tmp__ = 1U;
# 126 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 126 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 126 "include/linux/percpu-refcount.h"
          case 1:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30253;
# 126 "include/linux/percpu-refcount.h"
          case 2:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30253;
# 126 "include/linux/percpu-refcount.h"
          case 4:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30253;
# 126 "include/linux/percpu-refcount.h"
          case 8:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30253;
# 126 "include/linux/percpu-refcount.h"
          default:;
# 126 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 126 "include/linux/percpu-refcount.h"
        ldv_30253:;
      }
# 126 "include/linux/percpu-refcount.h"
      goto ldv_30237;
# 126 "include/linux/percpu-refcount.h"
      case 8:;
      {
# 126 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 126 "include/linux/percpu-refcount.h"
        int const pao_ID__ = 1;
# 126 "include/linux/percpu-refcount.h"
        if (0)
        {
# 126 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 126 "include/linux/percpu-refcount.h"
          pao_tmp__ = 1U;
# 126 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 126 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 126 "include/linux/percpu-refcount.h"
          case 1:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30263;
# 126 "include/linux/percpu-refcount.h"
          case 2:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30263;
# 126 "include/linux/percpu-refcount.h"
          case 4:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30263;
# 126 "include/linux/percpu-refcount.h"
          case 8:;
# 126 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 126 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 126 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 126 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 126 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 1U ) ) ;
# 126 "include/linux/percpu-refcount.h"
          goto ldv_30263;
# 126 "include/linux/percpu-refcount.h"
          default:;
# 126 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 126 "include/linux/percpu-refcount.h"
        ldv_30263:;
      }
# 126 "include/linux/percpu-refcount.h"
      goto ldv_30237;
# 126 "include/linux/percpu-refcount.h"
      default:;
# 126 "include/linux/percpu-refcount.h"
      __bad_size_call_parameter ( );
# 126 "include/linux/percpu-refcount.h"
      goto ldv_30237;
    }
# 126 "include/linux/percpu-refcount.h"
    ldv_30237:;
  }
  else
# 128 "include/linux/percpu-refcount.h"
    atomic_inc ( & ( * ref ) . count );
# 130 "include/linux/percpu-refcount.h"
  rcu_read_unlock_sched ( );
}
# 142 "include/linux/percpu-refcount.h"
static inline bool percpu_ref_tryget(struct percpu_ref *ref)
{
  unsigned int *pcpu_count;
  int ret = 0;
# 147 "include/linux/percpu-refcount.h"
  rcu_read_lock_sched ( );
# 149 "include/linux/percpu-refcount.h"
  if (( int ) __pcpu_ref_alive ( ref , & pcpu_count ))
  {
    {
# 150 "include/linux/percpu-refcount.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 150 "include/linux/percpu-refcount.h"
      ( void ) __vpp_verify;
    }
# 150 "include/linux/percpu-refcount.h"
    switch (4UL)
    {
# 150 "include/linux/percpu-refcount.h"
      case 1:;
      {
# 150 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 150 "include/linux/percpu-refcount.h"
        int const pao_ID__ = 1;
# 150 "include/linux/percpu-refcount.h"
        if (0)
        {
# 150 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 150 "include/linux/percpu-refcount.h"
          pao_tmp__ = 1U;
# 150 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 150 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 150 "include/linux/percpu-refcount.h"
          case 1:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30280;
# 150 "include/linux/percpu-refcount.h"
          case 2:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30280;
# 150 "include/linux/percpu-refcount.h"
          case 4:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30280;
# 150 "include/linux/percpu-refcount.h"
          case 8:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30280;
# 150 "include/linux/percpu-refcount.h"
          default:;
# 150 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 150 "include/linux/percpu-refcount.h"
        ldv_30280:;
      }
# 150 "include/linux/percpu-refcount.h"
      goto ldv_30285;
# 150 "include/linux/percpu-refcount.h"
      case 2:;
      {
# 150 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 150 "include/linux/percpu-refcount.h"
        int const pao_ID__ = 1;
# 150 "include/linux/percpu-refcount.h"
        if (0)
        {
# 150 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 150 "include/linux/percpu-refcount.h"
          pao_tmp__ = 1U;
# 150 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 150 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 150 "include/linux/percpu-refcount.h"
          case 1:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30291;
# 150 "include/linux/percpu-refcount.h"
          case 2:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30291;
# 150 "include/linux/percpu-refcount.h"
          case 4:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30291;
# 150 "include/linux/percpu-refcount.h"
          case 8:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30291;
# 150 "include/linux/percpu-refcount.h"
          default:;
# 150 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 150 "include/linux/percpu-refcount.h"
        ldv_30291:;
      }
# 150 "include/linux/percpu-refcount.h"
      goto ldv_30285;
# 150 "include/linux/percpu-refcount.h"
      case 4:;
      {
# 150 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 150 "include/linux/percpu-refcount.h"
        int const pao_ID__ = 1;
# 150 "include/linux/percpu-refcount.h"
        if (0)
        {
# 150 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 150 "include/linux/percpu-refcount.h"
          pao_tmp__ = 1U;
# 150 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 150 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 150 "include/linux/percpu-refcount.h"
          case 1:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30301;
# 150 "include/linux/percpu-refcount.h"
          case 2:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30301;
# 150 "include/linux/percpu-refcount.h"
          case 4:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30301;
# 150 "include/linux/percpu-refcount.h"
          case 8:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30301;
# 150 "include/linux/percpu-refcount.h"
          default:;
# 150 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 150 "include/linux/percpu-refcount.h"
        ldv_30301:;
      }
# 150 "include/linux/percpu-refcount.h"
      goto ldv_30285;
# 150 "include/linux/percpu-refcount.h"
      case 8:;
      {
# 150 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 150 "include/linux/percpu-refcount.h"
        int const pao_ID__ = 1;
# 150 "include/linux/percpu-refcount.h"
        if (0)
        {
# 150 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 150 "include/linux/percpu-refcount.h"
          pao_tmp__ = 1U;
# 150 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 150 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 150 "include/linux/percpu-refcount.h"
          case 1:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30311;
# 150 "include/linux/percpu-refcount.h"
          case 2:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30311;
# 150 "include/linux/percpu-refcount.h"
          case 4:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30311;
# 150 "include/linux/percpu-refcount.h"
          case 8:;
# 150 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 150 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 150 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 150 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 150 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 1U ) ) ;
# 150 "include/linux/percpu-refcount.h"
          goto ldv_30311;
# 150 "include/linux/percpu-refcount.h"
          default:;
# 150 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 150 "include/linux/percpu-refcount.h"
        ldv_30311:;
      }
# 150 "include/linux/percpu-refcount.h"
      goto ldv_30285;
# 150 "include/linux/percpu-refcount.h"
      default:;
# 150 "include/linux/percpu-refcount.h"
      __bad_size_call_parameter ( );
# 150 "include/linux/percpu-refcount.h"
      goto ldv_30285;
    }
# 150 "include/linux/percpu-refcount.h"
    ldv_30285:;
    ret = 1;
  }
  else
# 153 "include/linux/percpu-refcount.h"
    ret = atomic_add_unless ( & ( * ref ) . count , 1 , 0 );
# 156 "include/linux/percpu-refcount.h"
  rcu_read_unlock_sched ( );
# 158 "include/linux/percpu-refcount.h"
  return ret != 0;
}
# 175 "include/linux/percpu-refcount.h"
static inline bool percpu_ref_tryget_live(struct percpu_ref *ref)
{
  unsigned int *pcpu_count;
  int ret = 0;
# 180 "include/linux/percpu-refcount.h"
  rcu_read_lock_sched ( );
# 182 "include/linux/percpu-refcount.h"
  if (( int ) __pcpu_ref_alive ( ref , & pcpu_count ))
  {
    {
# 183 "include/linux/percpu-refcount.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 183 "include/linux/percpu-refcount.h"
      ( void ) __vpp_verify;
    }
# 183 "include/linux/percpu-refcount.h"
    switch (4UL)
    {
# 183 "include/linux/percpu-refcount.h"
      case 1:;
      {
# 183 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 183 "include/linux/percpu-refcount.h"
        int const pao_ID__ = 1;
# 183 "include/linux/percpu-refcount.h"
        if (0)
        {
# 183 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 183 "include/linux/percpu-refcount.h"
          pao_tmp__ = 1U;
# 183 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 183 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 183 "include/linux/percpu-refcount.h"
          case 1:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30328;
# 183 "include/linux/percpu-refcount.h"
          case 2:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30328;
# 183 "include/linux/percpu-refcount.h"
          case 4:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30328;
# 183 "include/linux/percpu-refcount.h"
          case 8:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30328;
# 183 "include/linux/percpu-refcount.h"
          default:;
# 183 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 183 "include/linux/percpu-refcount.h"
        ldv_30328:;
      }
# 183 "include/linux/percpu-refcount.h"
      goto ldv_30333;
# 183 "include/linux/percpu-refcount.h"
      case 2:;
      {
# 183 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 183 "include/linux/percpu-refcount.h"
        int const pao_ID__ = 1;
# 183 "include/linux/percpu-refcount.h"
        if (0)
        {
# 183 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 183 "include/linux/percpu-refcount.h"
          pao_tmp__ = 1U;
# 183 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 183 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 183 "include/linux/percpu-refcount.h"
          case 1:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30339;
# 183 "include/linux/percpu-refcount.h"
          case 2:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30339;
# 183 "include/linux/percpu-refcount.h"
          case 4:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30339;
# 183 "include/linux/percpu-refcount.h"
          case 8:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30339;
# 183 "include/linux/percpu-refcount.h"
          default:;
# 183 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 183 "include/linux/percpu-refcount.h"
        ldv_30339:;
      }
# 183 "include/linux/percpu-refcount.h"
      goto ldv_30333;
# 183 "include/linux/percpu-refcount.h"
      case 4:;
      {
# 183 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 183 "include/linux/percpu-refcount.h"
        int const pao_ID__ = 1;
# 183 "include/linux/percpu-refcount.h"
        if (0)
        {
# 183 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 183 "include/linux/percpu-refcount.h"
          pao_tmp__ = 1U;
# 183 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 183 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 183 "include/linux/percpu-refcount.h"
          case 1:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30349;
# 183 "include/linux/percpu-refcount.h"
          case 2:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30349;
# 183 "include/linux/percpu-refcount.h"
          case 4:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30349;
# 183 "include/linux/percpu-refcount.h"
          case 8:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30349;
# 183 "include/linux/percpu-refcount.h"
          default:;
# 183 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 183 "include/linux/percpu-refcount.h"
        ldv_30349:;
      }
# 183 "include/linux/percpu-refcount.h"
      goto ldv_30333;
# 183 "include/linux/percpu-refcount.h"
      case 8:;
      {
# 183 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 183 "include/linux/percpu-refcount.h"
        int const pao_ID__ = 1;
# 183 "include/linux/percpu-refcount.h"
        if (0)
        {
# 183 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 183 "include/linux/percpu-refcount.h"
          pao_tmp__ = 1U;
# 183 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 183 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 183 "include/linux/percpu-refcount.h"
          case 1:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30359;
# 183 "include/linux/percpu-refcount.h"
          case 2:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30359;
# 183 "include/linux/percpu-refcount.h"
          case 4:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30359;
# 183 "include/linux/percpu-refcount.h"
          case 8:;
# 183 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 183 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 183 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 183 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 183 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 1U ) ) ;
# 183 "include/linux/percpu-refcount.h"
          goto ldv_30359;
# 183 "include/linux/percpu-refcount.h"
          default:;
# 183 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 183 "include/linux/percpu-refcount.h"
        ldv_30359:;
      }
# 183 "include/linux/percpu-refcount.h"
      goto ldv_30333;
# 183 "include/linux/percpu-refcount.h"
      default:;
# 183 "include/linux/percpu-refcount.h"
      __bad_size_call_parameter ( );
# 183 "include/linux/percpu-refcount.h"
      goto ldv_30333;
    }
# 183 "include/linux/percpu-refcount.h"
    ldv_30333:;
    ret = 1;
  }
# 187 "include/linux/percpu-refcount.h"
  rcu_read_unlock_sched ( );
# 189 "include/linux/percpu-refcount.h"
  return ret != 0;
}
# 199 "include/linux/percpu-refcount.h"
static inline void percpu_ref_put(struct percpu_ref *ref)
{
  unsigned int *pcpu_count;
# 203 "include/linux/percpu-refcount.h"
  rcu_read_lock_sched ( );
# 205 "include/linux/percpu-refcount.h"
  if (( int ) __pcpu_ref_alive ( ref , & pcpu_count ))
  {
    {
# 206 "include/linux/percpu-refcount.h"
      void const *__vpp_verify = ( ( void const *) 0 );
# 206 "include/linux/percpu-refcount.h"
      ( void ) __vpp_verify;
    }
# 206 "include/linux/percpu-refcount.h"
    switch (4UL)
    {
# 206 "include/linux/percpu-refcount.h"
      case 1:;
      {
# 206 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 206 "include/linux/percpu-refcount.h"
        int const pao_ID__ = -1;
# 206 "include/linux/percpu-refcount.h"
        if (0)
        {
# 206 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 206 "include/linux/percpu-refcount.h"
          pao_tmp__ = 4294967295U;
# 206 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 206 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 206 "include/linux/percpu-refcount.h"
          case 1:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30375;
# 206 "include/linux/percpu-refcount.h"
          case 2:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30375;
# 206 "include/linux/percpu-refcount.h"
          case 4:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30375;
# 206 "include/linux/percpu-refcount.h"
          case 8:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30375;
# 206 "include/linux/percpu-refcount.h"
          default:;
# 206 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 206 "include/linux/percpu-refcount.h"
        ldv_30375:;
      }
# 206 "include/linux/percpu-refcount.h"
      goto ldv_30380;
# 206 "include/linux/percpu-refcount.h"
      case 2:;
      {
# 206 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 206 "include/linux/percpu-refcount.h"
        int const pao_ID__ = -1;
# 206 "include/linux/percpu-refcount.h"
        if (0)
        {
# 206 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 206 "include/linux/percpu-refcount.h"
          pao_tmp__ = 4294967295U;
# 206 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 206 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 206 "include/linux/percpu-refcount.h"
          case 1:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30386;
# 206 "include/linux/percpu-refcount.h"
          case 2:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30386;
# 206 "include/linux/percpu-refcount.h"
          case 4:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30386;
# 206 "include/linux/percpu-refcount.h"
          case 8:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30386;
# 206 "include/linux/percpu-refcount.h"
          default:;
# 206 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 206 "include/linux/percpu-refcount.h"
        ldv_30386:;
      }
# 206 "include/linux/percpu-refcount.h"
      goto ldv_30380;
# 206 "include/linux/percpu-refcount.h"
      case 4:;
      {
# 206 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 206 "include/linux/percpu-refcount.h"
        int const pao_ID__ = -1;
# 206 "include/linux/percpu-refcount.h"
        if (0)
        {
# 206 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 206 "include/linux/percpu-refcount.h"
          pao_tmp__ = 4294967295U;
# 206 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 206 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 206 "include/linux/percpu-refcount.h"
          case 1:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30396;
# 206 "include/linux/percpu-refcount.h"
          case 2:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30396;
# 206 "include/linux/percpu-refcount.h"
          case 4:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30396;
# 206 "include/linux/percpu-refcount.h"
          case 8:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30396;
# 206 "include/linux/percpu-refcount.h"
          default:;
# 206 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 206 "include/linux/percpu-refcount.h"
        ldv_30396:;
      }
# 206 "include/linux/percpu-refcount.h"
      goto ldv_30380;
# 206 "include/linux/percpu-refcount.h"
      case 8:;
      {
# 206 "include/linux/percpu-refcount.h"
        typedef unsigned int pao_T__;
# 206 "include/linux/percpu-refcount.h"
        int const pao_ID__ = -1;
# 206 "include/linux/percpu-refcount.h"
        if (0)
        {
# 206 "include/linux/percpu-refcount.h"
          pao_T__ pao_tmp__;
# 206 "include/linux/percpu-refcount.h"
          pao_tmp__ = 4294967295U;
# 206 "include/linux/percpu-refcount.h"
          ( void ) pao_tmp__;
        }
# 206 "include/linux/percpu-refcount.h"
        switch (4UL)
        {
# 206 "include/linux/percpu-refcount.h"
          case 1:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decb %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addb %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "qi" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30406;
# 206 "include/linux/percpu-refcount.h"
          case 2:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decw %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addw %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30406;
# 206 "include/linux/percpu-refcount.h"
          case 4:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decl %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addl %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "ri" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30406;
# 206 "include/linux/percpu-refcount.h"
          case 8:;
# 206 "include/linux/percpu-refcount.h"
          if (( int ) pao_ID__ == 1)
          {
# 206 "include/linux/percpu-refcount.h"
            asm ( "incq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
          }
          else
# 206 "include/linux/percpu-refcount.h"
            if (( int ) pao_ID__ == -1)
            {
# 206 "include/linux/percpu-refcount.h"
              asm ( "decq %%gs:%P0" : "+m" ( * pcpu_count ) ) ;
            }
            else
# 206 "include/linux/percpu-refcount.h"
              asm ( "addq %1, %%gs:%P0" : "+m" ( * pcpu_count ) : "re" ( 4294967295U ) ) ;
# 206 "include/linux/percpu-refcount.h"
          goto ldv_30406;
# 206 "include/linux/percpu-refcount.h"
          default:;
# 206 "include/linux/percpu-refcount.h"
          __bad_percpu_size ( );
        }
# 206 "include/linux/percpu-refcount.h"
        ldv_30406:;
      }
# 206 "include/linux/percpu-refcount.h"
      goto ldv_30380;
# 206 "include/linux/percpu-refcount.h"
      default:;
# 206 "include/linux/percpu-refcount.h"
      __bad_size_call_parameter ( );
# 206 "include/linux/percpu-refcount.h"
      goto ldv_30380;
    }
# 206 "include/linux/percpu-refcount.h"
    ldv_30380:;
  }
  else
# 207 "include/linux/percpu-refcount.h"
    if (__builtin_expect ( atomic_dec_and_test ( & ( * ref ) . count ) != 0 , 0L ) != 0L)
      ( * ref ) . release ( ref );
# 210 "include/linux/percpu-refcount.h"
  rcu_read_unlock_sched ( );
}
# 219 "include/linux/percpu-refcount.h"
static inline bool percpu_ref_is_zero(struct percpu_ref *ref)
{
  unsigned int *pcpu_count;
# 223 "include/linux/percpu-refcount.h"
  if (( int ) __pcpu_ref_alive ( ref , & pcpu_count ))
    return 0;
  return atomic_read ( ( atomic_t const *) & ( * ref ) . count ) == 0;
}
struct scatterlist
{
# 8 "include/asm-generic/scatterlist.h"
  long unsigned int sg_magic;
# 10 "include/asm-generic/scatterlist.h"
  long unsigned int page_link;
  unsigned int offset;
  unsigned int length;
  dma_addr_t dma_address;
# 15 "include/asm-generic/scatterlist.h"
  unsigned int dma_length;
};
struct scsi_ioctl_command;
struct elevator_queue;
struct request_pm_state;
struct blk_trace;
struct request;
struct sg_io_hdr;
struct bsg_job;
struct blkcg_gq;
# 50 "include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request *, int);
struct request_list
{
# 56 "include/linux/blkdev.h"
  struct request_queue *q;
# 58 "include/linux/blkdev.h"
  struct blkcg_gq *blkg;
# 64 "include/linux/blkdev.h"
  int count[2U];
  int starved[2U];
  mempool_t *rq_pool;
  wait_queue_head_t wait[2U];
  unsigned int flags;
};
enum rq_cmd_type_bits
{
  REQ_TYPE_FS = 1,
  REQ_TYPE_BLOCK_PC = 2,
  REQ_TYPE_SENSE = 3,
  REQ_TYPE_PM_SUSPEND = 4,
  REQ_TYPE_PM_RESUME = 5,
  REQ_TYPE_PM_SHUTDOWN = 6,
  REQ_TYPE_SPECIAL = 7,
  REQ_TYPE_ATA_TASKFILE = 8,
  REQ_TYPE_ATA_PC = 9
};
struct request
{
# 100 "include/linux/blkdev.h"
  struct list_head queuelist;
# 104 "include/linux/blkdev.h"
  union
  {
# 102 "include/linux/blkdev.h"
    struct call_single_data csd;
    long unsigned int fifo_time;
  } ldv_30456;
# 106 "include/linux/blkdev.h"
  struct request_queue *q;
  struct blk_mq_ctx *mq_ctx;
# 109 "include/linux/blkdev.h"
  u64 cmd_flags;
  enum rq_cmd_type_bits cmd_type;
  long unsigned int atomic_flags;
# 113 "include/linux/blkdev.h"
  int cpu;
# 116 "include/linux/blkdev.h"
  unsigned int __data_len;
  sector_t __sector;
# 119 "include/linux/blkdev.h"
  struct bio *bio;
  struct bio *biotail;
# 132 "include/linux/blkdev.h"
  union
  {
# 130 "include/linux/blkdev.h"
    struct hlist_node hash;
    struct list_head ipi_list;
  } ldv_30471;
# 142 "include/linux/blkdev.h"
  union
  {
# 140 "include/linux/blkdev.h"
    struct rb_node rb_node;
    void *completion_data;
  } ldv_30475;
# 161 "include/linux/blkdev.h"
  union
  {
# 154 "include/linux/blkdev.h"
    struct
    {
# 152 "include/linux/blkdev.h"
      struct io_cq *icq;
      void *priv[2U];
    } elv;
# 160 "include/linux/blkdev.h"
    struct
    {
# 157 "include/linux/blkdev.h"
      unsigned int seq;
      struct list_head list;
      rq_end_io_fn *saved_end_io;
    } flush;
  } ldv_30486;
# 163 "include/linux/blkdev.h"
  struct gendisk *rq_disk;
  struct hd_struct *part;
  long unsigned int start_time;
# 167 "include/linux/blkdev.h"
  struct request_list *rl;
  long long unsigned int start_time_ns;
  long long unsigned int io_start_time_ns;
# 174 "include/linux/blkdev.h"
  short unsigned int nr_phys_segments;
# 176 "include/linux/blkdev.h"
  short unsigned int nr_integrity_segments;
# 179 "include/linux/blkdev.h"
  short unsigned int ioprio;
# 181 "include/linux/blkdev.h"
  void *special;
# 183 "include/linux/blkdev.h"
  int tag;
  int errors;
# 189 "include/linux/blkdev.h"
  unsigned char __cmd[16U];
  unsigned char *cmd;
  short unsigned int cmd_len;
# 193 "include/linux/blkdev.h"
  unsigned int extra_len;
  unsigned int sense_len;
  unsigned int resid_len;
  void *sense;
# 198 "include/linux/blkdev.h"
  long unsigned int deadline;
  struct list_head timeout_list;
  unsigned int timeout;
  int retries;
# 206 "include/linux/blkdev.h"
  rq_end_io_fn *end_io;
  void *end_io_data;
# 210 "include/linux/blkdev.h"
  struct request *next_rq;
};
# 213 "include/linux/blkdev.h"
static inline short unsigned int req_get_ioprio(struct request *req)
{
  return ( * req ) . ioprio;
}
struct request_pm_state
{
# 225 "include/linux/blkdev.h"
  int pm_step;
# 227 "include/linux/blkdev.h"
  u32 pm_state;
  void *data;
};
struct fast_hash_ops;
# 5 "./arch/x86/include/asm/hash.h"
void setup_arch_fast_hash(struct fast_hash_ops *);
# 36 "include/linux/hash.h"
static inline u64 hash_64(u64 val, unsigned int bits)
{
  u64 hash = val;
# 41 "include/linux/hash.h"
  u64 n = hash;
  n <<= 18;
  hash -= n;
  n <<= 33;
  hash -= n;
  n <<= 3;
  hash += n;
  n <<= 3;
  hash -= n;
  n <<= 4;
  hash += n;
  n <<= 2;
  hash += n;
# 56 "include/linux/hash.h"
  return hash >> ( int ) ( 64U - bits );
}
# 59 "include/linux/hash.h"
static inline u32 hash_32(u32 val, unsigned int bits)
{
# 62 "include/linux/hash.h"
  u32 hash = val * 2654404609U;
# 65 "include/linux/hash.h"
  return hash >> ( int ) ( 32U - bits );
}
# 68 "include/linux/hash.h"
static inline long unsigned int hash_ptr(void const *ptr, unsigned int bits)
{
  return ( long unsigned int ) hash_64 ( ( u64 ) ptr , bits );
}
# 73 "include/linux/hash.h"
static inline u32 hash32_ptr(void const *ptr)
{
  long unsigned int val = ( long unsigned int ) ptr;
# 78 "include/linux/hash.h"
  val = val >> 32 ^ val;
# 80 "include/linux/hash.h"
  return ( u32 ) val;
}
struct fast_hash_ops
{
  u32 (*hash)(void const *, u32, u32);
  u32 (*hash2)(u32 const *, u32, u32);
};
# 100 "include/linux/hash.h"
u32 arch_fast_hash(void const *, u32, u32);
# 115 "include/linux/hash.h"
u32 arch_fast_hash2(u32 const *, u32, u32);
# 29 "include/linux/hashtable.h"
static inline void __hash_init(struct hlist_head *ht, unsigned int sz)
{
  unsigned int i;
# 33 "include/linux/hashtable.h"
  i = 0U;
# 33 "include/linux/hashtable.h"
  goto ldv_30563;
  ldv_30562:;
# 34 "include/linux/hashtable.h"
  ( * ( ht + ( long unsigned int ) i ) ) . first = ( ( struct hlist_node *) 0 );
# 33 "include/linux/hashtable.h"
  i ++;
  ldv_30563:;
# 33 "include/linux/hashtable.h"
  if (i < sz)
  {
    goto ldv_30562;
  }
  else
    goto ldv_30564;
  ldv_30564:;
}
# 71 "include/linux/hashtable.h"
static inline bool hash_hashed(struct hlist_node *node)
{
  return hlist_unhashed ( ( struct hlist_node const *) node ) == 0;
}
# 76 "include/linux/hashtable.h"
static inline bool __hash_empty(struct hlist_head *ht, unsigned int sz)
{
  unsigned int i;
# 80 "include/linux/hashtable.h"
  i = 0U;
# 80 "include/linux/hashtable.h"
  goto ldv_30574;
  ldv_30573:;
# 81 "include/linux/hashtable.h"
  if (hlist_empty ( ( struct hlist_head const *) ht + ( long unsigned int ) i ) == 0)
    return 0;
# 80 "include/linux/hashtable.h"
  i ++;
  ldv_30574:;
# 80 "include/linux/hashtable.h"
  if (i < sz)
  {
    goto ldv_30573;
  }
  else
    goto ldv_30575;
  ldv_30575:;
# 84 "include/linux/hashtable.h"
  return 1;
}
# 100 "include/linux/hashtable.h"
static inline void hash_del(struct hlist_node *node)
{
  hlist_del_init ( node );
}
# 109 "include/linux/hashtable.h"
static inline void hash_del_rcu(struct hlist_node *node)
{
  hlist_del_init_rcu ( node );
}
struct elevator_type;
# 12 "include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue *, struct request **, struct bio *);
# 15 "include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue *, struct request *, struct request *);
# 17 "include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue *, struct request *, int);
# 19 "include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue *, struct request *, struct bio *);
# 21 "include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue *, struct request *, struct bio *);
# 24 "include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue *, int);
# 26 "include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue *, struct request *);
typedef struct request *elevator_request_list_fn(struct request_queue *, struct request *);
typedef void elevator_completed_req_fn(struct request_queue *, struct request *);
typedef int elevator_may_queue_fn(struct request_queue *, int);
# 31 "include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq *);
typedef void elevator_exit_icq_fn(struct io_cq *);
typedef int elevator_set_req_fn(struct request_queue *, struct request *, struct bio *, gfp_t);
# 35 "include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request *);
typedef void elevator_activate_req_fn(struct request_queue *, struct request *);
typedef void elevator_deactivate_req_fn(struct request_queue *, struct request *);
# 39 "include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue *, struct elevator_type *);
# 41 "include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue *);
struct elevator_ops
{
# 45 "include/linux/elevator.h"
  elevator_merge_fn *elevator_merge_fn;
  elevator_merged_fn *elevator_merged_fn;
  elevator_merge_req_fn *elevator_merge_req_fn;
  elevator_allow_merge_fn *elevator_allow_merge_fn;
  elevator_bio_merged_fn *elevator_bio_merged_fn;
# 51 "include/linux/elevator.h"
  elevator_dispatch_fn *elevator_dispatch_fn;
  elevator_add_req_fn *elevator_add_req_fn;
  elevator_activate_req_fn *elevator_activate_req_fn;
  elevator_deactivate_req_fn *elevator_deactivate_req_fn;
# 56 "include/linux/elevator.h"
  elevator_completed_req_fn *elevator_completed_req_fn;
# 58 "include/linux/elevator.h"
  elevator_request_list_fn *elevator_former_req_fn;
  elevator_request_list_fn *elevator_latter_req_fn;
# 61 "include/linux/elevator.h"
  elevator_init_icq_fn *elevator_init_icq_fn;
  elevator_exit_icq_fn *elevator_exit_icq_fn;
# 64 "include/linux/elevator.h"
  elevator_set_req_fn *elevator_set_req_fn;
  elevator_put_req_fn *elevator_put_req_fn;
# 67 "include/linux/elevator.h"
  elevator_may_queue_fn *elevator_may_queue_fn;
# 69 "include/linux/elevator.h"
  elevator_init_fn *elevator_init_fn;
  elevator_exit_fn *elevator_exit_fn;
};
struct elv_fs_entry
{
# 76 "include/linux/elevator.h"
  struct attribute attr;
  ssize_t (*show)(struct elevator_queue *, char *);
  ssize_t (*store)(struct elevator_queue *, char const *, size_t);
};
struct elevator_type
{
# 87 "include/linux/elevator.h"
  struct kmem_cache *icq_cache;
# 90 "include/linux/elevator.h"
  struct elevator_ops ops;
  size_t icq_size;
  size_t icq_align;
  struct elv_fs_entry *elevator_attrs;
  char elevator_name[16U];
  struct module *elevator_owner;
# 98 "include/linux/elevator.h"
  char icq_cache_name[21U];
  struct list_head list;
};
struct elevator_queue
{
# 109 "include/linux/elevator.h"
  struct elevator_type *type;
  void *elevator_data;
  struct kobject kobj;
  struct mutex sysfs_lock;
  unsigned char registered : 1;
  struct hlist_head hash[64U];
};
# 120 "include/linux/elevator.h"
void elv_dispatch_sort(struct request_queue *, struct request *);
void elv_dispatch_add_tail(struct request_queue *, struct request *);
void elv_add_request(struct request_queue *, struct request *, int);
void __elv_add_request(struct request_queue *, struct request *, int);
int elv_merge(struct request_queue *, struct request **, struct bio *);
void elv_merge_requests(struct request_queue *, struct request *, struct request *);
# 127 "include/linux/elevator.h"
void elv_merged_request(struct request_queue *, struct request *, int);
void elv_bio_merged(struct request_queue *, struct request *, struct bio *);
# 130 "include/linux/elevator.h"
void elv_requeue_request(struct request_queue *, struct request *);
struct request *elv_former_request(struct request_queue *, struct request *);
struct request *elv_latter_request(struct request_queue *, struct request *);
int elv_register_queue(struct request_queue *);
void elv_unregister_queue(struct request_queue *);
int elv_may_queue(struct request_queue *, int);
void elv_completed_request(struct request_queue *, struct request *);
int elv_set_request(struct request_queue *, struct request *, struct bio *, gfp_t);
# 139 "include/linux/elevator.h"
void elv_put_request(struct request_queue *, struct request *);
void elv_drain_elevator(struct request_queue *);
# 145 "include/linux/elevator.h"
void load_default_elevator_module(void);
int elv_register(struct elevator_type *);
void elv_unregister(struct elevator_type *);
# 152 "include/linux/elevator.h"
ssize_t elv_iosched_show(struct request_queue *, char *);
ssize_t elv_iosched_store(struct request_queue *, char const *, size_t);
# 155 "include/linux/elevator.h"
int elevator_init(struct request_queue *, char *);
void elevator_exit(struct elevator_queue *);
int elevator_change(struct request_queue *, char const *);
bool elv_rq_merge_ok(struct request *, struct bio *);
struct elevator_queue *elevator_alloc(struct request_queue *, struct elevator_type *);
# 165 "include/linux/elevator.h"
struct request *elv_rb_former_request(struct request_queue *, struct request *);
struct request *elv_rb_latter_request(struct request_queue *, struct request *);
# 171 "include/linux/elevator.h"
void elv_rb_add(struct rb_root *, struct request *);
void elv_rb_del(struct rb_root *, struct request *);
struct request *elv_rb_find(struct rb_root *, sector_t);
enum ldv_24714
{
  ELV_MQUEUE_MAY = 0,
  ELV_MQUEUE_NO = 1,
  ELV_MQUEUE_MUST = 2
};
struct blk_queue_ctx;
# 235 "include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue *);
typedef void make_request_fn(struct request_queue *, struct bio *);
typedef int prep_rq_fn(struct request_queue *, struct request *);
typedef void unprep_rq_fn(struct request_queue *, struct request *);
struct bvec_merge_data
{
# 242 "include/linux/blkdev.h"
  struct block_device *bi_bdev;
  sector_t bi_sector;
  unsigned int bi_size;
  long unsigned int bi_rw;
};
typedef int merge_bvec_fn(struct request_queue *, struct bvec_merge_data *, struct bio_vec *);
# 249 "include/linux/blkdev.h"
typedef void softirq_done_fn(struct request *);
typedef int dma_drain_needed_fn(struct request *);
typedef int lld_busy_fn(struct request_queue *);
typedef int bsg_job_fn(struct bsg_job *);
enum blk_eh_timer_return
{
  BLK_EH_NOT_HANDLED = 0,
  BLK_EH_HANDLED = 1,
  BLK_EH_RESET_TIMER = 2
};
# 260 "include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request *);
enum blk_queue_state
{
  Queue_down = 0,
  Queue_up = 1
};
struct blk_queue_tag
{
  struct request **tag_index;
  long unsigned int *tag_map;
  int busy;
  int max_depth;
  int real_max_depth;
  atomic_t refcnt;
};
struct queue_limits
{
# 280 "include/linux/blkdev.h"
  long unsigned int bounce_pfn;
  long unsigned int seg_boundary_mask;
# 283 "include/linux/blkdev.h"
  unsigned int max_hw_sectors;
  unsigned int chunk_sectors;
  unsigned int max_sectors;
  unsigned int max_segment_size;
  unsigned int physical_block_size;
  unsigned int alignment_offset;
  unsigned int io_min;
  unsigned int io_opt;
  unsigned int max_discard_sectors;
  unsigned int max_write_same_sectors;
  unsigned int discard_granularity;
  unsigned int discard_alignment;
# 296 "include/linux/blkdev.h"
  short unsigned int logical_block_size;
  short unsigned int max_segments;
  short unsigned int max_integrity_segments;
# 300 "include/linux/blkdev.h"
  unsigned char misaligned;
  unsigned char discard_misaligned;
  unsigned char cluster;
  unsigned char discard_zeroes_data;
  unsigned char raid_partial_stripes_expensive;
};
struct request_queue
{
# 311 "include/linux/blkdev.h"
  struct list_head queue_head;
  struct request *last_merge;
  struct elevator_queue *elevator;
  int nr_rqs[2U];
  int nr_rqs_elvpriv;
# 323 "include/linux/blkdev.h"
  struct request_list root_rl;
# 325 "include/linux/blkdev.h"
  request_fn_proc *request_fn;
  make_request_fn *make_request_fn;
  prep_rq_fn *prep_rq_fn;
  unprep_rq_fn *unprep_rq_fn;
  merge_bvec_fn *merge_bvec_fn;
  softirq_done_fn *softirq_done_fn;
  rq_timed_out_fn *rq_timed_out_fn;
  dma_drain_needed_fn *dma_drain_needed;
  lld_busy_fn *lld_busy_fn;
# 335 "include/linux/blkdev.h"
  struct blk_mq_ops *mq_ops;
# 337 "include/linux/blkdev.h"
  unsigned int *mq_map;
# 340 "include/linux/blkdev.h"
  struct blk_mq_ctx *queue_ctx;
  unsigned int nr_queues;
# 344 "include/linux/blkdev.h"
  struct blk_mq_hw_ctx **queue_hw_ctx;
  unsigned int nr_hw_queues;
# 350 "include/linux/blkdev.h"
  sector_t end_sector;
  struct request *boundary_rq;
# 356 "include/linux/blkdev.h"
  struct delayed_work delay_work;
# 358 "include/linux/blkdev.h"
  struct backing_dev_info backing_dev_info;
# 364 "include/linux/blkdev.h"
  void *queuedata;
# 369 "include/linux/blkdev.h"
  long unsigned int queue_flags;
# 375 "include/linux/blkdev.h"
  int id;
# 380 "include/linux/blkdev.h"
  gfp_t bounce_gfp;
# 387 "include/linux/blkdev.h"
  spinlock_t __queue_lock;
  spinlock_t *queue_lock;
# 393 "include/linux/blkdev.h"
  struct kobject kobj;
# 398 "include/linux/blkdev.h"
  struct kobject mq_kobj;
# 401 "include/linux/blkdev.h"
  struct device *dev;
  int rpm_status;
  unsigned int nr_pending;
# 409 "include/linux/blkdev.h"
  long unsigned int nr_requests;
  unsigned int nr_congestion_on;
  unsigned int nr_congestion_off;
  unsigned int nr_batching;
# 414 "include/linux/blkdev.h"
  unsigned int dma_drain_size;
  void *dma_drain_buffer;
  unsigned int dma_pad_mask;
  unsigned int dma_alignment;
# 419 "include/linux/blkdev.h"
  struct blk_queue_tag *queue_tags;
  struct list_head tag_busy_list;
# 422 "include/linux/blkdev.h"
  unsigned int nr_sorted;
  unsigned int in_flight[2U];
# 429 "include/linux/blkdev.h"
  unsigned int request_fn_active;
# 431 "include/linux/blkdev.h"
  unsigned int rq_timeout;
  struct timer_list timeout;
  struct list_head timeout_list;
# 435 "include/linux/blkdev.h"
  struct list_head icq_list;
# 437 "include/linux/blkdev.h"
  long unsigned int blkcg_pols[1U];
  struct blkcg_gq *root_blkg;
  struct list_head blkg_list;
# 442 "include/linux/blkdev.h"
  struct queue_limits limits;
# 447 "include/linux/blkdev.h"
  unsigned int sg_timeout;
  unsigned int sg_reserved_size;
  int node;
# 456 "include/linux/blkdev.h"
  unsigned int flush_flags;
  unsigned char flush_not_queueable : 1;
  unsigned char flush_queue_delayed : 1;
  unsigned char flush_pending_idx : 1;
  unsigned char flush_running_idx : 1;
  long unsigned int flush_pending_since;
  struct list_head flush_queue[2U];
  struct list_head flush_data_in_flight;
  struct request *flush_rq;
  spinlock_t mq_flush_lock;
# 467 "include/linux/blkdev.h"
  struct list_head requeue_list;
  spinlock_t requeue_lock;
  struct work_struct requeue_work;
# 471 "include/linux/blkdev.h"
  struct mutex sysfs_lock;
# 473 "include/linux/blkdev.h"
  int bypass_depth;
  int mq_freeze_depth;
# 477 "include/linux/blkdev.h"
  bsg_job_fn *bsg_job_fn;
  int bsg_job_size;
  struct bsg_class_device bsg_dev;
# 484 "include/linux/blkdev.h"
  struct throtl_data *td;
# 486 "include/linux/blkdev.h"
  struct callback_head callback_head;
  wait_queue_head_t mq_freeze_wq;
  struct percpu_ref mq_usage_counter;
  struct list_head all_q_node;
# 491 "include/linux/blkdev.h"
  struct blk_mq_tag_set *tag_set;
  struct list_head tag_set_list;
};
# 527 "include/linux/blkdev.h"
static inline void queue_lockdep_assert_held(struct request_queue *q)
{
  if (( * q ) . queue_lock != ( ( spinlock_t *) 0 ))
    ({
# 530 "include/linux/blkdev.h"
      int __ret_warn_on = debug_locks != 0 && lock_is_held ( & ( * ( * q ) . queue_lock ) . ldv_6073 . ldv_6072 . dep_map ) == 0;
      {
# 530 "include/linux/blkdev.h"
        if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 530 "include/linux/blkdev.h"
          warn_slowpath_null ( ( char const *) "include/linux/blkdev.h" , 530 );
      }
# 530 "include/linux/blkdev.h"
      __builtin_expect ( __ret_warn_on != 0 , 0L );
    } );
}
static inline void queue_flag_set_unlocked(unsigned int flag, struct request_queue *q)
{
# 536 "include/linux/blkdev.h"
  __set_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * q ) . queue_flags );
}
# 539 "include/linux/blkdev.h"
static inline int queue_flag_test_and_clear(unsigned int flag, struct request_queue *q)
{
# 542 "include/linux/blkdev.h"
  queue_lockdep_assert_held ( q );
# 544 "include/linux/blkdev.h"
  if (variable_test_bit ( ( long int ) flag , ( long unsigned int const volatile *) & ( * q ) . queue_flags ) != 0)
  {
# 545 "include/linux/blkdev.h"
    __clear_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * q ) . queue_flags );
    return 1;
  }
# 549 "include/linux/blkdev.h"
  return 0;
}
# 552 "include/linux/blkdev.h"
static inline int queue_flag_test_and_set(unsigned int flag, struct request_queue *q)
{
# 555 "include/linux/blkdev.h"
  queue_lockdep_assert_held ( q );
# 557 "include/linux/blkdev.h"
  if (variable_test_bit ( ( long int ) flag , ( long unsigned int const volatile *) & ( * q ) . queue_flags ) == 0)
  {
# 558 "include/linux/blkdev.h"
    __set_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * q ) . queue_flags );
    return 0;
  }
# 562 "include/linux/blkdev.h"
  return 1;
}
# 565 "include/linux/blkdev.h"
static inline void queue_flag_set(unsigned int flag, struct request_queue *q)
{
  queue_lockdep_assert_held ( q );
  __set_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * q ) . queue_flags );
}
# 571 "include/linux/blkdev.h"
static inline void queue_flag_clear_unlocked(unsigned int flag, struct request_queue *q)
{
# 574 "include/linux/blkdev.h"
  __clear_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * q ) . queue_flags );
}
# 577 "include/linux/blkdev.h"
static inline int queue_in_flight(struct request_queue *q)
{
  return ( int ) ( ( * q ) . in_flight [ 0 ] + ( * q ) . in_flight [ 1 ] );
}
# 582 "include/linux/blkdev.h"
static inline void queue_flag_clear(unsigned int flag, struct request_queue *q)
{
  queue_lockdep_assert_held ( q );
  __clear_bit ( ( long int ) flag , ( long unsigned int volatile *) & ( * q ) . queue_flags );
}
# 631 "include/linux/blkdev.h"
static inline bool queue_is_rq_based(struct request_queue *q)
{
  return ( bool ) ( ( * q ) . request_fn != ( ( request_fn_proc *) 0 ) || ( * q ) . mq_ops != ( ( struct blk_mq_ops *) 0 ) );
}
# 636 "include/linux/blkdev.h"
static inline unsigned int blk_queue_cluster(struct request_queue *q)
{
  return ( unsigned int ) ( * q ) . limits . cluster;
}
# 644 "include/linux/blkdev.h"
static inline bool rw_is_sync(unsigned int rw_flags)
{
  return ( bool ) ( ( ( long long unsigned int ) rw_flags & 1ULL ) == 0ULL || ( ( long long unsigned int ) rw_flags & 16ULL ) != 0ULL );
}
# 649 "include/linux/blkdev.h"
static inline bool rq_is_sync(struct request *rq)
{
  return rw_is_sync ( ( unsigned int ) ( * rq ) . cmd_flags );
}
# 654 "include/linux/blkdev.h"
static inline bool blk_rl_full(struct request_list *rl, bool sync)
{
  unsigned int flag = ( int ) sync ? 1U : 2U;
# 658 "include/linux/blkdev.h"
  return ( ( * rl ) . flags & flag ) != 0U;
}
# 661 "include/linux/blkdev.h"
static inline void blk_set_rl_full(struct request_list *rl, bool sync)
{
  unsigned int flag = ( int ) sync ? 1U : 2U;
# 665 "include/linux/blkdev.h"
  ( * rl ) . flags |= flag;
}
# 668 "include/linux/blkdev.h"
static inline void blk_clear_rl_full(struct request_list *rl, bool sync)
{
  unsigned int flag = ( int ) sync ? 1U : 2U;
# 672 "include/linux/blkdev.h"
  ( * rl ) . flags &= ~ flag;
}
# 675 "include/linux/blkdev.h"
static inline bool rq_mergeable(struct request *rq)
{
  if (( unsigned int ) ( * rq ) . cmd_type != 1U)
    return 0;
# 680 "include/linux/blkdev.h"
  if (( ( long long unsigned int ) ( * rq ) . cmd_flags & 464896ULL ) != 0ULL)
    return 0;
# 683 "include/linux/blkdev.h"
  return 1;
}
# 686 "include/linux/blkdev.h"
static inline bool blk_check_merge_flags(unsigned int flags1, unsigned int flags2)
{
# 689 "include/linux/blkdev.h"
  if (( ( ( long long unsigned int ) flags1 ^ ( long long unsigned int ) flags2 ) & 128ULL ) != 0ULL)
    return 0;
# 692 "include/linux/blkdev.h"
  if (( ( ( long long unsigned int ) flags1 ^ ( long long unsigned int ) flags2 ) & 256ULL ) != 0ULL)
    return 0;
# 695 "include/linux/blkdev.h"
  if (( ( ( long long unsigned int ) flags1 ^ ( long long unsigned int ) flags2 ) & 512ULL ) != 0ULL)
    return 0;
# 698 "include/linux/blkdev.h"
  return 1;
}
# 701 "include/linux/blkdev.h"
static inline bool blk_write_same_mergeable(struct bio *a, struct bio *b)
{
  if (bio_data ( a ) == bio_data ( b ))
    return 1;
# 706 "include/linux/blkdev.h"
  return 0;
}
# 716 "include/linux/blkdev.h"
extern long unsigned int blk_max_low_pfn;
# 716 "include/linux/blkdev.h"
extern long unsigned int blk_max_pfn;
# 741 "include/linux/blkdev.h"
int init_emergency_isa_pool(void);
void blk_queue_bounce(struct request_queue *, struct bio **);
struct rq_map_data
{
# 754 "include/linux/blkdev.h"
  struct page **pages;
  int page_order;
  int nr_entries;
  long unsigned int offset;
  int null_mapped;
  int from_user;
};
struct req_iterator
{
  struct bvec_iter iter;
  struct bio *bio;
};
# 788 "include/linux/blkdev.h"
static inline void rq_flush_dcache_pages(struct request *rq)
{
}
# 793 "include/linux/blkdev.h"
int blk_register_queue(struct gendisk *);
void blk_unregister_queue(struct gendisk *);
void generic_make_request(struct bio *);
void blk_rq_init(struct request_queue *, struct request *);
void blk_put_request(struct request *);
void __blk_put_request(struct request_queue *, struct request *);
struct request *blk_get_request(struct request_queue *, int, gfp_t);
struct request *blk_make_request(struct request_queue *, struct bio *, gfp_t);
# 802 "include/linux/blkdev.h"
void blk_rq_set_block_pc(struct request *);
void blk_requeue_request(struct request_queue *, struct request *);
void blk_add_request_payload(struct request *, struct page *, unsigned int);
# 806 "include/linux/blkdev.h"
int blk_rq_check_limits(struct request_queue *, struct request *);
int blk_lld_busy(struct request_queue *);
int blk_rq_prep_clone(struct request *, struct request *, struct bio_set *, gfp_t, int (*)(struct bio *, struct bio *, void *), void *);
# 812 "include/linux/blkdev.h"
void blk_rq_unprep_clone(struct request *);
int blk_insert_cloned_request(struct request_queue *, struct request *);
# 815 "include/linux/blkdev.h"
void blk_delay_queue(struct request_queue *, long unsigned int);
void blk_recount_segments(struct request_queue *, struct bio *);
int scsi_verify_blk_ioctl(struct block_device *, unsigned int);
int scsi_cmd_blk_ioctl(struct block_device *, fmode_t, unsigned int, void *);
# 820 "include/linux/blkdev.h"
int scsi_cmd_ioctl(struct request_queue *, struct gendisk *, fmode_t, unsigned int, void *);
# 822 "include/linux/blkdev.h"
int sg_scsi_ioctl(struct request_queue *, struct gendisk *, fmode_t, struct scsi_ioctl_command *);
# 825 "include/linux/blkdev.h"
void blk_queue_bio(struct request_queue *, struct bio *);
# 832 "include/linux/blkdev.h"
static inline void blk_clear_queue_congested(struct request_queue *q, int sync)
{
  clear_bdi_congested ( & ( * q ) . backing_dev_info , sync );
}
# 841 "include/linux/blkdev.h"
static inline void blk_set_queue_congested(struct request_queue *q, int sync)
{
  set_bdi_congested ( & ( * q ) . backing_dev_info , sync );
}
# 846 "include/linux/blkdev.h"
void blk_start_queue(struct request_queue *);
void blk_stop_queue(struct request_queue *);
void blk_sync_queue(struct request_queue *);
void __blk_stop_queue(struct request_queue *);
void __blk_run_queue(struct request_queue *);
void blk_run_queue(struct request_queue *);
void blk_run_queue_async(struct request_queue *);
int blk_rq_map_user(struct request_queue *, struct request *, struct rq_map_data *, void *, long unsigned int, gfp_t);
# 856 "include/linux/blkdev.h"
int blk_rq_unmap_user(struct bio *);
int blk_rq_map_kern(struct request_queue *, struct request *, void *, unsigned int, gfp_t);
int blk_rq_map_user_iov(struct request_queue *, struct request *, struct rq_map_data *, struct sg_iovec const *, int, unsigned int, gfp_t);
# 861 "include/linux/blkdev.h"
int blk_execute_rq(struct request_queue *, struct gendisk *, struct request *, int);
# 863 "include/linux/blkdev.h"
void blk_execute_rq_nowait(struct request_queue *, struct gendisk *, struct request *, int, rq_end_io_fn *);
# 866 "include/linux/blkdev.h"
static inline struct request_queue *bdev_get_queue(struct block_device *bdev)
{
  return ( * ( * bdev ) . bd_disk ) . queue;
}
# 879 "include/linux/blkdev.h"
static inline sector_t blk_rq_pos(struct request const *rq)
{
  return ( sector_t ) ( * rq ) . __sector;
}
# 884 "include/linux/blkdev.h"
static inline unsigned int blk_rq_bytes(struct request const *rq)
{
  return ( unsigned int ) ( * rq ) . __data_len;
}
# 889 "include/linux/blkdev.h"
static inline int blk_rq_cur_bytes(struct request const *rq)
{
  return ( * rq ) . bio != ( ( struct bio *const ) 0 ) ? ( int ) bio_cur_bytes ( ( * rq ) . bio ) : 0;
}
# 894 "include/linux/blkdev.h"
unsigned int blk_rq_err_bytes(struct request const *);
# 896 "include/linux/blkdev.h"
static inline unsigned int blk_rq_sectors(struct request const *rq)
{
  return blk_rq_bytes ( rq ) >> 9;
}
# 901 "include/linux/blkdev.h"
static inline unsigned int blk_rq_cur_sectors(struct request const *rq)
{
  return ( unsigned int ) ( blk_rq_cur_bytes ( rq ) >> 9 );
}
# 906 "include/linux/blkdev.h"
static inline unsigned int blk_queue_get_max_sectors(struct request_queue *q, unsigned int cmd_flags)
{
# 909 "include/linux/blkdev.h"
  if (__builtin_expect ( ( ( long long unsigned int ) cmd_flags & 128ULL ) != 0ULL , 0L ) != 0L)
    return ({
# 910 "include/linux/blkdev.h"
      unsigned int _min1 = ( * q ) . limits . max_discard_sectors;
# 910 "include/linux/blkdev.h"
      unsigned int _min2 = 8388607U;
# 910 "include/linux/blkdev.h"
      ( void ) 0;
# 910 "include/linux/blkdev.h"
      ((_min1) < (_min2) ? (_min1) : (_min2));
    } );
  if (__builtin_expect ( ( ( long long unsigned int ) cmd_flags & 512ULL ) != 0ULL , 0L ) != 0L)
    return ( * q ) . limits . max_write_same_sectors;
# 915 "include/linux/blkdev.h"
  return ( * q ) . limits . max_sectors;
}
# 922 "include/linux/blkdev.h"
static inline unsigned int blk_max_size_offset(struct request_queue *q, sector_t offset)
{
# 925 "include/linux/blkdev.h"
  if (( * q ) . limits . chunk_sectors == 0U)
    return ( * q ) . limits . max_sectors;
# 928 "include/linux/blkdev.h"
  return ( * q ) . limits . chunk_sectors - ( (
# 929 "include/linux/blkdev.h"
  * q ) . limits . chunk_sectors - 1U & ( unsigned int ) offset );
}
# 932 "include/linux/blkdev.h"
static inline unsigned int blk_rq_get_max_sectors(struct request *rq)
{
  struct request_queue *q = ( * rq ) . q;
# 936 "include/linux/blkdev.h"
  if (__builtin_expect ( ( unsigned int ) ( * rq ) . cmd_type == 2U , 0L ) != 0L)
    return ( * q ) . limits . max_hw_sectors;
# 939 "include/linux/blkdev.h"
  if (( * q ) . limits . chunk_sectors == 0U)
    return blk_queue_get_max_sectors ( q , ( unsigned int ) ( * rq ) . cmd_flags );
# 942 "include/linux/blkdev.h"
  return ({
# 942 "include/linux/blkdev.h"
    unsigned int _min1 = blk_max_size_offset ( q , blk_rq_pos ( ( struct request const *) rq ) );
# 942 "include/linux/blkdev.h"
    unsigned int _min2 = blk_queue_get_max_sectors ( q , ( unsigned int ) ( * rq ) . cmd_flags );
# 942 "include/linux/blkdev.h"
    ( void ) 0;
# 942 "include/linux/blkdev.h"
    ((_min1) < (_min2) ? (_min1) : (_min2));
  } );
}
# 946 "include/linux/blkdev.h"
static inline unsigned int blk_rq_count_bios(struct request *rq)
{
  unsigned int nr_bios = 0U;
  struct bio *bio;
# 951 "include/linux/blkdev.h"
  if (( * rq ) . bio != ( ( struct bio *) 0 ))
  {
# 951 "include/linux/blkdev.h"
    bio = ( * rq ) . bio;
# 951 "include/linux/blkdev.h"
    goto ldv_31215;
    ldv_31214:;
# 952 "include/linux/blkdev.h"
    nr_bios ++;
# 951 "include/linux/blkdev.h"
    bio = ( * bio ) . bi_next;
    ldv_31215:;
# 951 "include/linux/blkdev.h"
    if (bio != ( ( struct bio *) 0 ))
    {
      goto ldv_31214;
    }
    else
      goto ldv_31216;
    ldv_31216:;
  }
# 954 "include/linux/blkdev.h"
  return nr_bios;
}
# 960 "include/linux/blkdev.h"
struct request *blk_peek_request(struct request_queue *);
void blk_start_request(struct request *);
struct request *blk_fetch_request(struct request_queue *);
# 977 "include/linux/blkdev.h"
bool blk_update_request(struct request *, int, unsigned int);
# 979 "include/linux/blkdev.h"
void blk_finish_request(struct request *, int);
bool blk_end_request(struct request *, int, unsigned int);
# 982 "include/linux/blkdev.h"
void blk_end_request_all(struct request *, int);
bool blk_end_request_cur(struct request *, int);
bool blk_end_request_err(struct request *, int);
bool __blk_end_request(struct request *, int, unsigned int);
# 987 "include/linux/blkdev.h"
void __blk_end_request_all(struct request *, int);
bool __blk_end_request_cur(struct request *, int);
bool __blk_end_request_err(struct request *, int);
# 991 "include/linux/blkdev.h"
void blk_complete_request(struct request *);
void __blk_complete_request(struct request *);
void blk_abort_request(struct request *);
void blk_unprep_request(struct request *);
# 999 "include/linux/blkdev.h"
struct request_queue *blk_init_queue_node(request_fn_proc *, spinlock_t *, int);
# 1001 "include/linux/blkdev.h"
struct request_queue *blk_init_queue(request_fn_proc *, spinlock_t *);
struct request_queue *blk_init_allocated_queue(struct request_queue *, request_fn_proc *, spinlock_t *);
# 1004 "include/linux/blkdev.h"
void blk_cleanup_queue(struct request_queue *);
void blk_queue_make_request(struct request_queue *, make_request_fn *);
void blk_queue_bounce_limit(struct request_queue *, u64);
void blk_limits_max_hw_sectors(struct queue_limits *, unsigned int);
void blk_queue_max_hw_sectors(struct request_queue *, unsigned int);
void blk_queue_chunk_sectors(struct request_queue *, unsigned int);
void blk_queue_max_segments(struct request_queue *, short unsigned int);
void blk_queue_max_segment_size(struct request_queue *, unsigned int);
void blk_queue_max_discard_sectors(struct request_queue *, unsigned int);
# 1014 "include/linux/blkdev.h"
void blk_queue_max_write_same_sectors(struct request_queue *, unsigned int);
# 1016 "include/linux/blkdev.h"
void blk_queue_logical_block_size(struct request_queue *, short unsigned int);
void blk_queue_physical_block_size(struct request_queue *, unsigned int);
void blk_queue_alignment_offset(struct request_queue *, unsigned int);
# 1020 "include/linux/blkdev.h"
void blk_limits_io_min(struct queue_limits *, unsigned int);
void blk_queue_io_min(struct request_queue *, unsigned int);
void blk_limits_io_opt(struct queue_limits *, unsigned int);
void blk_queue_io_opt(struct request_queue *, unsigned int);
void blk_set_default_limits(struct queue_limits *);
void blk_set_stacking_limits(struct queue_limits *);
int blk_stack_limits(struct queue_limits *, struct queue_limits *, sector_t);
# 1028 "include/linux/blkdev.h"
int bdev_stack_limits(struct queue_limits *, struct block_device *, sector_t);
# 1030 "include/linux/blkdev.h"
void disk_stack_limits(struct gendisk *, struct block_device *, sector_t);
# 1032 "include/linux/blkdev.h"
void blk_queue_stack_limits(struct request_queue *, struct request_queue *);
void blk_queue_dma_pad(struct request_queue *, unsigned int);
void blk_queue_update_dma_pad(struct request_queue *, unsigned int);
int blk_queue_dma_drain(struct request_queue *, dma_drain_needed_fn *, void *, unsigned int);
# 1038 "include/linux/blkdev.h"
void blk_queue_lld_busy(struct request_queue *, lld_busy_fn *);
void blk_queue_segment_boundary(struct request_queue *, long unsigned int);
void blk_queue_prep_rq(struct request_queue *, prep_rq_fn *);
void blk_queue_unprep_rq(struct request_queue *, unprep_rq_fn *);
void blk_queue_merge_bvec(struct request_queue *, merge_bvec_fn *);
void blk_queue_dma_alignment(struct request_queue *, int);
void blk_queue_update_dma_alignment(struct request_queue *, int);
void blk_queue_softirq_done(struct request_queue *, softirq_done_fn *);
void blk_queue_rq_timed_out(struct request_queue *, rq_timed_out_fn *);
void blk_queue_rq_timeout(struct request_queue *, unsigned int);
void blk_queue_flush(struct request_queue *, unsigned int);
void blk_queue_flush_queueable(struct request_queue *, bool);
struct backing_dev_info *blk_get_backing_dev_info(struct block_device *);
# 1052 "include/linux/blkdev.h"
int blk_rq_map_sg(struct request_queue *, struct request *, struct scatterlist *);
int blk_bio_map_sg(struct request_queue *, struct bio *, struct scatterlist *);
# 1055 "include/linux/blkdev.h"
void blk_dump_rq_flags(struct request *, char *);
long int nr_blockdev_pages(void);
# 1058 "include/linux/blkdev.h"
bool blk_get_queue(struct request_queue *);
struct request_queue *blk_alloc_queue(gfp_t);
struct request_queue *blk_alloc_queue_node(gfp_t, int);
void blk_put_queue(struct request_queue *);
# 1067 "include/linux/blkdev.h"
void blk_pm_runtime_init(struct request_queue *, struct device *);
int blk_pre_runtime_suspend(struct request_queue *);
void blk_post_runtime_suspend(struct request_queue *, int);
void blk_pre_runtime_resume(struct request_queue *);
void blk_post_runtime_resume(struct request_queue *, int);
struct blk_plug
{
# 1097 "include/linux/blkdev.h"
  struct list_head list;
  struct list_head mq_list;
  struct list_head cb_list;
};
struct blk_plug_cb;
# 1104 "include/linux/blkdev.h"
typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);
struct blk_plug_cb
{
# 1106 "include/linux/blkdev.h"
  struct list_head list;
  blk_plug_cb_fn callback;
  void *data;
};
struct blk_plug_cb *blk_check_plugged(blk_plug_cb_fn, void *, int);
# 1112 "include/linux/blkdev.h"
void blk_start_plug(struct blk_plug *);
void blk_finish_plug(struct blk_plug *);
void blk_flush_plug_list(struct blk_plug *, bool);
# 1116 "include/linux/blkdev.h"
static inline void blk_flush_plug(struct task_struct *tsk)
{
  struct blk_plug *plug = ( * tsk ) . plug;
# 1120 "include/linux/blkdev.h"
  if (plug != ( ( struct blk_plug *) 0 ))
    blk_flush_plug_list ( plug , 0 );
}
# 1124 "include/linux/blkdev.h"
static inline void blk_schedule_flush_plug(struct task_struct *tsk)
{
  struct blk_plug *plug = ( * tsk ) . plug;
# 1128 "include/linux/blkdev.h"
  if (plug != ( ( struct blk_plug *) 0 ))
    blk_flush_plug_list ( plug , 1 );
}
# 1132 "include/linux/blkdev.h"
static inline bool blk_needs_flush_plug(struct task_struct *tsk)
{
  struct blk_plug *plug = ( * tsk ) . plug;
# 1136 "include/linux/blkdev.h"
  return ( bool ) ( plug != ( ( struct blk_plug *) 0 ) && ( list_empty
# 1137 "include/linux/blkdev.h"
  ( ( struct list_head const *) & ( * plug ) . list ) == 0 || list_empty
# 1138 "include/linux/blkdev.h"
  ( ( struct list_head const *) & ( * plug ) . mq_list ) == 0 || list_empty
# 1139 "include/linux/blkdev.h"
  ( ( struct list_head const *) & ( * plug ) . cb_list ) == 0 ) );
}
# 1147 "include/linux/blkdev.h"
int blk_queue_start_tag(struct request_queue *, struct request *);
struct request *blk_queue_find_tag(struct request_queue *, int);
void blk_queue_end_tag(struct request_queue *, struct request *);
int blk_queue_init_tags(struct request_queue *, int, struct blk_queue_tag *);
void blk_queue_free_tags(struct request_queue *);
int blk_queue_resize_tags(struct request_queue *, int);
void blk_queue_invalidate_tags(struct request_queue *);
struct blk_queue_tag *blk_init_tags(int);
void blk_free_tags(struct blk_queue_tag *);
# 1157 "include/linux/blkdev.h"
static inline struct request *blk_map_queue_find_tag(struct blk_queue_tag *bqt, int tag)
{
# 1160 "include/linux/blkdev.h"
  if (__builtin_expect ( bqt == ( ( struct blk_queue_tag *) 0 ) , 0L ) != 0L || __builtin_expect ( ( * bqt ) . real_max_depth <= tag , 0L ) != 0L)
    return ( ( struct request *) 0 );
  return * ( ( * bqt ) . tag_index + ( long unsigned int ) tag );
}
# 1167 "include/linux/blkdev.h"
int blkdev_issue_flush(struct block_device *, gfp_t, sector_t *);
int blkdev_issue_discard(struct block_device *, sector_t, sector_t, gfp_t, long unsigned int);
# 1170 "include/linux/blkdev.h"
int blkdev_issue_write_same(struct block_device *, sector_t, sector_t, gfp_t, struct page *);
# 1172 "include/linux/blkdev.h"
int blkdev_issue_zeroout(struct block_device *, sector_t, sector_t, gfp_t);
# 1174 "include/linux/blkdev.h"
static inline int sb_issue_discard(struct super_block *sb, sector_t block, sector_t nr_blocks, gfp_t gfp_mask, long unsigned int flags)
{
# 1177 "include/linux/blkdev.h"
  return blkdev_issue_discard ( ( * sb ) . s_bdev , block << ( int ) ( * sb ) . s_blocksize_bits + -9 , nr_blocks
# 1178 "include/linux/blkdev.h"
  << ( int ) ( * sb ) . s_blocksize_bits + -9 , gfp_mask , flags );
}
# 1181 "include/linux/blkdev.h"
static inline int sb_issue_zeroout(struct super_block *sb, sector_t block, sector_t nr_blocks, gfp_t gfp_mask)
{
# 1184 "include/linux/blkdev.h"
  return blkdev_issue_zeroout ( ( * sb ) . s_bdev , block
# 1185 "include/linux/blkdev.h"
  << ( int ) ( * sb ) . s_blocksize_bits + -9 , nr_blocks
# 1186 "include/linux/blkdev.h"
  << ( int ) ( * sb ) . s_blocksize_bits + -9 , gfp_mask );
}
# 1190 "include/linux/blkdev.h"
int blk_verify_command(unsigned char *, fmode_t);
enum blk_default_limits
{
  BLK_MAX_SEGMENTS = 128,
  BLK_SAFE_MAX_SECTORS = 255,
  BLK_DEF_MAX_SECTORS = 1024,
  BLK_MAX_SEGMENT_SIZE = 65536,
  BLK_SEG_BOUNDARY_MASK = 4294967295
};
# 1202 "include/linux/blkdev.h"
static inline long unsigned int queue_bounce_pfn(struct request_queue *q)
{
  return ( * q ) . limits . bounce_pfn;
}
# 1207 "include/linux/blkdev.h"
static inline long unsigned int queue_segment_boundary(struct request_queue *q)
{
  return ( * q ) . limits . seg_boundary_mask;
}
# 1212 "include/linux/blkdev.h"
static inline unsigned int queue_max_sectors(struct request_queue *q)
{
  return ( * q ) . limits . max_sectors;
}
# 1217 "include/linux/blkdev.h"
static inline unsigned int queue_max_hw_sectors(struct request_queue *q)
{
  return ( * q ) . limits . max_hw_sectors;
}
# 1222 "include/linux/blkdev.h"
static inline short unsigned int queue_max_segments(struct request_queue *q)
{
  return ( * q ) . limits . max_segments;
}
# 1227 "include/linux/blkdev.h"
static inline unsigned int queue_max_segment_size(struct request_queue *q)
{
  return ( * q ) . limits . max_segment_size;
}
# 1232 "include/linux/blkdev.h"
static inline short unsigned int queue_logical_block_size(struct request_queue *q)
{
  int retval = 512;
# 1236 "include/linux/blkdev.h"
  if (q != ( ( struct request_queue *) 0 ) && ( * q ) . limits . logical_block_size != 0U)
    retval = ( int ) ( * q ) . limits . logical_block_size;
# 1239 "include/linux/blkdev.h"
  return ( short unsigned int ) retval;
}
# 1242 "include/linux/blkdev.h"
static inline short unsigned int bdev_logical_block_size(struct block_device *bdev)
{
  return queue_logical_block_size ( bdev_get_queue ( bdev ) );
}
# 1247 "include/linux/blkdev.h"
static inline unsigned int queue_physical_block_size(struct request_queue *q)
{
  return ( * q ) . limits . physical_block_size;
}
# 1252 "include/linux/blkdev.h"
static inline unsigned int bdev_physical_block_size(struct block_device *bdev)
{
  return queue_physical_block_size ( bdev_get_queue ( bdev ) );
}
# 1257 "include/linux/blkdev.h"
static inline unsigned int queue_io_min(struct request_queue *q)
{
  return ( * q ) . limits . io_min;
}
# 1262 "include/linux/blkdev.h"
static inline int bdev_io_min(struct block_device *bdev)
{
  return ( int ) queue_io_min ( bdev_get_queue ( bdev ) );
}
# 1267 "include/linux/blkdev.h"
static inline unsigned int queue_io_opt(struct request_queue *q)
{
  return ( * q ) . limits . io_opt;
}
# 1272 "include/linux/blkdev.h"
static inline int bdev_io_opt(struct block_device *bdev)
{
  return ( int ) queue_io_opt ( bdev_get_queue ( bdev ) );
}
# 1277 "include/linux/blkdev.h"
static inline int queue_alignment_offset(struct request_queue *q)
{
  if (( * q ) . limits . misaligned != 0U)
    return -1;
# 1282 "include/linux/blkdev.h"
  return ( int ) ( * q ) . limits . alignment_offset;
}
# 1285 "include/linux/blkdev.h"
static inline int queue_limit_alignment_offset(struct queue_limits *lim, sector_t sector)
{
  unsigned int granularity = ({
# 1287 "include/linux/blkdev.h"
    unsigned int _max1 = ( * lim ) . physical_block_size;
# 1287 "include/linux/blkdev.h"
    unsigned int _max2 = ( * lim ) . io_min;
# 1287 "include/linux/blkdev.h"
    ( void ) 0;
# 1287 "include/linux/blkdev.h"
    ((_max1) > (_max2) ? (_max1) : (_max2));
  } );
# 1288 "include/linux/blkdev.h"
  unsigned int alignment = ( unsigned int ) sector << 9U & granularity - 1U;
# 1290 "include/linux/blkdev.h"
  return ( int ) ( ( * lim ) . alignment_offset + granularity - alignment
# 1291 "include/linux/blkdev.h"
  & granularity - 1U );
}
# 1294 "include/linux/blkdev.h"
static inline int bdev_alignment_offset(struct block_device *bdev)
{
  struct request_queue *q = bdev_get_queue ( bdev );
# 1298 "include/linux/blkdev.h"
  if (( * q ) . limits . misaligned != 0U)
    return -1;
# 1301 "include/linux/blkdev.h"
  if (( * bdev ) . bd_contains != bdev)
    return ( int ) ( * ( * bdev ) . bd_part ) . alignment_offset;
# 1304 "include/linux/blkdev.h"
  return ( int ) ( * q ) . limits . alignment_offset;
}
# 1307 "include/linux/blkdev.h"
static inline int queue_discard_alignment(struct request_queue *q)
{
  if (( * q ) . limits . discard_misaligned != 0U)
    return -1;
# 1312 "include/linux/blkdev.h"
  return ( int ) ( * q ) . limits . discard_alignment;
}
# 1315 "include/linux/blkdev.h"
static inline int queue_limit_discard_alignment(struct queue_limits *lim, sector_t sector)
{
  unsigned int alignment;
# 1317 "include/linux/blkdev.h"
  unsigned int granularity;
# 1317 "include/linux/blkdev.h"
  unsigned int offset;
# 1319 "include/linux/blkdev.h"
  if (( * lim ) . max_discard_sectors == 0U)
    return 0;
# 1323 "include/linux/blkdev.h"
  alignment = ( * lim ) . discard_alignment >> 9;
  granularity = ( * lim ) . discard_granularity >> 9;
  if (granularity == 0U)
    return 0;
# 1329 "include/linux/blkdev.h"
  offset = ( unsigned int ) ({
# 1329 "include/linux/blkdev.h"
    int _res;
# 1329 "include/linux/blkdev.h"
    _res = ( int ) ( sector % ( sector_t ) granularity );
# 1329 "include/linux/blkdev.h"
    sector /= ( sector_t ) granularity;
# 1329 "include/linux/blkdev.h"
    _res;
  } );
# 1332 "include/linux/blkdev.h"
  offset = ( granularity + alignment - offset ) % granularity;
# 1335 "include/linux/blkdev.h"
  return ( int ) ( offset << 9 );
}
# 1338 "include/linux/blkdev.h"
static inline int bdev_discard_alignment(struct block_device *bdev)
{
  struct request_queue *q = bdev_get_queue ( bdev );
# 1342 "include/linux/blkdev.h"
  if (( * bdev ) . bd_contains != bdev)
    return ( int ) ( * ( * bdev ) . bd_part ) . discard_alignment;
# 1345 "include/linux/blkdev.h"
  return ( int ) ( * q ) . limits . discard_alignment;
}
# 1348 "include/linux/blkdev.h"
static inline unsigned int queue_discard_zeroes_data(struct request_queue *q)
{
  if (( * q ) . limits . max_discard_sectors != 0U && ( * q ) . limits . discard_zeroes_data == 1U)
    return 1U;
# 1353 "include/linux/blkdev.h"
  return 0U;
}
# 1356 "include/linux/blkdev.h"
static inline unsigned int bdev_discard_zeroes_data(struct block_device *bdev)
{
  return queue_discard_zeroes_data ( bdev_get_queue ( bdev ) );
}
# 1361 "include/linux/blkdev.h"
static inline unsigned int bdev_write_same(struct block_device *bdev)
{
  struct request_queue *q = bdev_get_queue ( bdev );
# 1365 "include/linux/blkdev.h"
  if (q != ( ( struct request_queue *) 0 ))
    return ( * q ) . limits . max_write_same_sectors;
# 1368 "include/linux/blkdev.h"
  return 0U;
}
# 1371 "include/linux/blkdev.h"
static inline int queue_dma_alignment(struct request_queue *q)
{
  return q != ( ( struct request_queue *) 0 ) ? ( int ) ( * q ) . dma_alignment : 511;
}
# 1376 "include/linux/blkdev.h"
static inline int blk_rq_aligned(struct request_queue *q, long unsigned int addr, unsigned int len)
{
# 1379 "include/linux/blkdev.h"
  unsigned int alignment = ( unsigned int ) queue_dma_alignment ( q ) | ( * q ) . dma_pad_mask;
  return ( ( long unsigned int ) alignment & addr ) == 0UL && ( len & alignment ) == 0U;
}
# 1384 "include/linux/blkdev.h"
static inline unsigned int blksize_bits(unsigned int size)
{
  unsigned int bits = 8U;
  ldv_31630:;
  bits ++;
  size >>= 1;
  if (size > 256U)
  {
    goto ldv_31630;
  }
  else
    goto ldv_31631;
  ldv_31631:;
# 1391 "include/linux/blkdev.h"
  return bits;
}
# 1394 "include/linux/blkdev.h"
static inline unsigned int block_size(struct block_device *bdev)
{
  return ( * bdev ) . bd_block_size;
}
# 1399 "include/linux/blkdev.h"
static inline bool queue_flush_queueable(struct request_queue *q)
{
  return ( ( * ( ( unsigned char *) & * q + 3064UL ) ) ) == 0U;
}
# 1404 "include/linux/blkdev.h"
typedef struct
{
# 1404 "include/linux/blkdev.h"
  struct page *v;
} Sector;
unsigned char *read_dev_sector(struct block_device *, sector_t, Sector *);
# 1408 "include/linux/blkdev.h"
static inline void put_dev_sector(Sector p)
{
  put_page ( p . v );
}
# 1414 "include/linux/blkdev.h"
int kblockd_schedule_work(struct work_struct *);
int kblockd_schedule_delayed_work(struct delayed_work *, long unsigned int);
int kblockd_schedule_delayed_work_on(int, struct delayed_work *, long unsigned int);
# 1424 "include/linux/blkdev.h"
static inline void set_start_time_ns(struct request *req)
{
  __preempt_count_add ( 1 );
# 1426 "include/linux/blkdev.h"
  asm volatile ( "" : : : "memory" ) ;
  ( * req ) . start_time_ns = sched_clock ( );
  asm volatile ( "" : : : "memory" ) ;
# 1428 "include/linux/blkdev.h"
  __preempt_count_sub ( 1 );
}
# 1431 "include/linux/blkdev.h"
static inline void set_io_start_time_ns(struct request *req)
{
  __preempt_count_add ( 1 );
# 1433 "include/linux/blkdev.h"
  asm volatile ( "" : : : "memory" ) ;
  ( * req ) . io_start_time_ns = sched_clock ( );
  asm volatile ( "" : : : "memory" ) ;
# 1435 "include/linux/blkdev.h"
  __preempt_count_sub ( 1 );
}
# 1438 "include/linux/blkdev.h"
static inline uint64_t rq_start_time_ns(struct request *req)
{
  return ( uint64_t ) ( * req ) . start_time_ns;
}
# 1443 "include/linux/blkdev.h"
static inline uint64_t rq_io_start_time_ns(struct request *req)
{
  return ( uint64_t ) ( * req ) . io_start_time_ns;
}
struct blk_integrity_exchg
{
# 1471 "include/linux/blkdev.h"
  void *prot_buf;
  void *data_buf;
  sector_t sector;
  unsigned int data_size;
  short unsigned int sector_size;
  char const *disk_name;
};
# 1479 "include/linux/blkdev.h"
typedef void integrity_gen_fn(struct blk_integrity_exchg *);
typedef int integrity_vrfy_fn(struct blk_integrity_exchg *);
typedef void integrity_set_tag_fn(void *, void *, unsigned int);
typedef void integrity_get_tag_fn(void *, void *, unsigned int);
struct blk_integrity
{
  integrity_gen_fn *generate_fn;
  integrity_vrfy_fn *verify_fn;
  integrity_set_tag_fn *set_tag_fn;
  integrity_get_tag_fn *get_tag_fn;
# 1490 "include/linux/blkdev.h"
  short unsigned int flags;
  short unsigned int tuple_size;
  short unsigned int sector_size;
  short unsigned int tag_size;
# 1495 "include/linux/blkdev.h"
  char const *name;
# 1497 "include/linux/blkdev.h"
  struct kobject kobj;
};
# 1500 "include/linux/blkdev.h"
bool blk_integrity_is_initialized(struct gendisk *);
int blk_integrity_register(struct gendisk *, struct blk_integrity *);
void blk_integrity_unregister(struct gendisk *);
int blk_integrity_compare(struct gendisk *, struct gendisk *);
int blk_rq_map_integrity_sg(struct request_queue *, struct bio *, struct scatterlist *);
# 1506 "include/linux/blkdev.h"
int blk_rq_count_integrity_sg(struct request_queue *, struct bio *);
int blk_integrity_merge_rq(struct request_queue *, struct request *, struct request *);
# 1509 "include/linux/blkdev.h"
int blk_integrity_merge_bio(struct request_queue *, struct request *, struct bio *);
# 1513 "include/linux/blkdev.h"
static inline struct blk_integrity *bdev_get_integrity(struct block_device *bdev)
{
  return ( * ( * bdev ) . bd_disk ) . integrity;
}
# 1518 "include/linux/blkdev.h"
static inline struct blk_integrity *blk_get_integrity(struct gendisk *disk)
{
  return ( * disk ) . integrity;
}
# 1523 "include/linux/blkdev.h"
static inline int blk_integrity_rq(struct request *rq)
{
  if (( * rq ) . bio == ( ( struct bio *) 0 ))
    return 0;
# 1528 "include/linux/blkdev.h"
  return ( * ( * rq ) . bio ) . bi_integrity != ( ( struct bio_integrity_payload *) 0 );
}
# 1531 "include/linux/blkdev.h"
static inline void blk_queue_max_integrity_segments(struct request_queue *q, unsigned int segs)
{
# 1534 "include/linux/blkdev.h"
  ( * q ) . limits . max_integrity_segments = ( short unsigned int ) segs;
}
# 1538 "include/linux/blkdev.h"
static inline short unsigned int queue_max_integrity_segments(struct request_queue *q)
{
  return ( * q ) . limits . max_integrity_segments;
}
struct block_device_operations
{
# 1613 "include/linux/blkdev.h"
  int (*open)(struct block_device *, fmode_t);
  void (*release)(struct gendisk *, fmode_t);
  int (*rw_page)(struct block_device *, sector_t, struct page *, int);
  int (*ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
  int (*compat_ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
  int (*direct_access)(struct block_device *, sector_t, void **, long unsigned int *);
# 1620 "include/linux/blkdev.h"
  unsigned int (*check_events)(struct gendisk *, unsigned int);
# 1623 "include/linux/blkdev.h"
  int (*media_changed)(struct gendisk *);
  void (*unlock_native_capacity)(struct gendisk *);
  int (*revalidate_disk)(struct gendisk *);
  int (*getgeo)(struct block_device *, struct hd_geometry *);
# 1628 "include/linux/blkdev.h"
  void (*swap_slot_free_notify)(struct block_device *, long unsigned int);
  struct module *owner;
};
# 1632 "include/linux/blkdev.h"
int __blkdev_driver_ioctl(struct block_device *, fmode_t, unsigned int, long unsigned int);
# 1634 "include/linux/blkdev.h"
int bdev_read_page(struct block_device *, sector_t, struct page *);
int bdev_write_page(struct block_device *, sector_t, struct page *, struct writeback_control *);
struct sg_table
{
# 13 "include/linux/scatterlist.h"
  struct scatterlist *sgl;
  unsigned int nents;
  unsigned int orig_nents;
};
# 57 "include/linux/scatterlist.h"
static inline void sg_assign_page(struct scatterlist *sg, struct page *page)
{
  long unsigned int page_link = ( * sg ) . page_link & 3UL;
# 65 "include/linux/scatterlist.h"
  if (__builtin_expect ( ( ( long unsigned int ) page & 3UL ) != 0UL , 0L ) != 0L)
  {
# 65 "include/linux/scatterlist.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/scatterlist.h" ) , "i" ( 65 ) , "i" ( 12UL ) ) ;
    ldv_31804:;
# 65 "include/linux/scatterlist.h"
    goto ldv_31804;
  }
  if (__builtin_expect ( ( * sg ) . sg_magic != 2271560481UL , 0L ) != 0L)
  {
# 67 "include/linux/scatterlist.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/scatterlist.h" ) , "i" ( 67 ) , "i" ( 12UL ) ) ;
    ldv_31805:;
# 67 "include/linux/scatterlist.h"
    goto ldv_31805;
  }
# 68 "include/linux/scatterlist.h"
  if (__builtin_expect ( ( long int ) ( int ) ( * sg ) . page_link & 1L , 0L ) != 0L)
  {
# 68 "include/linux/scatterlist.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/scatterlist.h" ) , "i" ( 68 ) , "i" ( 12UL ) ) ;
    ldv_31806:;
# 68 "include/linux/scatterlist.h"
    goto ldv_31806;
  }
  ( * sg ) . page_link = page_link | ( long unsigned int ) page;
}
# 87 "include/linux/scatterlist.h"
static inline void sg_set_page(struct scatterlist *sg, struct page *page, unsigned int len, unsigned int offset)
{
# 90 "include/linux/scatterlist.h"
  sg_assign_page ( sg , page );
  ( * sg ) . offset = offset;
  ( * sg ) . length = len;
}
# 95 "include/linux/scatterlist.h"
static inline struct page *sg_page(struct scatterlist *sg)
{
# 98 "include/linux/scatterlist.h"
  if (__builtin_expect ( ( * sg ) . sg_magic != 2271560481UL , 0L ) != 0L)
  {
# 98 "include/linux/scatterlist.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/scatterlist.h" ) , "i" ( 98 ) , "i" ( 12UL ) ) ;
    ldv_31816:;
# 98 "include/linux/scatterlist.h"
    goto ldv_31816;
  }
# 99 "include/linux/scatterlist.h"
  if (__builtin_expect ( ( long int ) ( int ) ( * sg ) . page_link & 1L , 0L ) != 0L)
  {
# 99 "include/linux/scatterlist.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/scatterlist.h" ) , "i" ( 99 ) , "i" ( 12UL ) ) ;
    ldv_31817:;
# 99 "include/linux/scatterlist.h"
    goto ldv_31817;
  }
  return ( struct page *) ( ( * sg ) . page_link & 18446744073709551612UL );
}
# 111 "include/linux/scatterlist.h"
static inline void sg_set_buf(struct scatterlist *sg, void const *buf, unsigned int buflen)
{
# 115 "include/linux/scatterlist.h"
  if (__builtin_expect ( ( long int ) ! ( _Bool ) __virt_addr_valid ( ( long unsigned int ) buf ) , 0L ) != 0L)
  {
# 115 "include/linux/scatterlist.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/scatterlist.h" ) , "i" ( 115 ) , "i" ( 12UL ) ) ;
    ldv_31823:;
# 115 "include/linux/scatterlist.h"
    goto ldv_31823;
  }
  sg_set_page ( sg , ( ( struct page *) -24189255811072 ) + ( __phys_addr ( ( long unsigned int ) buf ) >> 12 ) , buflen , ( unsigned int ) ( long int ) buf & 4095U );
}
# 136 "include/linux/scatterlist.h"
static inline void sg_chain(struct scatterlist *prv, unsigned int prv_nents, struct scatterlist *sgl)
{
# 146 "include/linux/scatterlist.h"
  ( * ( prv + ( long unsigned int ) ( prv_nents - 1U ) ) ) . offset = 0U;
  ( * ( prv + ( long unsigned int ) ( prv_nents - 1U ) ) ) . length = 0U;
# 153 "include/linux/scatterlist.h"
  ( * ( prv + ( long unsigned int ) ( prv_nents - 1U ) ) ) . page_link = ( long unsigned int ) sgl & 18446744073709551612UL | 1UL;
}
# 165 "include/linux/scatterlist.h"
static inline void sg_mark_end(struct scatterlist *sg)
{
# 168 "include/linux/scatterlist.h"
  if (__builtin_expect ( ( * sg ) . sg_magic != 2271560481UL , 0L ) != 0L)
  {
# 168 "include/linux/scatterlist.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/scatterlist.h" ) , "i" ( 168 ) , "i" ( 12UL ) ) ;
    ldv_31832:;
# 168 "include/linux/scatterlist.h"
    goto ldv_31832;
  }
# 173 "include/linux/scatterlist.h"
  ( * sg ) . page_link |= 2UL;
  ( * sg ) . page_link &= 18446744073709551614UL;
}
# 185 "include/linux/scatterlist.h"
static inline void sg_unmark_end(struct scatterlist *sg)
{
# 188 "include/linux/scatterlist.h"
  if (__builtin_expect ( ( * sg ) . sg_magic != 2271560481UL , 0L ) != 0L)
  {
# 188 "include/linux/scatterlist.h"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "include/linux/scatterlist.h" ) , "i" ( 188 ) , "i" ( 12UL ) ) ;
    ldv_31836:;
# 188 "include/linux/scatterlist.h"
    goto ldv_31836;
  }
  ( * sg ) . page_link &= 18446744073709551613UL;
}
# 203 "include/linux/scatterlist.h"
static inline dma_addr_t sg_phys(struct scatterlist *sg)
{
  return ( dma_addr_t ) ( ( ( long long unsigned int ) ( ( ( long int ) sg_page ( sg ) + 24189255811072L ) / 64L ) << 12 ) + ( long long unsigned int ) ( * sg ) . offset );
}
# 218 "include/linux/scatterlist.h"
static inline void *sg_virt(struct scatterlist *sg)
{
  return lowmem_page_address ( ( struct page const *) sg_page ( sg ) ) + ( long unsigned int ) ( * sg ) . offset;
}
# 223 "include/linux/scatterlist.h"
int sg_nents(struct scatterlist *);
struct scatterlist *sg_next(struct scatterlist *);
struct scatterlist *sg_last(struct scatterlist *, unsigned int);
void sg_init_table(struct scatterlist *, unsigned int);
void sg_init_one(struct scatterlist *, void const *, unsigned int);
# 229 "include/linux/scatterlist.h"
typedef struct scatterlist *sg_alloc_fn(unsigned int, gfp_t);
typedef void sg_free_fn(struct scatterlist *, unsigned int);
# 232 "include/linux/scatterlist.h"
void __sg_free_table(struct sg_table *, unsigned int, bool, sg_free_fn *);
void sg_free_table(struct sg_table *);
int __sg_alloc_table(struct sg_table *, unsigned int, unsigned int, struct scatterlist *, gfp_t, sg_alloc_fn *);
# 236 "include/linux/scatterlist.h"
int sg_alloc_table(struct sg_table *, unsigned int, gfp_t);
int sg_alloc_table_from_pages(struct sg_table *, struct page **, unsigned int, long unsigned int, long unsigned int, gfp_t);
# 242 "include/linux/scatterlist.h"
size_t sg_copy_from_buffer(struct scatterlist *, unsigned int, void *, size_t);
# 244 "include/linux/scatterlist.h"
size_t sg_copy_to_buffer(struct scatterlist *, unsigned int, void *, size_t);
# 247 "include/linux/scatterlist.h"
size_t sg_pcopy_from_buffer(struct scatterlist *, unsigned int, void *, size_t, off_t);
# 249 "include/linux/scatterlist.h"
size_t sg_pcopy_to_buffer(struct scatterlist *, unsigned int, void *, size_t, off_t);
struct sg_page_iter
{
# 269 "include/linux/scatterlist.h"
  struct scatterlist *sg;
  unsigned int sg_pgoffset;
# 273 "include/linux/scatterlist.h"
  unsigned int __nents;
  int __pg_advance;
};
# 278 "include/linux/scatterlist.h"
bool __sg_page_iter_next(struct sg_page_iter *);
void __sg_page_iter_start(struct sg_page_iter *, struct scatterlist *, unsigned int, long unsigned int);
# 286 "include/linux/scatterlist.h"
static inline struct page *sg_page_iter_page(struct sg_page_iter *piter)
{
  return ( ( struct page *) -24189255811072 ) + ( ( long unsigned int ) ( ( ( long int ) sg_page ( ( * piter ) . sg ) + 24189255811072L ) / 64L ) + ( long unsigned int ) ( * piter ) . sg_pgoffset );
}
# 296 "include/linux/scatterlist.h"
static inline dma_addr_t sg_page_iter_dma_address(struct sg_page_iter *piter)
{
  return ( * ( * piter ) . sg ) . dma_address + ( dma_addr_t ) ( ( * piter ) . sg_pgoffset << 12 );
}
struct sg_mapping_iter
{
# 334 "include/linux/scatterlist.h"
  struct page *page;
  void *addr;
  size_t length;
  size_t consumed;
  struct sg_page_iter piter;
# 341 "include/linux/scatterlist.h"
  unsigned int __offset;
  unsigned int __remaining;
  unsigned int __flags;
};
# 346 "include/linux/scatterlist.h"
void sg_miter_start(struct sg_mapping_iter *, struct scatterlist *, unsigned int, unsigned int);
# 348 "include/linux/scatterlist.h"
bool sg_miter_skip(struct sg_mapping_iter *, off_t);
bool sg_miter_next(struct sg_mapping_iter *);
void sg_miter_stop(struct sg_mapping_iter *);
struct ms_status_register
{
# 22 "include/linux/memstick.h"
  unsigned char reserved;
  unsigned char interrupt;
# 31 "include/linux/memstick.h"
  unsigned char status0;
# 39 "include/linux/memstick.h"
  unsigned char status1;
};
struct ms_id_register
{
# 51 "include/linux/memstick.h"
  unsigned char type;
  unsigned char if_mode;
  unsigned char category;
  unsigned char class;
};
struct ms_param_register
{
  unsigned char system;
# 62 "include/linux/memstick.h"
  unsigned char block_address_msb;
  short unsigned int block_address;
  unsigned char cp;
# 70 "include/linux/memstick.h"
  unsigned char page_address;
};
struct ms_extra_data_register
{
  unsigned char overwrite_flag;
# 80 "include/linux/memstick.h"
  unsigned char management_flag;
# 86 "include/linux/memstick.h"
  short unsigned int logical_address;
};
struct ms_register
{
  struct ms_status_register status;
  struct ms_id_register id;
  unsigned char reserved[8U];
  struct ms_param_register param;
  struct ms_extra_data_register extra_data;
};
struct mspro_param_register
{
  unsigned char system;
# 103 "include/linux/memstick.h"
  __be16 data_count;
  __be32 data_address;
  unsigned char tpc_param;
};
struct mspro_io_info_register
{
  unsigned char version;
  unsigned char io_category;
  unsigned char current_req;
  unsigned char card_opt_info;
  unsigned char rdy_wait_time;
};
struct mspro_io_func_register
{
  unsigned char func_enable;
  unsigned char func_select;
  unsigned char func_intmask;
  unsigned char transfer_mode;
};
struct mspro_io_cmd_register
{
  short unsigned int tpc_param;
  short unsigned int data_count;
  unsigned int data_address;
};
struct mspro_register
{
  struct ms_status_register status;
  struct ms_id_register id;
  unsigned char reserved0[8U];
  struct mspro_param_register param;
  unsigned char reserved1[8U];
  struct mspro_io_info_register io_info;
  struct mspro_io_func_register io_func;
  unsigned char reserved2[7U];
  struct mspro_io_cmd_register io_cmd;
  unsigned char io_int;
  unsigned char io_int_func;
};
struct ms_register_addr
{
  unsigned char r_offset;
  unsigned char r_length;
  unsigned char w_offset;
  unsigned char w_length;
};
enum memstick_tpc
{
  MS_TPC_READ_MG_STATUS = 1,
  MS_TPC_READ_LONG_DATA = 2,
  MS_TPC_READ_SHORT_DATA = 3,
  MS_TPC_READ_MG_DATA = 3,
  MS_TPC_READ_REG = 4,
  MS_TPC_READ_QUAD_DATA = 5,
  MS_TPC_READ_IO_DATA = 5,
  MS_TPC_GET_INT = 7,
  MS_TPC_SET_RW_REG_ADRS = 8,
  MS_TPC_EX_SET_CMD = 9,
  MS_TPC_WRITE_QUAD_DATA = 10,
  MS_TPC_WRITE_IO_DATA = 10,
  MS_TPC_WRITE_REG = 11,
  MS_TPC_WRITE_SHORT_DATA = 12,
  MS_TPC_WRITE_MG_DATA = 12,
  MS_TPC_WRITE_LONG_DATA = 13,
  MS_TPC_SET_CMD = 14
};
enum memstick_command
{
  MS_CMD_BLOCK_END = 51,
  MS_CMD_RESET = 60,
  MS_CMD_BLOCK_WRITE = 85,
  MS_CMD_SLEEP = 90,
  MS_CMD_BLOCK_ERASE = 153,
  MS_CMD_BLOCK_READ = 170,
  MS_CMD_CLEAR_BUF = 195,
  MS_CMD_FLASH_STOP = 204,
  MS_CMD_LOAD_ID = 96,
  MS_CMD_CMP_ICV = 127,
  MSPRO_CMD_FORMAT = 16,
  MSPRO_CMD_SLEEP = 17,
  MSPRO_CMD_WAKEUP = 18,
  MSPRO_CMD_READ_DATA = 32,
  MSPRO_CMD_WRITE_DATA = 33,
  MSPRO_CMD_READ_ATRB = 36,
  MSPRO_CMD_STOP = 37,
  MSPRO_CMD_ERASE = 38,
  MSPRO_CMD_READ_QUAD = 39,
  MSPRO_CMD_WRITE_QUAD = 40,
  MSPRO_CMD_SET_IBD = 70,
  MSPRO_CMD_GET_IBD = 71,
  MSPRO_CMD_IN_IO_DATA = 176,
  MSPRO_CMD_OUT_IO_DATA = 177,
  MSPRO_CMD_READ_IO_ATRB = 178,
  MSPRO_CMD_IN_IO_FIFO = 179,
  MSPRO_CMD_OUT_IO_FIFO = 180,
  MSPRO_CMD_IN_IOM = 181,
  MSPRO_CMD_OUT_IOM = 182
};
enum memstick_param
{
  MEMSTICK_POWER = 1,
  MEMSTICK_INTERFACE = 2
};
struct memstick_host;
struct memstick_driver;
struct memstick_device_id
{
# 217 "include/linux/memstick.h"
  unsigned char match_flags;
# 220 "include/linux/memstick.h"
  unsigned char type;
# 225 "include/linux/memstick.h"
  unsigned char category;
# 231 "include/linux/memstick.h"
  unsigned char class;
};
struct memstick_request
{
# 240 "include/linux/memstick.h"
  unsigned char tpc;
  unsigned char data_dir : 1;
  unsigned char need_card_int : 1;
  unsigned char long_data : 1;
  unsigned char int_reg;
  int error;
# 252 "include/linux/memstick.h"
  union
  {
# 247 "include/linux/memstick.h"
    struct scatterlist sg;
# 251 "include/linux/memstick.h"
    struct
    {
# 249 "include/linux/memstick.h"
      unsigned char data_len;
      unsigned char data[15U];
    } ldv_32082;
  } ldv_32083;
};
struct memstick_dev
{
  struct memstick_device_id id;
  struct memstick_host *host;
  struct ms_register_addr reg_addr;
  struct completion mrq_complete;
  struct memstick_request current_mrq;
# 263 "include/linux/memstick.h"
  int (*check)(struct memstick_dev *);
# 265 "include/linux/memstick.h"
  int (*next_request)(struct memstick_dev *, struct memstick_request **);
# 268 "include/linux/memstick.h"
  void (*stop)(struct memstick_dev *);
# 270 "include/linux/memstick.h"
  void (*start)(struct memstick_dev *);
# 272 "include/linux/memstick.h"
  struct device dev;
};
struct memstick_host
{
  struct mutex lock;
  unsigned int id;
  unsigned int caps;
# 283 "include/linux/memstick.h"
  struct work_struct media_checker;
  struct device dev;
# 286 "include/linux/memstick.h"
  struct memstick_dev *card;
  unsigned int retries;
# 290 "include/linux/memstick.h"
  void (*request)(struct memstick_host *);
# 292 "include/linux/memstick.h"
  int (*set_param)(struct memstick_host *, enum memstick_param, int);
# 295 "include/linux/memstick.h"
  long unsigned int private[0U];
};
struct memstick_driver
{
  struct memstick_device_id *id_table;
  int (*probe)(struct memstick_dev *);
  void (*remove)(struct memstick_dev *);
  int (*suspend)(struct memstick_dev *, pm_message_t);
# 304 "include/linux/memstick.h"
  int (*resume)(struct memstick_dev *);
# 306 "include/linux/memstick.h"
  struct device_driver driver;
};
# 309 "include/linux/memstick.h"
int memstick_register_driver(struct memstick_driver *);
void memstick_unregister_driver(struct memstick_driver *);
# 312 "include/linux/memstick.h"
struct memstick_host *memstick_alloc_host(unsigned int, struct device *);
# 315 "include/linux/memstick.h"
int memstick_add_host(struct memstick_host *);
void memstick_remove_host(struct memstick_host *);
void memstick_free_host(struct memstick_host *);
void memstick_detect_change(struct memstick_host *);
void memstick_suspend_host(struct memstick_host *);
void memstick_resume_host(struct memstick_host *);
# 322 "include/linux/memstick.h"
void memstick_init_req_sg(struct memstick_request *, unsigned char, struct scatterlist const *);
# 324 "include/linux/memstick.h"
void memstick_init_req(struct memstick_request *, unsigned char, void const *, size_t);
# 326 "include/linux/memstick.h"
int memstick_next_req(struct memstick_host *, struct memstick_request **);
# 328 "include/linux/memstick.h"
void memstick_new_req(struct memstick_host *);
# 330 "include/linux/memstick.h"
int memstick_set_rw_addr(struct memstick_dev *);
# 332 "include/linux/memstick.h"
static inline void *memstick_priv(struct memstick_host *host)
{
  return ( void *) & ( * host ) . private;
}
# 337 "include/linux/memstick.h"
static inline void *memstick_get_drvdata(struct memstick_dev *card)
{
  return dev_get_drvdata ( ( struct device const *) & ( * card ) . dev );
}
# 342 "include/linux/memstick.h"
static inline void memstick_set_drvdata(struct memstick_dev *card, void *data)
{
  dev_set_drvdata ( & ( * card ) . dev , data );
}
union ide_reg_valid_s
{
# 37 "./include/uapi/linux/hdreg.h"
  short unsigned int all;
# 56 "./include/uapi/linux/hdreg.h"
  struct
  {
# 39 "./include/uapi/linux/hdreg.h"
    unsigned char data : 1;
    unsigned char error_feature : 1;
    unsigned char sector : 1;
    unsigned char nsector : 1;
    unsigned char lcyl : 1;
    unsigned char hcyl : 1;
    unsigned char select : 1;
    unsigned char status_command : 1;
# 48 "./include/uapi/linux/hdreg.h"
    unsigned char data_hob : 1;
    unsigned char error_feature_hob : 1;
    unsigned char sector_hob : 1;
    unsigned char nsector_hob : 1;
    unsigned char lcyl_hob : 1;
    unsigned char hcyl_hob : 1;
    unsigned char select_hob : 1;
    unsigned char control_hob : 1;
  } b;
};
# 57 "./include/uapi/linux/hdreg.h"
typedef union ide_reg_valid_s ide_reg_valid_t;
struct ide_task_request_s
{
  __u8 io_ports[8U];
  __u8 hob_ports[8U];
  ide_reg_valid_t out_flags;
  ide_reg_valid_t in_flags;
  int data_phase;
  int req_cmd;
  long unsigned int out_size;
  long unsigned int in_size;
};
# 68 "./include/uapi/linux/hdreg.h"
typedef struct ide_task_request_s ide_task_request_t;
struct ide_ioctl_request_s
{
  ide_task_request_t *task_request;
  unsigned char *out_buffer;
  unsigned char *in_buffer;
};
# 74 "./include/uapi/linux/hdreg.h"
typedef struct ide_ioctl_request_s ide_ioctl_request_t;
struct hd_drive_cmd_hdr
{
  __u8 command;
  __u8 sector_number;
  __u8 feature;
  __u8 sector_count;
};
struct hd_geometry
{
# 324 "./include/uapi/linux/hdreg.h"
  unsigned char heads;
  unsigned char sectors;
  short unsigned int cylinders;
  long unsigned int start;
};
enum ldv_25417
{
  BUSSTATE_OFF = 0,
  BUSSTATE_ON = 1,
  BUSSTATE_TRISTATE = 2
};
# 12 "include/linux/delay.h"
extern long unsigned int loops_per_jiffy;
# 5 "include/asm-generic/delay.h"
void __bad_udelay(void);
void __bad_ndelay(void);
# 8 "include/asm-generic/delay.h"
void __udelay(long unsigned int);
void __ndelay(long unsigned int);
void __const_udelay(long unsigned int);
void __delay(long unsigned int);
# 6 "./arch/x86/include/asm/delay.h"
void use_tsc_delay(void);
# 44 "include/linux/delay.h"
extern long unsigned int lpj_fine;
void calibrate_delay(void);
void msleep(unsigned int);
long unsigned int msleep_interruptible(unsigned int);
void usleep_range(long unsigned int, long unsigned int);
# 50 "include/linux/delay.h"
static inline void ssleep(unsigned int seconds)
{
  msleep ( seconds * 1000U );
}
struct rand_pool_info
{
# 38 "include/uapi/linux/random.h"
  int entropy_count;
  int buf_size;
  __u32 buf[0U];
};
# 11 "include/linux/random.h"
void add_device_randomness(void const *, unsigned int);
void add_input_randomness(unsigned int, unsigned int, unsigned int);
# 14 "include/linux/random.h"
void add_interrupt_randomness(int, int);
# 16 "include/linux/random.h"
void get_random_bytes(void *, int);
void get_random_bytes_arch(void *, int);
void generate_random_uuid(unsigned char *);
int random_int_secret_init(void);
# 25 "include/linux/random.h"
unsigned int get_random_int(void);
long unsigned int randomize_range(long unsigned int, long unsigned int, long unsigned int);
# 28 "include/linux/random.h"
u32 prandom_u32(void);
void prandom_bytes(void *, int);
void prandom_seed(u32);
void prandom_reseed_late(void);
struct rnd_state
{
  __u32 s1;
# 34 "include/linux/random.h"
  __u32 s2;
# 34 "include/linux/random.h"
  __u32 s3;
# 34 "include/linux/random.h"
  __u32 s4;
};
# 37 "include/linux/random.h"
u32 prandom_u32_state(struct rnd_state *);
void prandom_bytes_state(struct rnd_state *, void *, int);
# 52 "include/linux/random.h"
static inline u32 prandom_u32_max(u32 ep_ro)
{
  return ( u32 ) ( ( long long unsigned int ) prandom_u32 ( ) * ( long long unsigned int ) ep_ro >> 32 );
}
# 60 "include/linux/random.h"
static inline u32 __seed(u32 x, u32 m)
{
  return x < m ? x + m : x;
}
# 70 "include/linux/random.h"
static inline void prandom_seed_state(struct rnd_state *state, u64 seed)
{
  u32 i = ( u32 ) ( seed >> 32 ) ^ ( u32 ) seed << 10U ^ ( u32 ) seed;
# 74 "include/linux/random.h"
  ( * state ) . s1 = __seed ( i , 2U );
  ( * state ) . s2 = __seed ( i , 8U );
  ( * state ) . s3 = __seed ( i , 16U );
  ( * state ) . s4 = __seed ( i , 128U );
}
# 46 "./arch/x86/include/asm/archrandom.h"
static inline int rdrand_long(long unsigned int *v)
{
  int ok;
  asm volatile ( "1: .byte 0x48,0x0f,0xc7,0xf0\n\tjc 2f\n\tdecl %0\n\tjnz 1b\n\t2:" : "=r" ( ok ) , "=a" (
# 54 "./arch/x86/include/asm/archrandom.h"
  * v ) : "0" ( 10 ) ) ;
# 56 "./arch/x86/include/asm/archrandom.h"
  return ok;
}
# 60 "./arch/x86/include/asm/archrandom.h"
static inline bool rdseed_long(long unsigned int *v)
{
  unsigned char ok;
  asm volatile ( ".byte 0x48,0x0f,0xc7,0xf8\n\tsetc %0" : "=qm" ( ok ) , "=a" (
# 65 "./arch/x86/include/asm/archrandom.h"
  * v ) ) ;
  return ok != 0U;
}
# 101 "./arch/x86/include/asm/archrandom.h"
static inline int arch_get_random_long(long unsigned int *v)
{
# 101 "./arch/x86/include/asm/archrandom.h"
  int ok;
# 101 "./arch/x86/include/asm/archrandom.h"
  asm volatile ( "661:\n\tmovl $0, %0\n\t.byte 0x66,0x66,0x90,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 4*32+30)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t\n1: .byte 0x48,0x0f,0xc7,0xf0\n\tjc 2f\n\tdecl %0\n\tjnz 1b\n\t2:\n6641:\n\t.popsection" : "=r" ( ok ) , "=a" ( * v ) : "i" ( 0 ) , "0" ( 10 ) ) ;
# 101 "./arch/x86/include/asm/archrandom.h"
  return ok;
}
# 102 "./arch/x86/include/asm/archrandom.h"
static inline int arch_get_random_int(unsigned int *v)
{
# 102 "./arch/x86/include/asm/archrandom.h"
  int ok;
# 102 "./arch/x86/include/asm/archrandom.h"
  asm volatile ( "661:\n\tmovl $0, %0\n\t.byte 0x66,0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 4*32+30)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t\n1: .byte 0x0f,0xc7,0xf0\n\tjc 2f\n\tdecl %0\n\tjnz 1b\n\t2:\n6641:\n\t.popsection" : "=r" ( ok ) , "=a" ( * v ) : "i" ( 0 ) , "0" ( 10 ) ) ;
# 102 "./arch/x86/include/asm/archrandom.h"
  return ok;
}
static inline int arch_get_random_seed_long(long unsigned int *v)
{
# 104 "./arch/x86/include/asm/archrandom.h"
  unsigned char ok;
# 104 "./arch/x86/include/asm/archrandom.h"
  asm volatile ( "661:\n\tmovb $0, %0\n\t.byte 0x66,0x66,0x90,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+18)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x48,0x0f,0xc7,0xf8\n\tsetc %0\n6641:\n\t.popsection" : "=q" ( ok ) , "=a" ( * v ) : "i" ( 0 ) ) ;
# 104 "./arch/x86/include/asm/archrandom.h"
  return ( int ) ok;
}
# 105 "./arch/x86/include/asm/archrandom.h"
static inline int arch_get_random_seed_int(unsigned int *v)
{
# 105 "./arch/x86/include/asm/archrandom.h"
  unsigned char ok;
# 105 "./arch/x86/include/asm/archrandom.h"
  asm volatile ( "661:\n\tmovb $0, %0\n\t.byte 0x66,0x66,0x66,0x90\n\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 9*32+18)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0x0f,0xc7,0xf8\n\tsetc %0\n6641:\n\t.popsection" : "=q" ( ok ) , "=a" ( * v ) : "i" ( 0 ) ) ;
# 105 "./arch/x86/include/asm/archrandom.h"
  return ( int ) ok;
}
# 134 "./arch/x86/include/asm/archrandom.h"
void x86_init_rdrand(struct cpuinfo_x86 *);
# 110 "include/linux/random.h"
static inline u32 next_pseudo_random32(u32 seed)
{
  return seed * 1664525U + 1013904223U;
}
struct ms_boot_header
{
# 56 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  short unsigned int block_id;
  short unsigned int format_reserved;
  unsigned char reserved0[184U];
  unsigned char data_entry;
  unsigned char reserved1[179U];
};
struct ms_system_item
{
# 65 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  unsigned int start_addr;
  unsigned int data_size;
  unsigned char data_type_id;
  unsigned char reserved[3U];
};
struct ms_system_entry
{
  struct ms_system_item disabled_block;
  struct ms_system_item cis_idi;
  unsigned char reserved[24U];
};
struct ms_boot_attr_info
{
  unsigned char memorystick_class;
  unsigned char format_unique_value1;
  short unsigned int block_size;
  short unsigned int number_of_blocks;
  short unsigned int number_of_effective_blocks;
  short unsigned int page_size;
  unsigned char extra_data_size;
  unsigned char format_unique_value2;
  unsigned char assembly_time[8U];
  unsigned char format_unique_value3;
  unsigned char serial_number[3U];
  unsigned char assembly_manufacturer_code;
  unsigned char assembly_model_code[3U];
  short unsigned int memory_manufacturer_code;
  short unsigned int memory_device_code;
  short unsigned int implemented_capacity;
  unsigned char format_unique_value4[2U];
  unsigned char vcc;
  unsigned char vpp;
  short unsigned int controller_number;
  short unsigned int controller_function;
  unsigned char reserved0[9U];
  unsigned char transfer_supporting;
  short unsigned int format_unique_value5;
  unsigned char format_type;
  unsigned char memorystick_application;
  unsigned char device_type;
  unsigned char reserved1[22U];
  unsigned char format_uniqure_value6[2U];
  unsigned char reserved2[15U];
};
struct ms_cis_idi
{
  short unsigned int general_config;
  short unsigned int logical_cylinders;
  short unsigned int reserved0;
  short unsigned int logical_heads;
  short unsigned int track_size;
  short unsigned int page_size;
  short unsigned int pages_per_track;
  short unsigned int msw;
  short unsigned int lsw;
  short unsigned int reserved1;
  unsigned char serial_number[20U];
  short unsigned int buffer_type;
  short unsigned int buffer_size_increments;
  short unsigned int long_command_ecc;
  unsigned char firmware_version[28U];
  unsigned char model_name[18U];
  short unsigned int reserved2[5U];
  short unsigned int pio_mode_number;
  short unsigned int dma_mode_number;
  short unsigned int field_validity;
  short unsigned int current_logical_cylinders;
  short unsigned int current_logical_heads;
  short unsigned int current_pages_per_track;
  unsigned int current_page_capacity;
  short unsigned int mutiple_page_setting;
  unsigned int addressable_pages;
  short unsigned int single_word_dma;
  short unsigned int multi_word_dma;
  unsigned char reserved3[128U];
};
struct ms_boot_page
{
# 144 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  struct ms_boot_header header;
  struct ms_system_entry entry;
  struct ms_boot_attr_info attr;
};
struct msb_data
{
  unsigned int usage_count;
  struct memstick_dev *card;
  struct gendisk *disk;
  struct request_queue *queue;
  spinlock_t q_lock;
  struct hd_geometry geometry;
  struct attribute_group attr_group;
  struct request *req;
  int caps;
  int disk_id;
# 162 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  struct workqueue_struct *io_queue;
  bool io_queue_stopped;
  struct work_struct io_work;
  bool card_dead;
# 168 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  struct ms_boot_page *boot_page;
  u16 boot_block_locations[2U];
  int boot_block_count;
# 172 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  bool read_only;
  short unsigned int page_size;
  int block_size;
  int pages_in_block;
  int zone_count;
  int block_count;
  int logical_block_count;
# 181 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  long unsigned int *used_blocks_bitmap;
  long unsigned int *erased_blocks_bitmap;
  u16 *lba_to_pba_table;
  int free_block_count[16U];
  bool ftl_initialized;
# 188 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  unsigned char *cache;
  long unsigned int valid_cache_bitmap;
  int cache_block_lba;
  bool need_flush_cache;
  struct timer_list cache_flush_timer;
# 195 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  unsigned char *block_buffer;
  struct scatterlist prealloc_sg[33U];
# 200 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  struct ms_register_addr reg_addr;
  bool addr_valid;
# 203 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  u8 command_value;
  bool command_need_oob;
  struct scatterlist *current_sg;
  int current_sg_offset;
# 208 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  struct ms_register regs;
  int current_page;
# 211 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  int state;
  int exit_error;
  bool int_polling;
  long unsigned int int_timeout;
};
enum msb_readpage_states
{
  MSB_RP_SEND_BLOCK_ADDRESS = 0,
  MSB_RP_SEND_READ_COMMAND = 1,
  MSB_RP_SEND_INT_REQ = 2,
  MSB_RP_RECEIVE_INT_REQ_RESULT = 3,
  MSB_RP_SEND_READ_STATUS_REG = 4,
  MSB_RP_RECEIVE_STATUS_REG = 5,
  MSB_RP_SEND_OOB_READ = 6,
  MSB_RP_RECEIVE_OOB_READ = 7,
  MSB_RP_SEND_READ_DATA = 8,
  MSB_RP_RECEIVE_READ_DATA = 9
};
enum msb_write_block_states
{
  MSB_WB_SEND_WRITE_PARAMS = 0,
  MSB_WB_SEND_WRITE_OOB = 1,
  MSB_WB_SEND_WRITE_COMMAND = 2,
  MSB_WB_SEND_INT_REQ = 3,
  MSB_WB_RECEIVE_INT_REQ = 4,
  MSB_WB_SEND_WRITE_DATA = 5,
  MSB_WB_RECEIVE_WRITE_CONFIRMATION = 6
};
enum msb_send_command_states
{
  MSB_SC_SEND_WRITE_PARAMS = 0,
  MSB_SC_SEND_WRITE_OOB = 1,
  MSB_SC_SEND_COMMAND = 2,
  MSB_SC_SEND_INT_REQ = 3,
  MSB_SC_RECEIVE_INT_REQ = 4
};
enum msb_reset_states
{
  MSB_RS_SEND = 0,
  MSB_RS_CONFIRM = 1
};
enum msb_par_switch_states
{
  MSB_PS_SEND_SWITCH_COMMAND = 0,
  MSB_PS_SWICH_HOST = 1,
  MSB_PS_CONFIRM = 2
};
struct chs_entry
{
# 269 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
  long unsigned int size;
  unsigned char sec;
  short unsigned int cyl;
  unsigned char head;
};
# 275 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
static int msb_reset(struct msb_data *, bool);
# 277 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-3.17-rc1.tar.xz/linux-3.17-rc1/drivers/memstick/core/ms_block.h"
static int h_msb_default_bad(struct memstick_dev *, struct memstick_request **);
# 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int debug;
static int cache_flush_timeout = 1000;
static bool verify_writes;
# 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static size_t msb_sg_copy(struct scatterlist *sg_from, struct scatterlist *sg_to, int to_nents, size_t offset, size_t len)
{
# 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  size_t copied = 0UL;
# 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32521;
  ldv_32526:;
# 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( size_t ) ( * sg_from ) . length <= offset)
  {
# 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( ( * sg_from ) . page_link & 2UL ) != 0UL)
      return 0UL;
# 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    offset -= ( size_t ) ( * sg_from ) . length;
    sg_from = sg_next ( sg_from );
    goto ldv_32521;
  }
# 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  copied = ({
# 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    size_t _min1 = len;
# 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    size_t _min2 = ( size_t ) ( * sg_from ) . length - offset;
# 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void ) 0;
# 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ((_min1) < (_min2) ? (_min1) : (_min2));
  } );
# 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_set_page ( sg_to , sg_page ( sg_from ) , ( unsigned int ) copied , (
# 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * sg_from ) . offset + ( unsigned int ) offset );
# 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  len -= copied;
  offset = 0UL;
# 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( ( * sg_from ) . page_link & 2UL ) != 0UL || len == 0UL)
    goto out;
# 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_to = sg_next ( sg_to );
  to_nents --;
  sg_from = sg_next ( sg_from );
  ldv_32521:;
# 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (offset != 0UL)
  {
    goto ldv_32526;
  }
  else
    goto ldv_32527;
  ldv_32527:;
# 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32529;
  ldv_32528:;
# 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  len -= ( size_t ) ( * sg_from ) . length;
  copied = ( size_t ) ( * sg_from ) . length + copied;
# 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_set_page ( sg_to , sg_page ( sg_from ) , (
# 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * sg_from ) . length , ( * sg_from ) . offset );
# 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( ( * sg_from ) . page_link & 2UL ) != 0UL || len == 0UL)
    goto out;
# 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_from = sg_next ( sg_from );
  sg_to = sg_next ( sg_to );
  ldv_32529:;
# 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( size_t ) ( * sg_from ) . length < len && to_nents -- != 0)
  {
    goto ldv_32528;
  }
  else
    goto ldv_32530;
  ldv_32530:;
# 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (len != 0UL && to_nents != 0)
  {
# 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    sg_set_page ( sg_to , sg_page ( sg_from ) , ( unsigned int ) len , ( * sg_from ) . offset );
    copied += len;
  }
  out:;
  sg_mark_end ( sg_to );
  return copied;
}
# 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_sg_compare_to_buffer(struct scatterlist *sg, size_t offset, u8 *buffer, size_t len)
{
# 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int retval = 0;
# 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int cmplen;
  struct sg_mapping_iter miter;
# 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_miter_start ( & miter , sg , ( unsigned int ) sg_nents ( sg ) , 5U );
# 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32540;
  ldv_32545:;
# 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (miter . length <= offset)
  {
# 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    offset -= miter . length;
    goto ldv_32540;
  }
# 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  cmplen = ( int ) ({
# 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    size_t _min1 = miter . length - offset;
# 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    size_t _min2 = len;
# 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void ) 0;
# 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ((_min1) < (_min2) ? (_min1) : (_min2));
  } );
# 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  retval = memcmp ( ( void const *) ( miter . addr + offset ) , ( void const *) buffer , ( size_t ) cmplen ) != 0 ? -1 : 0;
  if (retval != 0)
    goto ldv_32544;
# 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  buffer += ( long unsigned int ) cmplen;
  len -= ( size_t ) cmplen;
  offset = 0UL;
  ldv_32540:;
# 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) sg_miter_next ( & miter ) && len != 0UL)
  {
    goto ldv_32545;
  }
  else
    goto ldv_32544;
  ldv_32544:;
# 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (retval == 0 && len != 0UL)
    retval = -1;
# 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_miter_stop ( & miter );
  return retval;
}
# 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_get_zone_from_lba(int lba)
{
  if (lba <= 493)
    return 0;
  return ( lba + -494 ) / 496 + 1;
}
# 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_get_zone_from_pba(int pba)
{
  return pba / 512;
}
# 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_validate_used_block_bitmap(struct msb_data *msb)
{
  int total_free_blocks = 0;
  int i;
# 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug == 0)
    return 0;
# 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  i = 0;
# 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32558;
  ldv_32557:;
# 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  total_free_blocks = ( * msb ) . free_block_count [ i ] + total_free_blocks;
# 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  i ++;
  ldv_32558:;
# 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . zone_count > i)
  {
    goto ldv_32557;
  }
  else
    goto ldv_32559;
  ldv_32559:;
# 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . block_count - bitmap_weight ( ( long unsigned int const *) ( * msb ) . used_blocks_bitmap , ( unsigned int ) (
# 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . block_count ) == total_free_blocks)
    return 0;
# 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  printk ( ( char const *) "\13ms_block: BUG: free block counts don\'t match the bitmap" );
  ( * msb ) . read_only = 1;
  return -22;
}
# 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_mark_block_used(struct msb_data *msb, int pba)
{
  int zone = msb_get_zone_from_pba ( pba );
# 224 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (variable_test_bit ( ( long int ) pba , ( long unsigned int const volatile *) ( * msb ) . used_blocks_bitmap ) != 0)
  {
# 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: BUG: attempt to mark already used pba %d as used" , pba );
# 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . read_only = 1;
    return;
  }
# 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (msb_validate_used_block_bitmap ( msb ) != 0)
    return;
# 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  __set_bit ( ( long int ) pba , ( long unsigned int volatile *) ( * msb ) . used_blocks_bitmap );
  ( * msb ) . free_block_count [ zone ] --;
}
# 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_mark_block_unused(struct msb_data *msb, int pba)
{
  int zone = msb_get_zone_from_pba ( pba );
# 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (variable_test_bit ( ( long int ) pba , ( long unsigned int const volatile *) ( * msb ) . used_blocks_bitmap ) == 0)
  {
# 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: BUG: attempt to mark already unused pba %d as unused" , pba );
    ( * msb ) . read_only = 1;
    return;
  }
# 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (msb_validate_used_block_bitmap ( msb ) != 0)
    return;
# 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  __clear_bit ( ( long int ) pba , ( long unsigned int volatile *) ( * msb ) . used_blocks_bitmap );
  ( * msb ) . free_block_count [ zone ] ++;
}
# 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_invalidate_reg_window(struct msb_data *msb)
{
  ( * msb ) . reg_addr . w_offset = 4U;
  ( * msb ) . reg_addr . w_length = 4U;
  ( * msb ) . reg_addr . r_offset = 4U;
  ( * msb ) . reg_addr . r_length = 4U;
  ( * msb ) . addr_valid = 0;
}
# 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_run_state_machine(struct msb_data *msb, int (*state_func)(struct memstick_dev *, struct memstick_request **))
{
# 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  struct memstick_dev *card = ( * msb ) . card;
# 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ({
# 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    int __ret_warn_on = ( * msb ) . state != -1;
    {
# 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        warn_slowpath_null ( ( char const *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" , 274 );
    }
# 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    __builtin_expect ( __ret_warn_on != 0 , 0L );
  } );
# 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . int_polling = 0;
  ( * msb ) . state = 0;
  ( * msb ) . exit_error = 0;
# 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  memset ( ( void *) & ( * card ) . current_mrq , 0 , 48UL );
# 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * card ) . next_request = state_func;
  memstick_new_req ( ( * card ) . host );
  wait_for_completion ( & ( * card ) . mrq_complete );
# 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ({
# 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    int __ret_warn_on = ( * msb ) . state != -1;
    {
# 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        warn_slowpath_null ( ( char const *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" , 285 );
    }
# 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    __builtin_expect ( __ret_warn_on != 0 , 0L );
  } );
# 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return ( * msb ) . exit_error;
}
# 290 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_exit_state_machine(struct msb_data *msb, int error)
{
  ({
# 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    int __ret_warn_on = ( * msb ) . state == -1;
    {
# 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        warn_slowpath_null ( ( char const *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" , 292 );
    }
# 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    __builtin_expect ( __ret_warn_on != 0 , 0L );
  } );
  ( * msb ) . state = -1;
  ( * msb ) . exit_error = error;
  ( * ( * msb ) . card ) . next_request = & h_msb_default_bad;
# 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error != 0)
    msb_invalidate_reg_window ( msb );
# 302 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  complete ( & ( * ( * msb ) . card ) . mrq_complete );
  return -6;
}
# 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_read_int_reg(struct msb_data *msb, long int timeout)
{
  struct memstick_request *mrq = & ( * ( * msb ) . card ) . current_mrq;
# 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ({
# 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    int __ret_warn_on = ( * msb ) . state == -1;
    {
# 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        warn_slowpath_null ( ( char const *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" , 311 );
    }
# 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    __builtin_expect ( __ret_warn_on != 0 , 0L );
  } );
  if (( int ) ! ( _Bool ) ( * msb ) . int_polling)
  {
# 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . int_timeout = msecs_to_jiffies
# 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( timeout != -1L ? ( unsigned int const ) timeout : 500U )
# 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    + ( long unsigned int ) jiffies;
# 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . int_polling = 1;
  }
  else
# 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (({
# 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      long unsigned int __dummy;
# 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      long unsigned int volatile __dummy2;
# 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ( void ) 0;
# 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      1;
    } )
# 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    != 0 && ({
# 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      long unsigned int __dummy;
# 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      long unsigned int __dummy2;
# 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ( void ) 0;
# 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      1;
    } )
# 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    != 0 && ( long int ) ( ( * msb ) . int_timeout - ( long unsigned int ) jiffies ) < 0L)
    {
# 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ( * mrq ) . ldv_32083 . ldv_32082 . data [ 0 ] = 1U;
      return 0;
    }
# 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . caps & 1 && ( ( * ( ( unsigned char *) &
# 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * mrq + 1UL ) ) )
# 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  != 0U
# 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  && ( * mrq ) . error == 0)
  {
# 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * mrq ) . ldv_32083 . ldv_32082 . data [ 0 ] = ( * mrq ) . int_reg;
    ( * mrq ) . need_card_int = 0U;
    return 0;
  }
  else
  {
# 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    memstick_init_req ( mrq , 7 , ( ( void const *) 0 ) , 1UL );
    return 1;
  }
}
# 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_read_regs(struct msb_data *msb, int offset, int len)
{
  struct memstick_request *req = & ( * ( * msb ) . card ) . current_mrq;
# 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) ( * msb ) . reg_addr . r_offset != offset || ( int ) (
# 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . reg_addr . r_length != len || ( int ) ! ( _Bool ) ( * msb ) . addr_valid)
  {
    ( * msb ) . reg_addr . r_offset = ( unsigned char ) offset;
    ( * msb ) . reg_addr . r_length = ( unsigned char ) len;
    ( * msb ) . addr_valid = 1;
# 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    memstick_init_req ( req , 8 ,
# 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void const *) & ( * msb ) . reg_addr , 4UL );
    return 0;
  }
# 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  memstick_init_req ( req , 4 , ( ( void const *) 0 ) , ( size_t ) len );
  return 1;
}
# 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_write_regs(struct msb_data *msb, int offset, int len, void *buf)
{
  struct memstick_request *req = & ( * ( * msb ) . card ) . current_mrq;
# 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) ( * msb ) . reg_addr . w_offset != offset || ( int ) (
# 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . reg_addr . w_length != len || ( int ) ! ( _Bool ) ( * msb ) . addr_valid)
  {
    ( * msb ) . reg_addr . w_offset = ( unsigned char ) offset;
    ( * msb ) . reg_addr . w_length = ( unsigned char ) len;
    ( * msb ) . addr_valid = 1;
# 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    memstick_init_req ( req , 8 ,
# 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void const *) & ( * msb ) . reg_addr , 4UL );
    return 0;
  }
# 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  memstick_init_req ( req , 11 , ( void const *) buf , ( size_t ) len );
  return 1;
}
# 376 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int h_msb_default_bad(struct memstick_dev *card, struct memstick_request **mrq)
{
# 379 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return -6;
}
# 387 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int h_msb_read_page(struct memstick_dev *card, struct memstick_request **out_mrq)
{
# 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  struct memstick_request *mrq = * out_mrq = & ( * card ) . current_mrq;
  struct scatterlist sg[2U];
  u8 command;
# 393 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  u8 intreg;
# 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * mrq ) . error != 0)
  {
# 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 0)
# 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: read_page, unknown error\n" );
    return msb_exit_state_machine ( msb , ( * mrq ) . error );
  }
  again:;
  switch (( * msb ) . state)
  {
    struct
    {
# 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      signed char ldv_32640;
    };
    struct
    {
# 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      signed char ldv_32642;
    };
# 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 0:;
# 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (msb_write_regs ( msb , 16 , 6 ,
# 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void *) & ( * msb ) . regs . param )
# 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    == 0)
# 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      return 0;
# 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . state = 1;
    return 0;
# 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 1:;
    command = 170U;
    memstick_init_req ( mrq , 14 , ( void const *) & command , 1UL );
    ( * msb ) . state = 2;
    return 0;
# 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 2:;
    ( * msb ) . state = 3;
# 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (msb_read_int_reg ( msb , -1L ) != 0)
      return 0;
# 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 3:;
    intreg = ( * mrq ) . ldv_32083 . ldv_32082 . data [ 0 ];
    ( * msb ) . regs . status . interrupt = intreg;
# 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( int ) intreg & 1)
      return msb_exit_state_machine ( msb , -5 );
# 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( signed char ) intreg >= 0)
    {
# 436 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ( * msb ) . state = 2;
      goto again;
    }
# 440 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . int_polling = 0;
    ( * msb ) . state = ( ( int ) intreg & 64 ) != 0 ? 4
# 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    : 6;
    goto again;
# 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 4:;
# 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (msb_read_regs ( msb , 0 , 4 ) == 0)
# 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      return 0;
# 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . state = 5;
    return 0;
# 455 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 5:;
    ( * msb ) . regs . status = * ( struct ms_status_register *) & ( * mrq ) . ldv_32083 . ldv_32082 . data;
    ( * msb ) . state = 6;
# 460 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 6:;
    if (msb_read_regs ( msb , 22 , 4 ) == 0)
# 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      return 0;
# 466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . state = 7;
    return 0;
# 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 7:;
    ( * msb ) . regs . extra_data =
# 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    * ( struct ms_extra_data_register *) & ( * mrq ) . ldv_32083 . ldv_32082 . data;
    ( * msb ) . state = 8;
# 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 8:;
# 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( * msb ) . regs . param . cp == 64U)
    {
# 478 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ( * msb ) . state = 9;
      goto again;
    }
# 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    sg_init_table ( ( struct scatterlist *) & sg , 2U );
    msb_sg_copy ( ( * msb ) . current_sg , ( struct scatterlist *) & sg , 2 , ( size_t ) (
# 484 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    * msb ) . current_sg_offset , ( size_t ) (
# 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    * msb ) . page_size );
# 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    memstick_init_req_sg ( mrq , 2 , ( struct scatterlist const *) & sg );
    ( * msb ) . state = 9;
    return 0;
# 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 9:;
    if (( ( int ) ( * msb ) . regs . status . interrupt & 64 ) == 0)
    {
# 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ( * msb ) . current_sg_offset += ( int ) ( * msb ) . page_size;
      return msb_exit_state_machine ( msb , 0 );
    }
# 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( ( int ) ( * msb ) . regs . status . status1 & 21 ) != 0)
    {
# 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      if (debug > 0)
# 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        printk ( ( char const *) "\13ms_block: read_page: uncorrectable error\n" );
      return msb_exit_state_machine ( msb , -74 );
    }
# 502 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( ( int ) ( * msb ) . regs . status . status1 & 42 ) != 0)
    {
# 503 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      if (debug > 0)
# 503 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        printk ( ( char const *) "\13ms_block: read_page: correctable error\n" );
      ( * msb ) . current_sg_offset += ( int ) ( * msb ) . page_size;
      return msb_exit_state_machine ( msb , -117 );
    }
    else
    {
# 507 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      if (debug > 0)
# 507 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        printk ( ( char const *) "\13ms_block: read_page: INT error, but no status error bits\n" );
      return msb_exit_state_machine ( msb , -5 );
    }
  }
# 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" ) , "i" ( 512 ) , "i" ( 12UL ) ) ;
  ldv_32644:;
# 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32644;
}
# 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int h_msb_write_block(struct memstick_dev *card, struct memstick_request **out_mrq)
{
# 526 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  struct memstick_request *mrq = * out_mrq = & ( * card ) . current_mrq;
  struct scatterlist sg[2U];
  u8 intreg;
# 529 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  u8 command;
# 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * mrq ) . error != 0)
    return msb_exit_state_machine ( msb , ( * mrq ) . error );
# 534 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  again:;
  switch (( * msb ) . state)
  {
    struct
    {
# 607 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      signed char ldv_32662;
    };
    struct
    {
# 609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      signed char ldv_32664;
    };
# 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 0:;
    if (msb_write_regs ( msb , 16 , 6 ,
# 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void *) & ( * msb ) . regs . param )
# 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    == 0)
# 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      return 0;
# 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . state = 1;
    return 0;
# 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 1:;
    if (msb_write_regs ( msb , 22 , 4 ,
# 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void *) & ( * msb ) . regs . extra_data )
# 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    == 0)
# 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      return 0;
    ( * msb ) . state = 2;
    return 0;
# 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 2:;
    command = 85U;
    memstick_init_req ( mrq , 14 , ( void const *) & command , 1UL );
    ( * msb ) . state = 3;
    return 0;
# 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 3:;
    ( * msb ) . state = 4;
    if (msb_read_int_reg ( msb , -1L ) != 0)
      return 0;
# 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 4:;
    intreg = ( * mrq ) . ldv_32083 . ldv_32082 . data [ 0 ];
    ( * msb ) . regs . status . interrupt = intreg;
# 580 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( int ) intreg & 1)
      return msb_exit_state_machine ( msb , -5 );
# 583 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( ( int ) intreg & 64 ) != 0)
      return msb_exit_state_machine ( msb , -74 );
# 588 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( * msb ) . current_page == ( * msb ) . pages_in_block)
    {
# 589 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      if (( signed char ) intreg < 0)
        return msb_exit_state_machine ( msb , 0 );
      ( * msb ) . state = 3;
      goto again;
    }
# 597 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( ( int ) intreg & 32 ) == 0)
    {
# 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ( * msb ) . state = 3;
      goto again;
    }
# 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . int_polling = 0;
    ( * msb ) . state = 5;
# 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 5:;
    sg_init_table ( ( struct scatterlist *) & sg , 2U );
# 609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (msb_sg_copy ( ( * msb ) . current_sg , ( struct scatterlist *) & sg , 2 , ( size_t ) (
# 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    * msb ) . current_sg_offset , ( size_t ) (
# 611 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    * msb ) . page_size ) < ( size_t ) ( * msb ) . page_size)
      return msb_exit_state_machine ( msb , -5 );
# 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    memstick_init_req_sg ( mrq , 13 , ( struct scatterlist const *) & sg );
    ( * mrq ) . need_card_int = 1U;
    ( * msb ) . state = 6;
    return 0;
# 619 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 6:;
    ( * msb ) . current_page ++;
    ( * msb ) . current_sg_offset += ( int ) ( * msb ) . page_size;
    ( * msb ) . state = 3;
    goto again;
    default:;
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" ) , "i" ( 625 ) , "i" ( 12UL ) ) ;
    ldv_32667:;
# 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_32667;
  }
# 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return 0;
}
# 635 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int h_msb_send_command(struct memstick_dev *card, struct memstick_request **out_mrq)
{
# 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  struct memstick_request *mrq = * out_mrq = & ( * card ) . current_mrq;
  u8 intreg;
# 642 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * mrq ) . error != 0)
  {
# 643 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 0)
# 643 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: send_command: unknown error\n" );
    return msb_exit_state_machine ( msb , ( * mrq ) . error );
  }
  again:;
  switch (( * msb ) . state)
  {
# 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 0:;
    if (msb_write_regs ( msb , 16 , 6 ,
# 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void *) & ( * msb ) . regs . param )
# 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    == 0)
# 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      return 0;
    ( * msb ) . state = 1;
    return 0;
# 659 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 1:;
    if (( int ) ! ( _Bool ) ( * msb ) . command_need_oob)
    {
# 661 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ( * msb ) . state = 2;
      goto again;
    }
# 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (msb_write_regs ( msb , 22 , 4 ,
# 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void *) & ( * msb ) . regs . extra_data )
# 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    == 0)
# 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      return 0;
# 671 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . state = 2;
    return 0;
# 674 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 2:;
    memstick_init_req ( mrq , 14 , ( void const *) & ( * msb ) . command_value , 1UL );
    ( * msb ) . state = 3;
    return 0;
# 679 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 3:;
    ( * msb ) . state = 4;
    if (msb_read_int_reg ( msb , -1L ) != 0)
      return 0;
# 685 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 4:;
    intreg = ( * mrq ) . ldv_32083 . ldv_32082 . data [ 0 ];
# 688 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( int ) intreg & 1)
      return msb_exit_state_machine ( msb , -5 );
    if (( ( int ) intreg & 64 ) != 0)
      return msb_exit_state_machine ( msb , -74 );
# 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( signed char ) intreg >= 0)
    {
# 694 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ( * msb ) . state = 3;
      goto again;
    }
# 698 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    return msb_exit_state_machine ( msb , 0 );
  }
# 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" ) , "i" ( 701 ) , "i" ( 12UL ) ) ;
  ldv_32681:;
# 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32681;
}
# 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int h_msb_reset(struct memstick_dev *card, struct memstick_request **out_mrq)
{
# 708 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  u8 command = 60U;
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  struct memstick_request *mrq = * out_mrq = & ( * card ) . current_mrq;
# 712 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * mrq ) . error != 0)
    return msb_exit_state_machine ( msb , ( * mrq ) . error );
# 715 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  switch (( * msb ) . state)
  {
# 716 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 0:;
    memstick_init_req ( mrq , 14 , ( void const *) & command , 1UL );
    ( * mrq ) . need_card_int = 0U;
    ( * msb ) . state = 1;
    return 0;
    case 1:;
    return msb_exit_state_machine ( msb , 0 );
  }
  asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" ) , "i" ( 724 ) , "i" ( 12UL ) ) ;
  ldv_32691:;
# 724 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32691;
}
# 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int h_msb_parallel_switch(struct memstick_dev *card, struct memstick_request **out_mrq)
{
# 731 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  struct memstick_request *mrq = * out_mrq = & ( * card ) . current_mrq;
  struct memstick_host *host = ( * card ) . host;
# 735 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * mrq ) . error != 0)
  {
# 736 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 0)
# 736 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: parallel_switch: error\n" );
    ( * msb ) . regs . param . system &= 247U;
    return msb_exit_state_machine ( msb , ( * mrq ) . error );
  }
# 741 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  switch (( * msb ) . state)
  {
# 742 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 0:;
# 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . regs . param . system |= 8U;
# 746 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (msb_write_regs ( msb , 16 , 1 ,
# 749 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void *) & ( * msb ) . regs . param )
# 746 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    == 0)
# 750 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      return 0;
# 752 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . state = 1;
    return 0;
# 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 1:;
# 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * host ) . set_param ( host , MEMSTICK_INTERFACE , 1 );
    memstick_init_req ( mrq , 7 , ( ( void const *) 0 ) , 1UL );
    ( * msb ) . state = 2;
    return 0;
# 763 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    case 2:;
    return msb_exit_state_machine ( msb , 0 );
  }
# 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" ) , "i" ( 767 ) , "i" ( 12UL ) ) ;
  ldv_32702:;
# 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32702;
}
# 770 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_switch_to_parallel(struct msb_data *);
# 773 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_reset(struct msb_data *msb, bool full)
{
# 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  bool was_parallel = ( ( int ) ( * msb ) . regs . param . system & 8 ) != 0;
  struct memstick_dev *card = ( * msb ) . card;
  struct memstick_host *host = ( * card ) . host;
  int error;
# 782 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . regs . param . system = 128U;
# 784 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) full)
  {
# 785 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    error = ( * host ) . set_param ( host , MEMSTICK_POWER , 0 );
# 787 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (error != 0)
      goto out_error;
# 790 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    msb_invalidate_reg_window ( msb );
# 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    error = ( * host ) . set_param ( host , MEMSTICK_POWER , 1 );
# 794 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (error != 0)
      goto out_error;
# 797 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    error = ( * host ) . set_param ( host , MEMSTICK_INTERFACE , 0 );
# 799 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (error != 0)
    {
# 800 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      out_error:;
      if (debug > 0)
# 801 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        printk ( ( char const *) "\13ms_block: Failed to reset the host controller\n" );
      ( * msb ) . read_only = 1;
      return -14;
    }
  }
# 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_run_state_machine ( msb , & h_msb_reset );
  if (error != 0)
  {
# 809 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 0)
# 809 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: Failed to reset the card\n" );
    ( * msb ) . read_only = 1;
    return -19;
  }
# 815 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) was_parallel)
    msb_switch_to_parallel ( msb );
  return 0;
}
# 821 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_switch_to_parallel(struct msb_data *msb)
{
  int error;
# 825 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_run_state_machine ( msb , & h_msb_parallel_switch );
  if (error != 0)
  {
# 827 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Switch to parallel failed" );
    ( * msb ) . regs . param . system &= 247U;
    msb_reset ( msb , 1 );
    return -14;
  }
# 833 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . caps |= 1;
  return 0;
}
# 838 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_set_overwrite_flag(struct msb_data *msb, u16 pba, u8 page, u8 flag)
{
# 841 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) ( * msb ) . read_only)
    return -30;
# 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . regs . param . block_address = ( short unsigned int ) __fswab16 ( ( int ) pba );
  ( * msb ) . regs . param . page_address = page;
  ( * msb ) . regs . param . cp = 128U;
  ( * msb ) . regs . extra_data . overwrite_flag = flag;
  ( * msb ) . command_value = 85U;
  ( * msb ) . command_need_oob = 1;
# 851 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 851 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: changing overwrite flag to %02x for sector %d, page %d\n" , ( int ) flag , ( int ) pba , ( int ) page );
# 853 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return msb_run_state_machine ( msb , & h_msb_send_command );
}
# 856 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_mark_bad(struct msb_data *msb, int pba)
{
  printk ( ( char const *) "\15ms_block: marking pba %d as bad" , pba );
  msb_reset ( msb , 1 );
  return msb_set_overwrite_flag ( msb , ( int ) ( u16 ) pba , 0 , 127 );
}
# 864 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_mark_page_bad(struct msb_data *msb, int pba, int page)
{
  if (debug > 0)
# 866 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: marking page %d of pba %d as bad\n" , page , pba );
  msb_reset ( msb , 1 );
  return msb_set_overwrite_flag ( msb , ( int ) ( u16 ) pba , ( int ) ( u8 ) page , 191 );
}
# 873 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_erase_block(struct msb_data *msb, u16 pba)
{
  int error;
# 875 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int try;
  if (( int ) ( * msb ) . read_only)
    return -30;
# 879 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 879 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: erasing pba %d\n" , ( int ) pba );
# 881 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  try = 1;
# 881 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32741;
  ldv_32740:;
# 882 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . regs . param . block_address = ( short unsigned int ) __fswab16 ( ( int ) pba );
  ( * msb ) . regs . param . page_address = 0U;
  ( * msb ) . regs . param . cp = 0U;
  ( * msb ) . command_value = 153U;
  ( * msb ) . command_need_oob = 0;
# 889 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_run_state_machine ( msb , & h_msb_send_command );
  if (error == 0 || msb_reset ( msb , 1 ) != 0)
    goto ldv_32739;
# 881 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  try ++;
  ldv_32741:;
# 881 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (try <= 2)
  {
    goto ldv_32740;
  }
  else
    goto ldv_32739;
  ldv_32739:;
# 894 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error != 0)
  {
# 895 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: erase failed, marking pba %d as bad" , ( int ) pba );
    msb_mark_bad ( msb , ( int ) pba );
  }
# 899 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 899 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: erase success, marking pba %d as unused\n" , ( int ) pba );
  msb_mark_block_unused ( msb , ( int ) pba );
  __set_bit ( ( long int ) pba , ( long unsigned int volatile *) ( * msb ) . erased_blocks_bitmap );
  return error;
}
# 906 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_read_page(struct msb_data *msb, u16 pba, u8 page, struct ms_extra_data_register *extra, struct scatterlist *sg, int offset)
{
# 910 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int try;
# 910 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int error;
# 912 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( short unsigned int ) pba == 65535U)
  {
# 913 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int flags;
    struct sg_mapping_iter miter;
    size_t len = ( size_t ) ( * msb ) . page_size;
# 917 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 1)
# 917 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: read unmapped sector. returning 0xFF\n" );
# 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ({
# 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      long unsigned int __dummy;
# 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      long unsigned int __dummy2;
# 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ( void ) 0;
# 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      1;
    } );
# 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    flags = arch_local_irq_save ( );
# 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    trace_hardirqs_off ( );
    sg_miter_start ( & miter , sg , ( unsigned int ) sg_nents ( sg ) , 3U );
# 923 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_32759;
    ldv_32763:;
    {
# 925 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      int chunklen;
# 927 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      if (offset != 0 && ( size_t ) offset >= miter . length)
      {
# 928 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        offset = ( int ) ( ( unsigned int ) offset - ( unsigned int ) miter . length );
        goto ldv_32759;
      }
# 932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      chunklen = ( int ) ({
# 932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        size_t _min1 = miter . length - ( size_t ) offset;
# 932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        size_t _min2 = len;
# 932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        ( void ) 0;
# 932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        ((_min1) < (_min2) ? (_min1) : (_min2));
      } );
# 933 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      memset ( miter . addr + ( long unsigned int ) offset , 255 , ( size_t ) chunklen );
      len -= ( size_t ) chunklen;
      offset = 0;
    }
    ldv_32759:;
# 923 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( int ) sg_miter_next ( & miter ) && len != 0UL)
    {
      goto ldv_32763;
    }
    else
      goto ldv_32764;
    ldv_32764:;
# 938 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    sg_miter_stop ( & miter );
    if (({
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ({
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        long unsigned int __dummy;
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        long unsigned int __dummy2;
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        ( void ) 0;
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        1;
      } );
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      arch_irqs_disabled_flags ( flags );
    } )
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    != 0)
    {
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ({
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        long unsigned int __dummy;
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        long unsigned int __dummy2;
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        ( void ) 0;
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        1;
      } );
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      arch_local_irq_restore ( flags );
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      trace_hardirqs_off ( );
    }
    else
    {
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      trace_hardirqs_on ( );
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ({
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        long unsigned int __dummy;
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        long unsigned int __dummy2;
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        ( void ) 0;
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        1;
      } );
# 939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      arch_local_irq_restore ( flags );
    }
    if (offset != 0)
      return -14;
# 944 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (extra != ( ( struct ms_extra_data_register *) 0 ))
      memset ( ( void *) extra , 255 , 4UL );
    return 0;
  }
# 949 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) pba >= ( * msb ) . block_count)
  {
# 950 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: BUG: attempt to read beyond the end of the card at pba %d" , ( int ) pba );
    return -22;
  }
# 954 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  try = 1;
# 954 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32777;
  ldv_32776:;
# 955 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . regs . param . block_address = ( short unsigned int ) __fswab16 ( ( int ) pba );
  ( * msb ) . regs . param . page_address = page;
  ( * msb ) . regs . param . cp = 32U;
# 959 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . current_sg = sg;
  ( * msb ) . current_sg_offset = offset;
  error = msb_run_state_machine ( msb , & h_msb_read_page );
# 964 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error == -117)
  {
# 965 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\15ms_block: correctable error on pba %d, page %d" , ( int ) pba , ( int ) page );
# 967 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    error = 0;
  }
# 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error == 0 && extra != ( ( struct ms_extra_data_register *) 0 ))
    * extra = ( * msb ) . regs . extra_data;
# 973 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error == 0 || msb_reset ( msb , 1 ) != 0)
    goto ldv_32775;
# 954 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  try ++;
  ldv_32777:;
# 954 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (try <= 2)
  {
    goto ldv_32776;
  }
  else
    goto ldv_32775;
  ldv_32775:;
# 979 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error == -74)
  {
# 980 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: uncorrectable error on read of pba %d, page %d" , ( int ) pba , ( int ) page );
# 983 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( ( int ) ( * msb ) . regs . extra_data . overwrite_flag & 64 ) != 0)
# 985 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      msb_mark_page_bad ( msb , ( int ) pba , ( int ) page );
    return -74;
  }
# 989 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error != 0)
    printk ( ( char const *) "\13ms_block: read of pba %d, page %d failed with error %d" , ( int ) pba , ( int ) page , error );
# 992 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return error;
}
# 996 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_read_oob(struct msb_data *msb, u16 pba, u16 page, struct ms_extra_data_register *extra)
{
# 999 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int error;
# 1001 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (__builtin_expect ( extra == ( ( struct ms_extra_data_register *) 0 ) , 0L ) != 0L)
  {
# 1001 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" ) , "i" ( 1001 ) , "i" ( 12UL ) ) ;
    ldv_32785:;
# 1001 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_32785;
  }
# 1002 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . regs . param . block_address = ( short unsigned int ) __fswab16 ( ( int ) pba );
  ( * msb ) . regs . param . page_address = ( unsigned char ) page;
  ( * msb ) . regs . param . cp = 64U;
# 1006 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) pba > ( * msb ) . block_count)
  {
# 1007 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: BUG: attempt to read beyond the end of card at pba %d" , ( int ) pba );
    return -22;
  }
# 1011 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_run_state_machine ( msb , & h_msb_read_page );
  * extra = ( * msb ) . regs . extra_data;
# 1014 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error == -117)
  {
# 1015 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\15ms_block: correctable error on pba %d, page %d" , ( int ) pba , ( int ) page );
# 1017 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    return 0;
  }
# 1020 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return error;
}
# 1024 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_verify_block(struct msb_data *msb, u16 pba, struct scatterlist *orig_sg, int offset)
{
# 1027 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  struct scatterlist sg;
  int page = 0;
# 1028 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int error;
# 1030 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_init_one ( & sg , ( void const *) ( * msb ) . block_buffer , ( unsigned int ) ( * msb ) . block_size );
# 1032 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32796;
  ldv_32795:;
  error = msb_read_page ( msb , ( int ) pba , ( int ) ( u8 ) page , ( ( struct ms_extra_data_register *) 0 ) ,
# 1035 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  & sg , ( int ) ( * msb ) . page_size * page );
  if (error != 0)
    return error;
  page ++;
  ldv_32796:;
# 1032 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . pages_in_block > page)
  {
    goto ldv_32795;
  }
  else
    goto ldv_32797;
  ldv_32797:;
# 1041 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (msb_sg_compare_to_buffer ( orig_sg , ( size_t ) offset ,
# 1042 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( u8 *) ( * msb ) . block_buffer , ( size_t ) ( * msb ) . block_size )
# 1041 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  != 0)
# 1043 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    return -5;
  return 0;
}
# 1048 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_write_block(struct msb_data *msb, u16 pba, u32 lba, struct scatterlist *sg, int offset)
{
# 1051 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int error;
# 1051 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int current_try = 1;
  if (__builtin_expect ( ( * sg ) . length < ( unsigned int ) ( * msb ) . page_size , 0L ) != 0L)
  {
# 1052 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" ) , "i" ( 1052 ) , "i" ( 12UL ) ) ;
    ldv_32807:;
# 1052 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_32807;
  }
  if (( int ) ( * msb ) . read_only)
    return -30;
# 1057 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( short unsigned int ) pba == 65535U)
  {
# 1058 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: BUG: write: attempt to write MS_BLOCK_INVALID block" );
# 1060 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    return -22;
  }
# 1063 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) pba >= ( * msb ) . block_count || ( u32 ) ( * msb ) . logical_block_count <= lba)
  {
# 1064 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: BUG: write: attempt to write beyond the end of device" );
# 1066 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    return -22;
  }
# 1069 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (msb_get_zone_from_lba ( ( int ) lba ) != msb_get_zone_from_pba ( ( int ) pba ))
  {
# 1070 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: BUG: write: lba zone mismatch" );
    return -22;
  }
# 1074 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( short unsigned int ) ( * msb ) . boot_block_locations [ 0 ] == ( short unsigned int ) pba ||
# 1075 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( short unsigned int ) ( * msb ) . boot_block_locations [ 1 ] == ( short unsigned int ) pba)
  {
# 1076 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: BUG: write: attempt to write to boot blocks!" );
    return -22;
  }
  ldv_32809:;
# 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) ( * msb ) . read_only)
    return -30;
# 1085 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . regs . param . cp = 0U;
  ( * msb ) . regs . param . page_address = 0U;
  ( * msb ) . regs . param . block_address = ( short unsigned int ) __fswab16 ( ( int ) pba );
# 1089 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . regs . extra_data . management_flag = 255U;
  ( * msb ) . regs . extra_data . overwrite_flag = 248U;
  ( * msb ) . regs . extra_data . logical_address = ( short unsigned int ) __fswab16 ( ( int ) ( __u16 ) lba );
# 1093 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . current_sg = sg;
  ( * msb ) . current_sg_offset = offset;
  ( * msb ) . current_page = 0;
# 1097 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_run_state_machine ( msb , & h_msb_write_block );
# 1105 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error == 0 && ( ( int ) verify_writes || variable_test_bit
# 1106 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( ( long int ) pba , ( long unsigned int const volatile *) ( * msb ) . erased_blocks_bitmap ) == 0 ))
    error = msb_verify_block ( msb , ( int ) pba , sg , offset );
# 1109 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error == 0)
    goto ldv_32808;
# 1112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (current_try > 1 || msb_reset ( msb , 1 ) != 0)
    goto ldv_32808;
# 1115 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  printk ( ( char const *) "\13ms_block: write failed, trying to erase the pba %d" , ( int ) pba );
  error = msb_erase_block ( msb , ( int ) pba );
  if (error != 0)
    goto ldv_32808;
# 1120 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  current_try ++;
  goto ldv_32809;
  ldv_32808:;
# 1122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return error;
}
# 1126 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static u16 msb_get_free_block(struct msb_data *msb, int zone)
{
  u16 pos;
  int pba = zone * 512;
  int i;
# 1132 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  get_random_bytes ( ( void *) & pos , 2 );
# 1134 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . free_block_count [ zone ] == 0)
  {
# 1135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: NO free blocks in the zone %d, to use for a write, (media is WORN out) switching to RO mode" , zone );
    ( * msb ) . read_only = 1;
    return 65535U;
  }
# 1140 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  pos = ( u16 ) ( ( int ) pos % ( * msb ) . free_block_count [ zone ] );
# 1142 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1142 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: have %d choices for a free block, selected randomally: %d\n" , ( * msb ) . free_block_count [ zone ] , ( int ) pos );
# 1145 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  pba = ( int ) find_next_zero_bit ( ( long unsigned int const *) ( * msb ) . used_blocks_bitmap , ( long unsigned int ) (
# 1146 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . block_count , ( long unsigned int ) pba );
  i = 0;
# 1147 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32818;
  ldv_32817:;
# 1148 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  pba = ( int ) find_next_zero_bit ( ( long unsigned int const *) ( * msb ) . used_blocks_bitmap , ( long unsigned int ) (
# 1149 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . block_count , ( long unsigned int ) ( pba + 1 ) );
# 1147 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ++ i;
  ldv_32818:;
# 1147 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) pos > i)
  {
    goto ldv_32817;
  }
  else
    goto ldv_32819;
  ldv_32819:;
# 1151 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1151 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: result of the free blocks scan: pba %d\n" , pba );
# 1153 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . block_count == pba || msb_get_zone_from_pba ( pba ) != zone)
  {
# 1154 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: BUG: cant get a free block" );
    ( * msb ) . read_only = 1;
    return 65535U;
  }
# 1159 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  msb_mark_block_used ( msb , pba );
  return ( u16 ) pba;
}
# 1163 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_update_block(struct msb_data *msb, u16 lba, struct scatterlist *sg, int offset)
{
# 1166 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  u16 pba;
# 1166 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  u16 new_pba;
  int error;
# 1167 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int try;
# 1169 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  pba = * ( ( * msb ) . lba_to_pba_table + ( long unsigned int ) lba );
  if (debug > 1)
# 1170 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: start of a block update at lba  %d, pba %d\n" , ( int ) lba , ( int ) pba );
# 1172 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( short unsigned int ) pba != 65535U)
  {
# 1173 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 1)
# 1173 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: setting the update flag on the block\n" );
    msb_set_overwrite_flag ( msb , ( int ) pba , 0 , 239 );
  }
# 1178 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  try = 0;
# 1178 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32833;
  ldv_32832:;
# 1179 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  new_pba = msb_get_free_block ( msb , msb_get_zone_from_lba
# 1180 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( ( int ) lba ) );
# 1182 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( short unsigned int ) new_pba == 65535U)
  {
# 1183 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    error = -5;
    goto out;
  }
# 1187 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1187 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: block update: writing updated block to the pba %d\n" , ( int ) new_pba );
# 1189 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_write_block ( msb , ( int ) new_pba , ( u32 ) lba , sg , offset );
  if (error == -74)
  {
# 1191 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    msb_mark_bad ( msb , ( int ) new_pba );
    goto ldv_32831;
  }
# 1195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error != 0)
    goto out;
# 1198 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1198 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: block update: erasing the old block\n" );
  msb_erase_block ( msb , ( int ) pba );
  * ( ( * msb ) . lba_to_pba_table + ( long unsigned int ) lba ) = new_pba;
  return 0;
  ldv_32831:;
# 1178 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  try ++;
  ldv_32833:;
# 1178 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (try <= 2)
  {
    goto ldv_32832;
  }
  else
    goto ldv_32834;
  ldv_32834:;
# 1203 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  out:;
  if (error != 0)
  {
# 1205 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: block update error after %d tries,  switching to r/o mode" , try );
    ( * msb ) . read_only = 1;
  }
  return error;
}
# 1212 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_fix_boot_page_endianness(struct ms_boot_page *p)
{
  ( * p ) . header . block_id = ( short unsigned int ) __fswab16 ( ( int ) ( * p ) . header . block_id );
  ( * p ) . header . format_reserved = ( short unsigned int ) __fswab16 ( ( int ) ( * p ) . header . format_reserved );
# 1217 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  (
# 1216 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * p ) . entry . disabled_block . start_addr
# 1217 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  = ( unsigned int ) __fswab32 ( ( * p ) . entry . disabled_block . start_addr );
# 1219 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  (
# 1218 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * p ) . entry . disabled_block . data_size
# 1219 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  = ( unsigned int ) __fswab32 ( ( * p ) . entry . disabled_block . data_size );
# 1221 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  (
# 1220 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * p ) . entry . cis_idi . start_addr
# 1221 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  = ( unsigned int ) __fswab32 ( ( * p ) . entry . cis_idi . start_addr );
# 1223 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  (
# 1222 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * p ) . entry . cis_idi . data_size
# 1223 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  = ( unsigned int ) __fswab32 ( ( * p ) . entry . cis_idi . data_size );
  ( * p ) . attr . block_size = ( short unsigned int ) __fswab16 ( ( int ) ( * p ) . attr . block_size );
  ( * p ) . attr . number_of_blocks = ( short unsigned int ) __fswab16 ( ( int ) ( * p ) . attr . number_of_blocks );
# 1227 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  (
# 1226 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * p ) . attr . number_of_effective_blocks
# 1227 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  = ( short unsigned int ) __fswab16 ( ( int ) ( * p ) . attr . number_of_effective_blocks );
  ( * p ) . attr . page_size = ( short unsigned int ) __fswab16 ( ( int ) ( * p ) . attr . page_size );
# 1230 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  (
# 1229 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * p ) . attr . memory_manufacturer_code
# 1230 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  = ( short unsigned int ) __fswab16 ( ( int ) ( * p ) . attr . memory_manufacturer_code );
  ( * p ) . attr . memory_device_code = ( short unsigned int ) __fswab16 ( ( int ) ( * p ) . attr . memory_device_code );
# 1233 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  (
# 1232 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * p ) . attr . implemented_capacity
# 1233 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  = ( short unsigned int ) __fswab16 ( ( int ) ( * p ) . attr . implemented_capacity );
  ( * p ) . attr . controller_number = ( short unsigned int ) __fswab16 ( ( int ) ( * p ) . attr . controller_number );
  ( * p ) . attr . controller_function = ( short unsigned int ) __fswab16 ( ( int ) ( * p ) . attr . controller_function );
}
# 1238 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_read_boot_blocks(struct msb_data *msb)
{
  int pba = 0;
  struct scatterlist sg;
  struct ms_extra_data_register extra;
  struct ms_boot_page *page;
# 1245 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . boot_block_locations [ 0 ] = 65535U;
  ( * msb ) . boot_block_locations [ 1 ] = 65535U;
  ( * msb ) . boot_block_count = 0;
# 1249 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1249 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Start of a scan for the boot blocks\n" );
# 1251 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . boot_page == ( ( struct ms_boot_page *) 0 ))
  {
# 1252 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    page = ( struct ms_boot_page *) kmalloc ( 1024UL , 208U );
    if (page == ( ( struct ms_boot_page *) 0 ))
      return -12;
# 1256 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . boot_page = page;
  }
  else
# 1258 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    page = ( * msb ) . boot_page;
# 1260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . block_count = 12;
# 1262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  pba = 0;
# 1262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32848;
  ldv_32847:;
  sg_init_one ( & sg , ( void const *) page , 512U );
  if (msb_read_page ( msb , ( int ) ( u16 ) pba , 0 , & extra , & sg , 0 ) != 0)
  {
# 1266 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 0)
# 1266 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: boot scan: can\'t read pba %d\n" , pba );
    goto ldv_32845;
  }
# 1270 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( ( int ) extra . management_flag & 4 ) != 0)
  {
# 1271 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 0)
# 1271 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: managment flag doesn\'t indicate boot block %d\n" , pba );
# 1273 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_32845;
  }
# 1276 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( short unsigned int ) __fswab16 ( ( int ) ( * page ) . header . block_id ) != 1U)
  {
# 1277 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 0)
# 1277 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: the pba at %d doesn\' contain boot block ID\n" , pba );
    goto ldv_32845;
  }
# 1281 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  msb_fix_boot_page_endianness ( page );
  ( * msb ) . boot_block_locations [ ( * msb ) . boot_block_count ] = ( u16 ) pba;
# 1284 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  page ++;
  ( * msb ) . boot_block_count ++;
# 1287 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . boot_block_count == 2)
    goto ldv_32846;
  ldv_32845:;
# 1262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  pba ++;
  ldv_32848:;
# 1262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (pba <= 11)
  {
    goto ldv_32847;
  }
  else
    goto ldv_32846;
  ldv_32846:;
# 1291 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . boot_block_count == 0)
  {
# 1292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: media doesn\'t contain master page, aborting" );
    return -5;
  }
# 1296 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1296 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: End of scan for boot blocks\n" );
  return 0;
}
# 1300 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_read_bad_block_table(struct msb_data *msb, int block_nr)
{
  struct ms_boot_page *boot_block;
  struct scatterlist sg;
  u16 *buffer = ( ( u16 *) 0U );
  int offset = 0;
  int i;
# 1306 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int error = 0;
  int data_size;
# 1307 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int data_offset;
# 1307 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int page;
# 1307 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int page_offset;
# 1307 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int size_to_read;
  u16 pba;
# 1310 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (__builtin_expect ( block_nr > 1 , 0L ) != 0L)
  {
# 1310 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    asm volatile ( "1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection" : : "i" ( ( char *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" ) , "i" ( 1310 ) , "i" ( 12UL ) ) ;
    ldv_32865:;
# 1310 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_32865;
  }
# 1311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  boot_block = ( * msb ) . boot_page + ( long unsigned int ) block_nr;
  pba = ( * msb ) . boot_block_locations [ block_nr ];
# 1314 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( short unsigned int ) ( * msb ) . boot_block_locations [ block_nr ] == 65535U)
    return -22;
# 1317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  data_size = ( int ) ( * boot_block ) . entry . disabled_block . data_size;
  data_offset = ( int ) ( (
# 1319 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * boot_block ) . entry . disabled_block . start_addr + 512U );
  if (data_size == 0)
    return 0;
# 1323 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  page = data_offset / ( int ) ( * msb ) . page_size;
  page_offset = data_offset % ( int ) ( * msb ) . page_size;
  size_to_read = ( data_size
# 1326 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  + page_offset + ( int ) ( * msb ) . page_size + -1 ) / ( int ) ( * msb ) . page_size * ( int ) (
# 1327 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . page_size;
# 1329 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 0)
# 1329 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: reading bad block of boot block at pba %d, offset %d len %d\n" , ( int ) pba , data_offset , data_size );
# 1332 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  buffer = ( u16 *) kzalloc ( ( size_t ) size_to_read , 208U );
  if (buffer == ( ( u16 *) 0U ))
    return -12;
# 1337 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_init_one ( & sg , ( void const *) buffer , ( unsigned int ) size_to_read );
# 1339 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32869;
  ldv_32868:;
# 1340 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_read_page ( msb , ( int ) pba , ( int ) ( u8 ) page , ( ( struct ms_extra_data_register *) 0 ) , & sg , offset );
  if (error != 0)
    goto out;
# 1344 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  page ++;
  offset = ( int ) ( * msb ) . page_size + offset;
# 1347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . pages_in_block == page)
  {
# 1348 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: bad block table extends beyond the boot block" );
# 1350 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_32867;
  }
  ldv_32869:;
# 1339 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (offset < size_to_read)
  {
    goto ldv_32868;
  }
  else
    goto ldv_32867;
  ldv_32867:;
# 1355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  i = page_offset;
# 1355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32873;
  ldv_32872:;
  {
# 1357 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    u16 bad_block = ( u16 ) __fswab16 ( ( int ) * ( buffer + ( long unsigned int ) i ) );
# 1359 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( int ) bad_block >= ( * msb ) . block_count)
    {
# 1360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      if (debug > 0)
# 1360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        printk ( ( char const *) "\13ms_block: bad block table contains invalid block %d\n" , ( int ) bad_block );
# 1362 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      goto ldv_32871;
    }
# 1365 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (variable_test_bit ( ( long int ) bad_block , ( long unsigned int const volatile *) ( * msb ) . used_blocks_bitmap ) != 0)
    {
# 1366 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      if (debug > 0)
# 1366 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        printk ( ( char const *) "\13ms_block: duplicate bad block %d in the table\n" , ( int ) bad_block );
# 1368 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      goto ldv_32871;
    }
# 1371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 0)
# 1371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: block %d is marked as factory bad\n" , ( int ) bad_block );
    msb_mark_block_used ( msb , ( int ) bad_block );
  }
  ldv_32871:;
# 1355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  i ++;
  ldv_32873:;
# 1355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( long unsigned int ) i < ( long unsigned int ) data_size / 2UL)
  {
    goto ldv_32872;
  }
  else
    goto ldv_32874;
  ldv_32874:;
# 1374 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  out:;
  kfree ( ( void const *) buffer );
  return error;
}
# 1379 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_ftl_initialize(struct msb_data *msb)
{
  int i;
# 1383 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) ( * msb ) . ftl_initialized)
    return 0;
# 1386 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . zone_count = ( * msb ) . block_count / 512;
  ( * msb ) . logical_block_count = ( * msb ) . zone_count * 496 + -2;
# 1389 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . used_blocks_bitmap = ( long unsigned int *) kzalloc ( ( size_t ) ( ( * msb ) . block_count / 8 ) , 208U );
  ( * msb ) . erased_blocks_bitmap = ( long unsigned int *) kzalloc ( ( size_t ) ( ( * msb ) . block_count / 8 ) , 208U );
  ( * msb ) . lba_to_pba_table =
# 1392 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( u16 *) kmalloc ( ( long unsigned int ) ( * msb ) . logical_block_count * 2UL , 208U );
# 1394 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . used_blocks_bitmap == ( ( long unsigned int *) 0UL ) || ( * msb ) . lba_to_pba_table == ( ( u16 *) 0U ) || (
# 1395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . erased_blocks_bitmap == ( ( long unsigned int *) 0UL ))
  {
# 1396 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    kfree ( ( void const *) ( * msb ) . used_blocks_bitmap );
    kfree ( ( void const *) ( * msb ) . lba_to_pba_table );
    kfree ( ( void const *) ( * msb ) . erased_blocks_bitmap );
    return -12;
  }
# 1402 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  i = 0;
# 1402 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32880;
  ldv_32879:;
# 1403 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . free_block_count [ i ] = 512;
# 1402 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  i ++;
  ldv_32880:;
# 1402 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . zone_count > i)
  {
    goto ldv_32879;
  }
  else
    goto ldv_32881;
  ldv_32881:;
# 1405 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  memset ( ( void *) ( * msb ) . lba_to_pba_table , 65535 , ( long unsigned int ) (
# 1406 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . logical_block_count * 2UL );
# 1408 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 0)
# 1408 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: initial FTL tables created. Zone count = %d, Logical block count = %d\n" , ( * msb ) . zone_count , ( * msb ) . logical_block_count );
# 1411 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . ftl_initialized = 1;
  return 0;
}
# 1415 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_ftl_scan(struct msb_data *msb)
{
  u16 pba;
# 1417 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  u16 lba;
# 1417 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  u16 other_block;
  u8 overwrite_flag;
# 1418 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  u8 managment_flag;
# 1418 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  u8 other_overwrite_flag;
  int error;
  struct ms_extra_data_register extra;
  u8 *overwrite_flags = ( u8 *) kzalloc ( ( size_t ) ( * msb ) . block_count , 208U );
# 1423 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (overwrite_flags == ( ( u8 *) 0U ))
    return -12;
# 1426 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 0)
# 1426 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Start of media scanning\n" );
  pba = 0U;
# 1427 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32896;
  ldv_32895:;
  if (( short unsigned int ) ( * msb ) . boot_block_locations [ 0 ] == ( short unsigned int ) pba ||
# 1430 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( short unsigned int ) ( * msb ) . boot_block_locations [ 1 ] == ( short unsigned int ) pba)
  {
# 1431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 1)
# 1431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: pba %05d -> [boot block]\n" , ( int ) pba );
    msb_mark_block_used ( msb , ( int ) pba );
    goto ldv_32894;
  }
# 1436 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (variable_test_bit ( ( long int ) pba , ( long unsigned int const volatile *) ( * msb ) . used_blocks_bitmap ) != 0)
  {
# 1437 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 1)
# 1437 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: pba %05d -> [factory bad]\n" , ( int ) pba );
    goto ldv_32894;
  }
# 1441 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  memset ( ( void *) & extra , 0 , 4UL );
  error = msb_read_oob ( msb , ( int ) pba , 0 , & extra );
# 1445 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error == -74)
  {
# 1446 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\15ms_block: oob of pba %d damaged, will try to erase it" , ( int ) pba );
# 1448 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    msb_mark_block_used ( msb , ( int ) pba );
    msb_erase_block ( msb , ( int ) pba );
    goto ldv_32894;
  }
  else
# 1451 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (error != 0)
    {
# 1452 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: unknown error %d on read of oob of pba %d - aborting" , error , ( int ) pba );
# 1455 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      kfree ( ( void const *) overwrite_flags );
      return error;
    }
# 1459 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  lba = ( u16 ) __fswab16 ( ( int ) extra . logical_address );
  managment_flag = extra . management_flag;
  overwrite_flag = extra . overwrite_flag;
  * ( overwrite_flags + ( long unsigned int ) pba ) = overwrite_flag;
# 1465 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( signed char ) overwrite_flag >= 0)
  {
# 1466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 0)
# 1466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: pba %05d -> [BAD]\n" , ( int ) pba );
    msb_mark_block_used ( msb , ( int ) pba );
    goto ldv_32894;
  }
# 1472 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( ( int ) managment_flag & 52 ) != 52)
  {
    if (debug > 0)
# 1474 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: pba %05d -> [reserved managment flag %02x]\n" , ( int ) pba , ( int ) managment_flag );
# 1476 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    msb_mark_block_used ( msb , ( int ) pba );
    goto ldv_32894;
  }
# 1481 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( ( int ) managment_flag & 8 ) == 0)
  {
# 1482 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 0)
# 1482 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: pba %05d -> [temp table] - will erase\n" , ( int ) pba );
# 1484 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    msb_mark_block_used ( msb , ( int ) pba );
    msb_erase_block ( msb , ( int ) pba );
    goto ldv_32894;
  }
# 1489 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( short unsigned int ) lba == 65535U)
  {
# 1490 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 1)
# 1490 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: pba %05d -> [free]\n" , ( int ) pba );
    goto ldv_32894;
  }
# 1494 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  msb_mark_block_used ( msb , ( int ) pba );
# 1497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (msb_get_zone_from_lba ( ( int ) lba ) != msb_get_zone_from_pba ( ( int ) pba ))
  {
# 1498 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\15ms_block: pba %05d -> [bad lba %05d] - will erase" , ( int ) pba , ( int ) lba );
# 1500 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    msb_erase_block ( msb , ( int ) pba );
    goto ldv_32894;
  }
# 1505 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( short unsigned int ) * ( ( * msb ) . lba_to_pba_table + ( long unsigned int ) lba ) == 65535U)
  {
# 1506 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 1)
# 1506 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: pba %05d -> [lba %05d]\n" , ( int ) pba , ( int ) lba );
    * ( ( * msb ) . lba_to_pba_table + ( long unsigned int ) lba ) = pba;
    goto ldv_32894;
  }
# 1511 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  other_block = * ( ( * msb ) . lba_to_pba_table + ( long unsigned int ) lba );
  other_overwrite_flag = * ( overwrite_flags + ( long unsigned int ) other_block );
# 1514 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  printk ( ( char const *) "\15ms_block: Collision between pba %d and pba %d" , ( int ) pba , ( int ) other_block );
# 1517 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( ( int ) overwrite_flag & 16 ) == 0)
  {
# 1518 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\15ms_block: pba %d is marked as stable, use it" , ( int ) pba );
    msb_erase_block ( msb , ( int ) other_block );
    * ( ( * msb ) . lba_to_pba_table + ( long unsigned int ) lba ) = pba;
    goto ldv_32894;
  }
# 1524 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( ( int ) other_overwrite_flag & 16 ) == 0)
  {
# 1525 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\15ms_block: pba %d is marked as stable, use it" , ( int ) other_block );
# 1527 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    msb_erase_block ( msb , ( int ) pba );
    goto ldv_32894;
  }
# 1531 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  printk ( ( char const *) "\15ms_block: collision between blocks %d and %d, without stable flag set on both, erasing pba %d" , ( int ) pba , ( int ) other_block , ( int ) other_block );
# 1534 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  msb_erase_block ( msb , ( int ) other_block );
  * ( ( * msb ) . lba_to_pba_table + ( long unsigned int ) lba ) = pba;
  ldv_32894:;
# 1427 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  pba ++;
  ldv_32896:;
# 1427 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) pba < ( * msb ) . block_count)
  {
    goto ldv_32895;
  }
  else
    goto ldv_32897;
  ldv_32897:;
# 1538 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 0)
# 1538 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: End of media scanning\n" );
  kfree ( ( void const *) overwrite_flags );
  return 0;
}
# 1543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_cache_flush_timer(long unsigned int data)
{
  struct msb_data *msb = ( struct msb_data *) data;
  ( * msb ) . need_flush_cache = 1;
  queue_work ( ( * msb ) . io_queue , & ( * msb ) . io_work );
}
# 1551 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_cache_discard(struct msb_data *msb)
{
  if (( * msb ) . cache_block_lba == 65535)
    return;
# 1556 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  del_timer_sync ( & ( * msb ) . cache_flush_timer );
# 1558 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1558 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Discarding the write cache\n" );
  ( * msb ) . cache_block_lba = 65535;
  bitmap_zero ( & ( * msb ) . valid_cache_bitmap , ( * msb ) . pages_in_block );
}
# 1563 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_cache_init(struct msb_data *msb)
{
  {
# 1565 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    struct lock_class_key __key;
# 1565 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    init_timer_key ( & ( * msb ) . cache_flush_timer , 0U , ( char const *) "((&msb->cache_flush_timer))" , & __key );
  }
# 1565 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . cache_flush_timer . function = & msb_cache_flush_timer;
# 1565 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . cache_flush_timer . data = ( long unsigned int ) msb;
# 1568 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . cache == ( ( unsigned char *) 0U ))
    ( * msb ) . cache = ( unsigned char *) kzalloc ( ( size_t ) ( * msb ) . block_size , 208U );
  if (( * msb ) . cache == ( ( unsigned char *) 0U ))
    return -12;
# 1573 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  msb_cache_discard ( msb );
  return 0;
}
# 1577 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_cache_flush(struct msb_data *msb)
{
  struct scatterlist sg;
  struct ms_extra_data_register extra;
  int page;
# 1581 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int offset;
# 1581 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int error;
  u16 pba;
# 1582 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  u16 lba;
# 1584 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) ( * msb ) . read_only)
    return -30;
# 1587 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . cache_block_lba == 65535)
    return 0;
# 1590 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  lba = ( u16 ) ( * msb ) . cache_block_lba;
  pba = * ( ( * msb ) . lba_to_pba_table + ( long unsigned int ) lba );
# 1593 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1593 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Flushing the write cache of pba %d (LBA %d)\n" , ( int ) pba , ( * msb ) . cache_block_lba );
# 1596 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_init_one ( & sg , ( void const *) ( * msb ) . cache , ( unsigned int ) ( * msb ) . block_size );
# 1599 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  page = 0;
# 1599 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32921;
  ldv_32920:;
  if (variable_test_bit ( ( long int ) page , ( long unsigned int const volatile *) & ( * msb ) . valid_cache_bitmap ) != 0)
  {
# 1602 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_32919;
  }
  offset = ( int ) ( * msb ) . page_size * page;
# 1606 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1606 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: reading non-present sector %d of cache block %d\n" , page , ( int ) lba );
# 1608 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_read_page ( msb , ( int ) pba , ( int ) ( u8 ) page , & extra , & sg , offset );
# 1611 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error == -74)
  {
# 1612 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: read error on sector %d, contents probably damaged" , page );
    goto ldv_32919;
  }
# 1616 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error != 0)
    return error;
# 1619 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( ( int ) extra . overwrite_flag & 96 ) != 96)
  {
    if (debug > 0)
# 1621 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: page %d is marked as bad\n" , page );
    goto ldv_32919;
  }
# 1625 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  set_bit ( ( long int ) page , ( long unsigned int volatile *) & ( * msb ) . valid_cache_bitmap );
  ldv_32919:;
# 1599 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  page ++;
  ldv_32921:;
# 1599 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . pages_in_block > page)
  {
    goto ldv_32920;
  }
  else
    goto ldv_32922;
  ldv_32922:;
# 1629 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_update_block ( msb , ( int ) ( u16 ) ( * msb ) . cache_block_lba , & sg , 0 );
  pba = * ( ( * msb ) . lba_to_pba_table + ( long unsigned int ) ( * msb ) . cache_block_lba );
# 1633 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error == 0)
  {
# 1634 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    page = 0;
# 1634 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_32925;
    ldv_32924:;
    if (variable_test_bit ( ( long int ) page , ( long unsigned int const volatile *) & ( * msb ) . valid_cache_bitmap ) != 0)
    {
# 1637 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      goto ldv_32923;
    }
    if (debug > 0)
# 1639 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: marking page %d as containing damaged data\n" , page );
# 1641 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    msb_set_overwrite_flag ( msb , ( int ) pba , ( int ) ( u8 ) page , 159 );
    ldv_32923:;
# 1634 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    page ++;
    ldv_32925:;
# 1634 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( * msb ) . pages_in_block > page)
    {
      goto ldv_32924;
    }
    else
      goto ldv_32926;
    ldv_32926:;
  }
# 1646 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  msb_cache_discard ( msb );
  return error;
}
# 1650 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_cache_write(struct msb_data *msb, int lba, int page, bool add_to_cache_only, struct scatterlist *sg, int offset)
{
# 1653 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int error;
  struct scatterlist sg_tmp[10U];
  struct
  {
# 1681 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    signed char ldv_32938;
  };
  struct
  {
# 1682 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    signed char ldv_32940;
  };
# 1656 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) ( * msb ) . read_only)
    return -30;
# 1659 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . cache_block_lba == 65535 || (
# 1660 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . cache_block_lba != lba)
    if (( int ) add_to_cache_only)
      return 0;
# 1665 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . cache_block_lba != 65535 && (
# 1666 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . cache_block_lba != lba)
  {
# 1667 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 1)
# 1667 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: first flush the cache\n" );
    error = msb_cache_flush ( msb );
    if (error != 0)
      return error;
  }
# 1673 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . cache_block_lba == 65535)
  {
# 1674 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . cache_block_lba = lba;
    mod_timer ( & ( * msb ) . cache_flush_timer , msecs_to_jiffies
# 1676 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( ( unsigned int const ) cache_flush_timeout ) + ( long unsigned int ) jiffies );
  }
# 1679 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1679 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Write of LBA %d page %d to cache \n" , lba , page );
# 1681 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_init_table ( ( struct scatterlist *) & sg_tmp , 10U );
  msb_sg_copy ( sg , ( struct scatterlist *) & sg_tmp , 10 , ( size_t ) offset , ( size_t ) ( * msb ) . page_size );
# 1684 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_copy_to_buffer ( ( struct scatterlist *) & sg_tmp , ( unsigned int ) sg_nents ( ( struct scatterlist *) & sg_tmp ) ,
# 1685 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( void *) ( * msb ) . cache + ( long unsigned int ) ( long unsigned int ) ( ( int ) ( * msb ) . page_size * page ) , ( size_t ) ( * msb ) . page_size );
# 1687 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  set_bit ( ( long int ) page , ( long unsigned int volatile *) & ( * msb ) . valid_cache_bitmap );
  return 0;
}
# 1691 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_cache_read(struct msb_data *msb, int lba, int page, struct scatterlist *sg, int offset)
{
# 1694 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int pba = ( int ) * ( ( * msb ) . lba_to_pba_table + ( long unsigned int ) lba );
  struct scatterlist sg_tmp[10U];
  int error = 0;
# 1698 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . cache_block_lba == lba && variable_test_bit
# 1699 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( ( long int ) page , ( long unsigned int const volatile *) & ( * msb ) . valid_cache_bitmap )
# 1698 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  != 0)
  {
    struct
    {
# 1704 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      signed char ldv_32952;
    };
    struct
    {
# 1705 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      signed char ldv_32954;
    };
# 1701 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 1)
# 1701 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: Read of LBA %d (pba %d) sector %d from cache\n" , lba , pba , page );
# 1704 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    sg_init_table ( ( struct scatterlist *) & sg_tmp , 10U );
    msb_sg_copy ( sg , ( struct scatterlist *) & sg_tmp , 10 , ( size_t ) offset , ( size_t ) (
# 1706 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    * msb ) . page_size );
    sg_copy_from_buffer ( ( struct scatterlist *) & sg_tmp , ( unsigned int ) sg_nents ( ( struct scatterlist *) & sg_tmp ) ,
# 1708 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void *) ( * msb ) . cache + ( long unsigned int ) ( long unsigned int ) ( ( int ) ( * msb ) . page_size * page ) , ( size_t ) (
# 1709 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    * msb ) . page_size );
  }
  else
  {
# 1711 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 1)
# 1711 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: Read of LBA %d (pba %d) sector %d from device\n" , lba , pba , page );
# 1714 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    error = msb_read_page ( msb , ( int ) ( u16 ) pba , ( int ) ( u8 ) page , ( ( struct ms_extra_data_register *) 0 ) , sg , offset );
    if (error != 0)
      return error;
# 1718 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    msb_cache_write ( msb , lba , page , 1 , sg , offset );
  }
  return error;
}
# 1729 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static struct chs_entry const chs_table[7U] = { [ 0U ] = { . size = 4UL , . sec = 16U , . cyl = 247U , . head = 2U } , [ 1U ] = { . size = 8UL , . sec = 16U , . cyl = 495U , . head = 2U } , [ 2U ] = { . size = 16UL , . sec = 16U , . cyl = 495U , . head = 4U } , [ 3U ] = { . size = 32UL , . sec = 16U , . cyl = 991U , . head = 4U } , [ 4U ] = { . size = 64UL , . sec = 16U , . cyl = 991U , . head = 8U } , [ 5U ] = { . size = 128UL , . sec = 16U , . cyl = 991U , . head = 16U } , [ 6U ] = { . size = 0UL } };
# 1741 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_init_card(struct memstick_dev *card)
{
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  struct memstick_host *host = ( * card ) . host;
  struct ms_boot_page *boot_block;
  int error = 0;
# 1746 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int i;
# 1746 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int raw_size_in_megs;
# 1748 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . caps = 0;
# 1750 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * card ) . id . class != 0U && (
# 1751 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * card ) . id . class <= 1U)
    ( * msb ) . read_only = 1;
# 1754 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . state = -1;
  error = msb_reset ( msb , 0 );
  if (error != 0)
    return error;
# 1762 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( ( * host ) . caps & 2U ) != 0U)
    msb_switch_to_parallel ( msb );
# 1765 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . page_size = 512U;
# 1768 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_read_boot_blocks ( msb );
  if (error != 0)
    return -5;
# 1772 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  boot_block = ( * msb ) . boot_page;
# 1775 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . block_count = ( int ) ( * boot_block ) . attr . number_of_blocks;
  ( * msb ) . page_size = ( * boot_block ) . attr . page_size;
# 1778 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . pages_in_block = ( int ) ( * boot_block ) . attr . block_size * 2;
  ( * msb ) . block_size = ( int ) ( * msb ) . page_size * ( * msb ) . pages_in_block;
# 1781 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . page_size > 4096U)
  {
    if (debug > 0)
# 1783 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: device page %d size isn\'t supported\n" , ( int ) ( * msb ) . page_size );
    return -22;
  }
# 1787 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . block_buffer = ( unsigned char *) kzalloc ( ( size_t ) ( * msb ) . block_size , 208U );
  if (( * msb ) . block_buffer == ( ( unsigned char *) 0U ))
    return -12;
# 1791 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  raw_size_in_megs = ( * msb ) . block_size * ( * msb ) . block_count >> 20;
# 1793 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  i = 0;
# 1793 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32968;
  ldv_32967:;
  if (( long unsigned int ) chs_table [ i ] . size != ( long unsigned int ) raw_size_in_megs)
  {
# 1796 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_32965;
  }
  ( * msb ) . geometry . cylinders = chs_table [ i ] . cyl;
  ( * msb ) . geometry . heads = chs_table [ i ] . head;
  ( * msb ) . geometry . sectors = chs_table [ i ] . sec;
  goto ldv_32966;
  ldv_32965:;
# 1793 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  i ++;
  ldv_32968:;
# 1793 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( long unsigned int ) chs_table [ i ] . size != 0UL)
  {
    goto ldv_32967;
  }
  else
    goto ldv_32966;
  ldv_32966:;
# 1804 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * boot_block ) . attr . transfer_supporting == 1U)
    ( * msb ) . caps |= 2;
# 1807 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( ( int ) ( * boot_block ) . attr . device_type & 3 ) != 0)
    ( * msb ) . read_only = 1;
# 1810 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 0)
# 1810 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Total block count = %d\n" , ( * msb ) . block_count );
  if (debug > 0)
# 1811 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Each block consists of %d pages\n" , ( * msb ) . pages_in_block );
  if (debug > 0)
# 1812 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Page size = %d bytes\n" , ( int ) ( * msb ) . page_size );
  if (debug > 0)
# 1813 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Parallel mode supported: %d\n" , ( ( * msb ) . caps & 2 ) != 0 );
  if (debug > 0)
# 1814 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Read only: %d\n" , ( int ) ( * msb ) . read_only );
# 1822 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_cache_init ( msb );
  if (error != 0)
    return error;
# 1826 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_ftl_initialize ( msb );
  if (error != 0)
    return error;
# 1832 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_read_bad_block_table ( msb , 0 );
# 1834 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error != 0 && error != -12)
  {
# 1835 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 0)
# 1835 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: failed to read bad block table from primary boot block, trying from backup\n" );
    error = msb_read_bad_block_table ( msb , 1 );
  }
# 1839 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error != 0)
    return error;
# 1843 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_ftl_scan ( msb );
  if (error != 0)
  {
# 1845 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Scan of media failed" );
    return error;
  }
# 1849 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return 0;
}
# 1853 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_do_write_request(struct msb_data *msb, int lba, int page, struct scatterlist *sg, size_t len, int *sucessfuly_written)
{
# 1856 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int error = 0;
  off_t offset = 0L;
  * sucessfuly_written = 0;
# 1860 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32979;
  ldv_32980:;
# 1861 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (page == 0 && ( long unsigned int ) len - ( long unsigned int ) offset >= ( long unsigned int ) ( * msb ) . block_size)
  {
    if (( * msb ) . cache_block_lba == lba)
      msb_cache_discard ( msb );
# 1866 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 1)
# 1866 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: Writing whole lba %d\n" , lba );
    error = msb_update_block ( msb , ( int ) ( u16 ) lba , sg , ( int ) offset );
    if (error != 0)
      return error;
# 1871 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    offset = ( off_t ) ( * msb ) . block_size + offset;
    * sucessfuly_written += ( * msb ) . block_size;
    lba ++;
    goto ldv_32979;
  }
# 1877 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  error = msb_cache_write ( msb , lba , page , 0 , sg , ( int ) offset );
  if (error != 0)
    return error;
# 1881 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  offset = ( off_t ) ( * msb ) . page_size + offset;
  * sucessfuly_written += ( int ) ( * msb ) . page_size;
# 1884 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  page ++;
  if (( * msb ) . pages_in_block == page)
  {
# 1886 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    page = 0;
    lba ++;
  }
  ldv_32979:;
# 1860 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( long unsigned int ) offset < ( long unsigned int ) len)
  {
    goto ldv_32980;
  }
  else
    goto ldv_32981;
  ldv_32981:;
# 1890 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return 0;
}
# 1893 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_do_read_request(struct msb_data *msb, int lba, int page, struct scatterlist *sg, int len, int *sucessfuly_read)
{
# 1896 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int error = 0;
  int offset = 0;
  * sucessfuly_read = 0;
# 1900 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_32993;
  ldv_32992:;
  error = msb_cache_read ( msb , lba , page , sg , offset );
  if (error != 0)
    return error;
# 1906 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  offset = ( int ) ( * msb ) . page_size + offset;
  * sucessfuly_read += ( int ) ( * msb ) . page_size;
# 1909 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  page ++;
  if (( * msb ) . pages_in_block == page)
  {
# 1911 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    page = 0;
    lba ++;
  }
  ldv_32993:;
# 1900 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (offset < len)
  {
    goto ldv_32992;
  }
  else
    goto ldv_32994;
  ldv_32994:;
# 1915 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return 0;
}
# 1918 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_io_work(struct work_struct *work)
{
  struct msb_data *msb = ({
# 1920 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    struct work_struct const *__mptr = ( struct work_struct const *) work;
# 1920 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( struct msb_data *) __mptr + 18446744073709551432U;
  } );
# 1921 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int page;
# 1921 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int error;
# 1921 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int len;
  sector_t lba;
  long unsigned int flags;
  struct scatterlist *sg = ( struct scatterlist *) & ( * msb ) . prealloc_sg;
# 1926 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1926 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: IO: work started\n" );
  ldv_33019:;
# 1929 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ({
# 1929 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int __dummy;
# 1929 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int __dummy2;
# 1929 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void ) 0;
# 1929 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    1;
  } );
# 1929 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  flags = _raw_spin_lock_irqsave ( spinlock_check ( & ( * msb ) . q_lock ) );
# 1931 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) ( * msb ) . need_flush_cache)
  {
# 1932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . need_flush_cache = 0;
    spin_unlock_irqrestore ( & ( * msb ) . q_lock , flags );
    msb_cache_flush ( msb );
    goto ldv_33010;
  }
# 1938 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . req == ( ( struct request *) 0 ))
  {
# 1939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . req = blk_fetch_request ( ( * msb ) . queue );
    if (( * msb ) . req == ( ( struct request *) 0 ))
    {
# 1941 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      if (debug > 1)
# 1941 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        printk ( ( char const *) "\13ms_block: IO: no more requests exiting\n" );
      spin_unlock_irqrestore ( & ( * msb ) . q_lock , flags );
      return;
    }
  }
# 1947 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  spin_unlock_irqrestore ( & ( * msb ) . q_lock , flags );
# 1950 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . req == ( ( struct request *) 0 ))
    return;
# 1954 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1954 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: IO: processing new request\n" );
  blk_rq_map_sg ( ( * msb ) . queue , ( * msb ) . req , sg );
# 1957 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  lba = blk_rq_pos ( ( struct request const *) ( * msb ) . req );
# 1959 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ({
# 1959 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    int _res;
# 1959 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    _res = ( int ) ( lba % ( sector_t ) ( ( * msb ) . page_size / 512U ) );
# 1959 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    lba /= ( sector_t ) ( ( * msb ) . page_size / 512U );
# 1959 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    _res;
  } );
# 1960 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  page = ( int ) ({
# 1960 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    uint32_t __base = ( uint32_t ) ( * msb ) . pages_in_block;
# 1960 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    uint32_t __rem;
# 1960 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    __rem = ( uint32_t ) ( ( long long unsigned int ) lba % ( long long unsigned int ) __base );
# 1960 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    lba = ( sector_t ) ( ( long long unsigned int ) lba / ( long long unsigned int ) __base );
# 1960 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    __rem;
  } );
  if (( ( int ) ( * ( * msb ) . req ) . cmd_flags & 1 ) == 0)
  {
# 1963 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    error = msb_do_read_request ( msb , ( int ) lba , page , sg , ( int ) blk_rq_bytes
# 1964 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( ( struct request const *) ( * msb ) . req ) , & len );
  }
  else
# 1966 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    error = msb_do_write_request ( msb , ( int ) lba , page , sg , ( size_t ) blk_rq_bytes
# 1967 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( ( struct request const *) ( * msb ) . req ) , & len );
# 1969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ({
# 1969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int __dummy;
# 1969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int __dummy2;
# 1969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void ) 0;
# 1969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    1;
  } );
# 1969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  flags = _raw_spin_lock_irqsave ( spinlock_check ( & ( * msb ) . q_lock ) );
# 1971 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (len != 0)
    if (( int ) ! ( _Bool ) __blk_end_request ( ( * msb ) . req , 0 , ( unsigned int ) len ))
      ( * msb ) . req = ( ( struct request *) 0 );
# 1975 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (error != 0 && ( * msb ) . req != ( ( struct request *) 0 ))
  {
# 1976 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 1)
# 1976 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: IO: ending one sector of the request with error\n" );
    if (( int ) ! ( _Bool ) __blk_end_request ( ( * msb ) . req , error , ( unsigned int ) ( * msb ) . page_size ))
      ( * msb ) . req = ( ( struct request *) 0 );
  }
# 1981 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . req != ( ( struct request *) 0 ))
    if (debug > 1)
# 1982 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: IO: request still pending\n" );
# 1984 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  spin_unlock_irqrestore ( & ( * msb ) . q_lock , flags );
  ldv_33010:;
# 1985 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_33019;
}
# 1988 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static struct idr msb_disk_idr = { . lock = { . ldv_6073 = { . rlock = { . raw_lock = { . ldv_1452 = { . head_tail = 0U } } , . magic = 3735899821U , . owner_cpu = 4294967295U , . owner = ( ( void *) -1 ) , . dep_map = { . name = ( char const *) "msb_disk_idr.lock" } } } } };
static struct mutex msb_disk_lock = { . count = { . counter = 1 } , . wait_lock = { . ldv_6073 = { . rlock = { . raw_lock = { . ldv_1452 = { . head_tail = 0U } } , . magic = 3735899821U , . owner_cpu = 4294967295U , . owner = ( ( void *) -1 ) , . dep_map = { . name = ( char const *) "msb_disk_lock.wait_lock" } } } } , . wait_list = { . next = & msb_disk_lock . wait_list , . prev = & msb_disk_lock . wait_list } , . magic = ( void *) & msb_disk_lock , . dep_map = { . name = ( char const *) "msb_disk_lock" } };
# 1991 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_bd_open(struct block_device *bdev, fmode_t mode)
{
  struct gendisk *disk = ( * bdev ) . bd_disk;
  struct msb_data *msb = ( struct msb_data *) ( * disk ) . private_data;
# 1996 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 1996 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: block device open\n" );
# 1998 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_8 ( & msb_disk_lock );
# 2000 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (msb != ( ( struct msb_data *) 0 ) && ( * msb ) . card != ( ( struct memstick_dev *) 0 ))
    ( * msb ) . usage_count ++;
# 2003 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_unlock_9 ( & msb_disk_lock );
  return 0;
}
# 2007 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_data_clear(struct msb_data *msb)
{
  kfree ( ( void const *) ( * msb ) . boot_page );
  kfree ( ( void const *) ( * msb ) . used_blocks_bitmap );
  kfree ( ( void const *) ( * msb ) . lba_to_pba_table );
  kfree ( ( void const *) ( * msb ) . cache );
  ( * msb ) . card = ( ( struct memstick_dev *) 0 );
}
# 2016 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_disk_release(struct gendisk *disk)
{
  struct msb_data *msb = ( struct msb_data *) ( * disk ) . private_data;
# 2020 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 2020 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: block device release\n" );
  ldv_mutex_lock_10 ( & msb_disk_lock );
# 2023 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (msb != ( ( struct msb_data *) 0 ))
  {
# 2024 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( * msb ) . usage_count != 0U)
      ( * msb ) . usage_count --;
# 2027 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( * msb ) . usage_count == 0U)
    {
# 2028 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ( * disk ) . private_data = ( ( void *) 0 );
      idr_remove ( & msb_disk_idr , ( * msb ) . disk_id );
      put_disk ( disk );
      kfree ( ( void const *) msb );
    }
  }
  ldv_mutex_unlock_11 ( & msb_disk_lock );
  return 0;
}
# 2038 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_bd_release(struct gendisk *disk, fmode_t mode)
{
  msb_disk_release ( disk );
}
# 2043 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_bd_getgeo(struct block_device *bdev, struct hd_geometry *geo)
{
# 2046 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  struct msb_data *msb = ( struct msb_data *) ( * ( * bdev ) . bd_disk ) . private_data;
  * geo = ( * msb ) . geometry;
  return 0;
}
# 2051 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_prepare_req(struct request_queue *q, struct request *req)
{
  if (( unsigned int ) ( * req ) . cmd_type != 1U && ( unsigned int ) (
# 2054 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * req ) . cmd_type != 2U)
  {
# 2055 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    blk_dump_rq_flags ( req , ( char *) "MS unsupported request" );
    return 1;
  }
  ( * req ) . cmd_flags = ( long long unsigned int ) ( * req ) . cmd_flags | 524288ULL;
  return 0;
}
# 2062 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_submit_req(struct request_queue *q)
{
  struct memstick_dev *card = ( struct memstick_dev *) ( * q ) . queuedata;
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  struct request *req = ( ( struct request *) 0 );
# 2068 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 1)
# 2068 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Submit request\n" );
# 2070 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) ( * msb ) . card_dead)
  {
# 2071 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (debug > 0)
# 2071 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: Refusing requests on removed card\n" );
# 2073 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ({
# 2073 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      int __ret_warn_on = ( int ) ! ( _Bool ) ( * msb ) . io_queue_stopped;
      {
# 2073 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
        if (__builtin_expect ( __ret_warn_on != 0 , 0L ) != 0L)
# 2073 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
          warn_slowpath_null ( ( char const *) "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared" , 2073 );
      }
# 2073 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      __builtin_expect ( __ret_warn_on != 0 , 0L );
    } );
    goto ldv_33059;
    ldv_33058:;
# 2076 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    __blk_end_request_all ( req , -19 );
    ldv_33059:;
# 2075 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (( req = blk_fetch_request ( q ) ) != ( ( struct request *) 0 ))
    {
      goto ldv_33058;
    }
    else
      goto ldv_33060;
    ldv_33060:;
# 2077 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    return;
  }
# 2080 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . req != ( ( struct request *) 0 ))
    return;
# 2083 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) ! ( _Bool ) ( * msb ) . io_queue_stopped)
    queue_work ( ( * msb ) . io_queue , & ( * msb ) . io_work );
}
# 2087 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_check_card(struct memstick_dev *card)
{
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  return ( int ) ! ( _Bool ) ( * msb ) . card_dead;
}
# 2093 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_stop(struct memstick_dev *card)
{
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  long unsigned int flags;
# 2098 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 0)
# 2098 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Stopping all msblock IO\n" );
# 2100 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ({
# 2100 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int __dummy;
# 2100 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int __dummy2;
# 2100 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void ) 0;
# 2100 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    1;
  } );
# 2100 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  flags = _raw_spin_lock_irqsave ( spinlock_check ( & ( * msb ) . q_lock ) );
  blk_stop_queue ( ( * msb ) . queue );
  ( * msb ) . io_queue_stopped = 1;
  spin_unlock_irqrestore ( & ( * msb ) . q_lock , flags );
# 2105 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  del_timer_sync ( & ( * msb ) . cache_flush_timer );
  flush_workqueue ( ( * msb ) . io_queue );
# 2108 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . req != ( ( struct request *) 0 ))
  {
# 2109 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ({
# 2109 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      long unsigned int __dummy;
# 2109 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      long unsigned int __dummy2;
# 2109 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ( void ) 0;
# 2109 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      1;
    } );
# 2109 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    flags = _raw_spin_lock_irqsave ( spinlock_check ( & ( * msb ) . q_lock ) );
    blk_requeue_request ( ( * msb ) . queue , ( * msb ) . req );
    ( * msb ) . req = ( ( struct request *) 0 );
    spin_unlock_irqrestore ( & ( * msb ) . q_lock , flags );
  }
}
# 2117 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_start(struct memstick_dev *card)
{
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  long unsigned int flags;
# 2122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 0)
# 2122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Resuming IO from msblock\n" );
# 2124 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  msb_invalidate_reg_window ( msb );
# 2126 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ({
# 2126 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int __dummy;
# 2126 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int __dummy2;
# 2126 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void ) 0;
# 2126 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    1;
  } );
# 2126 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  flags = _raw_spin_lock_irqsave ( spinlock_check ( & ( * msb ) . q_lock ) );
  if (( int ) ! ( _Bool ) ( * msb ) . io_queue_stopped || ( int ) ( * msb ) . card_dead)
  {
# 2128 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    spin_unlock_irqrestore ( & ( * msb ) . q_lock , flags );
    return;
  }
  spin_unlock_irqrestore ( & ( * msb ) . q_lock , flags );
# 2134 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . need_flush_cache = 1;
  ( * msb ) . io_queue_stopped = 0;
# 2137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ({
# 2137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int __dummy;
# 2137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int __dummy2;
# 2137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void ) 0;
# 2137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    1;
  } );
# 2137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  flags = _raw_spin_lock_irqsave ( spinlock_check ( & ( * msb ) . q_lock ) );
  blk_start_queue ( ( * msb ) . queue );
  spin_unlock_irqrestore ( & ( * msb ) . q_lock , flags );
# 2141 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  queue_work ( ( * msb ) . io_queue , & ( * msb ) . io_work );
}
# 2145 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static struct block_device_operations const msb_bdops = { . open =
# 2146 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
& msb_bd_open , . release =
# 2147 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
& msb_bd_release , . getgeo =
# 2148 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
& msb_bd_getgeo , . owner =
# 2149 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
& __this_module };
# 2153 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_init_disk(struct memstick_dev *card)
{
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  struct memstick_host *host = ( * card ) . host;
  int rc;
  u64 limit = 18446744073709551615ULL;
  long unsigned int capacity;
# 2161 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * host ) . dev . dma_mask != ( ( u64 *) 0ULL ) && * ( * host ) . dev . dma_mask != 0ULL)
    limit = * ( * host ) . dev . dma_mask;
# 2164 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_12 ( & msb_disk_lock );
  ( * msb ) . disk_id = idr_alloc ( & msb_disk_idr , ( void *) card , 0 , 256 , 208U );
  ldv_mutex_unlock_13 ( & msb_disk_lock );
# 2168 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . disk_id < 0)
    return ( * msb ) . disk_id;
# 2171 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . disk = alloc_disk ( 0 );
  if (( * msb ) . disk == ( ( struct gendisk *) 0 ))
  {
# 2173 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    rc = -12;
    goto out_release_id;
  }
# 2177 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . queue = blk_init_queue ( ( request_fn_proc *) & msb_submit_req , & ( * msb ) . q_lock );
  if (( * msb ) . queue == ( ( struct request_queue *) 0 ))
  {
# 2179 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    rc = -12;
    goto out_put_disk;
  }
# 2183 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * ( * msb ) . queue ) . queuedata = ( void *) card;
  blk_queue_prep_rq ( ( * msb ) . queue , ( prep_rq_fn *) & msb_prepare_req );
# 2186 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  blk_queue_bounce_limit ( ( * msb ) . queue , limit );
  blk_queue_max_hw_sectors ( ( * msb ) . queue , 131071U );
  blk_queue_max_segments ( ( * msb ) . queue , 32 );
  blk_queue_max_segment_size ( ( * msb ) . queue , ( unsigned int ) ( ( int ) (
# 2190 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . page_size * 131071 ) );
  blk_queue_logical_block_size ( ( * msb ) . queue , ( int ) ( * msb ) . page_size );
# 2193 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sprintf ( ( char *) & ( * ( * msb ) . disk ) . disk_name , ( char const *) "msblk%d" , ( * msb ) . disk_id );
  ( * ( * msb ) . disk ) . fops = & msb_bdops;
  ( * ( * msb ) . disk ) . private_data = ( void *) msb;
  ( * ( * msb ) . disk ) . queue = ( * msb ) . queue;
  ( * ( * msb ) . disk ) . driverfs_dev = & ( * card ) . dev;
  ( * ( * msb ) . disk ) . flags |= 64;
# 2200 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  capacity = ( long unsigned int ) ( ( * msb ) . pages_in_block * ( * msb ) . logical_block_count );
  capacity = ( long unsigned int ) ( ( * msb ) . page_size / 512U ) * capacity;
  set_capacity ( ( * msb ) . disk , capacity );
  if (debug > 0)
# 2203 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Set total disk size to %lu sectors\n" , capacity );
# 2205 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . usage_count = 1U;
  ( * msb ) . io_queue = ({
# 2206 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    struct lock_class_key __key;
# 2206 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    char const *__lock_name;
# 2206 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    __lock_name = ( char const *) "\"ms_block\"";
# 2206 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    __alloc_workqueue_key ( ( char const *) "ms_block" , 131082U , 1 , & __key , __lock_name );
  } );
  {
# 2207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    struct lock_class_key __key;
# 2207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    __init_work ( & ( * msb ) . io_work , 0 );
# 2207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . io_work . data = ( atomic_long_t ) { . counter = WORK_STRUCT_NO_POOL };
# 2207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    lockdep_init_map ( & ( * msb ) . io_work . lockdep_map , ( char const *) "(&msb->io_work)" , & __key , 0 );
# 2207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    INIT_LIST_HEAD ( & ( * msb ) . io_work . entry );
# 2207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * msb ) . io_work . func = & msb_io_work;
  }
# 2208 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_init_table ( ( struct scatterlist *) & ( * msb ) . prealloc_sg , 33U );
# 2210 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) ( * msb ) . read_only)
    set_disk_ro ( ( * msb ) . disk , 1 );
# 2213 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  msb_start ( card );
  add_disk ( ( * msb ) . disk );
  if (debug > 0)
# 2215 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Disk added\n" );
  return 0;
# 2218 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  out_put_disk:;
  put_disk ( ( * msb ) . disk );
  out_release_id:;
  ldv_mutex_lock_14 ( & msb_disk_lock );
  idr_remove ( & msb_disk_idr , ( * msb ) . disk_id );
  ldv_mutex_unlock_15 ( & msb_disk_lock );
  return rc;
}
# 2227 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_probe(struct memstick_dev *card)
{
  struct msb_data *msb;
  int rc = 0;
# 2232 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  msb = ( struct msb_data *) kzalloc ( 1960UL , 208U );
  if (msb == ( ( struct msb_data *) 0 ))
    return -12;
  memstick_set_drvdata ( card , ( void *) msb );
  ( * msb ) . card = card;
  spinlock_check ( & ( * msb ) . q_lock );
  {
# 2237 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    struct lock_class_key __key;
# 2237 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    __raw_spin_lock_init ( ( raw_spinlock_t *) & ( * msb ) . q_lock . ldv_6073 . rlock , ( char const *) "&(&msb->q_lock)->rlock" , & __key );
  }
  rc = msb_init_card ( card );
  if (rc != 0)
    goto out_free;
# 2243 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  rc = msb_init_disk ( card );
  if (rc == 0)
  {
# 2245 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( * card ) . check = & msb_check_card;
    ( * card ) . stop = & msb_stop;
    ( * card ) . start = & msb_start;
    return 0;
  }
  out_free:;
  memstick_set_drvdata ( card , ( ( void *) 0 ) );
  msb_data_clear ( msb );
  kfree ( ( void const *) msb );
  return rc;
}
# 2257 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_remove(struct memstick_dev *card)
{
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  long unsigned int flags;
# 2262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( int ) ! ( _Bool ) ( * msb ) . io_queue_stopped)
    msb_stop ( card );
# 2265 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (debug > 0)
# 2265 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: Removing the disk device\n" );
# 2268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ({
# 2268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int __dummy;
# 2268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    long unsigned int __dummy2;
# 2268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ( void ) 0;
# 2268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    1;
  } );
# 2268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  flags = _raw_spin_lock_irqsave ( spinlock_check ( & ( * msb ) . q_lock ) );
  ( * msb ) . card_dead = 1;
  blk_start_queue ( ( * msb ) . queue );
  spin_unlock_irqrestore ( & ( * msb ) . q_lock , flags );
# 2274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  del_gendisk ( ( * msb ) . disk );
  blk_cleanup_queue ( ( * msb ) . queue );
  ( * msb ) . queue = ( ( struct request_queue *) 0 );
# 2278 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_16 ( & msb_disk_lock );
  msb_data_clear ( msb );
  ldv_mutex_unlock_17 ( & msb_disk_lock );
# 2282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  msb_disk_release ( ( * msb ) . disk );
  memstick_set_drvdata ( card , ( ( void *) 0 ) );
}
# 2288 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_suspend(struct memstick_dev *card, pm_message_t state)
{
  msb_stop ( card );
  return 0;
}
# 2294 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_resume(struct memstick_dev *card)
{
  struct msb_data *msb = ( struct msb_data *) memstick_get_drvdata ( card );
  struct msb_data *new_msb = ( ( struct msb_data *) 0 );
  bool card_dead = 1;
# 2304 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_18 ( & ( * ( * card ) . host ) . lock );
# 2306 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  new_msb = ( struct msb_data *) kzalloc ( 1960UL , 208U );
  if (new_msb == ( ( struct msb_data *) 0 ))
    goto out;
# 2310 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * new_msb ) . card = card;
  memstick_set_drvdata ( card , ( void *) new_msb );
  spinlock_check ( & ( * new_msb ) . q_lock );
  {
# 2312 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    struct lock_class_key __key;
# 2312 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    __raw_spin_lock_init ( ( raw_spinlock_t *) & ( * new_msb ) . q_lock . ldv_6073 . rlock , ( char const *) "&(&new_msb->q_lock)->rlock" , & __key );
  }
# 2313 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  sg_init_table ( ( struct scatterlist *) & ( * msb ) . prealloc_sg , 33U );
# 2315 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (msb_init_card ( card ) != 0)
    goto out;
# 2318 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . block_size != ( * new_msb ) . block_size)
    goto out;
# 2321 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (memcmp ( ( void const *) ( * msb ) . boot_page , ( void const *) ( * new_msb ) . boot_page , 512UL ) != 0)
# 2323 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto out;
# 2325 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . logical_block_count != ( * new_msb ) . logical_block_count || memcmp
# 2326 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( ( void const *) ( * msb ) . lba_to_pba_table , ( void const *) ( * new_msb ) . lba_to_pba_table , ( size_t ) (
# 2327 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . logical_block_count )
# 2325 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  != 0)
# 2328 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto out;
# 2330 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (( * msb ) . block_count != ( * new_msb ) . block_count || memcmp
# 2331 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( ( void const *) ( * msb ) . used_blocks_bitmap , ( void const *) ( * new_msb ) . used_blocks_bitmap , ( size_t ) ( (
# 2332 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  * msb ) . block_count / 8 ) )
# 2330 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  != 0)
# 2333 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto out;
# 2335 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  card_dead = 0;
  out:;
  if (( int ) card_dead)
    if (debug > 0)
# 2338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      printk ( ( char const *) "\13ms_block: Card was removed/replaced during suspend\n" );
# 2340 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ( * msb ) . card_dead = card_dead;
  memstick_set_drvdata ( card , ( void *) msb );
# 2343 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (new_msb != ( ( struct msb_data *) 0 ))
  {
# 2344 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    msb_data_clear ( new_msb );
    kfree ( ( void const *) new_msb );
  }
# 2348 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  msb_start ( card );
  ldv_mutex_unlock_19 ( & ( * ( * card ) . host ) . lock );
  return 0;
}
# 2359 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static struct memstick_device_id msb_id_tbl[6U] = { [ 0U ] = { . match_flags = 1U , . type = 255U , . category = 255U , . class = 255U } , [ 1U ] = { . match_flags = 1U , . type = 255U , . category = 255U , . class = 1U } , [ 2U ] = { . match_flags = 1U , . type = 255U , . category = 255U , . class = 2U } , [ 3U ] = { . match_flags = 1U , . type = 255U , . category = 255U , . class = 3U } , [ 4U ] = { . match_flags = 1U , . type = 0U , . category = 0U , . class = 0U } , [ 5U ] = { } };
# 2376 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
struct memstick_device_id const __mod_memstick__msb_id_tbl_device_table;
# 2379 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static struct memstick_driver msb_driver = { . id_table =
# 2384 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
( struct memstick_device_id *) & msb_id_tbl , . probe =
# 2385 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
& msb_probe , . remove =
# 2386 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
& msb_remove , . suspend =
# 2387 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
& msb_suspend , . resume =
# 2388 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
& msb_resume , . driver = { . name =
# 2381 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
( char const *) "ms_block" , . owner =
# 2382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
& __this_module } };
# 2391 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int major;
# 2393 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static int msb_init(void)
{
  int rc = register_blkdev ( 0U , ( char const *) "ms_block" );
# 2397 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (rc < 0)
  {
# 2398 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    printk ( ( char const *) "\13ms_block: failed to register major (error %d)\n" , rc );
    return rc;
  }
# 2402 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  major = rc;
  rc = memstick_register_driver ( & msb_driver );
  if (rc != 0)
  {
# 2405 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    unregister_blkdev ( ( unsigned int ) major , ( char const *) "ms_block" );
    printk ( ( char const *) "\13ms_block: failed to register memstick driver (error %d)\n" , rc );
  }
# 2409 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return rc;
}
# 2412 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static void msb_exit(void)
{
  memstick_unregister_driver ( & msb_driver );
  unregister_blkdev ( ( unsigned int ) major , ( char const *) "ms_block" );
  idr_destroy ( & msb_disk_idr );
}
# 2419 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static inline initcall_t __inittest(void)
{
# 2419 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return ( initcall_t ) & msb_init;
}
# 2419 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
int init_module(void);
static inline exitcall_t __exittest(void)
{
# 2420 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return ( exitcall_t ) & msb_exit;
}
# 2420 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void cleanup_module(void);
# 2422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static inline int *__check_cache_flush_timeout(void)
{
# 2422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return & cache_flush_timeout;
}
# 2422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static char const __param_str_cache_flush_timeout[20U] = "cache_flush_timeout";
# 2422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static struct kernel_param const __param_cache_flush_timeout = { . name = ( char const *) & __param_str_cache_flush_timeout , . ops = ( struct kernel_param_ops const *) & param_ops_int , . perm = 292U , . level = -1 , . ldv_15497 = { . arg = ( void *) & cache_flush_timeout } };
# 2422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static char const __UNIQUE_ID_cache_flush_timeouttype2422[33U] = "parmtype=cache_flush_timeout:int";
# 2424 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static char const __UNIQUE_ID_cache_flush_timeout2424[68U] = "parm=cache_flush_timeout:Cache flush timeout in msec (1000 default)";
static inline int *__check_debug(void)
{
# 2425 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return & debug;
}
# 2425 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static char const __param_str_debug[6U] = "debug";
# 2425 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static struct kernel_param const __param_debug = { . name = ( char const *) & __param_str_debug , . ops = ( struct kernel_param_ops const *) & param_ops_int , . perm = 420U , . level = -1 , . ldv_15497 = { . arg = ( void *) & debug } };
# 2425 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static char const __UNIQUE_ID_debugtype2425[19U] = "parmtype=debug:int";
static char const __UNIQUE_ID_debug2426[29U] = "parm=debug:Debug level (0-2)";
# 2428 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static inline bool *__check_verify_writes(void)
{
# 2428 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return & verify_writes;
}
# 2428 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static char const __param_str_verify_writes[14U] = "verify_writes";
# 2428 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static struct kernel_param const __param_verify_writes = { . name = ( char const *) & __param_str_verify_writes , . ops = ( struct kernel_param_ops const *) & param_ops_bool , . perm = 292U , . level = -1 , . ldv_15497 = { . arg = ( void *) & verify_writes } };
# 2428 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static char const __UNIQUE_ID_verify_writestype2428[28U] = "parmtype=verify_writes:bool";
static char const __UNIQUE_ID_verify_writes2429[64U] = "parm=verify_writes:Read back and check all data that is written";
# 2431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
static char const __UNIQUE_ID_license2431[12U] = "license=GPL";
static char const __UNIQUE_ID_author2432[22U] = "author=Maxim Levitsky";
static char const __UNIQUE_ID_description2433[49U] = "description=Sony MemoryStick block device driver";
# 2451 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_check_final_state(void);
# 2454 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_check_return_value(int);
# 2457 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_check_return_value_probe(int);
# 2460 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_initialize(void);
# 2463 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_handler_precall(void);
# 2466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
int nondet_int(void);
# 2469 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
int LDV_IN_INTERRUPT;
# 2472 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_main0_sequence_infinite_withcheck_stateful(void)
{
# 2486 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  struct block_device *var_group1;
# 2488 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  fmode_t var_msb_bd_open_45_p1;
# 2490 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int res_msb_bd_open_45;
# 2507 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  struct gendisk *var_group2;
# 2509 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  fmode_t var_msb_bd_release_48_p1;
# 2526 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  struct hd_geometry *var_group3;
# 2545 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  struct memstick_dev *var_group4;
# 2547 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int res_msb_probe_56;
# 2580 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  pm_message_t var_msb_suspend_58_p1;
# 2638 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int ldv_s_msb_bdops_block_device_operations = 0;
# 2641 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  int ldv_s_msb_driver_memstick_driver = 0;
# 2609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  LDV_IN_INTERRUPT = 1;
# 2618 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_initialize ( );
# 2635 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_handler_precall ( );
  if (msb_init ( ) != 0)
    goto ldv_final;
# 2645 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  goto ldv_33244;
  ldv_33243:;
# 2650 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  switch (nondet_int ( ))
  {
    case 0:;
# 2655 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (ldv_s_msb_bdops_block_device_operations == 0)
    {
# 2664 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ldv_handler_precall ( );
      res_msb_bd_open_45 = msb_bd_open ( var_group1 , var_msb_bd_open_45_p1 );
      ldv_check_return_value ( res_msb_bd_open_45 );
      if (res_msb_bd_open_45 != 0)
        goto ldv_module_exit;
# 2678 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ldv_s_msb_bdops_block_device_operations ++;
    }
# 2684 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_33235;
    case 1:;
# 2688 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (ldv_s_msb_bdops_block_device_operations == 1)
    {
# 2697 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ldv_handler_precall ( );
      msb_bd_release ( var_group2 , var_msb_bd_release_48_p1 );
# 2708 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ldv_s_msb_bdops_block_device_operations = 0;
    }
# 2714 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_33235;
    case 2:;
# 2727 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ldv_handler_precall ( );
    msb_bd_getgeo ( var_group1 , var_group3 );
# 2744 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_33235;
    case 3:;
# 2748 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (ldv_s_msb_driver_memstick_driver == 0)
    {
# 2757 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      res_msb_probe_56 = msb_probe ( var_group4 );
      ldv_check_return_value ( res_msb_probe_56 );
      ldv_check_return_value_probe ( res_msb_probe_56 );
      if (res_msb_probe_56 != 0)
        goto ldv_module_exit;
# 2771 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ldv_s_msb_driver_memstick_driver ++;
    }
# 2777 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_33235;
    case 4:;
# 2781 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    if (ldv_s_msb_driver_memstick_driver == 1)
    {
# 2790 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ldv_handler_precall ( );
      msb_remove ( var_group4 );
# 2801 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
      ldv_s_msb_driver_memstick_driver = 0;
    }
# 2807 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_33235;
    case 5:;
# 2821 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ldv_handler_precall ( );
    msb_suspend ( var_group4 , var_msb_suspend_58_p1 );
# 2837 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_33235;
    case 6:;
# 2851 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    ldv_handler_precall ( );
    msb_resume ( var_group4 );
# 2865 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_33235;
    default:;
# 2866 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
    goto ldv_33235;
  }
# 2870 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_33235:;
  ldv_33244:;
# 2645 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  if (nondet_int ( ) != 0
# 2646 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  || ldv_s_msb_bdops_block_device_operations != 0
# 2647 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  || ldv_s_msb_driver_memstick_driver != 0)
  {
    goto ldv_33243;
  }
  else
    goto ldv_33245;
  ldv_33245:;
# 2872 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_module_exit:;
# 2889 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_handler_precall ( );
  msb_exit ( );
# 2893 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_final:;
# 2893 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_check_final_state ( );
# 2896 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return;
}
# 2900 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1)
{
# 2903 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_lock ( ldv_func_arg1 );
# 2905 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_lock ( ldv_func_arg1 );
}
# 2908 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1)
{
# 2911 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_unlock_lock ( ldv_func_arg1 );
# 2913 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_unlock ( ldv_func_arg1 );
}
# 2916 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1)
{
# 2919 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_mutex_of_device ( ldv_func_arg1 );
# 2921 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_lock ( ldv_func_arg1 );
}
# 2924 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1)
{
  typedef int ldv_func_ret_type;
# 2928 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_func_ret_type ldv_func_res = mutex_trylock ( ldv_func_arg1 );
# 2930 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return ldv_mutex_trylock_mutex_of_device ( ldv_func_arg1 );
# 2932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  return ( int ) ldv_func_res;
}
# 2935 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1)
{
# 2938 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_unlock_mutex_of_device ( ldv_func_arg1 );
# 2940 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_unlock ( ldv_func_arg1 );
}
# 2943 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_unlock_6(struct mutex *ldv_func_arg1)
{
# 2946 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_unlock_i_mutex_of_inode ( ldv_func_arg1 );
# 2948 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_unlock ( ldv_func_arg1 );
}
# 2951 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_7(struct mutex *ldv_func_arg1)
{
# 2954 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_i_mutex_of_inode ( ldv_func_arg1 );
# 2956 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_lock ( ldv_func_arg1 );
}
# 2959 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_8(struct mutex *ldv_func_arg1)
{
# 2962 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_msb_disk_lock ( ldv_func_arg1 );
# 2964 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_lock ( ldv_func_arg1 );
}
# 2967 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1)
{
# 2970 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_unlock_msb_disk_lock ( ldv_func_arg1 );
# 2972 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_unlock ( ldv_func_arg1 );
}
# 2975 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1)
{
# 2978 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_msb_disk_lock ( ldv_func_arg1 );
# 2980 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_lock ( ldv_func_arg1 );
}
# 2983 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1)
{
# 2986 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_unlock_msb_disk_lock ( ldv_func_arg1 );
# 2988 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_unlock ( ldv_func_arg1 );
}
# 2991 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1)
{
# 2994 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_msb_disk_lock ( ldv_func_arg1 );
# 2996 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_lock ( ldv_func_arg1 );
}
# 2999 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_unlock_13(struct mutex *ldv_func_arg1)
{
# 3002 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_unlock_msb_disk_lock ( ldv_func_arg1 );
# 3004 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_unlock ( ldv_func_arg1 );
}
# 3007 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_14(struct mutex *ldv_func_arg1)
{
# 3010 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_msb_disk_lock ( ldv_func_arg1 );
# 3012 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_lock ( ldv_func_arg1 );
}
# 3015 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1)
{
# 3018 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_unlock_msb_disk_lock ( ldv_func_arg1 );
# 3020 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_unlock ( ldv_func_arg1 );
}
# 3023 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_16(struct mutex *ldv_func_arg1)
{
# 3026 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_msb_disk_lock ( ldv_func_arg1 );
# 3028 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_lock ( ldv_func_arg1 );
}
# 3031 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1)
{
# 3034 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_unlock_msb_disk_lock ( ldv_func_arg1 );
# 3036 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_unlock ( ldv_func_arg1 );
}
# 3039 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_lock_18(struct mutex *ldv_func_arg1)
{
# 3042 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_lock_lock_of_memstick_host ( ldv_func_arg1 );
# 3044 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_lock ( ldv_func_arg1 );
}
# 3047 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1)
{
# 3050 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  ldv_mutex_unlock_lock_of_memstick_host ( ldv_func_arg1 );
# 3052 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.17-rc1.tar.xz--X--32_7a--X--cpachecker/linux-3.17-rc1.tar.xz/csd_deg_dscv/2246/dscv_tempdir/dscv/ri/32_7a/drivers/memstick/core/ms_block.o.c.prepared"
  mutex_unlock ( ldv_func_arg1 );
}
