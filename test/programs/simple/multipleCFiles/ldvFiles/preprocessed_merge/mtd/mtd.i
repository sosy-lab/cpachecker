/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 175 "include/linux/types.h"
struct __anonstruct_atomic_t_7 {
   int counter ;
};
#line 175 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_7 atomic_t;
#line 185 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 8 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/arch/x86/include/asm/current.h"
struct task_struct;
#line 14 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 20 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_10 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 20 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_10 __annonCompField4 ;
};
#line 20 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 13 "include/linux/lockdep.h"
struct lockdep_map;
#line 10 "include/linux/stacktrace.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 50 "include/linux/lockdep.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 54 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8UL] ;
};
#line 65 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4] ;
   unsigned long contending_point[4] ;
};
#line 150 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 20 "include/linux/spinlock_types.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 64 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_35 {
   u8 __padding[(unsigned int )(& ((struct raw_spinlock *)0)->dep_map)] ;
   struct lockdep_map dep_map ;
};
#line 64 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField18 ;
};
#line 64 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField19 ;
};
#line 64 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 49 "include/linux/mutex.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 88 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 48 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 83 "include/linux/types.h"
typedef unsigned char u_char;
#line 86 "include/linux/types.h"
typedef unsigned long u_long;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 144 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 23 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/include/uapi/linux/sysinfo.h"
struct completion;
#line 322 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/arch/x86/include/asm/pgtable_types.h"
struct file;
#line 306 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 195 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 46 "include/linux/uidgid.h"
typedef uid_t kuid_t;
#line 47 "include/linux/uidgid.h"
typedef gid_t kgid_t;
#line 33 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 38 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 144 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 223 "include/linux/rcupdate.h"
struct notifier_block;
#line 317 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 386
struct tvec_base;
#line 387 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 267 "include/linux/timer.h"
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 72 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 301
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 308
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 316
struct wakeup_source;
#line 506 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 513
struct dev_pm_qos;
#line 513 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   bool early_init ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
#line 570 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 83 "include/linux/rbtree.h"
struct vm_area_struct;
#line 339 "include/linux/clocksource.h"
struct device_node;
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "include/linux/elf.h"
struct sock;
#line 49
struct kobject;
#line 50
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 56 "include/linux/elf.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 110 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 129
struct sysfs_dirent;
#line 198 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 115 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 214
struct kernel_param;
#line 215 "include/linux/kobject.h"
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 47 "include/linux/moduleparam.h"
struct kparam_string;
#line 47
struct kparam_array;
#line 47 "include/linux/moduleparam.h"
union __anonunion_ldv_14121_134 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 47 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_14121_134 ldv_14121 ;
};
#line 59 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 65 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 457 "include/linux/moduleparam.h"
struct static_key {
   atomic_t enabled ;
};
#line 210 "include/linux/jump_label.h"
struct tracepoint;
#line 211 "include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 201
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 208 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 222
struct module_sect_attrs;
#line 222
struct module_notes_attrs;
#line 222
struct ftrace_event_call;
#line 222 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 569 "include/linux/slab.h"
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 11 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 14
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct iommu_ops;
#line 21
struct iommu_group;
#line 22 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 55 "include/linux/device.h"
struct device_attribute;
#line 55
struct driver_attribute;
#line 55 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 131
struct device_type;
#line 188
struct of_device_id;
#line 188
struct acpi_device_id;
#line 188 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 253 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 309
struct class_attribute;
#line 309 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 404 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 457 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 485 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 590 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 599 "include/linux/device.h"
struct acpi_dev_node {
   void *handle ;
};
#line 604
struct dma_coherent_mem;
#line 604 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 746 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 470 "include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
#line 600
struct mfd_cell;
#line 601 "include/linux/mod_devicetable.h"
struct platform_device {
   char const   *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
#line 172 "include/linux/platform_device.h"
struct platform_driver {
   int (*probe)(struct platform_device * ) ;
   int (*remove)(struct platform_device * ) ;
   void (*shutdown)(struct platform_device * ) ;
   int (*suspend)(struct platform_device * , pm_message_t  ) ;
   int (*resume)(struct platform_device * ) ;
   struct device_driver driver ;
   struct platform_device_id  const  *id_table ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 142 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/include/uapi/mtd/mtd-abi.h"
struct otp_info {
   __u32 start ;
   __u32 length ;
   __u32 locked ;
};
#line 216 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/include/uapi/mtd/mtd-abi.h"
struct nand_oobfree {
   __u32 offset ;
   __u32 length ;
};
#line 238 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/include/uapi/mtd/mtd-abi.h"
struct mtd_ecc_stats {
   __u32 corrected ;
   __u32 failed ;
   __u32 badblocks ;
   __u32 bbtblocks ;
};
#line 260
struct mtd_info;
#line 260 "/home/shchepetkov/tests/thomas/inst/current/envs/linux-3.11-rc1.tar.xz/linux-3.11-rc1/include/uapi/mtd/mtd-abi.h"
struct erase_info {
   struct mtd_info *mtd ;
   uint64_t addr ;
   uint64_t len ;
   uint64_t fail_addr ;
   u_long time ;
   u_long retries ;
   unsigned int dev ;
   unsigned int cell ;
   void (*callback)(struct erase_info * ) ;
   u_long priv ;
   u_char state ;
   struct erase_info *next ;
};
#line 62 "include/linux/mtd/mtd.h"
struct mtd_erase_region_info {
   uint64_t offset ;
   uint32_t erasesize ;
   uint32_t numblocks ;
   unsigned long *lockmap ;
};
#line 69 "include/linux/mtd/mtd.h"
struct mtd_oob_ops {
   unsigned int mode ;
   size_t len ;
   size_t retlen ;
   size_t ooblen ;
   size_t oobretlen ;
   uint32_t ooboffs ;
   uint8_t *datbuf ;
   uint8_t *oobbuf ;
};
#line 99 "include/linux/mtd/mtd.h"
struct nand_ecclayout {
   __u32 eccbytes ;
   __u32 eccpos[640U] ;
   __u32 oobavail ;
   struct nand_oobfree oobfree[32U] ;
};
#line 114
struct backing_dev_info;
#line 114 "include/linux/mtd/mtd.h"
struct mtd_info {
   u_char type ;
   uint32_t flags ;
   uint64_t size ;
   uint32_t erasesize ;
   uint32_t writesize ;
   uint32_t writebufsize ;
   uint32_t oobsize ;
   uint32_t oobavail ;
   unsigned int erasesize_shift ;
   unsigned int writesize_shift ;
   unsigned int erasesize_mask ;
   unsigned int writesize_mask ;
   unsigned int bitflip_threshold ;
   char const   *name ;
   int index ;
   struct nand_ecclayout *ecclayout ;
   unsigned int ecc_strength ;
   int numeraseregions ;
   struct mtd_erase_region_info *eraseregions ;
   int (*_erase)(struct mtd_info * , struct erase_info * ) ;
   int (*_point)(struct mtd_info * , loff_t  , size_t  , size_t * , void ** , resource_size_t * ) ;
   int (*_unpoint)(struct mtd_info * , loff_t  , size_t  ) ;
   unsigned long (*_get_unmapped_area)(struct mtd_info * , unsigned long  , unsigned long  ,
                                       unsigned long  ) ;
   int (*_read)(struct mtd_info * , loff_t  , size_t  , size_t * , u_char * ) ;
   int (*_write)(struct mtd_info * , loff_t  , size_t  , size_t * , u_char const   * ) ;
   int (*_panic_write)(struct mtd_info * , loff_t  , size_t  , size_t * , u_char const   * ) ;
   int (*_read_oob)(struct mtd_info * , loff_t  , struct mtd_oob_ops * ) ;
   int (*_write_oob)(struct mtd_info * , loff_t  , struct mtd_oob_ops * ) ;
   int (*_get_fact_prot_info)(struct mtd_info * , struct otp_info * , size_t  ) ;
   int (*_read_fact_prot_reg)(struct mtd_info * , loff_t  , size_t  , size_t * , u_char * ) ;
   int (*_get_user_prot_info)(struct mtd_info * , struct otp_info * , size_t  ) ;
   int (*_read_user_prot_reg)(struct mtd_info * , loff_t  , size_t  , size_t * , u_char * ) ;
   int (*_write_user_prot_reg)(struct mtd_info * , loff_t  , size_t  , size_t * ,
                               u_char * ) ;
   int (*_lock_user_prot_reg)(struct mtd_info * , loff_t  , size_t  ) ;
   int (*_writev)(struct mtd_info * , struct kvec  const  * , unsigned long  , loff_t  ,
                  size_t * ) ;
   void (*_sync)(struct mtd_info * ) ;
   int (*_lock)(struct mtd_info * , loff_t  , uint64_t  ) ;
   int (*_unlock)(struct mtd_info * , loff_t  , uint64_t  ) ;
   int (*_is_locked)(struct mtd_info * , loff_t  , uint64_t  ) ;
   int (*_block_isbad)(struct mtd_info * , loff_t  ) ;
   int (*_block_markbad)(struct mtd_info * , loff_t  ) ;
   int (*_suspend)(struct mtd_info * ) ;
   void (*_resume)(struct mtd_info * ) ;
   int (*_get_device)(struct mtd_info * ) ;
   void (*_put_device)(struct mtd_info * ) ;
   struct backing_dev_info *backing_dev_info ;
   struct notifier_block reboot_notifier ;
   struct mtd_ecc_stats ecc_stats ;
   int subpage_sft ;
   void *priv ;
   struct module *owner ;
   struct device dev ;
   int usecount ;
};
#line 358
struct mtd_partition;
#line 359
struct mtd_part_parser_data;
#line 188 "include/linux/mtd/map.h"
union __anonunion_map_word_140 {
   unsigned long x[4U] ;
};
#line 188 "include/linux/mtd/map.h"
typedef union __anonunion_map_word_140 map_word;
#line 189
struct mtd_chip_driver;
#line 189 "include/linux/mtd/map.h"
struct map_info {
   char const   *name ;
   unsigned long size ;
   resource_size_t phys ;
   void *virt ;
   void *cached ;
   int swap ;
   int bankwidth ;
   map_word (*read)(struct map_info * , unsigned long  ) ;
   void (*copy_from)(struct map_info * , void * , unsigned long  , ssize_t  ) ;
   void (*write)(struct map_info * , map_word const    , unsigned long  ) ;
   void (*copy_to)(struct map_info * , unsigned long  , void const   * , ssize_t  ) ;
   void (*inval_cache)(struct map_info * , unsigned long  , ssize_t  ) ;
   void (*set_vpp)(struct map_info * , int  ) ;
   unsigned long pfow_base ;
   unsigned long map_priv_1 ;
   unsigned long map_priv_2 ;
   struct device_node *device_node ;
   void *fldrv_priv ;
   struct mtd_chip_driver *fldrv ;
};
#line 252 "include/linux/mtd/map.h"
struct mtd_chip_driver {
   struct mtd_info *(*probe)(struct map_info * ) ;
   void (*destroy)(struct mtd_info * ) ;
   struct module *module ;
   char *name ;
   struct list_head list ;
};
#line 456 "include/linux/mtd/map.h"
struct mtd_partition {
   char *name ;
   uint64_t size ;
   uint64_t offset ;
   uint32_t mask_flags ;
   struct nand_ecclayout *ecclayout ;
};
#line 46 "include/linux/mtd/partitions.h"
struct mtd_part_parser_data {
   unsigned long origin ;
   struct device_node *of_node ;
};
#line 87 "include/linux/mtd/partitions.h"
struct physmap_flash_data {
   unsigned int width ;
   int (*init)(struct platform_device * ) ;
   void (*exit)(struct platform_device * ) ;
   void (*set_vpp)(struct platform_device * , int  ) ;
   unsigned int nr_parts ;
   unsigned int pfow_base ;
   char *probe_type ;
   struct mtd_partition *parts ;
   char const   * const  *part_probe_types ;
};
#line 69 "include/linux/io.h"
struct physmap_flash_info {
   struct mtd_info *mtd[4U] ;
   struct mtd_info *cmtd ;
   struct map_info map[4U] ;
   spinlock_t vpp_lock ;
   int vpp_refcnt ;
};
#line 462 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
typedef int ldv_func_ret_type___2;
#line 1 "<compiler builtins>"
long __builtin_expect(long exp , long c ) ;
#line 10 "/home/shchepetkov/ldv/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void)  __attribute__((__no_instrument_function__)) ;
#line 10 "/home/shchepetkov/ldv/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: 
#line 12
  goto ERROR;
}
}
#line 25
extern int __VERIFIER_nondet_int(void) ;
#line 49 "/home/shchepetkov/ldv/kernel-rules/verifier/rcv.h"
long __builtin_expect(long exp , long c ) 
{ 


  {
#line 51
  return (exp);
}
}
#line 59 "/home/shchepetkov/ldv/kernel-rules/verifier/rcv.h"
void __builtin_trap(void) 
{ 


  {
#line 61
  ldv_error();
#line 62
  return;
}
}
#line 8 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  ;
#line 11 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_lock == 1) {

  } else {
#line 16
    ldv_error();
  }
#line 19
  nondetermined = __VERIFIER_nondet_int();
#line 22
  if (nondetermined) {
#line 25
    ldv_mutex_lock = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_lock == 1) {

  } else {
#line 42
    ldv_error();
  }
#line 45
  nondetermined = __VERIFIER_nondet_int();
#line 48
  if (nondetermined) {
#line 51
    ldv_mutex_lock = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_lock == 1) {

  } else {
#line 66
    ldv_error();
  }
#line 68
  ldv_mutex_lock = 2;
#line 69
  return;
}
}
#line 72 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_lock == 1) {

  } else {
#line 77
    ldv_error();
  }
#line 80
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 83
  if (is_mutex_held_by_another_thread) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_lock = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_lock == 1) {

  } else {
#line 103
    ldv_error();
  }
#line 106
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_lock = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_lock == 1) {
#line 130
    nondetermined = __VERIFIER_nondet_int();
#line 133
    if (nondetermined) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_lock == 2) {

  } else {
#line 155
    ldv_error();
  }
#line 157
  ldv_mutex_lock = 1;
#line 158
  return;
}
}
#line 160 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  ;
#line 163 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 168
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 168
    ldv_error();
  }
#line 171
  nondetermined = __VERIFIER_nondet_int();
#line 174
  if (nondetermined) {
#line 177
    ldv_mutex_mutex_of_device = 2;
#line 179
    return (0);
  } else {
#line 184
    return (-4);
  }
}
}
#line 189 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 194
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 194
    ldv_error();
  }
#line 197
  nondetermined = __VERIFIER_nondet_int();
#line 200
  if (nondetermined) {
#line 203
    ldv_mutex_mutex_of_device = 2;
#line 205
    return (0);
  } else {
#line 210
    return (-4);
  }
}
}
#line 215 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 218
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 218
    ldv_error();
  }
#line 220
  ldv_mutex_mutex_of_device = 2;
#line 221
  return;
}
}
#line 224 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 229
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 229
    ldv_error();
  }
#line 232
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 235
  if (is_mutex_held_by_another_thread) {
#line 238
    return (0);
  } else {
#line 243
    ldv_mutex_mutex_of_device = 2;
#line 245
    return (1);
  }
}
}
#line 250 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 255
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 255
    ldv_error();
  }
#line 258
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 261
  if (atomic_value_after_dec == 0) {
#line 264
    ldv_mutex_mutex_of_device = 2;
#line 266
    return (1);
  } else {

  }
#line 270
  return (0);
}
}
#line 275 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 279
  if (ldv_mutex_mutex_of_device == 1) {
#line 282
    nondetermined = __VERIFIER_nondet_int();
#line 285
    if (nondetermined) {
#line 288
      return (0);
    } else {
#line 293
      return (1);
    }
  } else {
#line 299
    return (1);
  }
}
}
#line 304 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 307
  if (ldv_mutex_mutex_of_device == 2) {

  } else {
#line 307
    ldv_error();
  }
#line 309
  ldv_mutex_mutex_of_device = 1;
#line 310
  return;
}
}
#line 314 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_initialize(void) 
{ 


  {
#line 317
  ldv_mutex_lock = 1;
#line 319
  ldv_mutex_mutex_of_device = 1;
#line 320
  return;
}
}
#line 323 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 326
  if (ldv_mutex_lock == 1) {

  } else {
#line 326
    ldv_error();
  }
#line 328
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 328
    ldv_error();
  }
#line 329
  return;
}
}
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 124 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 173 "include/linux/mutex.h"
extern int mutex_trylock(struct mutex * ) ;
#line 176
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) ;
#line 178
extern void mutex_unlock(struct mutex * ) ;
#line 181
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) ;
#line 7 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 10
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) ;
#line 33 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
int ldv_state_variable_1  ;
#line 34 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
int ref_cnt  ;
#line 35 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
int ldv_state_variable_0  ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 32 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 272 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 274
  return (& lock->__annonCompField19.rlock);
}
}
#line 338 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 340
  _raw_spin_unlock_irqrestore(& lock->__annonCompField19.rlock, flags);
#line 341
  return;
}
}
#line 139 "include/linux/ioport.h"
extern struct resource iomem_resource ;
#line 164 "include/linux/ioport.h"
__inline static resource_size_t resource_size(struct resource  const  *res ) 
{ 


  {
#line 166
  return (((unsigned long long )res->end - (unsigned long long )res->start) + 1ULL);
}
}
#line 213
extern struct resource *__devm_request_region(struct device * , struct resource * ,
                                              resource_size_t  , resource_size_t  ,
                                              char const   * ) ;
#line 80 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 82
  return ((char const   *)kobj->name);
}
}
#line 580 "include/linux/device.h"
extern void *devm_kzalloc(struct device * , size_t  , gfp_t  ) ;
#line 757 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 760
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 761
    return ((char const   *)dev->init_name);
  } else {

  }
#line 763
  tmp = kobject_name(& dev->kobj);
#line 763
  return (tmp);
}
}
#line 872
extern void *dev_get_drvdata(struct device  const  * ) ;
#line 873
extern int dev_set_drvdata(struct device * , void * ) ;
#line 982
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 43 "include/linux/platform_device.h"
extern int platform_device_register(struct platform_device * ) ;
#line 44
extern void platform_device_unregister(struct platform_device * ) ;
#line 191
extern int __platform_driver_register(struct platform_driver * , struct module * ) ;
#line 193
extern void platform_driver_unregister(struct platform_driver * ) ;
#line 201 "include/linux/platform_device.h"
__inline static void *platform_get_drvdata(struct platform_device  const  *pdev ) 
{ 
  void *tmp ;

  {
#line 203
  tmp = dev_get_drvdata(& pdev->dev);
#line 203
  return (tmp);
}
}
#line 206 "include/linux/platform_device.h"
__inline static void platform_set_drvdata(struct platform_device *pdev , void *data ) 
{ 


  {
#line 209
  dev_set_drvdata(& pdev->dev, data);
#line 210
  return;
}
}
#line 308 "include/linux/mtd/mtd.h"
__inline static int mtd_suspend(struct mtd_info *mtd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 310
  if ((unsigned long )mtd->_suspend != (unsigned long )((int (*)(struct mtd_info * ))0)) {
#line 310
    tmp = (*(mtd->_suspend))(mtd);
#line 310
    tmp___0 = tmp;
  } else {
#line 310
    tmp___0 = 0;
  }
#line 310
  return (tmp___0);
}
}
#line 313 "include/linux/mtd/mtd.h"
__inline static void mtd_resume(struct mtd_info *mtd ) 
{ 


  {
#line 315
  if ((unsigned long )mtd->_resume != (unsigned long )((void (*)(struct mtd_info * ))0)) {
#line 316
    (*(mtd->_resume))(mtd);
  } else {

  }
#line 317
  return;
}
}
#line 364
extern int mtd_device_parse_register(struct mtd_info * , char const   * const  * ,
                                     struct mtd_part_parser_data * , struct mtd_partition  const  * ,
                                     int  ) ;
#line 371
extern int mtd_device_unregister(struct mtd_info * ) ;
#line 264 "include/linux/mtd/map.h"
extern struct mtd_info *do_map_probe(char const   * , struct map_info * ) ;
#line 265
extern void map_destroy(struct mtd_info * ) ;
#line 455
extern void simple_map_init(struct map_info * ) ;
#line 26 "include/linux/mtd/concat.h"
extern struct mtd_info *mtd_concat_create(struct mtd_info ** , int  , char const   * ) ;
#line 31
extern void mtd_concat_destroy(struct mtd_info * ) ;
#line 61 "include/linux/io.h"
extern void *devm_ioremap(struct device * , resource_size_t  , unsigned long  ) ;
#line 62 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
static int physmap_flash_remove(struct platform_device *dev ) 
{ 
  struct physmap_flash_info *info ;
  struct physmap_flash_data *physmap_data ;
  int i ;
  void *tmp ;

  {
#line 68
  tmp = platform_get_drvdata((struct platform_device  const  *)dev);
#line 68
  info = (struct physmap_flash_info *)tmp;
#line 69
  if ((unsigned long )info == (unsigned long )((struct physmap_flash_info *)0)) {
#line 70
    return (0);
  } else {

  }
#line 71
  platform_set_drvdata(dev, 0);
#line 73
  physmap_data = (struct physmap_flash_data *)dev->dev.platform_data;
#line 75
  if ((unsigned long )info->cmtd != (unsigned long )((struct mtd_info *)0)) {
#line 76
    mtd_device_unregister(info->cmtd);
#line 77
    if ((unsigned long )info->cmtd != (unsigned long )info->mtd[0]) {
#line 78
      mtd_concat_destroy(info->cmtd);
    } else {

    }
  } else {

  }
#line 81
  i = 0;
#line 81
  goto ldv_16891;
  ldv_16890: ;
#line 82
  if ((unsigned long )info->mtd[i] != (unsigned long )((struct mtd_info *)0)) {
#line 83
    map_destroy(info->mtd[i]);
  } else {

  }
#line 81
  i = i + 1;
  ldv_16891: ;
#line 81
  if (i <= 3) {
#line 82
    goto ldv_16890;
  } else {

  }

#line 86
  if ((unsigned long )physmap_data->exit != (unsigned long )((void (*)(struct platform_device * ))0)) {
#line 87
    (*(physmap_data->exit))(dev);
  } else {

  }
#line 89
  return (0);
}
}
#line 92 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
static void physmap_set_vpp(struct map_info *map , int state ) 
{ 
  struct platform_device *pdev ;
  struct physmap_flash_data *physmap_data ;
  struct physmap_flash_info *info ;
  unsigned long flags ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 99
  pdev = (struct platform_device *)map->map_priv_1;
#line 100
  physmap_data = (struct physmap_flash_data *)pdev->dev.platform_data;
#line 102
  if ((unsigned long )physmap_data->set_vpp == (unsigned long )((void (*)(struct platform_device * ,
                                                                          int  ))0)) {
#line 103
    return;
  } else {

  }
#line 105
  tmp = platform_get_drvdata((struct platform_device  const  *)pdev);
#line 105
  info = (struct physmap_flash_info *)tmp;
#line 107
  tmp___0 = spinlock_check(& info->vpp_lock);
#line 107
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 108
  if (state != 0) {
#line 109
    info->vpp_refcnt = info->vpp_refcnt + 1;
#line 109
    if (info->vpp_refcnt == 1) {
#line 110
      (*(physmap_data->set_vpp))(pdev, 1);
    } else {
#line 112
      info->vpp_refcnt = info->vpp_refcnt - 1;
#line 112
      if (info->vpp_refcnt == 0) {
#line 113
        (*(physmap_data->set_vpp))(pdev, 0);
      } else {

      }
    }
  } else {

  }
#line 115
  spin_unlock_irqrestore(& info->vpp_lock, flags);
#line 116
  return;
}
}
#line 118 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
static char const   * const  rom_probe_types[5U]  = {      "cfi_probe",      "jedec_probe",      "qinfo_probe",      "map_rom", 
        0};
#line 121 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
static char const   * const  part_probe_types[4U]  = {      "cmdlinepart",      "RedBoot",      "afs",      0};
#line 124 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
static int physmap_flash_probe(struct platform_device *dev ) 
{ 
  struct physmap_flash_data *physmap_data ;
  struct physmap_flash_info *info ;
  char const   * const  *probe_type ;
  char const   * const  *part_types ;
  int err ;
  int i ;
  int devices_found ;
  void *tmp ;
  resource_size_t tmp___0 ;
  char const   *tmp___1 ;
  resource_size_t tmp___2 ;
  struct resource *tmp___3 ;
  resource_size_t tmp___4 ;
  char const   *tmp___5 ;
  struct lock_class_key __key ;

  {
#line 130
  err = 0;
#line 132
  devices_found = 0;
#line 134
  physmap_data = (struct physmap_flash_data *)dev->dev.platform_data;
#line 135
  if ((unsigned long )physmap_data == (unsigned long )((struct physmap_flash_data *)0)) {
#line 136
    return (-19);
  } else {

  }
#line 138
  tmp = devm_kzalloc(& dev->dev, 696UL, 208U);
#line 138
  info = (struct physmap_flash_info *)tmp;
#line 140
  if ((unsigned long )info == (unsigned long )((struct physmap_flash_info *)0)) {
#line 141
    err = -12;
#line 142
    goto err_out;
  } else {

  }
#line 145
  if ((unsigned long )physmap_data->init != (unsigned long )((int (*)(struct platform_device * ))0)) {
#line 146
    err = (*(physmap_data->init))(dev);
#line 147
    if (err != 0) {
#line 148
      goto err_out;
    } else {

    }
  } else {

  }
#line 151
  platform_set_drvdata(dev, (void *)info);
#line 153
  i = 0;
#line 153
  goto ldv_16921;
  ldv_16920: 
#line 154
  tmp___0 = resource_size((struct resource  const  *)dev->resource + (unsigned long )i);
#line 154
  printk("\rphysmap platform flash device: %.8llx at %.8llx\n", tmp___0, (dev->resource + (unsigned long )i)->start);
#line 158
  tmp___1 = dev_name((struct device  const  *)(& dev->dev));
#line 158
  tmp___2 = resource_size((struct resource  const  *)dev->resource + (unsigned long )i);
#line 158
  tmp___3 = __devm_request_region(& dev->dev, & iomem_resource, (dev->resource + (unsigned long )i)->start,
                                  tmp___2, tmp___1);
#line 158
  if ((unsigned long )tmp___3 == (unsigned long )((struct resource *)0)) {
#line 162
    dev_err((struct device  const  *)(& dev->dev), "Could not reserve memory region\n");
#line 163
    err = -12;
#line 164
    goto err_out;
  } else {

  }
#line 167
  info->map[i].name = dev_name((struct device  const  *)(& dev->dev));
#line 168
  info->map[i].phys = (dev->resource + (unsigned long )i)->start;
#line 169
  tmp___4 = resource_size((struct resource  const  *)dev->resource + (unsigned long )i);
#line 169
  info->map[i].size = (unsigned long )tmp___4;
#line 170
  info->map[i].bankwidth = (int )physmap_data->width;
#line 171
  info->map[i].set_vpp = & physmap_set_vpp;
#line 172
  info->map[i].pfow_base = (unsigned long )physmap_data->pfow_base;
#line 173
  info->map[i].map_priv_1 = (unsigned long )dev;
#line 175
  info->map[i].virt = devm_ioremap(& dev->dev, info->map[i].phys, info->map[i].size);
#line 177
  if ((unsigned long )info->map[i].virt == (unsigned long )((void *)0)) {
#line 178
    dev_err((struct device  const  *)(& dev->dev), "Failed to ioremap flash region\n");
#line 179
    err = -5;
#line 180
    goto err_out;
  } else {

  }
#line 183
  simple_map_init((struct map_info *)(& info->map) + (unsigned long )i);
#line 185
  probe_type = (char const   * const  *)(& rom_probe_types);
#line 186
  if ((unsigned long )physmap_data->probe_type == (unsigned long )((char *)0)) {
#line 187
    goto ldv_16918;
    ldv_16917: 
#line 188
    info->mtd[i] = do_map_probe(*probe_type, (struct map_info *)(& info->map) + (unsigned long )i);
#line 187
    probe_type = probe_type + 1;
    ldv_16918: ;
#line 187
    if ((unsigned long )info->mtd[i] == (unsigned long )((struct mtd_info *)0) && (unsigned long )*probe_type != (unsigned long )((char const   */* const  */)0)) {
#line 188
      goto ldv_16917;
    } else {

    }

  } else {
#line 190
    info->mtd[i] = do_map_probe((char const   *)physmap_data->probe_type, (struct map_info *)(& info->map) + (unsigned long )i);
  }
#line 192
  if ((unsigned long )info->mtd[i] == (unsigned long )((struct mtd_info *)0)) {
#line 193
    dev_err((struct device  const  *)(& dev->dev), "map_probe failed\n");
#line 194
    err = -6;
#line 195
    goto err_out;
  } else {
#line 197
    devices_found = devices_found + 1;
  }
#line 199
  (info->mtd[i])->owner = & __this_module;
#line 200
  (info->mtd[i])->dev.parent = & dev->dev;
#line 153
  i = i + 1;
  ldv_16921: ;
#line 153
  if ((u32 )i < dev->num_resources) {
#line 154
    goto ldv_16920;
  } else {

  }

#line 203
  if (devices_found == 1) {
#line 204
    info->cmtd = info->mtd[0];
  } else
#line 205
  if (devices_found > 1) {
#line 209
    tmp___5 = dev_name((struct device  const  *)(& dev->dev));
#line 209
    info->cmtd = mtd_concat_create((struct mtd_info **)(& info->mtd), devices_found,
                                   tmp___5);
#line 210
    if ((unsigned long )info->cmtd == (unsigned long )((struct mtd_info *)0)) {
#line 211
      err = -6;
    } else {

    }
  } else {

  }
#line 213
  if (err != 0) {
#line 214
    goto err_out;
  } else {

  }
#line 216
  spinlock_check(& info->vpp_lock);
#line 216
  __raw_spin_lock_init(& info->vpp_lock.__annonCompField19.rlock, "&(&info->vpp_lock)->rlock",
                       & __key);
#line 218
  part_types = (unsigned long )physmap_data->part_probe_types != (unsigned long )((char const   * const  *)0) ? physmap_data->part_probe_types : (char const   * const  *)(& part_probe_types);
#line 220
  mtd_device_parse_register(info->cmtd, part_types, 0, (struct mtd_partition  const  *)physmap_data->parts,
                            (int )physmap_data->nr_parts);
#line 222
  return (0);
  err_out: 
#line 225
  physmap_flash_remove(dev);
#line 226
  return (err);
}
}
#line 230 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
static void physmap_flash_shutdown(struct platform_device *dev ) 
{ 
  struct physmap_flash_info *info ;
  void *tmp ;
  int i ;
  int tmp___0 ;

  {
#line 232
  tmp = platform_get_drvdata((struct platform_device  const  *)dev);
#line 232
  info = (struct physmap_flash_info *)tmp;
#line 235
  i = 0;
#line 235
  goto ldv_16930;
  ldv_16929: 
#line 236
  tmp___0 = mtd_suspend(info->mtd[i]);
#line 236
  if (tmp___0 == 0) {
#line 237
    mtd_resume(info->mtd[i]);
  } else {

  }
#line 235
  i = i + 1;
  ldv_16930: ;
#line 235
  if (i <= 3 && (unsigned long )info->mtd[i] != (unsigned long )((struct mtd_info *)0)) {
#line 236
    goto ldv_16929;
  } else {

  }

#line 240
  return;
}
}
#line 243 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
static struct platform_driver physmap_flash_driver  =    {& physmap_flash_probe, & physmap_flash_remove, & physmap_flash_shutdown, 0, 0,
    {"physmap-flash", 0, & __this_module, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0}, 0};
#line 255 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
static struct physmap_flash_data physmap_flash_data  = 
#line 255
     {2U, 0, 0, 0, 0U, 0U, 0, 0, 0};
#line 259 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
static struct resource physmap_flash_resource  =    {134217728ULL, 134217727ULL, 0, 512UL, 0, 0, 0};
#line 265 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
static struct platform_device physmap_flash  = 
#line 265
     {"physmap-flash", 0, (_Bool)0, {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0}, 0, 0, {{0}, {{{{{0U}},
                                                                            0U, 0U,
                                                                            0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                                                                    {0, 0}, 0, 0,
                                                                    0, {0, {0, 0},
                                                                        0, 0, 0UL}},
                                   0, 0, (void *)(& physmap_flash_data), {{0}, (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (_Bool)0,
                                                                          (_Bool)0,
                                                                          (_Bool)0,
                                                                          (_Bool)0,
                                                                          {{{{{0U}},
                                                                             0U, 0U,
                                                                             0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                                          {0, 0},
                                                                          {0U, {{{{{{0U}},
                                                                                   0U,
                                                                                   0U,
                                                                                   0,
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}}}},
                                                                                {0,
                                                                                 0}}},
                                                                          0, (_Bool)0,
                                                                          (_Bool)0,
                                                                          {{0, 0},
                                                                           0UL, 0,
                                                                           0, 0UL,
                                                                           0, 0, 0,
                                                                           {(char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0},
                                                                           {0, {0,
                                                                                0},
                                                                            0, 0,
                                                                            0UL}},
                                                                          0UL, {{0L},
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                          {{{{{{0U}},
                                                                              0U,
                                                                              0U,
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                                           {0, 0}},
                                                                          {0}, {0},
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          0, 0, 0,
                                                                          0, 0UL,
                                                                          0UL, 0UL,
                                                                          0UL, 0,
                                                                          0}, 0, 0,
                                   0, 0ULL, 0, {0, 0}, 0, {0, 0}, 0, {0}, 0U, 0U,
                                   {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}},
                                   {0, 0}, {0, {0, 0}, {{0}}}, 0, 0, 0, 0, (_Bool)0,
                                   (_Bool)0}, 1U, & physmap_flash_resource, 0, 0,
    {}};
#line 276 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
static int physmap_init(void) 
{ 
  int err ;

  {
#line 280
  err = __platform_driver_register(& physmap_flash_driver, & __this_module);
#line 282
  if (err == 0) {
#line 283
    err = platform_device_register(& physmap_flash);
#line 284
    if (err != 0) {
#line 285
      platform_driver_unregister(& physmap_flash_driver);
    } else {

    }
  } else {

  }
#line 289
  return (err);
}
}
#line 292 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
static void physmap_exit(void) 
{ 


  {
#line 295
  platform_device_unregister(& physmap_flash);
#line 297
  platform_driver_unregister(& physmap_flash_driver);
#line 298
  return;
}
}
#line 313 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
struct platform_device *physmap_flash_driver_group0  ;
#line 314 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
int ldv_retval_0  ;
#line 315 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
int ldv_retval_1  ;
#line 325 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
void main(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 326
  ldv_initialize();
#line 328
  ldv_state_variable_1 = 0;
#line 329
  ref_cnt = 0;
#line 330
  ldv_state_variable_0 = 1;
  ldv_16984: 
#line 332
  tmp = __VERIFIER_nondet_int();
#line 332
  switch (tmp) {
  case 0: ;
#line 336
  if (ldv_state_variable_1 != 0) {
#line 337
    tmp___0 = __VERIFIER_nondet_int();
#line 337
    switch (tmp___0) {
    case 0: ;
#line 340
    if (ldv_state_variable_1 == 1) {
#line 342
      ldv_retval_0 = physmap_flash_probe(physmap_flash_driver_group0);
#line 344
      if (ldv_retval_0 == 0) {
#line 345
        ldv_state_variable_1 = 2;
#line 346
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 350
    goto ldv_16972;
    case 1: ;
#line 353
    if (ldv_state_variable_1 == 2) {
#line 355
      physmap_flash_shutdown(physmap_flash_driver_group0);
#line 357
      ldv_state_variable_1 = 3;
    } else {

    }
#line 360
    goto ldv_16972;
    case 2: ;
#line 363
    if (ldv_state_variable_1 == 3) {
#line 365
      physmap_flash_remove(physmap_flash_driver_group0);
#line 367
      ldv_state_variable_1 = 1;
#line 368
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 371
    if (ldv_state_variable_1 == 2) {
#line 373
      physmap_flash_remove(physmap_flash_driver_group0);
#line 375
      ldv_state_variable_1 = 1;
#line 376
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 379
    goto ldv_16972;
    default: ;
#line 380
    goto ldv_16972;
    }
    ldv_16972: ;
  } else {

  }
#line 384
  goto ldv_16976;
  case 1: ;
#line 388
  if (ldv_state_variable_0 != 0) {
#line 389
    tmp___1 = __VERIFIER_nondet_int();
#line 389
    switch (tmp___1) {
    case 0: ;
#line 392
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 394
      physmap_exit();
#line 395
      ldv_state_variable_0 = 2;
#line 396
      goto ldv_final;
    } else {

    }
#line 399
    goto ldv_16980;
    case 1: ;
#line 402
    if (ldv_state_variable_0 == 1) {
#line 404
      ldv_retval_1 = physmap_init();
#line 406
      if (ldv_retval_1 == 0) {
#line 407
        ldv_state_variable_0 = 3;
#line 408
        ldv_state_variable_1 = 1;
      } else {

      }
#line 410
      if (ldv_retval_1 != 0) {
#line 411
        ldv_state_variable_0 = 2;
#line 412
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 416
    goto ldv_16980;
    default: ;
#line 417
    goto ldv_16980;
    }
    ldv_16980: ;
  } else {

  }
#line 421
  goto ldv_16976;
  default: ;
#line 422
  goto ldv_16976;
  }
  ldv_16976: ;
#line 424
  goto ldv_16984;
  ldv_final: 
#line 426
  ldv_check_final_state();
#line 427
  return;
}
}
#line 430 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 435
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 437
  mutex_lock(ldv_func_arg1);
#line 438
  return;
}
}
#line 440 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 445
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 447
  mutex_unlock(ldv_func_arg1);
#line 448
  return;
}
}
#line 450 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 455
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 457
  mutex_lock(ldv_func_arg1);
#line 458
  return;
}
}
#line 460 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 465
  tmp = mutex_trylock(ldv_func_arg1);
#line 465
  ldv_func_res = tmp;
#line 467
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 467
  return (tmp___0);
#line 469
  return (ldv_func_res);
}
}
#line 472 "/home/shchepetkov/tests/thomas/work/current--X--drivers/mtd/maps/physmap.ko--X--x1linux-3.11-rc1.tar.xz--X--32_7a/linux-3.11-rc1.tar.xz/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/mtd/maps/physmap.c.prepared"
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 477
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 479
  mutex_unlock(ldv_func_arg1);
#line 480
  return;
}
}
