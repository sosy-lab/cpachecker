<!-- Refer to the doc/ReportTemplateStyleGuide.md for Coding and Style Guide. They will let you write better code
with considerably less effort -->

<!DOCTYPE html>
<html ng-app='report'>

<head>
    <meta charset="UTF-8">
    <meta name='generator' content='CPAchecker (unknown version)'>
    <title>CPAchecker Report</title>
    <style>
        /* Refer to the doc/ReportTemplateStyleGuide.md for Coding and Style Guide. They will let you write better code
with considerably less effort */

        html {
            position: relative;
            height: 100%;
            overflow: hidden;
        }

        body {
            padding-top: 50px;
            height: 100%;
            min-height: 300px;
            min-width: 750px;
            background-color: white;
        }

        .header {
            position: absolute;
            top: 0;
            width: 100%;
            min-width: 750px;
            height: 50px;
            background-color: #ffef96;
            border-bottom: solid 2px;
            border-bottom-color: lightgrey;
            padding: 7px;
            padding-top: 5px;
            text-align: center;
            justify-content: center;
        }

        .sections {
            height: 100%;
            padding: 0;
        }

        .nav>li>a:hover {
            background-color: #c0c0c0;
        }

        .btn {
            cursor: pointer;
        }

        .header img.logo {
            float: left;
            height: 40px;
            margin-left: 10px;
        }

        .header h1 {
            display: inline;
            font-size: 21px;
            color: #50394c;
        }

        .header .generated {
            float: right;
            margin-left: 2em;
            font-size: 80%;
        }

        .popover {
            min-width: 500px;
            max-height: 500px;
            white-space: pre-line !important;
            overflow: auto;
            background-color: #f5fff8;
            border: solid 2px;
            border-color: #00d415;
            font-family: monospace
        }

        .dropdown-menu a:hover {
            background-color: #71afff !important;
        }

        .dropdown-menu a {
            cursor: pointer;
        }

        /* The switch - the box around the slider */

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        /* Hide default HTML checkbox */

        .switch input {
            padding: 10px;
            display: none;
        }

        /* The slider */

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: grey;
            -webkit-transition: .4s;
            transition: .4s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
        }

        input:checked+.slider {
            background-color: #ffc107;
        }

        input:focus+.slider {
            box-shadow: 0 0 1px #ffc107;
        }

        input:checked+.slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }

        /* Rounded sliders */

        .slider.round {
            border-radius: 34px;
        }

        .slider.round:before {
            border-radius: 50%;
        }

        #errorpath_section {
            position: relative;
            float: left;
            width: 25%;
            min-width: 70px;
            height: inherit;
            background-color: white;
            border: solid 4px;
            border-color: lightgrey;
            padding: 5px;
        }

        #errorpath_section header .input-group {
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #errorpath_section .fileContent {
            height: calc(100% - 110px);
            margin: 5px;
            overflow: auto;
        }

        #searchOptions label {
            font-weight: normal;
        }

        #matches {
            display: none;
        }

        .markedValues {
            background-color: #83d480;
            border-radius: 25px;
            margin-bottom: 2px;
            padding: 2px;
            padding-left: 8px;
            max-width: 270px;
        }

        .markedDescriptions {
            background-color: #71afff;
            border-radius: 20px;
            padding: 2px;
            padding-left: 8px;
            margin-bottom: 2px;
            max-width: 270px;
        }

        .markedTableElement {
            border: solid 2px;
            border-color: #00d415;
        }

        .markedValueElement pre {
            background-color: #83d480 !important;
        }

        .markedDescElement pre {
            background-color: #71afff !important;
        }

        .markedValueDescElement pre {
            background: linear-gradient(#83d480, #71afff) !important;
        }

        #err-table td {
            cursor: pointer;
        }

        #err-table td.disabled {
            cursor: not-allowed;
            pointer-events: none;
        }

        #err-table td:hover {
            font-weight: bold;
        }

        #err-table td:first-child {
            border-radius: 6px;
        }

        #err-table td pre {
            padding: 0px;
            margin: 0px;
            border: none;
        }

        #err-table tr td pre.make-pretty {
            background-color: #ffe5d5;
        }

        #err-table tr.clickedErrPathElement {
            outline: #df80ff solid 2px;
        }

        .marked-source-line {
            background-color: #df80ff !important;
        }

        .marked-cfa-edge path {
            stroke: #8B008B !important;
            stroke-width: 3px !important;
        }

        .marked-arg-edge path {
            stroke: #8B008B !important;
            stroke-width: 3px !important;
        }

        .marked-cfa-node>rect {
            outline: #8B008B solid thick !important;
            rx: 5;
            ry: 5
        }

        .marked-cfa-node>polygon {
            stroke: #8B008B !important;
            stroke-width: 5px !important;
        }

        .marked-cfa-node>circle {
            stroke: #8B008B !important;
            stroke-width: 5px !important;
        }

        .marked-cfa-node-label {
            fill: #ff00ff !important;
        }

        .marked-arg-node>rect {
            outline: #8B008B solid thick !important;
            rx: 5;
            ry: 5
        }

        #externalFiles_section {
            float: right;
            width: 100%;
            height: 100%;
            background-color: white;
            padding: 5px;
            border: solid 4px;
            border-color: lightgrey;
            overflow: hidden;
            position: relative;
        }

        #externalFiles_section .popover {
            overflow-x: hidden;
            overflow-y: auto;
        }

        #externalFiles_section .fileContent {
            height: calc(100% - 50px);
            width: 100%;
            margin: 5px;
            position: relative;
        }

        #externalFiles_section div.content {
            overflow: scroll;
            position: absolute;
            top: 50px;
            bottom: 5px;
            left: 5px;
            right: 5px;
        }

        #externalFiles_section div.cfa-content {
            overflow: scroll;
            position: absolute;
            top: 100px;
            bottom: 5px;
            left: 5px;
            right: 5px;
        }

        #externalFiles_section div.arg-content {
            overflow: scroll;
            position: absolute;
            top: 100px;
            bottom: 5px;
            left: 5px;
            right: 5px;
        }

        table {
            border-collapse: separate;
            border-spacing: 2px;
        }

        .dataTables_wrapper {
            padding: 10px;
        }

        #statistics_table td:first-child {
            white-space: pre;
        }

        #statistics_table .table_head {
            background-color: #ccc;
        }

        #err-table td:first-child {
            background-color: #ccc;
        }

        .sourceContent td:first-child {
            background-color: #ccc;
        }

        .sourceContent td pre {
            padding: 0px;
            margin: 0px;
            border: none;
        }

        .sourceContent tr:nth-child(odd) td pre.prettyprint {
            background-color: #c6dce7;
        }

        .sourceContent tr:nth-child(even) td pre.prettyprint {
            background-color: #a8cfe2;
        }

        .edit-line {
            width: 100%;
            background-color: white;
            padding: 5px;
        }

        .edit-line div {
            display: inline-block;
        }

        .edit-line label {
            margin-right: 100px;
            display: inline-block;
        }

        .edit-line p {
            display: inline-block;
        }

        div pre {
            background-color: transparent;
            border: 0;
            margin: 0;
            padding: 0;
            overflow: visible;
        }

        .help_button {
            padding: 0px;
            border: 0px;
            margin: 0px;
            display: inline-block;
        }

        #externalFiles_section .help_button {
            margin-left: 10px;
            float: left;
        }

        .cfa-graph {
            visibility: hidden;
        }

        .arg-graph {
            visibility: hidden;
        }

        .loader {
            font-family: "Helvetica Neue", Helvetica, Arial, "sans-serf";
            font-size: 20px;
            font-style: italic;
            color: #4040a1;
        }

        #cfa-toolbar {
            width: 95%;
            background-color: white;
            margin-top: 5px;
            margin-left: 10px;
            padding: 5px;
            position: fixed;
            display: inline-block;
            visibility: hidden;
        }

        #cfa-toolbar select {
            max-width: 150px;
        }

        #cfa-toolbar label {
            margin-left: 20px;
            margin-right: 5px;
        }

        #cfa-toolbar text {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
            font-size: 11px;
        }

        input[type=text] {
            width: 80px;
            height: 34px;
        }

        #arg-toolbar {
            width: 95%;
            background-color: white;
            left: 20px;
            top: 60px;
            padding: 5px;
            position: absolute;
            display: inline-block;
            visibility: hidden;
        }

        #arg-toolbar label {
            margin-left: 20px;
            margin-right: 5px;
        }

        #arg-toolbar text {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
            font-size: 11px;
        }

        text {
            font-weight: bold;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
            font-size: 12px;
        }

        .arg-node.target>rect {
            fill: red;
            rx: 5;
            ry: 5
        }

        .arg-node.not-expanded>rect {
            fill: orange;
            rx: 5;
            ry: 5
        }

        .arg-node.highlighted>rect {
            fill: cornflowerblue;
            rx: 5;
            ry: 5
        }

        .arg-node.covered>rect {
            fill: green;
            rx: 5;
            ry: 5
        }

        .arg-node text {
            text-anchor: middle;
            font-family: "Times New Roman", serif;
        }

        .arg-node rect {
            fill: #fff;
            rx: 5;
            ry: 5
        }

        .cfa-node rect {
            stroke: #999;
            fill: #fff;
            stroke-width: 1.5px;
            rx: 5;
            ry: 5
        }

        .cfa-node circle {
            stroke: #999;
            fill: #fff;
            stroke-width: 1.5px;
        }

        .cfa-node polygon {
            stroke: #999;
            fill: #fff;
            stroke-width: 1.5px;
        }

        .cfa-dummy rect {
            fill: #fff;
            stroke: #c0c0c0;
            stroke-width: 0.5px;
            rx: 5;
            ry: 5
        }

        .arg-dummy rect {
            fill: #fff;
            stroke: #c0c0c0;
            stroke-width: 0.5px;
            rx: 5;
            ry: 5
        }

        .fcall rect {
            stroke: #999;
            fill: #fff;
            stroke-width: 1.5px;
            rx: 5;
            ry: 5
        }

        .edgePath path {
            stroke: #A9A9A9;
            fill: #ffffff;
            stroke-width: 1.5px;
        }

        .error-edge path {
            stroke: red;
            fill: #ffffff;
            stroke-width: 1.5px;
        }

        /* if we have display: none here Firefox cannot render the edges connecting to the dummy nodes */

        .dummy rect {
            visibility: hidden;
        }

        #infoBox {
            visibility: hidden;
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1;
            width: 200px;
            background-color: #ffef96;
            display: inline-block;
            border-radius: 6px;
        }

        .tool_tip #boxContent::after {
            content: "";
            position: absolute;
            top: 25%;
            right: 100%;
            margin-top: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent #ffef96 transparent transparent;
        }

        #insideBox {
            padding-top: 10px;
        }

        #boxContent {
            font-family: Verdana, Arial, Helvetica, sans-serif;
            font-size: 12px;
            line-height: 130%;
            color: black;
            text-align: center;
            padding: 5px 0;
        }

        .bold {
            font-weight: bold;
        }
    </style>
    <!-- <link rel="stylesheet" href="https://www.sosy-lab.org/lib/fontawesome-free/css/fontawesome-all.min.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp"
        crossorigin="anonymous"> -->
    <!-- <link rel="stylesheet" href="https://www.sosy-lab.org/lib/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB"
        crossorigin="anonymous">
    <script src="https://www.sosy-lab.org/lib/jquery/3.3.1/jquery.min.js" integrity="sha384-tsQFqpEReu7ZLhBV2VZlAu7zcOV+rXbYlF2cqB8txI/8aZajjp4Bqd+V6D5IgvKT"
        crossorigin="anonymous"></script>
    <script src="https://www.sosy-lab.org/lib/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
        crossorigin="anonymous"></script>
    <script src="https://www.sosy-lab.org/lib/tooltip.js/1.2.0/tooltip.min.js" integrity="sha384-+MiOfL4NtQBAtarjjgXq+jOiGz1Slxe5BaqDIeXw8XCrZe5K0PAV60JKfG0WoEu7"
        crossorigin="anonymous"></script>
    <script src="https://www.sosy-lab.org/lib/angularjs/1.7.0/angular.min.js" integrity="sha384-OGKaWeggmIvCx/zchfRERRmxXYyFHhSRKBcld3xfy5N42zsVueW6rVyiL7E53ZGJ"
        crossorigin="anonymous"></script>
    <script src="https://www.sosy-lab.org/lib/d3js/5.4.0/d3.min.js" integrity="sha384-Ha//YQhNUuPzmPKgC8aYpurZcTiV3JhEvEhH5uGW0IRjBfEgDQxvo0aF1Gef+blI"
        crossorigin="anonymous"></script>
    <script src="https://www.sosy-lab.org/lib/dagre-d3/0.5.0/dagre-d3.min.js" integrity="sha384-0qz1K6Ihi4XT9AwqcOOC/ciBQ9ufdzKZUc8G1It6RZ+oLJSk41EhaZiLPVoBE0JT"
        crossorigin="anonymous"></script>
    <script src="https://www.sosy-lab.org/lib/google-code-prettify/2018-04-29-453bd5f/prettify.js" integrity="sha384-KlbExXRJYYILJYRAJR121vJXgBDx+puqf1yjznMcTt7C5njwQajOLFwk6pMafFnX"
        crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://www.sosy-lab.org/lib/google-code-prettify/2018-04-29-453bd5f/prettify.css" integrity="sha384-tGeLopS7aWCwgeqg+ah7c+iI19JU3teQPshyaQVybvOMRravAVLscwoeT4HPsfoW"
        crossorigin="anonymous">
    <script src="https://www.sosy-lab.org/lib/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T"
        crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://www.sosy-lab.org/lib/datatables/1.10.18/datatables.min.css" integrity="sha384-t1jrh3H+gcVq93cU14/FvFkiDDLHAupR2uFWQFOIqqB0ZgNvd09e5yjT5Mc9mGPZ"
        crossorigin="anonymous">
    <script src="https://www.sosy-lab.org/lib/datatables/1.10.18/datatables.min.js" integrity="sha384-b6lz7vBoPNFWulOisoJlEziEWnbO6TbeulJvmrmuro+kXqlUgmn+sVfASUlqVcZo"
        crossorigin="anonymous"></script> -->
    <!-- <script>
        /* Refer to the doc/ReportTemplateStyleGuide.md for Coding and Style Guide. They will let you write better code
                        with considerably less effort */

        (function () {
            $(function () {
                // initialize all popovers
                $('[data-toggle="popover"]').popover({
                    html: true
                });
                // initialize all tooltips
                $("[data-toggle=tooltip]").tooltip();
                $(document).on('hover', '[data-toggle=tooltip]', function () {
                    $(this).tooltip('show');
                });
                // hide tooltip after 5 seconds
                $(document).on('shown.bs.tooltip', function (e) {
                    setTimeout(function () {
                        $(e.target).tooltip('hide');
                    }, 3000);
                });

                //Statistics table initialization
                statisticsTable = $('#statistics_table').DataTable({
                    "order": [],
                    aLengthMenu: [
                        [25, 50, 100, 200, -1],
                        [25, 50, 100, 200, "All"]
                    ],
                    iDisplayLength: -1, //Default display all entries
                    "columnDefs": [{
                        "orderable": false, //No ordering 
                        "targets": 0
                    }, {
                        "orderable": false, //No Ordering
                        "targets": 1,
                    }]
                });

                // Initialize Google pretiffy code 
                $(document).ready(function () {
                    PR.prettyPrint();
                });

                //Configuration table initialization
                $(document).ready(function () {
                    $('#config_table').DataTable({
                        "order": [
                            [1, "asc"]
                        ],
                        aLengthMenu: [
                            [25, 50, 100, 200, -1],
                            [25, 50, 100, 200, "All"]
                        ],
                        iDisplayLength: -1 //Default display all entries
                    });
                });

                //Log table initialization
                $(document).ready(function () {
                    $('#log_table').DataTable({
                        "order": [
                            [0, "asc"]
                        ],
                        autoWidth: false,
                        aoColumns: [{
                                sWidth: '12%'
                            },
                            {
                                sWidth: '10%'
                            },
                            {
                                sWidth: '10%'
                            },
                            {
                                sWidth: '25%'
                            },
                            {
                                sWidth: '43%'
                            },
                        ],
                        aLengthMenu: [
                            [25, 50, 100, 200, -1],
                            [25, 50, 100, 200, "All"]
                        ],
                        iDisplayLength: -1
                    });
                });


            });

            var app = angular.module('report', []);

            reportController = app.controller('ReportController', ['$rootScope', '$scope',
                function ($rootScope, $scope) {
                    $scope.logo = "https://cpachecker.sosy-lab.org/logo.svg";
                    $scope.help_content =
                        "<div class=\"container \" style=\"font-family: Arial\"><p><b>CFA</b> (Control Flow Automaton) shows the control flow of the program. <br> For each function in the source code one CFA graph is created. <br>" +
                        "Initially all CFA's are displayed below one another beginning with the CFA for the program entry function.</p>" +
                        "<p> If an error path is detected by the analysis the edges leading to it will appear red.</p>" +
                        "<p>&#9675; &nbsp; normal element</p>" +
                        "<p>&#9634; &nbsp; combined normal elements</p>" +
                        "<p>&#9645; &nbsp; function node</p>" +
                        "<p>&#9671; &nbsp; loop head</p>" +
                        "<p>- doubleclick on a function node to select the CFA for this function</p>" +
                        "<p>- doubleclick on edges to jump to the relating line in the Source tab</p>" +
                        "<p>- use the Displayed CFA select box to display only the CFA for the desired function </p>" +
                        "<p>- use the Mouse Wheel Zoom checkbox to alter between scroll and zoom behaviour on mouse wheel</p>" +
                        "<p>- use Split Threshold and 'Refresh button' to redraw the graph (values between 500 and 900)</p>" +
                        "<p><b>ARG</b> (Abstract Reachability Graph) shows the explored abstract state space</p>" +
                        "<p> If an error path is detected by the analysis the edges leading to it will appear red.</p>" +
                        "<p><span style=\"background-color:green;\">&#9645;</span> covered state</p>" +
                        "<p><span style=\"background-color:orange;\">&#9645;</span> not yet processed state</p>" +
                        "<p><span style=\"background-color:cornflowerblue;\">&#9645;</span> important state (depending on used analysis)</p>" +
                        "<p><span style=\"background-color:red;\">&#9645;</span> target state</p>" +
                        "<p>- doubleclick on node to jump to relating node in CFA</p>" +
                        "<p>- use the Displayed ARG select box to select between the complete ARG and ARG containing only the error path (only in case an error was found) </p>" +
                        "<p>- use the Mouse Wheel Zoom checkbox to alter between scroll and zoom behaviour on mouse wheel</p>" +
                        "<p>- use Split Threshold and 'Refresh button' to redraw the graph (values between 500 and 900)</p>" +
                        "<p><b>In case of split graph (applies to both CFA and ARG)</b><br> -- doubleclick on labelless node to jump to target node<br> -- doubleclick on 'split edge' to jump to initial edge </p></div>";
                    $scope.help_errorpath =
                        "<div style=\"font-family: Arial\"><p>The errorpath leads to the error 'edge by edge' (CFA) or 'node by node' (ARG) or 'line by line' (Source)</p>" +
                        "<p><b>-V- (Value Assignments)</b> Click to show all initialized variables and their values at that point in the programm.</p>" +
                        "<p><b>Edge-Description (Source-Code-View)</b> Click to jump to the relating edge in the CFA / node in the ARG / line in Source (depending on active tab).\n If non of the mentioned tabs is currently set, the ARG tab will be selected.</p>" +
                        "<p><b>Buttons (Prev, Start, Next)</b> Click to navigate through the errorpath and jump to the relating position in the active tab</p>" +
                        "<p><b>Search</b>\n - You can search for words or numbers in the edge-descriptions (matches appear blue)\n" +
                        "- You can search for value-assignments (variable names or their value) - it will highlight only where a variable has been initialized or where it has changed its value (matches appear green)\n" +
                        "- An 'exact matches' search will look for a variable declarator matching exactly the provided text considering both, edge descriptions and value assignments</p></div>";
                    $scope.tab = 1;
                    $scope.$on("ChangeTab", function (event, tabIndex) {
                        $scope.setTab(tabIndex);
                    });

                    //Toggle button to hide the error path section
                    $scope.toggleErrorPathSection = function (e) {
                        $('#toggle_error_path').on('change', function () {
                            if ($(this).is(':checked')) {
                                d3.select("#errorpath_section").style("display", "inline");
                                d3.select("#externalFiles_section").style("width", "75%");
                                d3.select("#cfa-toolbar").style("width", "70%");
                            } else {
                                d3.select("#errorpath_section").style("display", "none");
                                d3.select("#externalFiles_section").style("width", "100%");
                                d3.select("#cfa-toolbar").style("width", "95%");
                            }
                        });
                    }

                    //Full screen mode function to view the report in full screen
                    $('#full_screen_mode').click(function () {
                        $(this).find('i').toggleClass('fa-compress fa-expand')
                    });

                    $scope.makeFullScreen = function () {
                        if ((document.fullScreenElement && document.fullScreenElement !== null) || (!
                                document.mozFullScreen && !
                                document.webkitIsFullScreen)) {
                            if (document.documentElement.requestFullScreen) {
                                document.documentElement.requestFullScreen();
                            } else if (document.documentElement.mozRequestFullScreen) {
                                document.documentElement.mozRequestFullScreen();
                            } else if (document.documentElement.webkitRequestFullScreen) {
                                document.documentElement.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
                            }
                        } else {
                            if (document.cancelFullScreen) {
                                document.cancelFullScreen();
                            } else if (document.mozCancelFullScreen) {
                                document.mozCancelFullScreen();
                            } else if (document.webkitCancelFullScreen) {
                                document.webkitCancelFullScreen();
                            }
                        }
                    };

                    $scope.setTab = function (tabIndex) {
                        // if (error) return console.warn(error);
                        if (tabIndex === 1) {
                            if (d3.select("#arg-toolbar").style("visibility") !== "hidden") {
                                d3.select("#arg-toolbar").style("visibility", "hidden");
                                d3.selectAll(".arg-graph").style("visibility", "hidden");
                                d3.selectAll(".arg-error-graph").style("visibility", "hidden");
                                if (d3.select("#arg-container").classed("arg-content")) {
                                    d3.select("#arg-container").classed("arg-content", false);
                                }
                            }
                            d3.select("#cfa-toolbar").style("visibility", "visible");
                            if (!d3.select("#cfa-container").classed("cfa-content")) {
                                d3.select("#cfa-container").classed("cfa-content", true);
                            }
                            d3.selectAll(".cfa-graph").style("visibility", "visible");
                        } else if (tabIndex === 2) {
                            if (argTabDisabled) return;
                            if (d3.select("#cfa-toolbar").style("visibility") !== "hidden") {
                                d3.select("#cfa-toolbar").style("visibility", "hidden");
                                d3.selectAll(".cfa-graph").style("visibility", "hidden");
                                if (d3.select("#cfa-container").classed("cfa-content")) {
                                    d3.select("#cfa-container").classed("cfa-content", false);
                                }
                            }
                            d3.select("#arg-toolbar").style("visibility", "visible");
                            if (!d3.select("#arg-container").classed("arg-content")) {
                                d3.select("#arg-container").classed("arg-content", true);
                            }
                            if ($rootScope.displayedARG.indexOf("error") !== -1) {
                                d3.selectAll(".arg-error-graph").style("visibility", "visible");
                                if ($("#arg-container").scrollTop() === 0) {
                                    $("#arg-container").scrollTop(0).scrollLeft(0);
                                }
                            } else {
                                d3.selectAll(".arg-graph").style("visibility", "visible");
                                if ($("#arg-container").scrollTop() === 0) {
                                    var boundingRect = d3.select(".arg-node").node().getBoundingClientRect();
                                    $("#arg-container").scrollTop(boundingRect.top + $("#arg-container")
                                        .scrollTop() - 200).scrollLeft(boundingRect.left + $(
                                        "#arg-container").scrollLeft() - 500);
                                }
                            }
                        } else {
                            if (d3.select("#cfa-toolbar").style("visibility") !== "hidden") {
                                d3.select("#cfa-toolbar").style("visibility", "hidden");
                                d3.selectAll(".cfa-graph").style("visibility", "hidden");
                                if (d3.select("#cfa-container").classed("cfa-content")) {
                                    d3.select("#cfa-container").classed("cfa-content", false);
                                }
                            }
                            if (d3.select("#arg-toolbar").style("visibility") !== "hidden") {
                                d3.select("#arg-toolbar").style("visibility", "hidden");
                                d3.selectAll(".arg-graph").style("visibility", "hidden");
                                d3.selectAll(".arg-error-graph").style("visibility", "hidden");
                                if (d3.select("#arg-container").classed("arg-content")) {
                                    d3.select("#arg-container").classed("arg-content", false);
                                }
                            }
                        }
                        $scope.tab = tabIndex;
                    };
                    $scope.tabIsSet = function (tabIndex) {
                        return $scope.tab === tabIndex;
                    };

                    $scope.getTabSet = function () {
                        return $scope.tab;
                    };
                }
            ]);

            var errorpathController = app.controller("ErrorpathController", ['$rootScope', '$scope', function (
                $rootScope, $scope) {
                $rootScope.errorPath = [];

                function getValues(val, prevValDict) {
                    var values = {};
                    if (val != "") {
                        var singleStatements = val.split("\n");
                        for (var i = 0; i < singleStatements.length - 1; i++) {
                            if (!Object.keys(prevValDict).includes(singleStatements[i].split("==")[0].trim())) {
                                // previous dictionary does not include the statement
                                values[singleStatements[i].split("==")[0].trim()] = singleStatements[i]
                                    .split("==")[1].trim().slice(0, -1);
                            } else if (prevValDict[singleStatements[i].split("==")[0].trim()] !==
                                singleStatements[i].split("==")[1].trim().slice(0, -1)) {
                                // statement is included but with different value
                                values[singleStatements[i].split("==")[0].trim()] = singleStatements[i]
                                    .split("==")[1].trim().slice(0, -1);
                            }
                        }
                    }
                    return values;
                };

                if (errorPath !== undefined) {
                    var indentationlevel = 0;
                    for (var i = 0; i < errorPath.length; i++) {
                        var errPathElem = errorPath[i];
                        // do not show start, return and blank edges
                        if (errPathElem.desc.indexOf("Return edge from") === -1 && errPathElem.desc !=
                            "Function start dummy edge" && errPathElem.desc != "") {
                            var previousValueDictionary = {};
                            errPathElem["valDict"] = {};
                            errPathElem["valString"] = "";
                            if (i > 0) {
                                $.extend(errPathElem.valDict, $rootScope.errorPath[$rootScope.errorPath
                                    .length - 1].valDict);
                                previousValueDictionary = $rootScope.errorPath[$rootScope.errorPath.length -
                                    1].valDict;
                            }
                            var newValues = getValues(errPathElem.val, previousValueDictionary);
                            errPathElem["newValDict"] = newValues;
                            if (!$.isEmptyObject(newValues)) {
                                $.extend(errPathElem.valDict, newValues)
                            }
                            for (key in errPathElem.valDict) {
                                errPathElem.valString += key + ":  " + errPathElem.valDict[key] + "\n";
                            }
                            // add indentation
                            for (var j = 1; j <= indentationlevel; j++) {
                                errPathElem.desc = "   " + errPathElem.desc;
                            }
                            $rootScope.errorPath.push(errPathElem);
                        } else if (errPathElem.desc.indexOf("Return edge from") !== -1) {
                            indentationlevel -= 1;
                        } else if (errPathElem.desc.indexOf("Function start dummy") !== -1) {
                            indentationlevel += 1;
                        }
                    }
                }

                $scope.errPathPrevClicked = function ($event) {
                    var selection = d3.select("tr.clickedErrPathElement");
                    if (!selection.empty()) {
                        var prevId = parseInt(selection.attr("id").substring("errpath-".length)) -
                            1;
                        selection.classed("clickedErrPathElement", false);
                        d3.select("#errpath-" + prevId).classed("clickedErrPathElement", true);
                        $("#value-assignment").scrollTop($("#value-assignment").scrollTop() - 18);
                        markErrorPathElementInTab("Prev", prevId);
                    }
                };

                $scope.errPathStartClicked = function () {
                    d3.select("tr.clickedErrPathElement").classed("clickedErrPathElement", false);
                    d3.select("#errpath-0").classed("clickedErrPathElement", true);
                    $("#value-assignment").scrollTop(0);
                    markErrorPathElementInTab("Start", 0);
                };

                $scope.errPathNextClicked = function ($event) {
                    var selection = d3.select("tr.clickedErrPathElement");
                    if (!selection.empty()) {
                        var nextId = parseInt(selection.attr("id").substring("errpath-".length)) +
                            1;
                        selection.classed("clickedErrPathElement", false);
                        d3.select("#errpath-" + nextId).classed("clickedErrPathElement", true);
                        $("#value-assignment").scrollTop($("#value-assignment").scrollTop() + 18);
                        markErrorPathElementInTab("Next", nextId);
                    }
                };

                $scope.clickedErrpathElement = function ($event) {
                    d3.select("tr.clickedErrPathElement").classed("clickedErrPathElement", false);
                    var clickedElement = d3.select($event.currentTarget.parentNode);
                    clickedElement.classed("clickedErrPathElement", true);
                    markErrorPathElementInTab("", clickedElement.attr("id").substring("errpath-".length));
                };

                function markErrorPathElementInTab(buttonId, selectedErrPathElemId) {
                    if ($rootScope.errorPath[selectedErrPathElemId] === undefined) {
                        return;
                    }
                    var currentTab = $("#report-controller").scope().getTabSet();
                    // when the current tab is not one of CFA, ARG, source, set the tab to ARG
                    if (buttonId === "") {
                        handleErrorPathElemClick(currentTab, selectedErrPathElemId);
                    } else if (buttonId === "Start") {
                        handleStartButtonClick(currentTab);
                    } else if (buttonId === "Prev") {
                        handlePrevButtonClick(currentTab, selectedErrPathElemId);
                    } else { // "Next"
                        handleNextButtonClick(currentTab, selectedErrPathElemId);
                    }
                }

                function handleErrorPathElemClick(currentTab, errPathElemIndex) {
                    if (currentTab === 1) {
                        markCfaEdge($rootScope.errorPath[errPathElemIndex]);
                    } else if (currentTab === 2) {
                        markArgNode($rootScope.errorPath[errPathElemIndex]);
                    } else if (currentTab === 3) {
                        markSourceLine($rootScope.errorPath[errPathElemIndex]);
                    } else {
                        $("#report-controller").scope().setTab(2);
                        markArgNode($rootScope.errorPath[errPathElemIndex]);
                    }
                }

                function handleStartButtonClick(currentTab) {
                    if (currentTab === 1) {
                        markCfaEdge($rootScope.errorPath[0]);
                    } else if (currentTab === 2) {
                        markArgNode($rootScope.errorPath[0]);
                    } else if (currentTab === 3) {
                        markSourceLine($rootScope.errorPath[0]);
                    } else {
                        $("#report-controller").scope().setTab(2);
                        markArgNode($rootScope.errorPath[0]);
                    }
                }

                function handlePrevButtonClick(currentTab, elementId) {
                    if (currentTab === 1) {
                        markCfaEdge($rootScope.errorPath[elementId]);
                    } else if (currentTab === 2) {
                        markArgNode($rootScope.errorPath[elementId]);
                    } else if (currentTab === 3) {
                        markSourceLine($rootScope.errorPath[elementId]);
                    } else {
                        $("#report-controller").scope().setTab(2);
                        markArgNode($rootScope.errorPath[elementId]);
                    }
                }

                function handleNextButtonClick(currentTab, elementId) {
                    if (currentTab === 1) {
                        markCfaEdge($rootScope.errorPath[elementId]);
                    } else if (currentTab === 2) {
                        markArgNode($rootScope.errorPath[elementId]);
                    } else if (currentTab === 3) {
                        markSourceLine($rootScope.errorPath[elementId]);
                    } else {
                        $("#report-controller").scope().setTab(2);
                        markArgNode($rootScope.errorPath[elementId]);
                    }
                }

                function markCfaEdge(errPathEntry) {
                    var actualSourceAndTarget = getActualSourceAndTarget(errPathEntry);
                    if ($.isEmptyObject(actualSourceAndTarget)) return;
                    if (actualSourceAndTarget.target === undefined) {
                        var selection = d3.select("#cfa-node" + actualSourceAndTarget.source);
                        selection.classed("marked-cfa-node", true);
                        var boundingRect = selection.node().getBoundingClientRect();
                        $("#cfa-container").scrollTop(boundingRect.top + $("#cfa-container").scrollTop() -
                            200).scrollLeft(boundingRect.left - d3.select("#cfa-container").style(
                            "width").split("px")[0] - $("#cfa-container").scrollLeft());
                        if (actualSourceAndTarget.source in cfaJson.combinedNodes) {
                            d3.selectAll(".marked-cfa-node-label").classed("marked-cfa-node-label",
                                false);
                            selection.selectAll("tspan").each(function (d, i) {
                                if (d3.select(this).html().includes(errPathEntry.source)) {
                                    d3.select(this).classed("marked-cfa-node-label", true);
                                }
                            });
                        }
                        return;
                    }
                    if (!d3.select(".marked-cfa-edge").empty()) {
                        d3.select(".marked-cfa-edge").classed("marked-cfa-edge", false);
                    }
                    d3.selectAll(".marked-cfa-node").classed("marked-cfa-node", false);
                    d3.selectAll(".marked-cfa-node-label").classed("marked-cfa-node-label", false);
                    var selection = d3.select("#cfa-edge_" + actualSourceAndTarget.source + "-" +
                        actualSourceAndTarget.target);
                    selection.classed("marked-cfa-edge", true);
                    var boundingRect = selection.node().getBoundingClientRect();
                    $("#cfa-container").scrollTop(boundingRect.top + $("#cfa-container").scrollTop() -
                        200).scrollLeft(boundingRect.left - d3.select("#cfa-container").style(
                        "width").split("px")[0] - $("#cfa-container").scrollLeft());
                }

                function getActualSourceAndTarget(element) {
                    var result = {};
                    if (cfaJson.mergedNodes.includes(element.source) && cfaJson.mergedNodes.includes(
                            element.target)) {
                        result["source"] = getMergingNode(element.source);
                        return result;
                    }
                    if (element.source in cfaJson.combinedNodes) {
                        result["source"] = element.source;
                        return result;
                    }
                    if (!cfaJson.mergedNodes.includes(element.source) && !cfaJson.mergedNodes.includes(
                            element.target)) {
                        result["source"] = element.source;
                        result["target"] = element.target;
                    } else if (!cfaJson.mergedNodes.includes(element.source) && cfaJson.mergedNodes.includes(
                            element.target)) {
                        result["source"] = element.source;
                        result["target"] = getMergingNode(element.target);
                    } else if (cfaJson.mergedNodes.includes(element.source) && !cfaJson.mergedNodes.includes(
                            element.target)) {
                        result["source"] = getMergingNode(element.source);
                        result["target"] = element.target;
                    }
                    if (Object.keys(cfaJson.functionCallEdges).includes("" + result["source"])) {
                        result["target"] = cfaJson.functionCallEdges["" + result["source"]][0];
                    }
                    // Ensure empty object is returned if source = target (edge non existent)
                    if (result["source"] === result["target"]) {
                        delete result["source"];
                        delete result["target"];
                    }
                    return result;
                }

                // Retrieve the node in which this node was merged
                function getMergingNode(index) {
                    var result = "";
                    Object.keys(cfaJson.combinedNodes).some(function (key) {
                        if (cfaJson.combinedNodes[key].includes(index)) {
                            result = key;
                            return result;
                        }
                    })
                    return result;
                }

                function markArgNode(errPathEntry) {
                    if (errPathEntry.argelem === undefined) {
                        return;
                    }
                    if (!d3.select(".marked-arg-node").empty()) {
                        d3.select(".marked-arg-node").classed("marked-arg-node", false);
                    }
                    var idToSelect;
                    if (d3.select("#arg-graph0").style("display") !== "none")
                        idToSelect = "#arg-node";
                    else
                        idToSelect = "#arg-error-node";
                    var selection = d3.select(idToSelect + errPathEntry.argelem);
                    selection.classed("marked-arg-node", true);
                    var boundingRect = selection.node().getBoundingClientRect();
                    $("#arg-container").scrollTop(boundingRect.top + $("#arg-container").scrollTop() -
                        200).scrollLeft(boundingRect.left - d3.select("#arg-container").style(
                        "width").split("px")[0] - $("#arg-container").scrollLeft());
                }

                function markSourceLine(errPathEntry) {
                    if (!d3.select(".marked-source-line").empty()) {
                        d3.select(".marked-source-line").classed("marked-source-line", false);
                    }
                    if (errPathEntry.line === 0) {
                        errPathEntry.line = 1;
                    }
                    var selection = d3.select("#source-" + errPathEntry.line + " td pre.prettyprint");
                    selection.classed("marked-source-line", true);
                    $(".sourceContent").scrollTop(selection.node().getBoundingClientRect().top + $(
                        ".sourceContent").scrollTop() - 200);
                }

            }]);

            var searchController = app.controller("SearchController", ['$rootScope', '$scope', function ($rootScope,
                $scope) {
                $scope.numOfValueMatches = 0;
                $scope.numOfDescriptionMatches = 0;

                $scope.checkIfEnter = function ($event) {
                    if ($event.keyCode == 13) {
                        $scope.searchFor();
                    }
                };

                $scope.searchFor = function () {
                    $scope.numOfValueMatches = 0;
                    $scope.numOfDescriptionMatches = 0;
                    if (d3.select("#matches").style("display") === "none") {
                        d3.select("#matches").style("display", "inline");
                    }
                    d3.selectAll(".markedValueDescElement").classed("markedValueDescElement", false);
                    d3.selectAll(".markedValueElement").classed("markedValueElement", false);
                    d3.selectAll(".markedDescElement").classed("markedDescElement", false);
                    var searchInput = $(".search-input").val().trim();
                    if (searchInput != "") {
                        if ($("#optionExactMatch").prop("checked")) {
                            $rootScope.errorPath.forEach(function (it, i) {
                                var exactMatchInValues = searchInValues(it.newValDict,
                                    searchInput, true);
                                if (exactMatchInValues && searchInDescription(it.desc.trim(),
                                        searchInput)) {
                                    $scope.numOfValueMatches++;
                                    $scope.numOfDescriptionMatches++;
                                    $("#errpath-" + i + " td")[1].classList.add(
                                        "markedValueDescElement");
                                } else if (exactMatchInValues) {
                                    $scope.numOfValueMatches++;
                                    $("#errpath-" + i + " td")[1].classList.add(
                                        "markedValueElement");
                                } else if (searchInDescription(it.desc.trim(), searchInput)) {
                                    $scope.numOfDescriptionMatches++;
                                    $("#errpath-" + i + " td")[1].classList.add(
                                        "markedDescElement");
                                }
                            })
                        } else {
                            $rootScope.errorPath.forEach(function (it, i) {
                                var matchInValues = searchInValues(it.newValDict,
                                    searchInput, false);
                                if (matchInValues && it.desc.indexOf(searchInput) !== -1) {
                                    $scope.numOfValueMatches++;
                                    $scope.numOfDescriptionMatches++;
                                    $("#errpath-" + i + " td")[1].classList.add(
                                        "markedValueDescElement");
                                } else if (matchInValues) {
                                    $scope.numOfValueMatches++;
                                    $("#errpath-" + i + " td")[1].classList.add(
                                        "markedValueElement");
                                } else if (it.desc.indexOf(searchInput) !== -1) {
                                    $scope.numOfDescriptionMatches++;
                                    $("#errpath-" + i + " td")[1].classList.add(
                                        "markedDescElement");
                                }
                            })
                        }
                    }
                };

                // Search for input in the description by using only words. A word is defined by a-zA-Z0-9 and underscore
                function searchInDescription(desc, searchInput) {
                    var descStatements = desc.split(" ");
                    for (var i = 0; i < descStatements.length; i++) {
                        if (descStatements[i].replace(/[^\w.]/g, "") === searchInput) {
                            return true;
                        }
                    }
                    return false;
                }

                // Search for input in object, either exact match or a match containing the input
                function searchInValues(values, searchInput, exact) {
                    if ($.isEmptyObject(values)) return false;
                    var match;
                    if (exact) {
                        match = Object.keys(values).find(function (v) {
                            return v === searchInput;
                        })
                    } else {
                        match = Object.keys(values).find(function (v) {
                            return v.indexOf(searchInput) !== -1;
                        })
                    }
                    if (match) return true;
                    else return false;
                }
            }]);

            var valueAssignmentsController = app.controller("ValueAssignmentsController", ['$rootScope', '$scope',
                function ($rootScope, $scope) {
                    $scope.showValues = function ($event) {
                        var element = $event.currentTarget;
                        if (element.classList.contains("markedTableElement")) {
                            element.classList.remove("markedTableElement");
                        } else {
                            element.classList.add("markedTableElement");
                        }
                    };
                }
            ]);

            cfaToolbarController = app.controller('CFAToolbarController', ['$scope',
                function ($scope) {
                    if (functions.length > 1) {
                        $scope.functions = ["all"].concat(functions);
                    } else {
                        $scope.functions = functions;
                    }
                    $scope.selectedCFAFunction = $scope.functions[0];
                    $scope.zoomEnabled = false;

                    $scope.setCFAFunction = function () {
                        if ($scope.zoomEnabled) {
                            $scope.zoomControl();
                        }
                        // FIXME: two-way binding does not update the selected option
                        d3.selectAll("#cfa-toolbar option").attr("selected", null).attr("disabled",
                            null);
                        d3.select("#cfa-toolbar [label=" + $scope.selectedCFAFunction + "]").attr(
                            "selected", "selected").attr("disabled", true);
                        if ($scope.selectedCFAFunction === "all") {
                            functions.forEach(function (func) {
                                d3.selectAll(".cfa-svg-" + func).attr("display", "inline-block");
                            });
                        } else {
                            var funcToHide = $scope.functions.filter(function (it) {
                                return it !== $scope.selectedCFAFunction && it !== "all";
                            });
                            funcToHide.forEach(function (func) {
                                d3.selectAll(".cfa-svg-" + func).attr("display", "none");
                            });
                            d3.selectAll(".cfa-svg-" + $scope.selectedCFAFunction).attr("display",
                                "inline-block");
                        }
                        var firstElRect = d3.select("[display=inline-block] .cfa-node:nth-child(2)").node()
                            .getBoundingClientRect();
                        if (d3.select("#errorpath_section").style("display") !== "none") {
                            $("#cfa-container").scrollTop(firstElRect.top + $("#cfa-container").scrollTop() -
                                200).scrollLeft(firstElRect.left - $("#cfa-container").scrollLeft() -
                                d3.select("#externalFiles_section").style("width"));
                        } else {
                            $("#cfa-container").scrollTop(firstElRect.top + $("#cfa-container").scrollTop() -
                                200).scrollLeft(firstElRect.left - $("#cfa-container").scrollLeft());
                        }
                    };

                    $scope.cfaFunctionIsSet = function (value) {
                        return value === $scope.selectedCFAFunction;
                    };

                    $scope.zoomControl = function () {
                        if ($scope.zoomEnabled) {
                            $scope.zoomEnabled = false;
                            d3.select("#cfa-zoom-button").html("<i class='far fa-square'></i>");
                            // revert zoom and remove listeners
                            d3.selectAll(".cfa-svg").each(function (d, i) {
                                d3.select(this).on("zoom", null).on("wheel.zoom", null).on(
                                    "dblclick.zoom", null).on("touchstart.zoom", null);
                            });
                        } else {
                            $scope.zoomEnabled = true;
                            d3.select("#cfa-zoom-button").html("<i class='far fa-check-square'></i>");
                            d3.selectAll(".cfa-svg").each(function (d, i) {
                                var svg = d3.select(this),
                                    svgGroup = d3.select(this.firstChild);
                                var zoom = d3.zoom().on("zoom", function () {
                                    svgGroup.attr("transform", d3.event.transform);
                                });
                                svg.call(zoom);
                                svg.on("dblclick.zoom", null).on("touchstart.zoom", null);
                            });
                        }
                    };

                    $scope.redraw = function () {
                        var input = $("#cfa-split-threshold").val();
                        if (!$scope.validateInput(input)) {
                            alert("Invalid input!");
                            return;
                        }
                        d3.selectAll(".cfa-graph").remove();
                        if ($scope.zoomEnabled) {
                            $scope.zoomControl();
                        }
                        $scope.selectedCFAFunction = $scope.functions[0];
                        cfaSplit = true;
                        var graphCount = 0;
                        cfaJson.functionNames.forEach(function (f) {
                            var fNodes = cfaJson.nodes.filter(function (n) {
                                return n.func === f;
                            })
                            graphCount += Math.ceil(fNodes.length / input);
                        });
                        $("#cfa-modal").text("0/" + graphCount);
                        graphCount = null;
                        $("#renderStateModal").modal("show");
                        if (cfaWorker === undefined) {
                            cfaWorker = new Worker(URL.createObjectURL(new Blob(["(" +
                                cfaWorker_function + ")()"
                            ], {
                                type: "text/javascript"
                            })));
                        }
                        cfaWorker.postMessage({
                            "split": input
                        });
                        cfaWorker.postMessage({
                            "renderer": "ready"
                        });
                    };

                    $scope.validateInput = function (input) {
                        if (input % 1 !== 0) return false;
                        if (input < 500 || input > 900) return false;
                        return true;
                    }
                }
            ]);

            var argToolbarController = app.controller('ARGToolbarController', ['$rootScope', '$scope',
                function ($rootScope, $scope) {
                    $scope.zoomEnabled = false;
                    $scope.argSelections = ["complete"];
                    if (errorPath !== undefined) {
                        $scope.argSelections.push("error path");
                    }
                    $rootScope.displayedARG = $scope.argSelections[0];

                    $scope.displayARG = function () {
                        if ($scope.argSelections.length > 1) {
                            if ($rootScope.displayedARG.indexOf("error") !== -1) {
                                d3.selectAll(".arg-graph").style("display", "none");
                                $("#arg-container").scrollTop(0).scrollLeft(0);
                                if (d3.select(".arg-error-graph").empty()) {
                                    argWorker.postMessage({
                                        "errorGraph": true
                                    });
                                } else {
                                    d3.selectAll(".arg-error-graph").style("display", "inline-block").style(
                                        "visibility", "visible");
                                }
                            } else {
                                if (!d3.select(".arg-error-graph").empty()) {
                                    d3.selectAll(".arg-error-graph").style("display", "none");
                                }
                                d3.selectAll(".arg-graph").style("display", "inline-block").style(
                                    "visibility", "visible");
                                $("#arg-container").scrollLeft(d3.select(".arg-svg").attr("width") / 4);
                            }
                        }
                    };

                    $scope.argZoomControl = function () {
                        if ($scope.zoomEnabled) {
                            $scope.zoomEnabled = false;
                            d3.select("#arg-zoom-button").html("<i class='far fa-square'></i>");
                            // revert zoom and remove listeners
                            d3.selectAll(".arg-svg").each(function (d, i) {
                                d3.select(this).on("zoom", null).on("wheel.zoom", null).on(
                                    "dblclick.zoom", null).on("touchstart.zoom", null);
                            });
                        } else {
                            $scope.zoomEnabled = true;
                            d3.select("#arg-zoom-button").html("<i class='far fa-check-square'></i>");
                            d3.selectAll(".arg-svg").each(function (d, i) {
                                var svg = d3.select(this),
                                    svgGroup = d3.select(this.firstChild);
                                var zoom = d3.zoom().on("zoom", function () {
                                    svgGroup.attr("transform", d3.event.transform);
                                });
                                svg.call(zoom);
                                svg.on("dblclick.zoom", null).on("touchstart.zoom", null);
                            });
                        }
                    };

                    $scope.argRedraw = function () {
                        var input = $("#arg-split-threshold").val();
                        if (!$scope.validateInput(input)) {
                            alert("Invalid input!");
                            return;
                        }
                        d3.selectAll(".arg-graph").remove();
                        d3.selectAll(".arg-error-graph").remove();
                        if ($scope.zoomEnabled) {
                            $scope.argZoomControl();
                        }
                        var graphCount = Math.ceil(argJson.nodes.length / input);
                        $("#arg-modal").text("0/" + graphCount);
                        graphCount = null;
                        $("#renderStateModal").modal("show");
                        if (argWorker === undefined) {
                            argWorker = new Worker(URL.createObjectURL(new Blob(["(" +
                                argWorker_function + ")()"
                            ], {
                                type: "text/javascript"
                            })));
                        }
                        argWorker.postMessage({
                            "split": input
                        });
                        argWorker.postMessage({
                            "renderer": "ready"
                        });
                    };

                    $scope.validateInput = function (input) {
                        if (input % 1 !== 0) return false;
                        if (input < 500 || input > 900) return false;
                        return true;
                    }
                }
            ]);

            var sourceController = app.controller('SourceController', ['$rootScope', '$scope', '$location',
                '$anchorScroll',
                function ($rootScope, $scope, $location, $anchorScroll) {
                    // available sourcefiles
                    $scope.sourceFiles = sourceFiles;
                    $scope.selectedSourceFile = 0;
                    $scope.setSourceFile = function (value) {
                        $scope.selectedSourceFile = value;
                    };
                    $scope.sourceFileIsSet = function (value) {
                        return value === $scope.selectedSourceFile;
                    };
                }
            ]);

        })();

        var argJson = {
            "nodes": [{
                "func": "main",
                "index": 0,
                "label": "0 @ N23\nmain entry\nAbstractionState: ABS0: true\\",
                "type": "highlighted"
            }, {
                "func": "main",
                "index": 1,
                "label": "1 @ N27\nmain\n",
                "type": ""
            }, {
                "func": "main",
                "index": 2,
                "label": "2 @ N24\nmain\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 3,
                "label": "3 @ N1\n__Main entry\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 4,
                "label": "4 @ N4\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 5,
                "label": "5 @ N7\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 6,
                "label": "6 @ N6\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 7,
                "label": "7 @ N12\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 8,
                "label": "8 @ N10\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 9,
                "label": "9 @ N9\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 10,
                "label": "10 @ N14\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 12,
                "label": "12 @ N15\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 14,
                "label": "14 @ N8\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 16,
                "label": "16 @ N16\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 18,
                "label": "18 @ N5\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 19,
                "label": "19 @ N17\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 20,
                "label": "20 @ N19\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 21,
                "label": "21 @ N18\n__Main\n",
                "type": ""
            }, {
                "func": "__Main",
                "index": 22,
                "label": "22 @ N0\n__Main exit\n",
                "type": ""
            }, {
                "func": "main",
                "index": 23,
                "label": "23 @ N25\nmain\n",
                "type": "not-expanded"
            }, {
                "func": "__Main",
                "index": 25,
                "label": "25 @ N20\n__Main\nAbstractionState: ABS1: true\\n AutomatonState: ErrorLabelAutomaton: _predefinedState_ERROR\\",
                "type": "target"
            }],
            "edges": [{
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": "12",
                "source": 8,
                "label": "Line 12\np1 = 0;",
                "type": "StatementEdge",
                "target": 12
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": "18",
                "source": 19,
                "label": "Line 18\n[p1 != p2]",
                "type": "AssumeEdge",
                "target": 20
            }, {
                "file": "<none>",
                "line": "0",
                "source": 10,
                "label": "Line 0\n",
                "type": "BlankEdge",
                "target": 14
            }, {
                "file": "<none>",
                "line": "0",
                "source": 0,
                "label": "Line 0\nINIT GLOBAL VARS",
                "type": "BlankEdge",
                "target": 1
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "source": 1,
                "label": "Lines 1 - 0:\nint __VERIFIER_nondet_int();\nint *__VERIFIER_nondet_pointer();\nvoid __Main(int flag);\nint main();\nFunction start dummy edge",
                "type": "DeclarationEdge",
                "lines": "1 - 0:",
                "target": 2
            }, {
                "file": "<none>",
                "line": "0",
                "source": 12,
                "label": "Line 0\n",
                "type": "BlankEdge",
                "target": 14
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": "24",
                "source": 2,
                "label": "Line 24\n__Main(0)",
                "type": "FunctionCallEdge",
                "target": 3
            }, {
                "file": "<none>",
                "source": 3,
                "label": "Lines 0 - 6:\nFunction start dummy edge\nint *p1 = 0;\nint *p2;",
                "type": "BlankEdge",
                "lines": "0 - 6:",
                "target": 4
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": "17",
                "source": 18,
                "label": "Line 17\np2 = __VERIFIER_nondet_pointer();",
                "type": "StatementEdge",
                "target": 19
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": "7",
                "source": 4,
                "label": "Line 7\n[flag == 0]",
                "type": "AssumeEdge",
                "target": 5
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": "8",
                "source": 7,
                "label": "Line 8\n[!(__CPAchecker_TMP_0 == 0)]",
                "type": "AssumeEdge",
                "target": 9
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": "7",
                "source": 4,
                "label": "Line 7\n[!(flag == 0)]",
                "type": "AssumeEdge",
                "target": 6
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "source": 6,
                "label": "Lines 8 - 8:\nint __CPAchecker_TMP_0;\n__CPAchecker_TMP_0 = __VERIFIER_nondet_int();",
                "type": "DeclarationEdge",
                "lines": "8 - 8:",
                "target": 7
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": "8",
                "source": 7,
                "label": "Line 8\n[__CPAchecker_TMP_0 == 0]",
                "type": "AssumeEdge",
                "target": 8
            }, {
                "file": "<none>",
                "line": "0",
                "source": 21,
                "label": "Line 0\ndefault return",
                "type": "BlankEdge",
                "target": 22
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": "15",
                "source": 5,
                "label": "Line 15\np1 = __VERIFIER_nondet_pointer();",
                "type": "StatementEdge",
                "target": 16
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": "18",
                "source": 19,
                "label": "Line 18\n[!(p1 != p2)]",
                "type": "AssumeEdge",
                "target": 21
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "source": 9,
                "label": "Lines 9 - 10:\np2 = p1;\np1 = 0;",
                "type": "StatementEdge",
                "lines": "9 - 10:",
                "target": 10
            }, {
                "file": "<none>",
                "line": "0",
                "source": 14,
                "label": "Line 0\n",
                "type": "BlankEdge",
                "target": 18
            }, {
                "file": "<none>",
                "line": "0",
                "source": 16,
                "label": "Line 0\n",
                "type": "BlankEdge",
                "target": 18
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": "24",
                "source": 22,
                "label": "Line 24\nReturn edge from __Main to main\n __Main(0);",
                "type": "FunctionReturnEdge",
                "target": 23
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": "19",
                "source": 20,
                "label": "Line 19\nLabel: ERROR",
                "type": "BlankEdge",
                "target": 25
            }]
        }

        var sourceFiles = ["test\/programs\/simple\/SSAMap-bug_false-unreach-label.c"];
        var cfaJson = {
            "functionNames": ["main", "__Main"],
            "functionCallEdges": {
                "24": [100001, 25]
            },
            "combinedNodes": {
                "1": [2, 3],
                "6": [11],
                "9": [13, 14],
                "10": [15],
                "27": [28, 29, 30, 31]
            },
            "combinedNodesLabels": {
                "1": "1 Function start dummy edge\n2 int *p1 = 0;\n3 int *p2;",
                "6": "6 int __CPAchecker_TMP_0;\n11 __CPAchecker_TMP_0 = __VERIFIER_nondet_int();",
                "9": "9 p2 = p1;\n13 p1 = 0;\n14 ",
                "10": "10 p1 = 0;\n15 ",
                "27": "27 int __VERIFIER_nondet_int();\n28 int *__VERIFIER_nondet_pointer();\n29 void __Main(int flag);\n30 int main();\n31 Function start dummy edge"
            },
            "mergedNodes": [2, 3, 11, 13, 14, 15, 28, 29, 30, 31],
            "errorPath": [{
                "val": "",
                "file": "<none>",
                "line": 0,
                "argelem": 0,
                "source": 23,
                "target": 27,
                "desc": "INIT GLOBAL VARS"
            }, {
                "val": "",
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 1,
                "argelem": 1,
                "source": 27,
                "target": 28,
                "desc": "int __VERIFIER_nondet_int();"
            }, {
                "val": "",
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 2,
                "source": 28,
                "target": 29,
                "desc": "int *__VERIFIER_nondet_pointer();"
            }, {
                "val": "",
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 4,
                "source": 29,
                "target": 30,
                "desc": "void __Main(int flag);"
            }, {
                "val": "",
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 23,
                "source": 30,
                "target": 31,
                "desc": "int main();"
            }, {
                "val": "",
                "file": "<none>",
                "line": 0,
                "source": 31,
                "target": 24,
                "desc": "Function start dummy edge"
            }, {
                "val": "",
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 24,
                "argelem": 2,
                "source": 24,
                "target": 1,
                "desc": "__Main(0)"
            }, {
                "val": "flag == 0;\n",
                "file": "<none>",
                "line": 0,
                "argelem": 3,
                "source": 1,
                "target": 2,
                "desc": "Function start dummy edge"
            }, {
                "val": "p1 == 0LL;\nflag == 0;\n",
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 6,
                "source": 2,
                "target": 3,
                "desc": "int *p1 = 0;"
            }, {
                "val": "",
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 6,
                "source": 3,
                "target": 4,
                "desc": "int *p2;"
            }, {
                "val": "flag == 0;",
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 7,
                "argelem": 4,
                "source": 4,
                "target": 7,
                "desc": "[flag == 0]"
            }, {
                "val": "p1 == 1LL;\n",
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 15,
                "argelem": 5,
                "source": 7,
                "target": 16,
                "desc": "p1 = __VERIFIER_nondet_pointer();"
            }, {
                "val": "",
                "file": "<none>",
                "line": 0,
                "argelem": 16,
                "source": 16,
                "target": 5,
                "desc": ""
            }, {
                "val": "p2 == 2LL;\n",
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 17,
                "argelem": 18,
                "source": 5,
                "target": 17,
                "desc": "p2 = __VERIFIER_nondet_pointer();"
            }, {
                "val": "p1 == 1LL;\np2 == 2LL;",
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 18,
                "argelem": 19,
                "source": 17,
                "target": 19,
                "desc": "[p1 != p2]"
            }, {
                "val": "",
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 19,
                "argelem": 20,
                "source": 19,
                "target": 20,
                "desc": "Label: ERROR"
            }],
            "nodes": [{
                "func": "__Main",
                "loop": false,
                "index": 0,
                "rpid": 2,
                "type": "exit"
            }, {
                "func": "__Main",
                "loop": false,
                "index": 1,
                "rpid": 20,
                "type": "entry"
            }, {
                "func": "__Main",
                "loop": false,
                "index": 2,
                "rpid": 19,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 3,
                "rpid": 18,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 4,
                "rpid": 17,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 5,
                "rpid": 5,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 6,
                "rpid": 16,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 7,
                "rpid": 7,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 8,
                "rpid": 8,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 9,
                "rpid": 13,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 10,
                "rpid": 10,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 11,
                "rpid": 15,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 12,
                "rpid": 14,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 13,
                "rpid": 12,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 14,
                "rpid": 11,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 15,
                "rpid": 9,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 16,
                "rpid": 6,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 17,
                "rpid": 4,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 18,
                "rpid": 3,
                "type": ""
            }, {
                "func": "__Main",
                "loop": false,
                "index": 19,
                "rpid": 1,
                "type": ""
            }, {
                "func": "__Main",
                "loop": true,
                "index": 20,
                "rpid": 0,
                "type": ""
            }, {
                "func": "main",
                "loop": false,
                "index": 22,
                "rpid": 0,
                "type": "exit"
            }, {
                "func": "main",
                "loop": false,
                "index": 23,
                "rpid": 8,
                "type": "entry"
            }, {
                "func": "main",
                "loop": false,
                "index": 24,
                "rpid": 2,
                "type": ""
            }, {
                "func": "main",
                "loop": false,
                "index": 25,
                "rpid": 1,
                "type": ""
            }, {
                "func": "main",
                "loop": false,
                "index": 27,
                "rpid": 7,
                "type": ""
            }, {
                "func": "main",
                "loop": false,
                "index": 28,
                "rpid": 6,
                "type": ""
            }, {
                "func": "main",
                "loop": false,
                "index": 29,
                "rpid": 5,
                "type": ""
            }, {
                "func": "main",
                "loop": false,
                "index": 30,
                "rpid": 4,
                "type": ""
            }, {
                "func": "main",
                "loop": false,
                "index": 31,
                "rpid": 3,
                "type": ""
            }],
            "edges": [{
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 19,
                "source": 19,
                "type": "BlankEdge",
                "stmt": "Label: ERROR",
                "target": 20
            }, {
                "file": "<none>",
                "line": 0,
                "source": 23,
                "type": "BlankEdge",
                "stmt": "INIT GLOBAL VARS",
                "target": 27
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 8,
                "source": 12,
                "type": "AssumeEdge",
                "stmt": "[__CPAchecker_TMP_0 == 0]",
                "target": 10
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 2,
                "source": 28,
                "type": "DeclarationEdge",
                "stmt": "int *__VERIFIER_nondet_pointer();",
                "target": 29
            }, {
                "file": "<none>",
                "line": 0,
                "source": 1,
                "type": "BlankEdge",
                "stmt": "Function start dummy edge",
                "target": 2
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 18,
                "source": 17,
                "type": "AssumeEdge",
                "stmt": "[p1 != p2]",
                "target": 19
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 6,
                "source": 3,
                "type": "DeclarationEdge",
                "stmt": "int *p2;",
                "target": 4
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 18,
                "source": 17,
                "type": "AssumeEdge",
                "stmt": "[!(p1 != p2)]",
                "target": 18
            }, {
                "file": "<none>",
                "line": 0,
                "source": 15,
                "type": "BlankEdge",
                "stmt": "",
                "target": 8
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 8,
                "source": 6,
                "type": "DeclarationEdge",
                "stmt": "int __CPAchecker_TMP_0;",
                "target": 11
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 17,
                "source": 5,
                "type": "StatementEdge",
                "stmt": "p2 = __VERIFIER_nondet_pointer();",
                "target": 17
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 15,
                "source": 7,
                "type": "StatementEdge",
                "stmt": "p1 = __VERIFIER_nondet_pointer();",
                "target": 16
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 1,
                "source": 27,
                "type": "DeclarationEdge",
                "stmt": "int __VERIFIER_nondet_int();",
                "target": 28
            }, {
                "file": "<none>",
                "line": 0,
                "source": 18,
                "type": "BlankEdge",
                "stmt": "default return",
                "target": 0
            }, {
                "file": "<none>",
                "line": 0,
                "source": 16,
                "type": "BlankEdge",
                "stmt": "",
                "target": 5
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 8,
                "source": 11,
                "type": "StatementEdge",
                "stmt": "__CPAchecker_TMP_0 = __VERIFIER_nondet_int();",
                "target": 12
            }, {
                "file": "<none>",
                "line": 0,
                "source": 31,
                "type": "BlankEdge",
                "stmt": "Function start dummy edge",
                "target": 24
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 4,
                "source": 29,
                "type": "DeclarationEdge",
                "stmt": "void __Main(int flag);",
                "target": 30
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 19,
                "source": 20,
                "type": "BlankEdge",
                "stmt": "Goto: ERROR",
                "target": 20
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 12,
                "source": 10,
                "type": "StatementEdge",
                "stmt": "p1 = 0;",
                "target": 15
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 25,
                "source": 25,
                "type": "ReturnStatementEdge",
                "stmt": "return 0;",
                "target": 22
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 6,
                "source": 2,
                "type": "DeclarationEdge",
                "stmt": "int *p1 = 0;",
                "target": 3
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 7,
                "source": 4,
                "type": "AssumeEdge",
                "stmt": "[!(flag == 0)]",
                "target": 6
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 7,
                "source": 4,
                "type": "AssumeEdge",
                "stmt": "[flag == 0]",
                "target": 7
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 23,
                "source": 30,
                "type": "DeclarationEdge",
                "stmt": "int main();",
                "target": 31
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 8,
                "source": 12,
                "type": "AssumeEdge",
                "stmt": "[!(__CPAchecker_TMP_0 == 0)]",
                "target": 9
            }, {
                "file": "<none>",
                "line": 0,
                "source": 14,
                "type": "BlankEdge",
                "stmt": "",
                "target": 8
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 24,
                "source": 24,
                "type": "CallToReturnEdge",
                "stmt": "__Main(0);",
                "target": 25
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 9,
                "source": 9,
                "type": "StatementEdge",
                "stmt": "p2 = p1;",
                "target": 13
            }, {
                "file": "<none>",
                "line": 0,
                "source": 8,
                "type": "BlankEdge",
                "stmt": "",
                "target": 5
            }, {
                "file": "test\/programs\/simple\/SSAMap-bug_false-unreach-label.c",
                "line": 10,
                "source": 13,
                "type": "StatementEdge",
                "stmt": "p1 = 0;",
                "target": 14
            }]
        }

        // CFA graph variable declarations
        var functions = cfaJson.functionNames;
        var functionCallEdges = cfaJson.functionCallEdges;
        var errorPath;
        if (cfaJson.hasOwnProperty("errorPath")) {
            errorPath = cfaJson.errorPath;
        }
        var graphSplitThreshold = 700;
        var zoomEnabled = false;
        // A Dagre D3 Renderer
        var render = new dagreD3.render();
        const margin = 20;
        var cfaWorker, argWorker;
        var cfaSplit = false,
            argTabDisabled = false;

        function init() {

            // Calculate total count of graphs to display in modal
            var argTotalGraphCount;
            if (argJson.nodes) {
                argTotalGraphCount = Math.ceil(argJson.nodes.length / graphSplitThreshold);
                $("#arg-modal").text("0/" + argTotalGraphCount);
            } else { // No ARG data -> happens if the AbstractStates are not ARGStates
                $("#arg-modal").text("0/0");
                $("#set-tab-2").parent().addClass("disabled");
                argTabDisabled = true;
            }
            var cfaTotalGraphCount = 0;
            cfaJson.functionNames.forEach(function (f) {
                var fNodes = cfaJson.nodes.filter(function (n) {
                    return n.func === f;
                })
                cfaTotalGraphCount += Math.ceil(fNodes.length / graphSplitThreshold);
            });
            $("#cfa-modal").text("0/" + cfaTotalGraphCount);
            cfaTotalGraphCount = null;

            // Display modal window containing current rendering state
            $("#renderStateModal").modal("show");

            // Setup section widths accordingly 
            if (errorPath === undefined) {
                d3.select("#errorpath_section").style("display", "none");
                $("#toggle_button_error_path").hide();
                $("#toggle_button_error_path_placeholder").hide();
            } else {
                d3.select("#externalFiles_section").style("width", "75%");
                d3.select("#cfa-toolbar").style("width", "70%");
            }

            // ======================= Define CFA and ARG Workers logic =======================
            /**
             * The CFA Worker. Contains the logic for building a single or a multi CFA graph.
             * The graph(s) is/are returned to the main script once created
             */
            function cfaWorker_function() {
                self.importScripts("https://www.sosy-lab.org/lib/d3js/5.4.0/d3.min.js",
                    "https://www.sosy-lab.org/lib/dagre-d3/0.5.0/dagre-d3.min.js");
                var json, nodes, mainNodes, edges, functions, combinedNodes, combinedNodesLabels, mergedNodes,
                    functionCallEdges, errorPath;
                var graphSplitThreshold = 700; // default value
                var graphMap = [];
                var graphCounter = 0;

                // The first posted message will include the cfaJson
                self.addEventListener('message', function (m) {
                    if (m.data.json !== undefined) {
                        json = JSON.parse(m.data.json);
                        extractVariables();
                        buildGraphsAndPostResults();
                    } else if (m.data.renderer !== undefined) {
                        if (graphMap[graphCounter] !== undefined) {
                            var node = nodes.find(function (n) {
                                return n.index === parseInt(graphMap[graphCounter].nodes()[0]);
                            });
                            self.postMessage({
                                "graph": JSON.stringify(graphMap[graphCounter]),
                                "id": node.func + graphCounter,
                                "func": node.func
                            });
                            graphCounter++;
                        } else {
                            self.postMessage({
                                "status": "done"
                            });
                            graphMap = [];
                            graphCounter = 0;
                        }
                    } else if (m.data.split !== undefined) {
                        graphSplitThreshold = m.data.split;
                        buildGraphsAndPostResults();
                    }
                }, false);

                // Extract information from the cfaJson
                function extractVariables() {
                    nodes = json.nodes;
                    functions = json.functionNames;
                    mainNodes = nodes.filter(function (n) {
                        return n.func === functions[0];
                    });
                    edges = json.edges;
                    combinedNodes = json.combinedNodes;
                    combinedNodesLabels = json.combinedNodesLabels;
                    mergedNodes = json.mergedNodes;
                    functionCallEdges = json.functionCallEdges;
                    if (json.hasOwnProperty("errorPath")) {
                        errorPath = [];
                        prepareCfaErrorPath();
                    }
                }

                // Prepare Error Path array to be used in edge class decider
                function prepareCfaErrorPath() {
                    var returnedEdges = {};
                    for (key in functionCallEdges) {
                        returnedEdges[functionCallEdges[key][1]] = functionCallEdges[key][0]
                    }
                    json.errorPath.forEach(function (errPathElem) {
                        if (errPathElem.source in functionCallEdges) {
                            errPathElem.target = functionCallEdges[errPathElem.source][0];
                        }
                        if (errPathElem.target in returnedEdges) {
                            errorPath.push({
                                "source": returnedEdges[errPathElem.target],
                                "target": errPathElem.target
                            })
                        }
                        errorPath.push(errPathElem);
                    })
                }

                function buildGraphsAndPostResults() {
                    if (mainNodes.length > graphSplitThreshold) {
                        buildMultipleGraphs(mainNodes, functions[0]);
                    } else {
                        buildSingleGraph(mainNodes, functions[0]);
                    }
                    if (functions.length > 1) {
                        var functionsToProcess = functions.filter(function (f) {
                            return f !== functions[0];
                        });
                        functionsToProcess.forEach(function (func) {
                            var funcNodes = nodes.filter(function (n) {
                                return n.func === func;
                            });
                            if (funcNodes.length > graphSplitThreshold) {
                                buildMultipleGraphs(funcNodes, func);
                            } else {
                                buildSingleGraph(funcNodes, func);
                            }
                        });
                    }
                }

                function buildSingleGraph(nodesToSet, funcName) {
                    var g = createGraph();
                    setGraphNodes(g, nodesToSet);
                    roundNodeCorners(g);
                    var nodesIndices = [];
                    nodesToSet.forEach(function (n) {
                        nodesIndices.push(n.index);
                    });
                    var edgesToSet = edges.filter(function (e) {
                        return nodesIndices.includes(e.source) && nodesIndices.includes(e.target);
                    });
                    setGraphEdges(g, edgesToSet, false);
                    if (funcName === functions[0]) {
                        self.postMessage({
                            "graph": JSON.stringify(g),
                            "id": funcName + graphCounter,
                            "func": funcName
                        });
                        graphMap.push(g);
                    } else {
                        graphMap.push(g);
                    }
                }

                function buildMultipleGraphs(nodesToSet, funcName) {
                    var requiredGraphs = Math.ceil(nodesToSet.length / graphSplitThreshold);
                    var firstGraphBuild = false;
                    var nodesPerGraph = [];
                    for (var i = 1; i <= requiredGraphs; i++) {
                        if (!firstGraphBuild) {
                            nodesPerGraph = nodesToSet.slice(0, graphSplitThreshold);
                            firstGraphBuild = true;
                        } else {
                            if (nodesToSet[graphSplitThreshold * i - 1] !== undefined)
                                nodesPerGraph = nodesToSet.slice(graphSplitThreshold * (i - 1), graphSplitThreshold * i);
                            else
                                nodesPerGraph = nodesToSet.slice(graphSplitThreshold * (i - 1));
                        }
                        var graph = createGraph();
                        setGraphNodes(graph, nodesPerGraph);
                        if (graph.nodes().length > 0) {
                            graphMap.push(graph);
                            roundNodeCorners(graph);
                            var graphEdges = edges.filter(function (e) {
                                if ((nodesPerGraph[0].index <= e.source && e.source <= nodesPerGraph[
                                        nodesPerGraph.length - 1].index) &&
                                    (nodesPerGraph[0].index <= e.target && e.target <= nodesPerGraph[
                                        nodesPerGraph.length - 1].index)) {
                                    return e;
                                }
                            });
                            setGraphEdges(graph, graphEdges, true);
                        }
                    }
                    buildCrossgraphEdges(nodesToSet);
                    if (funcName === functions[0]) {
                        self.postMessage({
                            "graph": JSON.stringify(graphMap[graphCounter]),
                            "id": funcName + graphCounter,
                            "func": funcName
                        });
                        graphCounter++;
                    }
                }

                // Handle Edges that connect Graphs
                function buildCrossgraphEdges(crossGraphNodes) {
                    var nodesIndices = [];
                    crossGraphNodes.forEach(function (n) {
                        nodesIndices.push(n.index);
                    });
                    var edgesToConsider = edges.filter(function (e) {
                        return nodesIndices.includes(e.source) && nodesIndices.includes(e.target);
                    });
                    edgesToConsider.forEach(function (edge) {
                        var source = edge.source;
                        var target = edge.target;
                        if (mergedNodes.includes(source) && mergedNodes.includes(target)) return;
                        if (mergedNodes.includes(source)) source = getMergingNode(source);
                        if (mergedNodes.includes(target)) target = getMergingNode(target);
                        var sourceGraph = getGraphForNode(source);
                        var targetGraph = getGraphForNode(target);
                        if (sourceGraph < targetGraph) {
                            if (Object.keys(functionCallEdges).includes("" + source)) {
                                var funcCallNodeId = functionCallEdges["" + source][0];
                                graphMap[sourceGraph].setNode(funcCallNodeId, {
                                    label: getNodeLabelFCall(edge.stmt),
                                    class: "cfa-node fcall",
                                    id: "cfa-node" + funcCallNodeId,
                                    shape: "rect"
                                });
                                graphMap[sourceGraph].setEdge(source, funcCallNodeId, {
                                    label: edge.stmt,
                                    labelStyle: labelStyleDecider(edge, source, funcCallNodeId),
                                    class: edgeClassDecider(edge, source, funcCallNodeId),
                                    id: "cfa-edge_" + source + "-" + funcCallNodeId
                                });
                                graphMap[sourceGraph].setNode("" + source + target + sourceGraph, {
                                    label: "",
                                    class: "cfa-dummy",
                                    id: "dummy-" + target,
                                    shape: "rect"
                                });
                                graphMap[sourceGraph].setEdge(funcCallNodeId, "" + source + target +
                                    sourceGraph, {
                                        label: source + "->" + target,
                                        style: "stroke-dasharray: 5, 5;"
                                    });
                            } else {
                                graphMap[sourceGraph].setNode("" + source + target + sourceGraph, {
                                    label: "",
                                    class: "cfa-dummy",
                                    id: "dummy-" + target,
                                    shape: "rect"
                                });
                                graphMap[sourceGraph].setEdge(source, "" + source + target + sourceGraph, {
                                    label: edge.stmt,
                                    labelStyle: labelStyleDecider(edge, source, "" + source + target +
                                        sourceGraph),
                                    id: "cfa-edge_" + source + "-" + target,
                                    class: edgeClassDecider(edge, source, "" + source + target +
                                        sourceGraph),
                                    style: "stroke-dasharray: 5, 5;"
                                });
                            }
                            graphMap[targetGraph].setNode("" + target + source + targetGraph, {
                                label: "",
                                class: "dummy"
                            });
                            graphMap[targetGraph].setEdge("" + target + source + targetGraph, target, {
                                label: "",
                                labelStyle: "font-size: 12px;",
                                id: "cfa-split-edge_" + source + "-" + target,
                                class: "cfa-split-edge",
                                style: "stroke-dasharray: 5, 5;"
                            });
                        } else if (sourceGraph > targetGraph) {
                            graphMap[sourceGraph].setNode("" + source + target + sourceGraph, {
                                label: "",
                                class: "cfa-dummy",
                                id: "dummy-" + target
                            });
                            graphMap[sourceGraph].setEdge(source, "" + source + target + sourceGraph, {
                                label: edge.stmt,
                                labelStyle: labelStyleDecider(edge, "" + source + target + sourceGraph,
                                    source),
                                id: "cfa-edge_" + source + "-" + target,
                                class: edgeClassDecider(edge, "" + source + target + sourceGraph,
                                    source),
                                arrowhead: "undirected",
                                style: "stroke-dasharray: 5, 5;"
                            })
                            graphMap[targetGraph].setNode("" + target + source + targetGraph, {
                                label: "",
                                class: "dummy",
                                id: "node" + source
                            });
                            graphMap[targetGraph].setEdge("" + target + source + targetGraph, target, {
                                label: "",
                                labelStyle: "font-size: 12px;",
                                id: "cfa-split-edge_" + source + "-" + target,
                                class: "cfa-split-edge",
                                arrowhead: "undirected",
                                style: "stroke-dasharray: 5, 5;"
                            });
                        }
                    });
                }

                // Return the graph in which the nodeNumber is present
                function getGraphForNode(nodeNumber) {
                    return graphMap.findIndex(function (graph) {
                        return graph.nodes().includes("" + nodeNumber);
                    })
                }

                // create and return a graph element with a set transition
                function createGraph() {
                    var g = new dagreD3.graphlib.Graph().setGraph({}).setDefaultEdgeLabel(
                        function () {
                            return {};
                        });
                    return g;
                }

                // Set nodes for the graph contained in the json nodes
                function setGraphNodes(graph, nodesToSet) {
                    nodesToSet.forEach(function (n) {
                        if (!mergedNodes.includes(n.index)) {
                            graph.setNode(n.index, {
                                label: setNodeLabel(n),
                                labelStyle: "font-family: 'Courier New', Courier, monospace",
                                class: "cfa-node",
                                id: "cfa-node" + n.index,
                                shape: nodeShapeDecider(n)
                            });
                        }
                    });
                }

                // Node label, the label from combined nodes or a simple label
                function setNodeLabel(node) {
                    var nodeIndex = "" + node.index;
                    if (Object.keys(combinedNodesLabels).includes(nodeIndex))
                        return combinedNodesLabels[nodeIndex];
                    else return "N" + nodeIndex;
                }

                // Decide the shape of the nodes based on type
                function nodeShapeDecider(n) {
                    if (n.loop) {
                        return "diamond";
                    } else if (Object.keys(combinedNodes).includes("" + n.index)) {
                        return "rect";
                    } else {
                        return "circle";
                    }
                }

                // Round the corners of rectangle shaped nodes
                function roundNodeCorners(graph) {
                    graph.nodes().forEach(function (it) {
                        var item = graph.node(it);
                        item.rx = item.ry = 5;
                    });
                }

                // Set the edges for a single graph while considering merged nodes and edges between them
                function setGraphEdges(graph, edgesToSet, multigraph) {
                    edgesToSet.forEach(function (e) {
                        var source, target;
                        if (!mergedNodes.includes(e.source) && !mergedNodes.includes(e.target)) {
                            source = e.source;
                            target = e.target;
                        } else if (!mergedNodes.includes(e.source) && mergedNodes.includes(e.target)) {
                            source = e.source;
                            target = getMergingNode(e.target);
                        } else if (mergedNodes.includes(e.source) && !mergedNodes.includes(e.target)) {
                            source = getMergingNode(e.source);
                            target = e.target;
                        }
                        if (multigraph && (!graph.nodes().includes("" + source) || !graph.nodes().includes("" +
                                target)))
                            source = undefined;
                        if (source !== undefined && target !== undefined && checkEligibleEdge(source, target)) {
                            if (Object.keys(functionCallEdges).includes("" + source)) {
                                var funcCallNodeId = functionCallEdges["" + source][0];
                                graph.setNode(funcCallNodeId, {
                                    label: getNodeLabelFCall(e.stmt),
                                    class: "cfa-node fcall",
                                    id: "cfa-node" + funcCallNodeId,
                                    shape: "rect"
                                });
                                graph.setEdge(source, funcCallNodeId, {
                                    label: e.stmt,
                                    labelStyle: labelStyleDecider(e, source, funcCallNodeId),
                                    class: edgeClassDecider(e, source, funcCallNodeId),
                                    id: "cfa-edge_" + source + "-" + funcCallNodeId,
                                    weight: edgeWeightDecider(source, target)
                                });
                                graph.setEdge(funcCallNodeId, target, {
                                    label: "",
                                    labelStyle: labelStyleDecider(e, funcCallNodeId, target),
                                    class: edgeClassDecider(e, funcCallNodeId, target),
                                    id: "cfa-edge_" + funcCallNodeId + "-" + target,
                                    weight: edgeWeightDecider(source, target)
                                });
                            } else {
                                graph.setEdge(source, target, {
                                    label: e.stmt,
                                    labelStyle: labelStyleDecider(e, source, target),
                                    lineInterpolate: "basis",
                                    class: edgeClassDecider(e, source, target),
                                    id: "cfa-edge_" + source + "-" + target,
                                    weight: edgeWeightDecider(source, target)
                                });
                            }
                        }
                    });
                }

                // If edge is part of error path, give it a representative class
                function edgeClassDecider(edge, source, target) {
                    if (errorPath === undefined) {
                        return "cfa-edge";
                    }
                    var mergedMatch = errorPath.find(function (entry) {
                        return entry.source === source && entry.target === target;
                    })
                    var initialMatch = errorPath.find(function (entry) {
                        return entry.source === edge.source && entry.target === edge.target;
                    })
                    if (mergedMatch !== undefined || initialMatch !== undefined) {
                        return "cfa-edge error-edge";
                    } else {
                        return "cfa-edge";
                    }
                }

                // If edge is part of error path, give its label a representative class
                function labelStyleDecider(edge, source, target) {
                    var edgeClass = edgeClassDecider(edge, source, target);
                    if (edgeClass.indexOf("error") !== -1) {
                        return "font-size: 12px; fill: red";
                    }
                    return "font-size: 12px";
                }

                // Check if edge is eligible to place in graph. Same node edge only if it is not combined node
                function checkEligibleEdge(source, target) {
                    if (mergedNodes.includes(source) && mergedNodes.includes(target)) return false;
                    if (mergedNodes.includes(source) && Object.keys(combinedNodes).includes("" + target)) {
                        if (combinedNodes["" + target].includes(source)) return false;
                        else return true;
                    }
                    if (Object.keys(combinedNodes).includes("" + source) && mergedNodes.includes(target)) {
                        if (combinedNodes["" + source].includes(target)) return false;
                        else return true;
                    }
                    if ((Object.keys(combinedNodes).includes("" + source) && Object.keys(combinedNodes).includes("" +
                            target)) && source == target) return false;
                    return true;
                }

                // Retrieve the node in which this node was merged
                function getMergingNode(index) {
                    var result = "";
                    Object.keys(combinedNodes).some(function (key) {
                        if (combinedNodes[key].includes(index)) {
                            result = key;
                            return result;
                        }
                    })
                    return parseInt(result);
                }

                // Decide the weight for the edges based on type
                function edgeWeightDecider(source, target) {
                    var sourceNode = nodes.find(function (it) {
                        return it.index === source;
                    })
                    var targetNode = nodes.find(function (it) {
                        return it.index === target;
                    })
                    if (source === target) {
                        return 2;
                    } else if (sourceNode.rpid < targetNode.rpid) {
                        return 0;
                    } else {
                        return 1;
                    }
                }

                // Get node label for functionCall node by providing the edge statement
                function getNodeLabelFCall(stmt) {
                    var result = "";
                    if (stmt.includes("=")) {
                        result = stmt.split("=")[1].split("(")[0].trim();
                    } else {
                        result = stmt.split("(")[0].trim();
                    }
                    return result;
                }

            }

            /**
             * The ARG Worker. Contains the logic for creating a single or multi ARG graph.
             * Once the graph(s) is/are created they are returned to the main script.
             * ONLY if ARG data is available!
             */
            if (argJson.nodes) {
                function argWorker_function() {
                    self.importScripts("https://www.sosy-lab.org/lib/d3js/5.4.0/d3.min.js",
                        "https://www.sosy-lab.org/lib/dagre-d3/0.5.0/dagre-d3.min.js");
                    var json, nodes, edges, errorPath, errorGraphMap;
                    var graphSplitThreshold = 700;
                    var graphMap = [],
                        graphCounter = 0;
                    self.addEventListener("message", function (m) {
                        if (m.data.json !== undefined) {
                            json = JSON.parse(m.data.json);
                            nodes = json.nodes;
                            edges = json.edges;
                            buildGraphsAndPrepareResults()
                        } else if (m.data.errorPath !== undefined) {
                            errorPath = [];
                            JSON.parse(m.data.errorPath).forEach(function (d) {
                                if (d.argelem !== undefined) {
                                    errorPath.push(d.argelem);
                                }
                            });
                        } else if (m.data.renderer !== undefined) {
                            if (graphMap.length > 0) {
                                self.postMessage({
                                    "graph": JSON.stringify(graphMap[0]),
                                    "id": graphCounter
                                });
                                graphMap.shift();
                                graphCounter++;
                            } else {
                                self.postMessage({
                                    "status": "done"
                                });
                                if (errorPath !== undefined) {
                                    errorGraphMap = [];
                                    graphCounter = 0;
                                    prepareErrorGraph();
                                }
                            }
                        } else if (m.data.errorGraph !== undefined) {
                            if (errorGraphMap.length > 0) {
                                self.postMessage({
                                    "graph": JSON.stringify(errorGraphMap[0]),
                                    "id": graphCounter,
                                    "errorGraph": true
                                });
                                errorGraphMap.shift();
                                graphCounter++;
                            }
                        } else if (m.data.split !== undefined) {
                            graphSplitThreshold = m.data.split;
                            if (errorGraphMap !== undefined && errorGraphMap.length > 0) {
                                errorGraphMap = [];
                            }
                            buildGraphsAndPrepareResults();
                        }
                    }, false);

                    function buildGraphsAndPrepareResults() {
                        if (nodes.length > graphSplitThreshold) {
                            buildMultipleGraphs();
                        } else {
                            buildSingleGraph();
                        }
                    }

                    // After the initial ARG graph has been send to the master script, prepare ARG containing only error path		
                    function prepareErrorGraph() {
                        var errorNodes = [],
                            errorEdges = [];
                        nodes.forEach(function (n) {
                            if (errorPath.includes(n.index)) {
                                errorNodes.push(n);
                            }
                        });
                        edges.forEach(function (e) {
                            if (errorPath.includes(e.source) && errorPath.includes(e.target)) {
                                errorEdges.push(e);
                            }
                        });
                        if (errorNodes.length > graphSplitThreshold) {
                            buildMultipleErrorGraphs(errorNodes, errorEdges);
                        } else {
                            var g = createGraph();
                            setGraphNodes(g, errorNodes);
                            setGraphEdges(g, errorEdges, false);
                            errorGraphMap.push(g);
                        }
                    }

                    function buildSingleGraph() {
                        var g = createGraph();
                        setGraphNodes(g, nodes);
                        setGraphEdges(g, edges, false);
                        graphMap.push(g);
                    }

                    // Split the ARG graph honoring the split threshold
                    function buildMultipleGraphs() {
                        nodes.sort(function (firstNode, secondNode) {
                            return firstNode.index - secondNode.index;
                        })
                        var requiredGraphs = Math.ceil(nodes.length / graphSplitThreshold);
                        var firstGraphBuild = false;
                        var nodesPerGraph = [];
                        for (var i = 1; i <= requiredGraphs; i++) {
                            if (!firstGraphBuild) {
                                nodesPerGraph = nodes.slice(0, graphSplitThreshold);
                                firstGraphBuild = true;
                            } else {
                                if (nodes[graphSplitThreshold * i - 1] !== undefined) {
                                    nodesPerGraph = nodes.slice(graphSplitThreshold * (i - 1), graphSplitThreshold * i);
                                } else {
                                    nodesPerGraph = nodes.slice(graphSplitThreshold * (i - 1));
                                }
                            }
                            var graph = createGraph();
                            graphMap.push(graph);
                            setGraphNodes(graph, nodesPerGraph);
                            var nodesIndices = []
                            nodesPerGraph.forEach(function (n) {
                                nodesIndices.push(n.index);
                            });
                            var graphEdges = edges.filter(function (e) {
                                if (nodesIndices.includes(e.source) && nodesIndices.includes(e.target)) {
                                    return e;
                                }
                            });
                            setGraphEdges(graph, graphEdges, true);
                        }
                        buildCrossgraphEdges(edges, false);
                    }

                    // Split the ARG error graph honoring the split threshold
                    function buildMultipleErrorGraphs(errorNodes, errorEdges) {
                        errorNodes.sort(function (firstNode, secondNode) {
                            return firstNode.index - secondNode.index;
                        })
                        var requiredGraphs = Math.ceil(errorNodes.length / graphSplitThreshold);
                        var firstGraphBuild = false;
                        var nodesPerGraph = [];
                        for (var i = 1; i <= requiredGraphs; i++) {
                            if (!firstGraphBuild) {
                                nodesPerGraph = errorNodes.slice(0, graphSplitThreshold);
                                firstGraphBuild = true;
                            } else {
                                if (nodes[graphSplitThreshold * i - 1] !== undefined) {
                                    nodesPerGraph = errorNodes.slice(graphSplitThreshold * (i - 1), graphSplitThreshold *
                                        i);
                                } else {
                                    nodesPerGraph = errorNodes.slice(graphSplitThreshold * (i - 1));
                                }
                            }
                            var graph = createGraph();
                            errorGraphMap.push(graph);
                            setGraphNodes(graph, nodesPerGraph);
                            var nodesIndices = []
                            nodesPerGraph.forEach(function (n) {
                                nodesIndices.push(n.index);
                            });
                            var graphEdges = errorEdges.filter(function (e) {
                                if (nodesIndices.includes(e.source) && nodesIndices.includes(e.target)) {
                                    return e;
                                }
                            });
                            setGraphEdges(graph, graphEdges, true);
                        }
                        buildCrossgraphEdges(errorEdges, true);
                    }

                    // Handle graph connecting edges
                    function buildCrossgraphEdges(edges, errorGraph) {
                        edges.forEach(function (edge) {
                            var sourceGraph, targetGraph;
                            if (errorGraph) {
                                sourceGraph = getGraphForErrorNode(edge.source);
                                targetGraph = getGraphForErrorNode(edge.target);
                                if (sourceGraph < targetGraph) {
                                    errorGraphMap[sourceGraph].setNode("" + edge.source + edge.target +
                                        sourceGraph, {
                                            label: "",
                                            class: "arg-dummy",
                                            id: "dummy-" + edge.target
                                        });
                                    errorGraphMap[sourceGraph].setEdge(edge.source, "" + edge.source + edge.target +
                                        sourceGraph, {
                                            label: edge.label,
                                            id: "arg-edge" + edge.source + edge.target,
                                            style: "stroke-dasharray: 5, 5;",
                                            class: edgeClassDecider(edge)
                                        });
                                    errorGraphMap[targetGraph].setNode("" + edge.target + edge.source +
                                        targetGraph, {
                                            label: "",
                                            class: "dummy"
                                        });
                                    errorGraphMap[targetGraph].setEdge("" + edge.target + edge.source +
                                        targetGraph, edge.target, {
                                            label: "",
                                            labelStyle: "font-size: 12px;",
                                            id: "arg-edge_" + edge.source + "-" + edge.target,
                                            style: "stroke-dasharray: 5, 5;",
                                            class: "arg-split-edge"
                                        });
                                } else if (sourceGraph > targetGraph) {
                                    errorGraphMap[sourceGraph].setNode("" + edge.source + edge.target +
                                        sourceGraph, {
                                            label: "",
                                            class: "arg-dummy",
                                            id: "dummy-" + edge.target
                                        });
                                    errorGraphMap[sourceGraph].setEdge(edge.source, "" + edge.source + edge.target +
                                        sourceGraph, {
                                            label: edge.label,
                                            id: "arg-edge" + edge.source + edge.target,
                                            arrowhead: "undirected",
                                            style: "stroke-dasharray: 5, 5;",
                                            class: edgeClassDecider(edge)
                                        })
                                    errorGraphMap[targetGraph].setNode("" + edge.target + edge.source +
                                        targetGraph, {
                                            label: "",
                                            class: "dummy"
                                        });
                                    errorGraphMap[targetGraph].setEdge("" + edge.target + edge.source +
                                        targetGraph, edge.target, {
                                            label: "",
                                            labelStyle: "font-size: 12px;",
                                            id: "arg-edge_" + edge.source + "-" + edge.target,
                                            arrowhead: "undirected",
                                            style: "stroke-dasharray: 5, 5;",
                                            class: "arg-split-edge"
                                        });
                                }
                            } else {
                                sourceGraph = getGraphForNode(edge.source);
                                targetGraph = getGraphForNode(edge.target);
                                if (sourceGraph < targetGraph) {
                                    graphMap[sourceGraph].setNode("" + edge.source + edge.target + sourceGraph, {
                                        label: "",
                                        class: "arg-dummy",
                                        id: "dummy-" + edge.target
                                    });
                                    graphMap[sourceGraph].setEdge(edge.source, "" + edge.source + edge.target +
                                        sourceGraph, {
                                            label: edge.label,
                                            id: "arg-edge" + edge.source + edge.target,
                                            style: "stroke-dasharray: 5, 5;",
                                            class: edgeClassDecider(edge)
                                        });
                                    graphMap[targetGraph].setNode("" + edge.target + edge.source + targetGraph, {
                                        label: "",
                                        class: "dummy"
                                    });
                                    graphMap[targetGraph].setEdge("" + edge.target + edge.source + targetGraph,
                                        edge.target, {
                                            label: "",
                                            labelStyle: "font-size: 12px;",
                                            id: "arg-edge_" + edge.source + "-" + edge.target,
                                            style: "stroke-dasharray: 5, 5;",
                                            class: "arg-split-edge"
                                        });
                                } else if (sourceGraph > targetGraph) {
                                    graphMap[sourceGraph].setNode("" + edge.source + edge.target + sourceGraph, {
                                        label: "",
                                        class: "arg-dummy",
                                        id: "dummy-" + edge.target
                                    });
                                    graphMap[sourceGraph].setEdge(edge.source, "" + edge.source + edge.target +
                                        sourceGraph, {
                                            label: edge.label,
                                            id: "arg-edge" + edge.source + edge.target,
                                            arrowhead: "undirected",
                                            style: "stroke-dasharray: 5, 5;",
                                            class: edgeClassDecider(edge)
                                        })
                                    graphMap[targetGraph].setNode("" + edge.target + edge.source + targetGraph, {
                                        label: "",
                                        class: "dummy"
                                    });
                                    graphMap[targetGraph].setEdge("" + edge.target + edge.source + targetGraph,
                                        edge.target, {
                                            label: "",
                                            labelStyle: "font-size: 12px;",
                                            id: "arg-edge_" + edge.source + "-" + edge.target,
                                            arrowhead: "undirected",
                                            style: "stroke-dasharray: 5, 5;",
                                            class: "arg-split-edge"
                                        });
                                }
                            }
                        });
                    }

                    // Return the graph in which the nodeNumber is present
                    function getGraphForNode(nodeNumber) {
                        return graphMap.findIndex(function (graph) {
                            return graph.nodes().includes("" + nodeNumber);
                        })
                    }

                    // Return the graph in which the nodeNumber is present for an error node
                    function getGraphForErrorNode(nodeNumber) {
                        return errorGraphMap.findIndex(function (graph) {
                            return graph.nodes().includes("" + nodeNumber);
                        })
                    }

                    // create and return a graph element with a set transition
                    function createGraph() {
                        var g = new dagreD3.graphlib.Graph().setGraph({}).setDefaultEdgeLabel(
                            function () {
                                return {};
                            });
                        return g;
                    }

                    // Set nodes for the graph contained in the json nodes
                    function setGraphNodes(graph, nodesToSet) {
                        nodesToSet.forEach(function (n) {
                            if (n.type === "target" && errorPath !== undefined && !errorPath.includes(n.index)) {
                                errorPath.push(n.index);
                            }
                            graph.setNode(n.index, {
                                label: n.label,
                                class: "arg-node " + n.type,
                                id: nodeIdDecider(n)
                            });
                        });
                    }

                    function nodeIdDecider(node) {
                        if (errorGraphMap === undefined)
                            return "arg-node" + node.index;
                        else
                            return "arg-error-node" + node.index;
                    }

                    // Set the graph edges 
                    function setGraphEdges(graph, edgesToSet, multigraph) {
                        edgesToSet.forEach(function (e) {
                            if (!multigraph || (graph.nodes().includes("" + e.source) && graph.nodes().includes(
                                    "" + e.target))) {
                                graph.setEdge(e.source, e.target, {
                                    label: e.label,
                                    lineInterpolate: "basis",
                                    class: edgeClassDecider(e),
                                    id: "arg-edge" + e.source + e.target,
                                    weight: edgeWeightDecider(e)
                                });
                            }
                        });
                    }

                    // Set class for passed edge
                    function edgeClassDecider(edge) {
                        if (errorPath !== undefined && errorPath.includes(edge.source) && errorPath.includes(edge.target)) {
                            return "arg-edge error-edge";
                        } else {
                            return "arg-edge";
                        }
                    }

                    // Decide the weight for the edges based on type
                    function edgeWeightDecider(edge) {
                        if (edge.type === "covered") return 0;
                        return 1;
                    }

                }
            }

            // ======================= Create CFA and ARG Worker Listeners =======================
            /**
             * Create workers using blobs due to Chrome's default security policy and 
             * the need of having a single file at the end that can be send i.e. via e-mail
             */
            cfaWorker = new Worker(URL.createObjectURL(new Blob(["(" + cfaWorker_function + ")()"], {
                type: 'text/javascript'
            })));
            if (argJson.nodes) {
                argWorker = new Worker(URL.createObjectURL(new Blob(["(" + argWorker_function + ")()"], {
                    type: "text/javascript"
                })));
            }

            cfaWorker.addEventListener("message", function (m) {
                if (m.data.graph !== undefined) {
                    // id was already processed
                    if (!d3.select("#cfa-graph-" + m.data.id).empty()) {
                        cfaWorker.postMessage({
                            "renderer": "ready"
                        });
                        return;
                    }
                    var id = m.data.id;
                    d3.select("#cfa-container").append("div").attr("id", "cfa-graph-" + id).attr("class",
                        "cfa-graph");
                    var g = createGraph();
                    g = Object.assign(g, JSON.parse(m.data.graph));
                    var svg = d3.select("#cfa-graph-" + id).append("svg").attr("id", "cfa-svg-" + id).attr(
                        "class", "cfa-svg " + "cfa-svg-" + m.data.func);
                    var svgGroup = svg.append("g");
                    render(d3.select("#cfa-svg-" + id + " g"), g);
                    // Center the graph - calculate svg.attributes
                    svg.attr("height", g.graph().height + margin * 2);
                    svg.attr("width", g.graph().width + margin * 10);
                    svgGroup.attr("transform", "translate(" + margin * 2 + ", " + margin + ")");
                    $("#cfa-modal").text(parseInt($("#cfa-modal").text().split("/")[0]) + 1 + "/" + $(
                        "#cfa-modal").text().split("/")[1]);
                    cfaWorker.postMessage({
                        "renderer": "ready"
                    });
                } else if (m.data.status !== undefined) {
                    addEventsToCfa();
                    d3.select("#cfa-toolbar").style("visibility", "visible");
                    d3.select("#cfa-container").classed("cfa-content", true);
                    d3.selectAll(".cfa-svg").each(function (d, i) {
                        d3.select(this).attr("width", Math.max(d3.select(this).attr("width"), d3.select(
                            this.parentNode).style("width").split("px")[0]));
                    });
                    d3.selectAll(".cfa-graph").style("visibility", "visible");
                    if (cfaSplit) {
                        $("#renderStateModal").hide();
                        $('.modal-backdrop').hide();
                    } else {
                        if (!argTabDisabled) {
                            argWorker.postMessage({
                                "renderer": "ready"
                            });
                        } else {
                            $("#renderStateModal").hide();
                            $('.modal-backdrop').hide();
                        }
                    }
                }
            }, false);

            cfaWorker.addEventListener("error", function (e) {
                alert("CFA Worker failed in line " + e.lineno + " with message " + e.message)
            }, false);

            // Initial postMessage to the CFA worker to trigger CFA graph(s) creation
            cfaWorker.postMessage({
                "json": JSON.stringify(cfaJson)
            });

            // ONLY if ARG data is available
            if (argJson.nodes) {
                argWorker.addEventListener('message', function (m) {
                    if (m.data.graph !== undefined) {
                        var id = "arg-graph" + m.data.id;
                        var argClass = "arg-graph";
                        if (m.data.errorGraph !== undefined) {
                            id = "arg-error-graph" + m.data.id;
                            argClass = "arg-error-graph";
                            d3.select("#arg-modal-error").style("display", "inline");
                            $("#renderStateModal").modal("show");
                        }
                        var g = createGraph();
                        g = Object.assign(g, JSON.parse(m.data.graph));
                        d3.select("#arg-container").append("div").attr("id", id).attr("class", argClass);
                        var svg = d3.select("#" + id).append("svg").attr("id", "arg-svg" + id).attr("class",
                            "arg-svg");
                        var svgGroup = svg.append("g");
                        render(d3.select("#arg-svg" + id + " g"), g);
                        // Center the graph - calculate svg.attributes
                        svg.attr("height", g.graph().height + margin * 2);
                        svg.attr("width", g.graph().width + margin * 10);
                        svgGroup.attr("transform", "translate(" + margin * 2 + ", " + margin + ")");
                        // FIXME: until https://github.com/cpettitt/dagre-d3/issues/169 is not resolved, label centering like so:
                        d3.selectAll(".arg-node tspan").each(function (d, i) {
                            var transformation = d3.select(this.parentNode.parentNode).attr("transform")
                            d3.select(this).attr("dx", Math.abs(getTransformation(transformation).translateX));
                        })
                        if (m.data.errorGraph !== undefined) {
                            addEventsToArg();
                            $("#renderStateModal").hide();
                            $('.modal-backdrop').hide();
                            argWorker.postMessage({
                                "errorGraph": true
                            });
                        } else {
                            $("#arg-modal").text(parseInt($("#arg-modal").text().split("/")[0]) + 1 + "/" + $(
                                "#arg-modal").text().split("/")[1]);
                            argWorker.postMessage({
                                "renderer": "ready"
                            });
                        }
                    } else if (m.data.status !== undefined) {
                        if ($("#report-controller").scope().getTabSet() === 2) {
                            d3.select("#arg-toolbar").style("visibility", "visible");
                            d3.select("#arg-container").classed("arg-content", true);
                            d3.selectAll(".arg-graph").style("visibility", "visible");
                            $("#arg-container").scrollLeft(d3.select(".arg-svg").attr("width") / 4);
                        }
                        addEventsToArg();
                        if (errorPath !== undefined) {
                            d3.selectAll("td.disabled").classed("disabled", false);
                            if (!d3.select(".make-pretty").classed("prettyprint")) {
                                d3.selectAll(".make-pretty").classed("prettyprint", true);
                                PR.prettyPrint();
                            }
                        }
                        $("#renderStateModal").hide();
                        $('.modal-backdrop').hide();
                    }
                }, false);

                argWorker.addEventListener("error", function (e) {
                    alert("ARG Worker failed in line " + e.lineno + " with message " + e.message)
                }, false);

                // Initial postMessage to the ARG worker to trigger ARG graph(s) creation
                if (errorPath !== undefined) {
                    argWorker.postMessage({
                        "errorPath": JSON.stringify(errorPath)
                    });
                }
                argWorker.postMessage({
                    "json": JSON.stringify(argJson)
                });
            }

            // Function to get transfromation thorugh translate as in new version of D3.js d3.transfrom is removed 
            function getTransformation(transform) {
                // Create a dummy g for calculation purposes only. This will never
                // be appended to the DOM and will be discarded once this function 
                // returns.
                var g = document.createElementNS("http://www.w3.org/2000/svg", "g");

                // Set the transform attribute to the provided string value.
                g.setAttributeNS(null, "transform", transform);

                // consolidate the SVGTransformList containing all transformations
                // to a single SVGTransform of type SVG_TRANSFORM_MATRIX and get
                // its SVGMatrix. 
                var matrix = g.transform.baseVal.consolidate().matrix;

                // Below calculations are taken and adapted from the private function
                // transform/decompose.js of D3's module d3-interpolate.
                // var {
                // 	a,
                // 	b,
                // 	c,
                // 	d,
                // 	e,
                // 	f
                // } = matrix; // ES6, if this doesn't work, use below assignment
                var a = matrix.a,
                    b = matrix.b,
                    c = matrix.c,
                    d = matrix.d,
                    e = matrix.e,
                    f = matrix.f; // ES5
                var scaleX, scaleY, skewX;
                if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
                if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
                if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
                if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
                return {
                    translateX: e,
                    translateY: f,
                    rotate: Math.atan2(b, a) * 180 / Math.PI,
                    skewX: Math.atan(skewX) * 180 / Math.PI,
                    scaleX: scaleX,
                    scaleY: scaleY
                };
            }

            // create and return a graph element with a set transition
            function createGraph() {
                var g = new dagreD3.graphlib.Graph().setGraph({}).setDefaultEdgeLabel(
                    function () {
                        return {};
                    });
                return g;
            }

            // Retrieve the node in which this node was merged - used for the node events
            // FIXME: this is a duplicate function already contained in error path controller, currently no better way to call it
            function getMergingNode(index) {
                var result = "";
                Object.keys(cfaJson.combinedNodes).some(function (key) {
                    if (cfaJson.combinedNodes[key].includes(index)) {
                        result = key;
                        return result;
                    }
                })
                return result;
            }

            // Add desired events to CFA nodes and edges
            function addEventsToCfa() {
                addPanEvent(".cfa-svg");
                d3.selectAll(".cfa-node").on("mouseover", function (d) {
                    var message;
                    if (parseInt(d) > 100000) {
                        message = "<span class=\" bold \">type</span>: function call node <br>" +
                            "<span class=\" bold \">dblclick</span>: Select function";
                    } else {
                        var node = cfaJson.nodes.find(function (n) {
                            return n.index === parseInt(d);
                        });
                        message = "<span class=\" bold \">function</span>: " + node.func;
                        if (d in cfaJson.combinedNodes) {
                            message += "<br><span class=\" bold \">combines nodes</span> : " + Math.min.apply(
                                null, cfaJson.combinedNodes[d]) + "-" + Math.max.apply(null, cfaJson.combinedNodes[
                                d]);
                        }
                        message += "<br> <span class=\" bold \">reverse postorder Id</span>: " + node.rpid;
                    }
                    showToolTipBox(d3.event, message);
                }).on("mouseout", function () {
                    hideToolTipBox();
                });
                d3.selectAll(".fcall").on("dblclick", function (d) {
                    $("#cfa-toolbar").scope().selectedCFAFunction = d3.select("#cfa-node" + d + " text").text();
                    $("#cfa-toolbar").scope().setCFAFunction();
                });
                d3.selectAll(".cfa-dummy").on("mouseover", function (d) {
                    showToolTipBox(d3.event,
                        "<span class=\" bold \">type</span>: placeholder <br> <span class=\" bold \">dblclick</span>: jump to Target node"
                    );
                }).on("mouseout", function () {
                    hideToolTipBox();
                }).on("dblclick", function () {
                    if (!d3.select(".marked-cfa-node").empty()) {
                        d3.select(".marked-cfa-node").classed("marked-cfa-node", false);
                    }
                    var selection = d3.select("#cfa-node" + d3.select(this).attr("id").split("-")[1]);
                    selection.classed("marked-cfa-node", true);
                    var boundingRect = selection.node().getBoundingClientRect();
                    $("#cfa-container").scrollTop(boundingRect.top + $("#cfa-container").scrollTop() - 200).scrollLeft(
                        boundingRect.left + $("#cfa-container").scrollLeft() - $("#errorpath_section").width() -
                        2 * boundingRect.width);
                })
                d3.selectAll(".cfa-edge")
                    .on("mouseover", function (d) {
                        d3.select(this).select("path").style("stroke-width", "3px");
                        showToolTipBox(d3.event, "<span class=\" bold \">dblclick</span>: jump to Source line");
                    }).on("mouseout", function () {
                        d3.select(this).select("path").style("stroke-width", "1.5px");
                        hideToolTipBox();
                    }).on("dblclick", function (d) {
                        var edge = findCfaEdge(d);
                        if (edge === undefined) { // this occurs for edges between graphs - splitting edges
                            var thisEdgeData = d3.select(this).attr("id").split("_")[1];
                            edge = findCfaEdge({
                                v: thisEdgeData.split("-")[0],
                                w: thisEdgeData.split("-")[1]
                            })
                        }
                        $("#set-tab-3").click();
                        var line = edge.line;
                        if (line === 0) {
                            line = 1;
                        }
                        if (!d3.select(".marked-source-line").empty()) {
                            d3.select(".marked-source-line").classed("marked-source-line", false);
                        }
                        var selection = d3.select("#source-" + line + " td pre.prettyprint");
                        selection.classed("marked-source-line", true);
                        $(".sourceContent").scrollTop(selection.node().getBoundingClientRect().top + $(
                            ".sourceContent").scrollTop() - 200);
                    });
                d3.selectAll(".cfa-split-edge")
                    .on("mouseover", function (d) {
                        d3.select(this).select("path").style("stroke-width", "3px");
                        showToolTipBox(d3.event,
                            "<span class=\" bold \">type</span>: place holder <br> <span class=\" bold \">dblclick</span>: jump to Original edge"
                        );
                    }).on("mouseout", function () {
                        d3.select(this).select("path").style("stroke-width", "1.5px");
                        hideToolTipBox();
                    }).on("dblclick", function () {
                        var edgeSourceTarget = d3.select(this).attr("id").split("_")[1];
                        if (!d3.select(".marked-cfa-edge").empty()) {
                            d3.select(".marked-cfa-edge").classed("marked-cfa-edge", false);
                        }
                        var selection = d3.select("#cfa-edge_" + edgeSourceTarget.split("-")[0] + "-" +
                            edgeSourceTarget.split("-")[1]);
                        selection.classed("marked-cfa-edge", true);
                        var boundingRect = selection.node().getBoundingClientRect();
                        $("#cfa-container").scrollTop(boundingRect.top + $("#cfa-container").scrollTop() - 200).scrollLeft(
                            boundingRect.left + $("#cfa-container").scrollLeft() - $("#errorpath_section").width() -
                            2 * boundingRect.width);
                    })
            }

            // Find and return the actual edge element from cfaJson.edges array by considering funcCallEdges and combinedNodes
            function findCfaEdge(eventElement) {
                var source = parseInt(eventElement.v);
                var target = parseInt(eventElement.w);
                if (source > 100000) {
                    source = Object.keys(cfaJson.functionCallEdges).find(function (key) {
                        if (cfaJson.functionCallEdges[key].includes(source)) {
                            return key;
                        }
                    });
                }
                if (target > 100000) {
                    target = cfaJson.functionCallEdges[eventElement.v][1];
                }
                if (source in cfaJson.combinedNodes) {
                    source = cfaJson.combinedNodes[source][cfaJson.combinedNodes[source].length - 1];
                }
                return cfaJson.edges.find(function (e) {
                    return e.source === parseInt(source) && e.target === target;
                })
            }

            // Add desired events to ARG the nodes
            function addEventsToArg() {
                addPanEvent(".arg-svg");
                d3.selectAll(".arg-node")
                    .on("mouseover", function (d) {
                        var node = argJson.nodes.find(function (it) {
                            return it.index === parseInt(d);
                        })
                        var message = "<span class=\" bold \">function</span>: " + node.func + "<br>";
                        if (node.type) {
                            message += "<span class=\" bold \">type</span>: " + node.type + "<br>";
                        }
                        message += "<span class=\" bold \">dblclick</span>: jump to CFA node";
                        showToolTipBox(d3.event, message);
                    }).on("mouseout", function () {
                        hideToolTipBox();
                    }).on("dblclick", function () {
                        $("#set-tab-1").click();
                        if (!d3.select(".marked-cfa-node").empty()) {
                            d3.select(".marked-cfa-node").classed("marked-cfa-node", false);
                        }
                        var nodeId = d3.select(this).select("tspan").text().split("N")[1];
                        if (cfaJson.mergedNodes.includes(parseInt(nodeId))) {
                            nodeId = getMergingNode(parseInt(nodeId));
                        }
                        var selection = d3.select("#cfa-node" + nodeId);
                        selection.classed("marked-cfa-node", true);
                        var boundingRect = selection.node().getBoundingClientRect();
                        $("#cfa-container").scrollTop(boundingRect.top + $("#cfa-container").scrollTop() - 200).scrollLeft(
                            boundingRect.left + $("#cfa-container").scrollLeft() - $("#errorpath_section").width() -
                            2 * boundingRect.width);
                    });
                d3.selectAll(".arg-dummy")
                    .on("mouseover", function (d) {
                        showToolTipBox(d3.event,
                            "<span class=\" bold \">type</span>: placeholder <br> <span class=\" bold \">dblclick</span>: jump to Target node"
                        );
                    }).on("mouseout", function () {
                        hideToolTipBox();
                    }).on("dblclick", function () {
                        if (!d3.select(".marked-arg-node").empty()) {
                            d3.select(".marked-arg-node").classed("marked-arg-node", false);
                        }
                        var selection = d3.select("#arg-node" + d3.select(this).attr("id").split("-")[1]);
                        selection.classed("marked-arg-node", true);
                        var boundingRect = selection.node().getBoundingClientRect();
                        $("#arg-container").scrollTop(boundingRect.top + $("#arg-container").scrollTop() - 200).scrollLeft(
                            boundingRect.left + $("#arg-container").scrollLeft() - $("#errorpath_section").width() -
                            2 * boundingRect.width);
                    });
                d3.selectAll(".arg-edge")
                    .on("mouseover", function (d) {
                        d3.select(this).select("path").style("stroke-width", "3px");
                        var edge = argJson.edges.find(function (it) {
                            return it.source === parseInt(d.v) && it.target === parseInt(d.w);
                        })
                        if (edge) {
                            showToolTipBox(d3.event, "<span class=\" bold \">type</span>: " + edge.type);
                        } else {
                            showToolTipBox(d3.event, "<span class=\" bold \">type</span>: graph connecting edge")
                        }
                    }).on("mouseout", function () {
                        d3.select(this).select("path").style("stroke-width", "1.5px");
                        hideToolTipBox();
                    });
                d3.selectAll(".arg-split-edge")
                    .on("mouseover", function (d) {
                        d3.select(this).select("path").style("stroke-width", "3px");
                        showToolTipBox(d3.event,
                            "<span class=\" bold \">type</span>: place holder <br> <span class=\" bold \">dblclick</span>: jump to Original edge"
                        );
                    }).on("mouseout", function () {
                        d3.select(this).select("path").style("stroke-width", "1.5px");
                        hideToolTipBox();
                    }).on("dblclick", function () {
                        var edgeSourceTarget = d3.select(this).attr("id").split("_")[1];
                        if (!d3.select(".marked-arg-edge").empty()) {
                            d3.select(".marked-arg-edge").classed("marked-arg-edge", false);
                        }
                        var selection = d3.select("#arg-edge" + edgeSourceTarget.split("-")[0] + edgeSourceTarget.split(
                            "-")[1]);
                        selection.classed("marked-arg-edge", true);
                        var boundingRect = selection.node().getBoundingClientRect();
                        $("#arg-container").scrollTop(boundingRect.top + $("#arg-container").scrollTop() - 200).scrollLeft(
                            boundingRect.left + $("#arg-container").scrollLeft() - $("#errorpath_section").width() -
                            2 * boundingRect.width);
                    });
            }

            // Use D3 zoom behavior to add pan event
            function addPanEvent(itemsToSelect) {
                d3.selectAll(itemsToSelect).each(function (d, i) {
                    var svg = d3.select(this),
                        svgGroup = d3.select(this.firstChild);
                    var zoom = d3.zoom().on("zoom", function () {
                        svgGroup.attr("transform", d3.event.transform)
                    });
                    svg.call(zoom);
                    svg.on("zoom", null).on("wheel.zoom", null).on("dblclick.zoom", null).on("touchstart.zoom",
                        null);
                });
            }

            // On mouse over display tool tip box
            function showToolTipBox(e, displayInfo) {
                var offsetX = 20;
                var offsetY = 0;
                var positionX = e.pageX;
                var positionY = e.pageY;
                d3.select("#boxContent").html("<p>" + displayInfo + "</p>");
                d3.select("#infoBox").style("left", function () {
                    return positionX + offsetX + "px";
                }).style("top", function () {
                    return positionY + offsetY + "px";
                }).style("visibility", "visible");
            }

            // On mouse out hide the tool tip box
            function hideToolTipBox() {
                d3.select("#infoBox").style("visibility", "hidden");
            }

        }
    </script> -->
</head>

<body ng-controller="ReportController" id="report-controller" onload="init()">
    <header class="header">
        <a href="https://cpachecker.sosy-lab.org/">
            <img class="logo" ng-src="{{logo}}" />
        </a>
        <h1>
            Report for test/programs/simple/SSAMap-bug_false-unreach-label.c (Counterexample 1) </h1>
        <span class="badge badge-info generated">
            Generated on 2018-07-03 10:26:20 by CPAchecker (unknown version) </span>
    </header>

    <div class="modal fade" id="renderStateModal" role="dialog" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h4 class="modal-title text-center">Graphs Rendering Progress</h4>
                </div>
                <div class="modal-body">
                    <p class="loader">Rendered CFA graphs : &nbsp;
                        <span id="cfa-modal"></span>
                    </p>
                    <p class="loader">Rendered ARG graphs : &nbsp;
                        <span id="arg-modal"></span>
                    </p>
                    <p id="arg-modal-error" class="loader" style="display: none;"> Render ARG Error Graph </p>
                </div>
            </div>
        </div>
    </div>

    <div class="sections">

        <section id="errorpath_section" ng-controller="ErrorpathController">
            <header ng-controller="SearchController" class="text-center">
                <div class="btn-group" role="group" aria-label="Button group">
                    <button class="btn btn-success" ng-click="errPathPrevClicked($event)" data-toggle="tooltip" data-placement="top" title="Click here to move on Previous Line">Prev</button>
                    <button class="btn btn-warning" ng-click="errPathStartClicked()">Start</button>
                    <button class="btn btn-success" ng-click="errPathNextClicked($event)" data-toggle="tooltip" data-placement="bottom" title="Click here to move on Next Line">Next</button>
                </div>
                <div class="help_button" data-toggle="tooltip" data-placement="top" title="Get help!">
                    <a tabindex="0" role="button" data-container="body" data-toggle="popover" data-html="true" data-placement="right" data-trigger="focus"
                        data-content="{{help_errorpath}}" class="btn btn-outline-info btn-lg help_button">
                        <i class="fas fa-question-circle"></i>
                    </a>
                </div>
                <div class="input-group input-group-sm">
                    <input type="text" ng-keydown="checkIfEnter($event)" class="form-control search-input" placeholder="Search for...">
                    <span class="input-group-btn">
                        <button ng-click="searchFor()" class="btn btn-light" type="button">
                            <i class="fas fa-search"></i>
                        </button>
                    </span>
                </div>
                <div id="searchOptions">
                    <label for="optionExactMatch">
                        <input id="optionExactMatch" type="checkbox" name="searchOption">
                        <strong>Find only exact matches</strong>
                    </label>
                </div>
                <div id="matches">
                    <p class="markedValues">Matches in value-assignements (V): {{numOfValueMatches}}</p>
                    <p class="markedDescriptions">Matches in edge-description: {{numOfDescriptionMatches}}</p>
                </div>
            </header>
            <div class="fileContent" ng-controller="ValueAssignmentsController" id="value-assignment">
                <table id="err-table">
                    <tr id="errpath-{{$index}}" ng-repeat="line in errorPath">
                        <td ng-click="showValues($event)" data-toggle="popover" data-placement="right" data-trigger="click" data-content="{{line.valString}}">
                            <pre>-V-</pre>
                        </td>
                        <td class="disabled" ng-click="clickedErrpathElement($event)">
                            <pre class="make-pretty">{{line.desc}}</pre>
                        </td>
                    </tr>
                </table>
            </div>
        </section>

        <section id="externalFiles_section">

            <ul class="nav nav-pills nav-tabs">
                <li class="nav-item" id="toggle_button_error_path">
                    <label class="switch" style="margin-top:5px" data-toggle="tooltip" data-placement="bottom" title="Toggle slider to show/hide error path section">
                        <input type="checkbox" checked id="toggle_error_path" ng-click="toggleErrorPathSection($event)">
                        <span class="slider round"></span>
                    </label>
                    <li class="nav-item" style="padding:10px;" id="toggle_button_error_path_placeholder">
                        <span class="badge badge-warning" style="font-size: 1.1em" data-toggle="tooltip" data-placement="top" title="Toggle slider to show/hide error path section">Show Error Path Section</span>
                    </li>
                </li>
                <li class="nav-item" ng-class="{active: tabIsSet(1)}" data-toggle="tooltip" data-placement="top" title="Shows CFA (Control flow Automation) of the Program">
                    <a class="nav-link active" data-toggle="pill" href ng-click="setTab(1)" id="set-tab-1">CFA</a>
                </li>
                <li class="nav-item" ng-class="{active: tabIsSet(2)}" data-toggle="tooltip" data-placement="top" title="Shows ARG (Abstract Reachability Graph) of the Program">
                    <a class="nav-link" data-toggle="pill" href ng-click="setTab(2)" id="set-tab-2">ARG</a>
                </li>
                <li class="nav-item" ng-class="{active: tabIsSet(3)}" data-toggle="tooltip" data-placement="top" title="Click here for source code of the program">
                    <a class="nav-link" data-toggle="pill" href ng-click="setTab(3)" id="set-tab-3">Source</a>
                </li>
                <li class="nav-item" ng-class="{active: tabIsSet(4)}">
                    <a class="nav-link" data-toggle="pill" href ng-click="setTab(4)">Log</a>
                </li>
                <li class="nav-item" ng-class="{active: tabIsSet(5)}">
                    <a class="nav-link" data-toggle="pill" href ng-click="setTab(5)">Statistics</a>
                </li>
                <li class="nav-item" ng-class="{active: tabIsSet(6)}">
                    <a class="nav-link" data-toggle="pill" href ng-click="setTab(6)">Configurations</a>
                </li>
                <div>
                    <button id="full_screen_mode" class="btn btn-outline-info btn-lg help_button" ng-click="makeFullScreen()">
                        <i class="fas fa-expand"></i> Full Screen Mode</button>
                </div>
                <div class="help_button" data-toggle="tooltip" data-placement="top" title="Get help!">
                    <a tabindex="0" role="button" data-container="body" data-toggle="popover" data-html="true" data-placement="bottom" data-trigger="focus"
                        data-content="{{help_content}}" class="btn btn-outline-info btn-lg help_button">
                        <i class="fas fa-question-circle"></i>
                    </a>
                </div>
            </ul>

            <div id="cfa-toolbar" ng-controller="CFAToolbarController">
                <nav class="navbar navbar-light bg-light">
                    <div class="nav-item">
                        <label>
                            <strong>Displayed CFA</strong>
                        </label>
                        <select class="btn btn-outline-secondary selectpicker" ng-options="f as f for f in functions" ng-model="selectedCFAFunction"
                            ng-change="setCFAFunction()">
                        </select>
                    </div>
                    <div class="nav-item">
                        <label>
                            <strong>Mouse Wheel Zoom</strong>
                        </label>
                        <span class="button-checkbox">
                            <button class="btn btn-outline-secondary" id="cfa-zoom-button" type="button" data-color="primary" ng-click="zoomControl()">
                                <i class="far fa-square"></i>
                            </button>
                        </span>
                    </div>
                    <div class="nav-item">
                        <label>
                            <strong>Split Threshold</strong>
                        </label>
                        <input type="text" aria-label="Split Threshold" id="cfa-split-threshold">
                        <button class="btn btn-outline-secondary" type="button" ng-click="redraw()" data-toggle="tooltip" data-placement="top" title="Refresh Split Threshold">
                            <i class="fas fa-sync"></i>
                        </button>
                    </div>
                    </ul>
                </nav>
            </div>

            <div id="cfa-container" ng-class="{active: tabIsSet(1)}">
            </div>

            <div id="arg-toolbar" ng-controller="ARGToolbarController">
                <nav class="navbar navbar-light bg-light">
                    <div class="nav-item">
                        <label>
                            <strong>Displayed ARG</strong>
                        </label>
                        <select class="btn btn-outline-secondary selectpicker" ng-options="s as s for s in argSelections" ng-model="$root.displayedARG"
                            ng-change="displayARG()"></select>
                        <label>
                    </div>
                    <div class="nav-item">
                        <strong>Mouse Wheel Zoom</strong>
                        </label>
                        <span class="button-checkbox">
                            <button class="btn btn-outline-secondary" id="arg-zoom-button" type="button" data-color="primary" ng-click="argZoomControl()">
                                <i class="far fa-square"></i>
                            </button>
                        </span>
                    </div>
                    <div class="nav-item">
                        <label>
                            <strong>Split Threshold</strong>
                        </label>
                        <input type="text" aria-label="Split Threshold" id="arg-split-threshold">
                        <button class="btn btn-outline-secondary" type="button" ng-click="argRedraw()" data-toggle="tooltip" data-placement="top"
                            title="Refresh Split Threshold">
                            <i class="fas fa-sync"></i>
                        </button>
                    </div>
                </nav>
            </div>

            <div id="arg-container" ng-class="{active: tabIsSet(2)}">
            </div>

            <div class="fileContent content" ng-show="tabIsSet(3)" ng-class="{active: tabIsSet(3)}" ng-controller="SourceController">
                <div class="edit-line">
                    <div class="dropdown" id="dropdownMenu2">
                        <button class="btn btn-outline-secondary dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">
                            Displayed Sourcefile
                            <span class="caret"></span>
                        </button>
                        <ul class="dropdown-menu pre-scrollable">
                            <li ng-repeat="file in sourceFiles">
                                <a ng-click="setSourceFile($index)">{{file}}</a>
                            </li>
                        </ul>
                    </div>
                    <label>
                        <strong>{{sourceFiles[selectedSourceFile]}}</strong>
                    </label>
                </div>
                <div class="sourceContent content" ng-show="sourceFileIsSet(0)">
                    <table>
                        <tr id="source-1">
                            <td>
                                <pre>1</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">extern int __VERIFIER_nondet_int();  </pre>
                            </td>
                        </tr>
                        <tr id="source-2">
                            <td>
                                <pre>2</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">extern int *__VERIFIER_nondet_pointer();  </pre>
                            </td>
                        </tr>
                        <tr id="source-3">
                            <td>
                                <pre>3</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">  </pre>
                            </td>
                        </tr>
                        <tr id="source-4">
                            <td>
                                <pre>4</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">void  __Main(int flag)  </pre>
                            </td>
                        </tr>
                        <tr id="source-5">
                            <td>
                                <pre>5</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">{  </pre>
                            </td>
                        </tr>
                        <tr id="source-6">
                            <td>
                                <pre>6</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">	int *p1 = 0, *p2;  </pre>
                            </td>
                        </tr>
                        <tr id="source-7">
                            <td>
                                <pre>7</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">	if (flag) {  </pre>
                            </td>
                        </tr>
                        <tr id="source-8">
                            <td>
                                <pre>8</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">		if (__VERIFIER_nondet_int()) {  </pre>
                            </td>
                        </tr>
                        <tr id="source-9">
                            <td>
                                <pre>9</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">                        p2 = p1;  </pre>
                            </td>
                        </tr>
                        <tr id="source-10">
                            <td>
                                <pre>10</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">			p1 = 0;  </pre>
                            </td>
                        </tr>
                        <tr id="source-11">
                            <td>
                                <pre>11</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">		} else {  </pre>
                            </td>
                        </tr>
                        <tr id="source-12">
                            <td>
                                <pre>12</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">			p1 = 0;  </pre>
                            </td>
                        </tr>
                        <tr id="source-13">
                            <td>
                                <pre>13</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">		}  </pre>
                            </td>
                        </tr>
                        <tr id="source-14">
                            <td>
                                <pre>14</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">	} else {  </pre>
                            </td>
                        </tr>
                        <tr id="source-15">
                            <td>
                                <pre>15</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">		p1 = __VERIFIER_nondet_pointer();  </pre>
                            </td>
                        </tr>
                        <tr id="source-16">
                            <td>
                                <pre>16</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">	}  </pre>
                            </td>
                        </tr>
                        <tr id="source-17">
                            <td>
                                <pre>17</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">	p2 = __VERIFIER_nondet_pointer();  </pre>
                            </td>
                        </tr>
                        <tr id="source-18">
                            <td>
                                <pre>18</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">        if (p1 != p2)  {  </pre>
                            </td>
                        </tr>
                        <tr id="source-19">
                            <td>
                                <pre>19</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">	ERROR: goto ERROR;	  </pre>
                            </td>
                        </tr>
                        <tr id="source-20">
                            <td>
                                <pre>20</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">	}	  </pre>
                            </td>
                        </tr>
                        <tr id="source-21">
                            <td>
                                <pre>21</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">}  </pre>
                            </td>
                        </tr>
                        <tr id="source-22">
                            <td>
                                <pre>22</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">  </pre>
                            </td>
                        </tr>
                        <tr id="source-23">
                            <td>
                                <pre>23</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">int main() {  </pre>
                            </td>
                        </tr>
                        <tr id="source-24">
                            <td>
                                <pre>24</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">	__Main(0);  </pre>
                            </td>
                        </tr>
                        <tr id="source-25">
                            <td>
                                <pre>25</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">	return 0;  </pre>
                            </td>
                        </tr>
                        <tr id="source-26">
                            <td>
                                <pre>26</pre>
                            </td>
                            <td>
                                <pre class="prettyprint">}  </pre>
                            </td>
                        </tr>
                    </table>
                </div>
            </div>
            <div class="fileContent content" ng-show="tabIsSet(4)" ng-class="{active: tabIsSet(4)}">
                <table id="log_table" class="display" style="width:100%;padding: 10px" class="table table-bordered">
                    <thead class="thead-light">
                        <tr>
                            <th scope="col">Date</th>
                            <th scope="col">Time</th>
                            <th scope="col">Log Level</th>
                            <th scope="col">Log Info</th>
                            <th scope="col">Log Message</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr id="log-0">
                            <th scope="row">2018-07-03</th>
                            <td>10:26:16:697</td>
                            <td>INFO</td>
                            <td>ResourceLimitChecker.fromConfiguration</td>
                            <td>Using the following resource limits: CPU-time limit of 900s</td>
                        </tr>
                        <tr id="log-2">
                            <th scope="row">2018-07-03</th>
                            <td>10:26:16:818</td>
                            <td>INFO</td>
                            <td>CPAchecker.run</td>
                            <td>CPAchecker (unknown version) (OpenJDK 64-Bit Server VM 1.8.0_171) started</td>
                        </tr>
                        <tr id="log-4">
                            <th scope="row">2018-07-03</th>
                            <td>10:26:19:373</td>
                            <td>WARNING</td>
                            <td>PredicateCPA:JavaSMT:Mathsat5SolverContext.&lt;init&gt;</td>
                            <td>MathSAT5 is available for research and evaluation purposes only. It can not be used in a commercial
                                environment, particularly as part of a commercial product, without written permission. MathSAT5
                                is provided as is, without any warranty. Please write to mathsat@fbk.eu for additional questions
                                regarding licensing MathSAT5 or obtaining more up-to-date versions.</td>
                        </tr>
                        <tr id="log-6">
                            <th scope="row">2018-07-03</th>
                            <td>10:26:19:572</td>
                            <td>INFO</td>
                            <td>PredicateCPA:PredicateCPA.&lt;init&gt;</td>
                            <td>Using predicate analysis with MathSAT5 version 5.5.2 (850e644d5107) (May 22 2018 13:53:37, gmp
                                6.1.0, gcc 4.8.5, 64-bit, reentrant) and JFactory 1.21.</td>
                        </tr>
                        <tr id="log-8">
                            <th scope="row">2018-07-03</th>
                            <td>10:26:19:710</td>
                            <td>WARNING</td>
                            <td>ARGCPA:JavaSMT:Mathsat5SolverContext.&lt;init&gt;</td>
                            <td>MathSAT5 is available for research and evaluation purposes only. It can not be used in a commercial
                                environment, particularly as part of a commercial product, without written permission. MathSAT5
                                is provided as is, without any warranty. Please write to mathsat@fbk.eu for additional questions
                                regarding licensing MathSAT5 or obtaining more up-to-date versions.</td>
                        </tr>
                        <tr id="log-10">
                            <th scope="row">2018-07-03</th>
                            <td>10:26:19:734</td>
                            <td>WARNING</td>
                            <td>ARGCPA:JavaSMT:Mathsat5SolverContext.&lt;init&gt;</td>
                            <td>MathSAT5 is available for research and evaluation purposes only. It can not be used in a commercial
                                environment, particularly as part of a commercial product, without written permission. MathSAT5
                                is provided as is, without any warranty. Please write to mathsat@fbk.eu for additional questions
                                regarding licensing MathSAT5 or obtaining more up-to-date versions.</td>
                        </tr>
                        <tr id="log-12">
                            <th scope="row">2018-07-03</th>
                            <td>10:26:19:953</td>
                            <td>INFO</td>
                            <td>PredicateCPA:PredicateCPARefiner.&lt;init&gt;</td>
                            <td>Using refinement for predicate analysis with PredicateAbstractionRefinementStrategy strategy.</td>
                        </tr>
                        <tr id="log-14">
                            <th scope="row">2018-07-03</th>
                            <td>10:26:19:986</td>
                            <td>INFO</td>
                            <td>CPAchecker.runAlgorithm</td>
                            <td>Starting analysis ...</td>
                        </tr>
                        <tr id="log-16">
                            <th scope="row">2018-07-03</th>
                            <td>10:26:20:296</td>
                            <td>INFO</td>
                            <td>CPAchecker.runAlgorithm</td>
                            <td>Stopping analysis ...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="fileContent content" ng-show="tabIsSet(5)" ng-class="{active: tabIsSet(5)}">
                <table id="statistics_table" class="display" style="width:100%;padding: 10px" class="table table-bordered">
                    <thead class="thead-light">
                        <tr>
                            <th scope="col">Statistics Name</th>
                            <th scope="col">Statistics Value</th>
                            <th>Additional Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="table_head" id="statistics-1">
                            <th>PredicateCPA statistics</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr id="statistics-3">
                            <td>Number of abstractions</td>
                            <td> 1 </td>
                            <td>3% of all post computations</td>
                        </tr>
                        <tr id="statistics-5">
                            <td> Times abstraction was reused</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-7">
                            <td> Because of function entry/exit</td>
                            <td> 0 </td>
                            <td>0%</td>
                        </tr>
                        <tr id="statistics-9">
                            <td> Because of loop head</td>
                            <td> 1 </td>
                            <td>100%</td>
                        </tr>
                        <tr id="statistics-11">
                            <td> Because of join nodes</td>
                            <td> 0 </td>
                            <td>0%</td>
                        </tr>
                        <tr id="statistics-13">
                            <td> Because of threshold</td>
                            <td> 0 </td>
                            <td>0%</td>
                        </tr>
                        <tr id="statistics-15">
                            <td> Because of target state</td>
                            <td> 0 </td>
                            <td>0%</td>
                        </tr>
                        <tr id="statistics-17">
                            <td> Times precision was empty</td>
                            <td> 1 </td>
                            <td>100%</td>
                        </tr>
                        <tr id="statistics-19">
                            <td> Times precision was {false}</td>
                            <td> 0 </td>
                            <td>0%</td>
                        </tr>
                        <tr id="statistics-21">
                            <td> Times result was cached</td>
                            <td> 0 </td>
                            <td>0%</td>
                        </tr>
                        <tr id="statistics-23">
                            <td> Times cartesian abs was used</td>
                            <td> 0 </td>
                            <td>0%</td>
                        </tr>
                        <tr id="statistics-25">
                            <td> Times boolean abs was used</td>
                            <td> 0 </td>
                            <td>0%</td>
                        </tr>
                        <tr id="statistics-27">
                            <td> Times result was &#39;false&#39;</td>
                            <td> 0 </td>
                            <td>0%</td>
                        </tr>
                        <tr id="statistics-29">
                            <td>Number of strengthen sat checks</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-31">
                            <td>Number of coverage checks</td>
                            <td> 4</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-33">
                            <td> BDD entailment checks</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-35">
                            <td>Number of SMT sat checks</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-37">
                            <td> trivial</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-39">
                            <td> cached</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-42">
                            <td>Max ABE block size</td>
                            <td> 11</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-44">
                            <td>Number of predicates discovered</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-47">
                            <td>Time for post operator</td>
                            <td> 0.091s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-49">
                            <td> Time for path formula creation</td>
                            <td> 0.089s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-51">
                            <td>Time for strengthen operator</td>
                            <td> 0.002s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-53">
                            <td>Time for prec operator</td>
                            <td> 0.006s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-55">
                            <td> Time for abstraction</td>
                            <td> 0.003s </td>
                            <td>Max: 0.003s, Count: 1</td>
                        </tr>
                        <tr id="statistics-57">
                            <td> Solving time</td>
                            <td> 0.000s </td>
                            <td>Max: 0.000s</td>
                        </tr>
                        <tr id="statistics-59">
                            <td> Model enumeration time</td>
                            <td> 0.000s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-61">
                            <td> Time for BDD construction</td>
                            <td> 0.000s </td>
                            <td>Max: 0.000s</td>
                        </tr>
                        <tr id="statistics-63">
                            <td>Time for merge operator</td>
                            <td> 0.012s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-65">
                            <td>Time for coverage check</td>
                            <td> 0.000s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-67">
                            <td>Total time for SMT solver (w/o itp)</td>
                            <td> 0.000s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-70">
                            <td>Number of path formula cache hits</td>
                            <td> 13 </td>
                            <td>28%</td>
                        </tr>
                        <tr id="statistics-73">
                            <td>Inside post operator</td>
                            <td> </td>
                            <td></td>
                        </tr>
                        <tr id="statistics-75">
                            <td> Inside path formula creation</td>
                            <td> </td>
                            <td></td>
                        </tr>
                        <tr id="statistics-77">
                            <td> Time for path formula computation</td>
                            <td> 0.090s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-80">
                            <td>Total number of created targets for pointer analysis</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-84">
                            <td>Number of BDD nodes</td>
                            <td> 202</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-86">
                            <td>Size of BDD node table</td>
                            <td> 55949</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-88">
                            <td>Size of BDD cache</td>
                            <td> 5623</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-90">
                            <td>Size of BDD node cleanup queue</td>
                            <td> 0.00 </td>
                            <td>sum: 0, count: 12, min: 0, max: 0</td>
                        </tr>
                        <tr id="statistics-92">
                            <td>Time for BDD node cleanup</td>
                            <td> 0.000s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-94">
                            <td>Time for BDD garbage collection</td>
                            <td> 0.000s </td>
                            <td>in 0 runs</td>
                        </tr>
                        <tr class="table_head" id="statistics-97">
                            <th>KeyValue statistics</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr id="statistics-99">
                            <td>Init. function predicates</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-101">
                            <td>Init. global predicates</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-103">
                            <td>Init. location predicates</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr class="table_head" id="statistics-106">
                            <th>Invariant Generation statistics</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr class="table_head" id="statistics-109">
                            <th>AutomatonAnalysis (AssertionAutomaton) statistics</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr id="statistics-111">
                            <td>Number of states</td>
                            <td> 1</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-113">
                            <td>Total time for successor computation</td>
                            <td> 0.003s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-115">
                            <td>Automaton transfers with branching</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-117">
                            <td>Automaton transfer successors</td>
                            <td> 1.00 </td>
                            <td>sum: 30, count: 30, min: 1, max: 1 [1 x 30]</td>
                        </tr>
                        <tr class="table_head" id="statistics-120">
                            <th>AutomatonAnalysis (ErrorLabelAutomaton) statistics</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr id="statistics-122">
                            <td>Number of states</td>
                            <td> 1</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-124">
                            <td>Total time for successor computation</td>
                            <td> 0.005s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-126">
                            <td>Automaton transfers with branching</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-128">
                            <td>Automaton transfer successors</td>
                            <td> 1.00 </td>
                            <td>sum: 30, count: 30, min: 1, max: 1 [1 x 30]</td>
                        </tr>
                        <tr class="table_head" id="statistics-131">
                            <th>AutomatonAnalysis (TerminatingFunctions) statistics</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr id="statistics-133">
                            <td>Number of states</td>
                            <td> 1</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-135">
                            <td>Total time for successor computation</td>
                            <td> 0.000s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-137">
                            <td>Automaton transfers with branching</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-139">
                            <td>Automaton transfer successors</td>
                            <td> 1.00 </td>
                            <td>sum: 30, count: 30, min: 1, max: 1 [1 x 30]</td>
                        </tr>
                        <tr class="table_head" id="statistics-142">
                            <th>CPA algorithm statistics</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr id="statistics-144">
                            <td>Number of iterations</td>
                            <td> 19</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-146">
                            <td>Max size of waitlist</td>
                            <td> 3</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-148">
                            <td>Average size of waitlist</td>
                            <td> 1</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-150">
                            <td>ReversePostorderSortedWaitlist</td>
                            <td> 0.00 </td>
                            <td>sum: 0, count: 8, min: 0, max: 0</td>
                        </tr>
                        <tr id="statistics-152">
                            <td>CallstackSortedWaitlist</td>
                            <td> 11.00 </td>
                            <td>sum: 11, count: 1, min: 11, max: 11</td>
                        </tr>
                        <tr id="statistics-154">
                            <td>Number of computed successors</td>
                            <td> 22</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-156">
                            <td>Max successors for one state</td>
                            <td> 2</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-158">
                            <td>Number of times merged</td>
                            <td> 2</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-160">
                            <td>Number of times stopped</td>
                            <td> 2</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-162">
                            <td>Number of times breaked</td>
                            <td> 1</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-165">
                            <td>Total time for CPA algorithm</td>
                            <td> 0.151s </td>
                            <td>Max: 0.151s</td>
                        </tr>
                        <tr id="statistics-167">
                            <td> Time for choose from waitlist</td>
                            <td> 0.001s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-169">
                            <td> Time for precision adjustment</td>
                            <td> 0.012s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-171">
                            <td> Time for transfer relation</td>
                            <td> 0.116s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-173">
                            <td> Time for merge operator</td>
                            <td> 0.016s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-175">
                            <td> Time for stop operator</td>
                            <td> 0.003s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-177">
                            <td> Time for adding to reached set</td>
                            <td> 0.003s</td>
                            <td></td>
                        </tr>
                        <tr class="table_head" id="statistics-180">
                            <th>Static Predicate Refiner statistics</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr id="statistics-182">
                            <td>Number of predicates found statically</td>
                            <td> 0 </td>
                            <td>count: 0, min: 0, max: 0, avg: 0.00</td>
                        </tr>
                        <tr id="statistics-185">
                            <td>Total time for static refinement</td>
                            <td> 0.125s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-187">
                            <td> Time for path feasibility check</td>
                            <td> 0.036s</td>
                            <td></td>
                        </tr>
                        <tr class="table_head" id="statistics-190">
                            <th>PredicateCPARefiner statistics</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr id="statistics-192">
                            <td>Number of predicate refinements</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr class="table_head" id="statistics-195">
                            <th>Predicate-Abstraction Refiner statistics</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr id="statistics-197">
                            <td> Predicate creation</td>
                            <td> 0.000s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-199">
                            <td> Precision update</td>
                            <td> 0.000s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-201">
                            <td> ARG update</td>
                            <td> 0.000s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-204">
                            <td>Length of refined path (in blocks)</td>
                            <td> 0.00 </td>
                            <td>sum: 0, count: 0, min: 0, max: 0</td>
                        </tr>
                        <tr id="statistics-206">
                            <td>Number of affected states</td>
                            <td> 0 </td>
                            <td>count: 0, min: 0, max: 0, avg: 0.00</td>
                        </tr>
                        <tr id="statistics-208">
                            <td>Length (states) of path with itp &#39;true&#39;</td>
                            <td> 0 </td>
                            <td>count: 0, min: 0, max: 0, avg: 0.00</td>
                        </tr>
                        <tr id="statistics-210">
                            <td>Length (states) of path with itp non-trivial itp</td>
                            <td> 0 </td>
                            <td>count: 0, min: 0, max: 0, avg: 0.00</td>
                        </tr>
                        <tr id="statistics-212">
                            <td>Length (states) of path with itp &#39;false&#39;</td>
                            <td> 0 </td>
                            <td>count: 0, min: 0, max: 0, avg: 0.00</td>
                        </tr>
                        <tr id="statistics-214">
                            <td>Different non-trivial interpolants along paths</td>
                            <td> 0 </td>
                            <td>count: 0, min: 0, max: 0, avg: 0.00</td>
                        </tr>
                        <tr id="statistics-216">
                            <td>Equal non-trivial interpolants along paths</td>
                            <td> 0 </td>
                            <td>count: 0, min: 0, max: 0, avg: 0.00</td>
                        </tr>
                        <tr id="statistics-218">
                            <td>Number of refs with location-based cutoff</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr class="table_head" id="statistics-221">
                            <th>CEGAR algorithm statistics</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr id="statistics-223">
                            <td>Number of refinements</td>
                            <td> 1</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-225">
                            <td>Number of successful refinements</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-227">
                            <td>Number of failed refinements</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-229">
                            <td>Max. size of reached set before ref.</td>
                            <td> 21</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-231">
                            <td>Max. size of reached set after ref.</td>
                            <td> 0</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-233">
                            <td>Avg. size of reached set before ref.</td>
                            <td> 21.00</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-235">
                            <td>Avg. size of reached set after ref.</td>
                            <td> NaN</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-238">
                            <td>Total time for CEGAR algorithm</td>
                            <td> 0.306s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-240">
                            <td>Time for refinements</td>
                            <td> 0.155s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-242">
                            <td>Average time for refinement</td>
                            <td> 0.155s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-244">
                            <td>Max time for refinement</td>
                            <td> 0.155s</td>
                            <td></td>
                        </tr>
                        <tr class="table_head" id="statistics-247">
                            <th>Code Coverage</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr id="statistics-249">
                            <td> Function coverage</td>
                            <td> 1.000</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-251">
                            <td> Visited lines</td>
                            <td> 13</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-253">
                            <td> Total lines</td>
                            <td> 14</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-255">
                            <td> Line coverage</td>
                            <td> 0.929</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-257">
                            <td> Visited conditions</td>
                            <td> 6</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-259">
                            <td> Total conditions</td>
                            <td> 6</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-261">
                            <td> Condition coverage</td>
                            <td> 1.000</td>
                            <td></td>
                        </tr>
                        <tr class="table_head" id="statistics-264">
                            <th>CPAchecker general statistics</th>
                            <th></th>
                            <th></th>
                        </tr>
                        <tr id="statistics-266">
                            <td>Number of program locations</td>
                            <td> 30</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-268">
                            <td>Number of CFA edges (per node)</td>
                            <td> 32 </td>
                            <td>count: 30, min: 0, max: 2, avg: 1.07</td>
                        </tr>
                        <tr id="statistics-270">
                            <td>Number of relevant variables</td>
                            <td> 4</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-272">
                            <td>Number of functions</td>
                            <td> 2</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-274">
                            <td>Number of loops (and loop nodes)</td>
                            <td> 1 </td>
                            <td>sum: 1, min: 1, max: 1, avg: 1.00</td>
                        </tr>
                        <tr id="statistics-276">
                            <td>Size of reached set</td>
                            <td> 21</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-278">
                            <td> Number of reached locations</td>
                            <td> 21 </td>
                            <td>70%</td>
                        </tr>
                        <tr id="statistics-280">
                            <td> Avg states per location</td>
                            <td> 1</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-282">
                            <td> Max states per location</td>
                            <td> 1 </td>
                            <td>at node N0</td>
                        </tr>
                        <tr id="statistics-284">
                            <td> Number of reached functions</td>
                            <td> 2 </td>
                            <td>100%</td>
                        </tr>
                        <tr id="statistics-286">
                            <td> Number of partitions</td>
                            <td> 21</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-288">
                            <td> Avg size of partitions</td>
                            <td> 1</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-290">
                            <td> Max size of partitions</td>
                            <td> 1</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-292">
                            <td> Number of target states</td>
                            <td> 1</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-294">
                            <td> Size of final wait list</td>
                            <td> 2</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-297">
                            <td>Time for analysis setup</td>
                            <td> 3.137s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-299">
                            <td> Time for loading CPAs</td>
                            <td> 1.167s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-301">
                            <td> Time for loading parser</td>
                            <td> 0.536s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-303">
                            <td> Time for CFA construction</td>
                            <td> 1.174s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-305">
                            <td> Time for parsing file(s)</td>
                            <td> 0.589s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-307">
                            <td> Time for AST to CFA</td>
                            <td> 0.276s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-309">
                            <td> Time for CFA sanity check</td>
                            <td> 0.013s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-311">
                            <td> Time for post-processing</td>
                            <td> 0.188s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-313">
                            <td> Time for CFA export</td>
                            <td> 0.788s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-315">
                            <td> Time for function pointers resolving</td>
                            <td> 0.006s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-317">
                            <td> Function calls via function pointers</td>
                            <td> 0 </td>
                            <td>count: 1, min: 0, max: 0, avg: 0.00</td>
                        </tr>
                        <tr id="statistics-319">
                            <td> Instrumented function pointer calls</td>
                            <td> 0 </td>
                            <td>count: 1, min: 0, max: 0, avg: 0.00</td>
                        </tr>
                        <tr id="statistics-321">
                            <td> Function calls with function pointer arguments</td>
                            <td> 0 </td>
                            <td>count: 1, min: 0, max: 0, avg: 0.00</td>
                        </tr>
                        <tr id="statistics-323">
                            <td> Instrumented function pointer arguments</td>
                            <td> 0 </td>
                            <td>count: 1, min: 0, max: 0, avg: 0.00</td>
                        </tr>
                        <tr id="statistics-325">
                            <td> Time for var class.</td>
                            <td> 0.105s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-327">
                            <td> Time for collecting variables</td>
                            <td> 0.033s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-329">
                            <td> Time for solving dependencies</td>
                            <td> 0.001s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-331">
                            <td> Time for building hierarchy</td>
                            <td> 0.000s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-333">
                            <td> Time for building classification</td>
                            <td> 0.057s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-335">
                            <td> Time for exporting data</td>
                            <td> 0.014s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-337">
                            <td>Time for Analysis</td>
                            <td> 0.306s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-339">
                            <td>CPU time for analysis</td>
                            <td> 0.400s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-341">
                            <td>Time for analyzing result</td>
                            <td> 0.000s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-343">
                            <td>Total time for CPAchecker</td>
                            <td> 3.449s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-345">
                            <td>Total CPU time for CPAchecker</td>
                            <td> 7.170s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-347">
                            <td>Time for statistics</td>
                            <td> 0.507s</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-350">
                            <td>Time for Garbage Collector</td>
                            <td> 0.134s </td>
                            <td>in 3 runs</td>
                        </tr>
                        <tr id="statistics-352">
                            <td>Garbage Collector(s) used</td>
                            <td> PS MarkSweep, PS Scavenge</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-354">
                            <td>Used heap memory</td>
                            <td> 73MB ( 69 MiB) max; 43MB ( 41 MiB) avg; 95MB ( 90 MiB) peak</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-356">
                            <td>Used non-heap memory</td>
                            <td> 36MB ( 34 MiB) max; 25MB ( 23 MiB) avg; 40MB ( 38 MiB) peak</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-358">
                            <td>Used in PS Old Gen pool</td>
                            <td> 17MB ( 16 MiB) max; 6MB ( 5 MiB) avg; 17MB ( 16 MiB) peak</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-360">
                            <td>Allocated heap memory</td>
                            <td> 257MB ( 245 MiB) max; 237MB ( 226 MiB) avg</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-362">
                            <td>Allocated non-heap memory</td>
                            <td> 37MB ( 35 MiB) max; 25MB ( 24 MiB) avg</td>
                            <td></td>
                        </tr>
                        <tr id="statistics-364">
                            <td>Total process virtual memory</td>
                            <td> 349608MB (333412 MiB) max; 349459MB (333270 MiB) avg</td>
                            <td></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="fileContent content" ng-show="tabIsSet(6)" ng-class="{active: tabIsSet(6)}">
                <table id="config_table" class="display" style="width:100%;padding: 10px" class="table table-bordered">
                    <thead class="thead-light">
                        <tr>
                            <th scope="col">#</th>
                            <th scope="col">Configuration Name</th>
                            <th scope="col">Configuration Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr id="config-0">
                            <th scope="row">1</th>
                            <td>analysis.algorithm.CEGAR </td>
                            <td> true</td>
                        </tr>
                        <tr id="config-1">
                            <th scope="row">2</th>
                            <td>analysis.programNames </td>
                            <td> test/programs/simple/SSAMap-bug_false-unreach-label.c</td>
                        </tr>
                        <tr id="config-2">
                            <th scope="row">3</th>
                            <td>analysis.traversal.order </td>
                            <td> bfs</td>
                        </tr>
                        <tr id="config-3">
                            <th scope="row">4</th>
                            <td>analysis.traversal.useCallstack </td>
                            <td> true</td>
                        </tr>
                        <tr id="config-4">
                            <th scope="row">5</th>
                            <td>analysis.traversal.useReversePostorder </td>
                            <td> true</td>
                        </tr>
                        <tr id="config-5">
                            <th scope="row">6</th>
                            <td>ARGCPA.cpa </td>
                            <td> cpa.composite.CompositeCPA</td>
                        </tr>
                        <tr id="config-6">
                            <th scope="row">7</th>
                            <td>cegar.refiner </td>
                            <td> cpa.predicate.PredicateRefiner</td>
                        </tr>
                        <tr id="config-7">
                            <th scope="row">8</th>
                            <td>CompositeCPA.cpas </td>
                            <td> cpa.location.LocationCPA, cpa.callstack.CallstackCPA, cpa.functionpointer.FunctionPointerCPA,
                                cpa.predicate.PredicateCPA
                            </td>
                        </tr>
                        <tr id="config-8">
                            <th scope="row">9</th>
                            <td>cpa </td>
                            <td> cpa.arg.ARGCPA</td>
                        </tr>
                        <tr id="config-9">
                            <th scope="row">10</th>
                            <td>cpa.composite.aggregateBasicBlocks </td>
                            <td> true</td>
                        </tr>
                        <tr id="config-10">
                            <th scope="row">11</th>
                            <td>cpa.predicate.blk.alwaysAtFunctions </td>
                            <td> false</td>
                        </tr>
                        <tr id="config-11">
                            <th scope="row">12</th>
                            <td>cpa.predicate.blk.alwaysAtLoops </td>
                            <td> true</td>
                        </tr>
                        <tr id="config-12">
                            <th scope="row">13</th>
                            <td>cpa.predicate.refinement.performInitialStaticRefinement </td>
                            <td> true</td>
                        </tr>
                        <tr id="config-13">
                            <th scope="row">14</th>
                            <td>limits.time.cpu </td>
                            <td> 900s</td>
                        </tr>
                        <tr id="config-14">
                            <th scope="row">15</th>
                            <td>log.level </td>
                            <td> INFO</td>
                        </tr>
                        <tr id="config-15">
                            <th scope="row">16</th>
                            <td>specification </td>
                            <td> ../specification/default.spc</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
    </div>
    <div class="tool_tip" id="infoBox" style="z-index: 1; visibility: hidden;">
        <div id="insideBox">
            <span id="boxContent">&nbsp;</span>
        </div>
    </div>
</body>

</html>