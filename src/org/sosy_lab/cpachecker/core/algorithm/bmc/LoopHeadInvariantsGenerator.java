// This file is part of CPAchecker,
// a tool for configurable software verification:
// https://cpachecker.sosy-lab.org
//
// SPDX-FileCopyrightText: 2022 Dirk Beyer <https://www.sosy-lab.org>
//
// SPDX-License-Identifier: Apache-2.0

package org.sosy_lab.cpachecker.core.algorithm.bmc;

import static org.sosy_lab.cpachecker.core.algorithm.bmc.BMCHelper.assertAt;
import static org.sosy_lab.cpachecker.core.algorithm.bmc.BMCHelper.filterIteration;

import com.google.common.collect.FluentIterable;
import java.util.Optional;
import java.util.Set;
import java.util.logging.Level;
import org.sosy_lab.common.ShutdownNotifier;
import org.sosy_lab.common.log.LogManager;
import org.sosy_lab.cpachecker.cfa.model.CFANode;
import org.sosy_lab.cpachecker.core.algorithm.bmc.AbstractBMCAlgorithm.InvariantGeneratorHeadStart;
import org.sosy_lab.cpachecker.core.algorithm.bmc.BMCHelper.FormulaInContext;
import org.sosy_lab.cpachecker.core.algorithm.invariants.InvariantGenerator;
import org.sosy_lab.cpachecker.core.algorithm.invariants.InvariantSupplier;
import org.sosy_lab.cpachecker.core.interfaces.AbstractState;
import org.sosy_lab.cpachecker.core.reachedset.ReachedSet;
import org.sosy_lab.cpachecker.exceptions.CPAException;
import org.sosy_lab.cpachecker.exceptions.CPATransferException;
import org.sosy_lab.cpachecker.util.AbstractStates;
import org.sosy_lab.cpachecker.util.predicates.pathformula.PathFormula;
import org.sosy_lab.cpachecker.util.predicates.pathformula.PathFormulaManager;
import org.sosy_lab.cpachecker.util.predicates.smt.BooleanFormulaManagerView;
import org.sosy_lab.cpachecker.util.predicates.smt.FormulaManagerView;
import org.sosy_lab.java_smt.api.BooleanFormula;

public class LoopHeadInvariantsGenerator {
  private final InvariantGenerator invariantGenerator;
  private final InvariantGeneratorHeadStart invariantGeneratorHeadStart;
  private boolean invariantGenerationRunning;
  private final ShutdownNotifier shutdownNotifier;
  private final LogManager logger;

  private final PathFormulaManager pfmgr;
  private final FormulaManagerView fmgr;
  private BooleanFormula loopHeadInvariants;

  public LoopHeadInvariantsGenerator(
      InvariantGenerator pInvariantGenerator,
      InvariantGeneratorHeadStart pInvariantGeneratorHeadStart,
      ShutdownNotifier pShutdownNotifier,
      LogManager pLogger,
      FormulaManagerView pFormulaMgr,
      PathFormulaManager pPathMgr) {
    invariantGenerator = pInvariantGenerator;
    invariantGeneratorHeadStart = pInvariantGeneratorHeadStart;
    invariantGenerationRunning = true;
    shutdownNotifier = pShutdownNotifier;
    logger = pLogger;
    pfmgr = pPathMgr;
    fmgr = pFormulaMgr;
    loopHeadInvariants = fmgr.getBooleanFormulaManager().makeTrue();
  }

  void start(CFANode initLocation) {
    invariantGenerator.start(initLocation);
  }

  void headStart() throws InterruptedException {
    invariantGeneratorHeadStart.waitForInvariantGenerator();
  }

  void cancel() {
    invariantGenerator.cancel();
  }

  BooleanFormula getInvariants(ReachedSet reachedSet, Set<CFANode> loopHeadLocs)
      throws CPATransferException, InterruptedException {
    Iterable<AbstractState> loopHeadStates =
        getLoopHeadStatesAtFirstIteration(reachedSet, loopHeadLocs);
    return assertAt(
        getLoopHeadStatesAtFirstIteration(reachedSet, loopHeadLocs),
        getInvariantsInContext(loopHeadStates),
        fmgr,
        true);
  }

  BooleanFormula getUninstantiatedInvariants(ReachedSet reachedSet, Set<CFANode> loopHeadLocs)
      throws CPATransferException, InterruptedException {
    return fmgr.uninstantiate(getInvariants(reachedSet, loopHeadLocs));
  }

  boolean isProgramSafe() {
    return invariantGenerator.isProgramSafe();
  }

  private FluentIterable<AbstractState> getLoopHeadStatesAtFirstIteration(
      ReachedSet reachedSet, Set<CFANode> loopHeadLocs) {
    FluentIterable<AbstractState> loopHeadStates =
        AbstractStates.filterLocations(reachedSet, loopHeadLocs);
    return filterIteration(loopHeadStates, 1, loopHeadLocs);
  }

  /**
   * Gets the most current invariants generated by the invariant generator.
   *
   * @return the most current invariants generated by the invariant generator.
   */
  private FormulaInContext getInvariantsInContext(Iterable<AbstractState> pAssertionStates) {
    final BooleanFormulaManagerView bfmgr = fmgr.getBooleanFormulaManager();
    Set<CFANode> stopLoopHeads = AbstractStates.extractLocations(pAssertionStates).toSet();
    return pContext -> {
      shutdownNotifier.shutdownIfNecessary();
      if (!bfmgr.isFalse(loopHeadInvariants) && invariantGenerationRunning) {
        BooleanFormula lhi = bfmgr.makeFalse();
        for (CFANode loopHead : stopLoopHeads) {
          lhi = bfmgr.or(lhi, getLocationInvariants(loopHead, pContext));
          shutdownNotifier.shutdownIfNecessary();
        }
        loopHeadInvariants = lhi;
      }
      return loopHeadInvariants;
    };
  }

  private BooleanFormula getLocationInvariants(CFANode pLocation, PathFormula pContext)
      throws InterruptedException {
    shutdownNotifier.shutdownIfNecessary();
    InvariantSupplier currentInvariantsSupplier = getInvariantSupplier();

    return currentInvariantsSupplier.getInvariantFor(
        pLocation, Optional.empty(), fmgr, pfmgr, pContext);
  }

  private InvariantSupplier getInvariantSupplier() throws InterruptedException {
    if (invariantGenerationRunning) {
      try {
        return invariantGenerator.getSupplier();
      } catch (CPAException e) {
        logger.logUserException(Level.FINE, e, "Invariant generation failed.");
        invariantGenerationRunning = false;
      } catch (InterruptedException e) {
        shutdownNotifier.shutdownIfNecessary();
        logger.log(Level.FINE, "Invariant generation was cancelled.");
        logger.logDebugException(e);
        invariantGenerationRunning = false;
      }
    }
    return InvariantSupplier.TrivialInvariantSupplier.INSTANCE;
  }
}
