/*
 *  CPAchecker is a tool for configurable software verification.
 *  This file is part of CPAchecker.
 *
 *  Copyright (C) 2007-2011  Dirk Beyer
 *  All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *
 *  CPAchecker web page:
 *    http://cpachecker.sosy-lab.org
 */
package org.sosy_lab.cpachecker.cpa.relyguarantee;

import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Vector;

import org.sosy_lab.common.LogManager;
import org.sosy_lab.common.Pair;
import org.sosy_lab.common.configuration.Configuration;
import org.sosy_lab.common.configuration.InvalidConfigurationException;
import org.sosy_lab.common.configuration.Option;
import org.sosy_lab.common.configuration.Options;
import org.sosy_lab.cpachecker.cfa.ast.IASTExpressionAssignmentStatement;
import org.sosy_lab.cpachecker.cfa.ast.IASTIdExpression;
import org.sosy_lab.cpachecker.cfa.ast.IASTNode;
import org.sosy_lab.cpachecker.cfa.objectmodel.CFAEdge;
import org.sosy_lab.cpachecker.cpa.art.ARTElement;
import org.sosy_lab.cpachecker.util.AbstractElements;
import org.sosy_lab.cpachecker.util.predicates.CachingPathFormulaManager;
import org.sosy_lab.cpachecker.util.predicates.PathFormula;
import org.sosy_lab.cpachecker.util.predicates.PathFormulaManagerImpl;
import org.sosy_lab.cpachecker.util.predicates.SSAMap;
import org.sosy_lab.cpachecker.util.predicates.interfaces.Formula;
import org.sosy_lab.cpachecker.util.predicates.interfaces.PathFormulaManager;
import org.sosy_lab.cpachecker.util.predicates.mathsat.MathsatFormulaManager;
import org.sosy_lab.cpachecker.util.predicates.mathsat.MathsatTheoremProver;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;

/**
 * Stores information about environmental transitions.
 */
@Options(prefix="cpa.relyguarantee")
public class RelyGuaranteeEnvironment {
  @Option(name="symbolcCoverageCheck",description="Use a theorem prover to remove covered environemtal transitions" +
  " if false perform only a syntatic check for equivalence")
  private boolean checkEnvTransitionCoverage = true;

  @Option(description="List of variables global to multiple threads")
  protected String[] globalVariables = {};

  // map from ART elements to unprocessed env transitions
  private final Multimap<ARTElement, RelyGuaranteeEnvironmentalTransition> unprocessedTransitions;
  // all rely guarantee transitions  generated by thread i that do not have to be processed again
  private final Vector<RelyGuaranteeEnvironmentalTransition>[] envTransProcessedBeforeFromThread;
  // rely env edges valid for thread i, that have been applied on the CFA
  private final Vector<RelyGuaranteeCFAEdge>[] appliedEnvEdgesForThread;
  // rely guarantee edges valid for thread i, that haven't been applied yet on the CFA
  private final Vector<RelyGuaranteeCFAEdge>[] unappliedEnvEdgesForThread;
  // rely guarantee edges for thread i, that are covered by more general edges in appliedEnvEdgesForThread or unappliedEnvEdgesForThread
  private final Vector<RelyGuaranteeCFAEdge>[] coveredEnvEdgesForThread;
  // number of threads
  private int threadNo;

  // Managers
  private PathFormulaManager pfManager;
  private MathsatFormulaManager fManager;
  private MathsatTheoremProver tProver;

  // set of global variables
  private HashSet<String> globalVarsSet;

  public RelyGuaranteeEnvironment(int threadNo, Configuration config, LogManager logger){
    // TODO add option for caching
    MathsatFormulaManager msatFormulaManager;
    try {
      config.inject(this, RelyGuaranteeEnvironment.class);
      // set up managers
      msatFormulaManager = MathsatFormulaManager.getInstance(config, logger);
      fManager = msatFormulaManager;
      tProver = MathsatTheoremProver.getInstance(msatFormulaManager);
      PathFormulaManager pfMgr  = PathFormulaManagerImpl.getInstance(msatFormulaManager, config, logger);
      pfMgr = CachingPathFormulaManager.getInstance(pfMgr);
      pfManager = pfMgr;
    } catch (InvalidConfigurationException e) {
      e.printStackTrace();
    }

    // create a set of global variables
    globalVarsSet = new HashSet<String>();
    for (String var : globalVariables) {
      globalVarsSet.add(var);
    }

    this.threadNo = threadNo;
    unprocessedTransitions = HashMultimap.<ARTElement, RelyGuaranteeEnvironmentalTransition>create();
    envTransProcessedBeforeFromThread = new Vector[threadNo];
    appliedEnvEdgesForThread = new Vector[threadNo];
    unappliedEnvEdgesForThread = new Vector[threadNo];
    coveredEnvEdgesForThread = new Vector[threadNo];

    for (int i=0; i< threadNo; i++){
      envTransProcessedBeforeFromThread[i] = new Vector<RelyGuaranteeEnvironmentalTransition>();
      appliedEnvEdgesForThread[i] = new Vector<RelyGuaranteeCFAEdge>();
      unappliedEnvEdgesForThread[i] = new Vector<RelyGuaranteeCFAEdge>();
      coveredEnvEdgesForThread[i] = new Vector<RelyGuaranteeCFAEdge>();
    }
  }

  /**
   * Add new environmental transitions for processing.
   * @param pAElement
   * @param pNewEnvTransitions
   */
  public void addEnvTransitions(ARTElement aElement, Vector<RelyGuaranteeEnvironmentalTransition> newTransitions) {
    if (!newTransitions.isEmpty()){
      unprocessedTransitions.putAll(aElement, newTransitions);
    }
  }

  public void appliedEnvEdgesForThread(int i) {
    appliedEnvEdgesForThread[i].addAll( unappliedEnvEdgesForThread[i]);
    unappliedEnvEdgesForThread[i].removeAllElements();
  }

  public Multimap<ARTElement, RelyGuaranteeEnvironmentalTransition> getUnprocessedTransitions(){
    return unprocessedTransitions;
  }

  public void addNewEnvEgde(int j, RelyGuaranteeCFAEdge edge) {
    unappliedEnvEdgesForThread[j].add(edge);
  }

  public  List<RelyGuaranteeEnvironmentalTransition> getEnvTransitionsCreatedBy(int i) {
    return envTransProcessedBeforeFromThread[i];
  }

  public void remberEnvTransitions(int i, Collection<RelyGuaranteeEnvironmentalTransition> values) {
    envTransProcessedBeforeFromThread[i].addAll(values);
  }

  public  List<RelyGuaranteeCFAEdge> getAppliedEnvEdgesForThread(int i) {
    return appliedEnvEdgesForThread[i];
  }

  public  List<RelyGuaranteeCFAEdge> getUnappliedEnvEdgesForThread(int i) {
    return unappliedEnvEdgesForThread[i];
  }

  public void printUnprocessedTransitions() {
    System.out.println();
    System.out.println("## Env transitions created ##");
    for (ARTElement key : unprocessedTransitions.keys()){
      for (RelyGuaranteeEnvironmentalTransition edge : unprocessedTransitions.get(key)){
        System.out.println(key.getElementId()+" -> "+edge);
      }
    }

  }

  /**
   * Removes all unprocessed environmental transitions that belong to subtree root at the specified element.
   * @param root
   */
  public void removeUnprocessedTransitionsFromElement(ARTElement root) {
    Set<ARTElement> subtree = root.getSubtree();
    Set<ARTElement> toDelete = new HashSet<ARTElement>();
    for (ARTElement element : unprocessedTransitions.keys()){
      if (subtree.contains(element)){
        toDelete.add(element);
      }
    }
    for (ARTElement element : toDelete){
      System.out.println("Dropping unp. transitions at "+element.getElementId());
      unprocessedTransitions.removeAll(element);
    }
  }

  /**
   * Convert environmental transitions for thread i into relevant CFA edges.
   * Remove edges that are useless, have been applied before or are covered.
   * @param i
   */
  public void processEnvTransitions(int i) {
    syntacticCoverageCheck(i);
    // generate CFA edges from env transitions
    Multimap<ARTElement, RelyGuaranteeEnvironmentalTransition> newEnvTransitions =  this.getUnprocessedTransitions();
    Vector<RelyGuaranteeCFAEdge> rgEdges = new Vector<RelyGuaranteeCFAEdge>();
    for (RelyGuaranteeEnvironmentalTransition  et: newEnvTransitions.values()){
      Formula f = et.getFormula();
      PathFormula pf = et.getPathFormula();
      PathFormula newPF = pfManager.makeAnd(pf, f);
      newPF = pfManager.normalize(newPF);
      RelyGuaranteeCFAEdge rgEdge = new RelyGuaranteeCFAEdge(et.getEdge(), newPF, et.getSourceThread(), et.getSourceARTElement(), et);
      rgEdges.add(rgEdge);
    }
    newEnvTransitions.clear();

    if (checkEnvTransitionCoverage) {
      semanticCoverageCheck(rgEdges, i);
    }

    // distribute the env edge to other threads
    System.out.println("## Env after filtering ##");
    RelyGuaranteeCFAEdge edge;
    while (!rgEdges.isEmpty()){
      edge = rgEdges.remove(0);
      System.out.println(edge);
      for (int j=0; j<this.threadNo; j++){
        if (j!=i) {
          this.addNewEnvEgde(j, edge.makeCopy());
        }
      }
    }
  }

  //
  /**
   * Remove environmental transitions that have been produced before by thread i  or are obviously unnecessary.
   */
  private void syntacticCoverageCheck(int i) {
    Vector<Pair<ARTElement, RelyGuaranteeEnvironmentalTransition>> toDelete = new Vector<Pair<ARTElement, RelyGuaranteeEnvironmentalTransition>>();
    Multimap<ARTElement, RelyGuaranteeEnvironmentalTransition> newEnvTransitions =  this.getUnprocessedTransitions();
    for (ARTElement key : newEnvTransitions.keys()){
      for (RelyGuaranteeEnvironmentalTransition  et: newEnvTransitions.get(key)){
        Formula f = et.getFormula();
        PathFormula pf = et.getPathFormula();
        CFAEdge localEdge = et.getEdge();
        int sourceThread = et.getSourceThread();
        // don't generate transition with 'false' or transitions that assign to local variables
        if (f.isFalse() || pf.getFormula().isFalse() || isLocalAssigment(localEdge)) {
          toDelete.add(Pair.of(key, et));
          System.out.println("Removed (syn,false): "+et);
        } else {
          // check if the transition was produced before
          for (RelyGuaranteeEnvironmentalTransition oldEt : this.getEnvTransitionsCreatedBy(i)) {
            if (et.equals(oldEt)) {
              toDelete.add(Pair.of(key, et));
              System.out.println("Removed (syn,old): "+et);
            }
          }
        }
      }
    }

    for (Pair<ARTElement, RelyGuaranteeEnvironmentalTransition> pair: toDelete){
      newEnvTransitions.remove(pair.getFirst(), pair.getSecond());
    }

    // TODO check if needed
    // remove duplicate transitions from newEnvTransitions
    /*toDelete.removeAllElements();
    Vector<RelyGuaranteeEnvironmentalTransition> toProcess = new Vector<RelyGuaranteeEnvironmentalTransition>(newEnvTransitions);
    while (! toProcess.isEmpty()){
      RelyGuaranteeEnvironmentalTransition et = toProcess.remove(0);
      for (RelyGuaranteeEnvironmentalTransition other : toProcess){
        if (et.equals(other)){
          toDelete.add(other);
          System.out.println("Removed (syn,new): "+other);
        }
      }
    }
    newEnvTransitions.removeAll(toDelete);*/
    this.remberEnvTransitions(i,newEnvTransitions.values());
    //envTransitionsCreatedBy[i].addAll();
  }

  /**
   * Removes new  and old edges (from rgEdges and unappliedEnvEdgesForThread[i], respectively) from thread i that are covered.
   */
  private void semanticCoverageCheck(Vector<RelyGuaranteeCFAEdge> rgEdges, int i) {

    //Vector<RelyGuaranteeCFAEdge> uncovered = new Vector<RelyGuaranteeCFAEdge>(rgEdges);
    Vector<RelyGuaranteeCFAEdge> toProcess = new Vector<RelyGuaranteeCFAEdge>(rgEdges);
    Vector<RelyGuaranteeCFAEdge> toDelete = new Vector<RelyGuaranteeCFAEdge>();

    // remove edges in rgEdges that are covered by some other edge in this vector
    for(RelyGuaranteeCFAEdge edge : rgEdges){
      for(RelyGuaranteeCFAEdge other : toProcess){
        if (!edge.equals(other) && isCovered(edge, other)){
          toProcess.remove(edge);
          toDelete.add(edge);
          System.out.println("Covered tr. "+edge+" \t=>\t "+other);
          break;
        }
      }
    }

   rgEdges.removeAll(toDelete);
   // removed edges in rgEdges or in envEdgesForThread[i] if they are covered
   while(! toProcess.isEmpty()){
     RelyGuaranteeCFAEdge newEdge = toProcess.remove(0);
     List<RelyGuaranteeCFAEdge> envEdgesForThread = this.getAppliedEnvEdgesForThread(i);
     for (RelyGuaranteeCFAEdge oldEdge : envEdgesForThread){
       if (isCovered(newEdge, oldEdge)) {
         // newEdge => oldEdge
         rgEdges.remove(newEdge);
         System.out.println("Covered tr. "+newEdge+" \t=>\t "+oldEdge);
         break;
       } else if (isCovered(oldEdge, newEdge)) {
         // oldEdge => newEdge, but not newEdge => oldEdge
         toDelete.add(oldEdge);
         rgEdges.add(newEdge);
         System.out.println("Covered tr. "+oldEdge+" \t=>\t "+newEdge);
       }
     }

     envEdgesForThread.removeAll(toDelete);
     toDelete.removeAllElements();
   }
  }

  /**
   * Returns true if env1 => env2, sound but not complete
   */
  public boolean isCovered(RelyGuaranteeCFAEdge env1, RelyGuaranteeCFAEdge env2) {
    if (env1.equals(env2)){
      return true;
    }
    if (!env1.getLocalEdge().equals(env2.getLocalEdge())){
      return false;
    }

    Formula f1 = env1.getPathFormula().getFormula();
    Formula f2 = env2.getPathFormula().getFormula();
    SSAMap s1 = env1.getPathFormula().getSsa();
    SSAMap s2 = env2.getPathFormula().getSsa();
    if (f1.isFalse() || f2.isTrue()) {
      return true;
    }
    /*int offset = env1.getPathFormula().getPrimedNo() + 1;
    Formula f2p = fManager.primeFormula(f2, offset);
    Formula ef = fManager.makeTrue();
    // every last unprimed value in f2 must equal to the  last value in f1
    for (String var : s2.allVariables()){
      // skip primed variables
      if(PathFormula.getPrimeData(var).getSecond()>0) {
        continue;
      }
      int idx1 = s1.getIndex(var);
      if (idx1 == -1){
        idx1 = 1;
      }
      int idx2 = s2.getIndex(var);
      String name2 = var+"^"+offset;
      Formula var1 = fManager.makeVariable(var, idx1);
      Formula var2 = fManager.makeVariable(name2, idx2);
      Formula eq = fManager.makeEqual(var1, var2);
      ef = fManager.makeAnd(ef, eq);
    }*/
    Formula nImpl = fManager.makeAnd(f1, fManager.makeNot(f2));
    tProver.init();
     try {
      return tProver.isUnsat(nImpl);
    } finally {
      tProver.reset();
    }
  }

  /**
   * Returns true iff edge is an assignment to a non-global variable
   */
  private boolean isLocalAssigment(CFAEdge edge) {
    String var = getLhsVariable(edge);
    if (var != null && !globalVarsSet.contains(var)){
      return true;
    }
    return false;
  }

  /**
   * Get the variable in the lhs of an expression or return null
   */
  private String getLhsVariable(CFAEdge edge){
    IASTNode node = edge.getRawAST();
    if (node instanceof IASTExpressionAssignmentStatement) {
      IASTExpressionAssignmentStatement stmNode = (IASTExpressionAssignmentStatement) node;
      if (stmNode.getLeftHandSide() instanceof IASTIdExpression) {
        IASTIdExpression idExp = (IASTIdExpression) stmNode.getLeftHandSide();
        return new String(idExp.getName());
      }
    }
    return null;
  }

  /**
   * Sets the path formula of the transitions that were generated in the subtree of root to false. These transtions will
   * not be applied again. Transitions covered by them will be valid again, unless they have been also killed.
   * @param root
   */
  public void killEnvironmetalEdges(ARTElement root) {
    // get source thread no
    RelyGuaranteeAbstractElement rgElement = AbstractElements.extractElementByType(root, RelyGuaranteeAbstractElement.class);
    int sourceTid = rgElement.getTid();
    Set<ARTElement> subtree = root.getSubtree();
    // remove covered transitions that belong to the subtree
    killCovered(root, sourceTid);
    // kill valid but unapplied env. edges
    killValidUnapplied(root, sourceTid);
    // kill valid and processed env. edges
    killValidApplied(root, sourceTid);
    // drop unprocess transitions that were generated in the subtree and process the remaining ones
    removeUnprocessedTransitionsFromElement(root);

    /*for (int tid=0; tid<threadNo; tid++){
      for (RelyGuaranteeCFAEdge rgEdge: appliedEnvEdgesForThread[tid]){
        if (tid != sourceTid && subtree.contains(rgEdge.getSourceARTElement())){
          killAndRevert(rgEdge);
        }
      }
    }*/

  }

  /**
   * For every covered env. edge that belongs to subtree:
   * - remove them for the set
   * - handle transitions that they cover
   * - make them false
   * - remove from envTransProcessedBeforeFromThread so it can be generated again
   * @param pRoot
   */
  private void killCovered(ARTElement root, int tid) {
    // TODO Auto-generated method stub

  }


  private void killValidApplied(ARTElement root, int tid) {
    // TODO Auto-generated method stub

  }

  private void killValidUnapplied(ARTElement root, int tid) {
    // TODO Auto-generated method stub

  }



  /**
   * Makes an environmetal edge 'false' - its path formula is false and the source element is null.
   * @param rgEdge
   */
  private void makeRelyGuaranteeEnvEdgeFalse(RelyGuaranteeCFAEdge rgEdge){
    PathFormula falsePathFormula = pfManager.makeFalsePathFormula();
    rgEdge.setPathFormula(falsePathFormula);
    rgEdge.setSourceARTElement(null);
  }

}
