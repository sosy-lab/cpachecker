/*
 *  CPAchecker is a tool for configurable software verification.
 *  This file is part of CPAchecker.
 *
 *  Copyright (C) 2007-2011  Dirk Beyer
 *  All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *
 *  CPAchecker web page:
 *    http://cpachecker.sosy-lab.org
 */
package org.sosy_lab.cpachecker.cpa.relyguarantee;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Vector;

import org.sosy_lab.common.LogManager;
import org.sosy_lab.common.Pair;
import org.sosy_lab.common.configuration.Configuration;
import org.sosy_lab.common.configuration.InvalidConfigurationException;
import org.sosy_lab.common.configuration.Option;
import org.sosy_lab.common.configuration.Options;
import org.sosy_lab.cpachecker.cfa.ast.IASTExpressionAssignmentStatement;
import org.sosy_lab.cpachecker.cfa.ast.IASTIdExpression;
import org.sosy_lab.cpachecker.cfa.ast.IASTNode;
import org.sosy_lab.cpachecker.cfa.objectmodel.CFAEdge;
import org.sosy_lab.cpachecker.cfa.objectmodel.CFAEdgeType;
import org.sosy_lab.cpachecker.core.interfaces.AbstractElement;
import org.sosy_lab.cpachecker.core.reachedset.UnmodifiableReachedSet;
import org.sosy_lab.cpachecker.cpa.art.ARTElement;
import org.sosy_lab.cpachecker.cpa.art.ARTReachedSet;
import org.sosy_lab.cpachecker.cpa.relyguarantee.RelyGuaranteeAbstractElement.AbstractionElement;
import org.sosy_lab.cpachecker.cpa.relyguarantee.RelyGuaranteeCFAEdgeTemplate.ARTElementWrapper;
import org.sosy_lab.cpachecker.cpa.relyguarantee.RelyGuaranteeCFAEdgeTemplate.PathFormulaWrapper;
import org.sosy_lab.cpachecker.util.AbstractElements;
import org.sosy_lab.cpachecker.util.predicates.CachingPathFormulaManager;
import org.sosy_lab.cpachecker.util.predicates.PathFormula;
import org.sosy_lab.cpachecker.util.predicates.PathFormulaManagerImpl;
import org.sosy_lab.cpachecker.util.predicates.SSAMap;
import org.sosy_lab.cpachecker.util.predicates.interfaces.Formula;
import org.sosy_lab.cpachecker.util.predicates.interfaces.PathFormulaManager;
import org.sosy_lab.cpachecker.util.predicates.mathsat.MathsatFormulaManager;
import org.sosy_lab.cpachecker.util.predicates.mathsat.MathsatTheoremProver;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;

/**
 * Stores information about environmental edges.
 */
@Options(prefix="cpa.relyguarantee")
public class RelyGuaranteeEnvironment {
  @Option(name="symbolicCoverageCheck",description="Use a theorem prover to remove covered environemtal transitions" +
  " if false perform only a syntatic check for equivalence")
  private boolean checkEnvTransitionCoverage = true;

  @Option(description="List of variables global to multiple threads")
  protected String[] globalVariables = {};
  // TODO more efficient data structures
  // map from ART elements to unprocessed env transitions
  private final Multimap<ARTElement, RelyGuaranteeEnvironmentalTransition> unprocessedTransitions;
  // all rely guarantee transitions  generated by thread i that do not have to be processed again
  // for thread i envTransProcessedBeforeFromThread[i] is a multimap : source ART element -> generated env transitions
  //private final Multimap<ARTElement, RelyGuaranteeEnvironmentalTransition>[] envTransProcessedBeforeFromThread;
  // valid rely env edges generated by thread i
  private final Vector<RelyGuaranteeCFAEdgeTemplate>[] validEnvEdgesFromThread;
  // rely guarantee edges valid for thread i, that haven't been applied yet on the CFA
  // these edges should belong to some  validEnvEdgesFromThread[j], where j != i
  // this data structure is used for termination check
  private final Vector<RelyGuaranteeCFAEdgeTemplate>[] unappliedEnvEdgesForThread;
  // rely guarantee edges generated by thread i, that are covered by more general edges in appliedEnvEdgesFromThread[i]
  // the edges in appliedEnvEdgesForThread[i] cannot be in coveredEnvEdgesFromThread[i]

  //private final Vector<RelyGuaranteeCFAEdgeTemplate>[] coveredEnvEdgesFromThread;
  private final Set<RelyGuaranteeCFAEdgeTemplate>[] coveredEnvEdgesFromThread;
  // number of threads
  private int threadNo;

  // Managers
  private PathFormulaManager pfManager;
  private MathsatFormulaManager fManager;
  private MathsatTheoremProver tProver;

  // set of global variables
  private HashSet<String> globalVarsSet;

  public RelyGuaranteeEnvironment(int threadNo, Configuration config, LogManager logger){
    // TODO add option for caching
    MathsatFormulaManager msatFormulaManager;
    try {
      config.inject(this, RelyGuaranteeEnvironment.class);
      // set up managers
      msatFormulaManager = MathsatFormulaManager.getInstance(config, logger);
      fManager = msatFormulaManager;
      tProver = MathsatTheoremProver.getInstance(msatFormulaManager);
      PathFormulaManager pfMgr  = PathFormulaManagerImpl.getInstance(msatFormulaManager, config, logger);
      pfMgr = CachingPathFormulaManager.getInstance(pfMgr);
      pfManager = pfMgr;
    } catch (InvalidConfigurationException e) {
      e.printStackTrace();
    }

    // create a set of global variables
    globalVarsSet = new HashSet<String>();
    for (String var : globalVariables) {
      globalVarsSet.add(var);
    }

    this.threadNo = threadNo;
    unprocessedTransitions = HashMultimap.<ARTElement, RelyGuaranteeEnvironmentalTransition>create();
    //envTransProcessedBeforeFromThread = new Multimap[threadNo];
    validEnvEdgesFromThread = new Vector[threadNo];
    unappliedEnvEdgesForThread = new Vector[threadNo];
    coveredEnvEdgesFromThread = new HashSet[threadNo];

    for (int i=0; i< threadNo; i++){
      //envTransProcessedBeforeFromThread[i] = HashMultimap.<ARTElement, RelyGuaranteeEnvironmentalTransition>create();
      validEnvEdgesFromThread[i] = new Vector<RelyGuaranteeCFAEdgeTemplate>();
      unappliedEnvEdgesForThread[i] = new Vector<RelyGuaranteeCFAEdgeTemplate>();
      coveredEnvEdgesFromThread[i] = new HashSet<RelyGuaranteeCFAEdgeTemplate>();
    }
  }

  /**
   * Add new environmental transitions for processing.
   * @param pAElement
   * @param pNewEnvTransitions
   */
  public void addEnvTransitions(ARTElement aElement, Vector<RelyGuaranteeEnvironmentalTransition> newTransitions) {
    if (!newTransitions.isEmpty()){
      unprocessedTransitions.putAll(aElement, newTransitions);
    }
  }

  public void clearUnappliedEnvEdgesForThread(int i) {
    unappliedEnvEdgesForThread[i].removeAllElements();
  }

  public Multimap<ARTElement, RelyGuaranteeEnvironmentalTransition> getUnprocessedTransitions(){
    return unprocessedTransitions;
  }

  public void addNewEnvEgde(int j, RelyGuaranteeCFAEdgeTemplate edge) {
    unappliedEnvEdgesForThread[j].add(edge);
  }

  /*public void remberEnvTransitions(int i, Collection<RelyGuaranteeEnvironmentalTransition> values) {
    envTransProcessedBeforeFromThread[i].addAll(values);
  }*/

  public  List<RelyGuaranteeCFAEdgeTemplate> getValidEnvEdgesFromThread(int i) {
    return Collections.unmodifiableList(validEnvEdgesFromThread[i]);
  }

  public  List<RelyGuaranteeCFAEdgeTemplate> getUnappliedEnvEdgesForThread(int i) {
    return Collections.unmodifiableList(unappliedEnvEdgesForThread[i]);
  }

  public void printUnprocessedTransitions() {
    printTransitions("Enviornmental transitions generated:", unprocessedTransitions.values());
  }

  /**
   * Convert environmental transitions from thread i into relevant CFA edges.
   * Remove edges that are useless, have been applied before or are covered.
   * @param i   thread that generate the transitions
   */
  public void processEnvTransitions(int i) {
    syntacticCoverageCheck(i);
    // generate CFA edges from env transitions
    Vector<RelyGuaranteeCFAEdgeTemplate> rgEdges = new Vector<RelyGuaranteeCFAEdgeTemplate>();
    for (RelyGuaranteeEnvironmentalTransition  et: unprocessedTransitions.values()){
      //assert envTransProcessedBeforeFromThread[i].containsValue(et);
      Formula f = et.getFormula();
      PathFormula pf = et.getPathFormula();
      PathFormula newPF = pfManager.makeAnd(pf, f);
      //newPF = pfManager.normalize(newPF);
      RelyGuaranteeCFAEdgeTemplate rgEdge = new RelyGuaranteeCFAEdgeTemplate(et.getEdge(), newPF, et.getSourceThread(), et.getSourceARTElement(), et);
      rgEdges.add(rgEdge);
    }
    unprocessedTransitions.clear();

    if (checkEnvTransitionCoverage) {
      Pair<Vector<RelyGuaranteeCFAEdgeTemplate>, Vector<RelyGuaranteeCFAEdgeTemplate>> pair = semanticCoverageCheck(rgEdges, i);
      printEdges("New env. edges that are not covered:",pair.getFirst());
      printEdges("Old env. edges that are covered by some new ones:",pair.getSecond());
      rgEdges = pair.getFirst();
      // remove valid edges that have been covered
      validEnvEdgesFromThread[i].removeAll(pair.getSecond());
      // unapplied edges may also become covered
      for (int j=0; j<threadNo; j++){
        if (j != i){
          unappliedEnvEdgesForThread[j].removeAll(pair.getSecond());
        }
      }
    }
    // add the edges after filtering to the set of valid edges by thread i
    // add them to the set of unapplied edges for other threads
    validEnvEdgesFromThread[i].addAll(rgEdges);
    distributeAsUnapplied(rgEdges, i);
    printEdges("All valid env. edges from thread "+i+" after filtering", validEnvEdgesFromThread[i]);

    assertion();

  }


  private void assertion(){
    for (int i=0; i<threadNo; i++){
      // valid
      for (RelyGuaranteeCFAEdgeTemplate et : validEnvEdgesFromThread[i]){
        //assert envTransProcessedBeforeFromThread[i].containsValue(et.getSourceEnvTransition());
        if (coveredEnvEdgesFromThread[i].contains(et)){
          System.out.println("DEBUG: "+et+" thread "+i);
        }
        assert !coveredEnvEdgesFromThread[i].contains(et);
        assert !et.getSourceARTElement().isDestroyed();
        assert !et.getPathFormula().toString().contains("dummy");
        if (checkEnvTransitionCoverage){
          for (RelyGuaranteeCFAEdgeTemplate et2 : validEnvEdgesFromThread[i]){
            if (!(et == et2 || !isCovered(et, et2))) {
              System.out.println("DEBUG "+et+", "+et2);
            }
            assert et == et2 || !isCovered(et, et2);
          }
        }

      }
      // covered
      for (RelyGuaranteeCFAEdgeTemplate et3 : coveredEnvEdgesFromThread[i]){
        //assert envTransProcessedBeforeFromThread[i].containsValue(et3.getSourceEnvTransition());
        assert !validEnvEdgesFromThread[i].contains(et3);
        assert !et3.getPathFormula().toString().contains("dummy");
        if (et3.getSourceARTElement().isDestroyed()){
          System.out.println("DEBUG: "+et3);
        }
        assert !et3.getSourceARTElement().isDestroyed();
        assert et3.getCoveredBy()!=null;
        assert et3.getCoveredBy().getCovers().contains(et3);
        if (!validEnvEdgesFromThread[i].contains(et3.getCoveredBy()) &&  !coveredEnvEdgesFromThread[i].contains(et3.getCoveredBy())){
          System.out.println("DEBUG: "+et3+" covered by "+et3.getCoveredBy());
        }
        assert validEnvEdgesFromThread[i].contains(et3.getCoveredBy()) || coveredEnvEdgesFromThread[i].contains(et3.getCoveredBy());
      }
      // processed before
      /*for (ARTElement artElement: envTransProcessedBeforeFromThread[i].keySet()){
        assert !artElement.isDestroyed();
        for (RelyGuaranteeEnvironmentalTransition et : envTransProcessedBeforeFromThread[i].get(artElement)){
          assert artElement == et.getSourceARTElement();
        }
      }*/

    }
    // unapplied
    for (int j=0; j<threadNo; j++){
      for (RelyGuaranteeCFAEdgeTemplate et: this.unappliedEnvEdgesForThread[j]){
        boolean isValid = false;
        for (int i=0; i<threadNo; i++){
          if (i!=j){
            if (validEnvEdgesFromThread[i].contains(et)){
              isValid = true;
            }
          }
        }
        if (!isValid){
          System.out.println("DEBUG: "+et);
        }
        assert isValid;
        assert !et.getPathFormula().toString().contains("dummy");
        assert !et.getSourceARTElement().isDestroyed();
      }
    }
    // unprocessed
    for ( RelyGuaranteeEnvironmentalTransition et: this.unprocessedTransitions.values()){
      assert !et.getSourceARTElement().isDestroyed();
    }

  }
  /**
   * Print env. edges with a title.
   * @param string
   * @param rgEdges
   */
  private void printEdges(String string, List<RelyGuaranteeCFAEdgeTemplate> rgEdges) {
    System.out.println();
    if (rgEdges.isEmpty()){
      System.out.println(string+"\tnone");
    } else {
      System.out.println(string);
    }
    for (RelyGuaranteeCFAEdgeTemplate edge : rgEdges){
      System.out.println("\t-"+edge);
    }
  }

  /**
   * Print env. transitinos with a title.
   * @param string
   */
  private void printTransitions(String string, Collection<RelyGuaranteeEnvironmentalTransition> transitions) {
    System.out.println();
    if (transitions.isEmpty()){
      System.out.println(string+"\tnone");
    } else {
      System.out.println(string);
    }
    for (RelyGuaranteeEnvironmentalTransition tran : transitions){
      System.out.println("\t-"+tran);
    }
  }

  /**
   * Distributes env. edges as unapplied to threads other than i.
   * @param rgEdges
   * @param i
   */
  private void distributeAsUnapplied(List<RelyGuaranteeCFAEdgeTemplate> rgEdges, int i) {
    for (int j=0; j<threadNo; j++){
      if (j!=i){
        unappliedEnvEdgesForThread[j].addAll(rgEdges);
      }
    }
  }

  /**
   * Removes environmental transitions that have been produced before by thread i  or are obviously unnecessary.
   */
  private void syntacticCoverageCheck(int i) {
    Vector<Pair<ARTElement, RelyGuaranteeEnvironmentalTransition>> toDelete = new Vector<Pair<ARTElement, RelyGuaranteeEnvironmentalTransition>>();
    Vector<RelyGuaranteeEnvironmentalTransition> toPrint = new Vector<RelyGuaranteeEnvironmentalTransition>();

    for (ARTElement key : unprocessedTransitions.keySet()){
      for (RelyGuaranteeEnvironmentalTransition  et: unprocessedTransitions.get(key)){
        Formula f = et.getFormula();
        PathFormula pf = et.getPathFormula();
        CFAEdge localEdge = et.getEdge();
        // don't generate transition with 'false' or transitions that assign to local variables
        if (f.isFalse() || pf.getFormula().isFalse() || isLocalAssigment(localEdge)) {
          toDelete.add(Pair.of(key, et));
          System.out.println("Removed (syn,false): "+et);
        }

      }
    }
    for (Pair<ARTElement, RelyGuaranteeEnvironmentalTransition> pair: toDelete){
      unprocessedTransitions.remove(pair.getFirst(), pair.getSecond());
      toPrint.add(pair.getSecond());
    }

    printTransitions("Env. transitions removed by syntactick check:", toPrint);
  }



  /**
   * Return a pair of list.
   * The first list contains env. edges from newEdges that ARE NOT properly covered by any other edge in this list
   * or in validEnvEdgesFromThread[i].
   * The second list contains env. edges from validEnvEdgesFromThread[i] that ARE properly covered by some edge in newEdges.
   * @param rgEdges   set of new env edges generated by thread i
   * @param i         source thread
   */
  private Pair<Vector<RelyGuaranteeCFAEdgeTemplate>, Vector<RelyGuaranteeCFAEdgeTemplate>> semanticCoverageCheck(List<RelyGuaranteeCFAEdgeTemplate> newEdges, int i) {

    Vector<RelyGuaranteeCFAEdgeTemplate> toProcess = new Vector<RelyGuaranteeCFAEdgeTemplate>(newEdges);
    Vector<RelyGuaranteeCFAEdgeTemplate> toDelete = new Vector<RelyGuaranteeCFAEdgeTemplate>();


    // find the most general env. edges in toProcess. If edge2 is more general then edge1, but they are not equivalent,
    // then remember that edge2 covers edge1
    for (RelyGuaranteeCFAEdgeTemplate edge1 : toProcess){
      if (!toDelete.contains(edge1)){
        for (RelyGuaranteeCFAEdgeTemplate edge2 : toProcess){
          if (edge1 !=edge2 && !toDelete.contains(edge2)){
            if (isCovered(edge1,edge2)){
              // edge1 => edge2
              toDelete.add(edge1);
              System.out.println("Covered 0:\t"+edge1+" => "+edge2);
              edge1.coveredBy(edge2);
              coveredEnvEdgesFromThread[i].add(edge1);
              assert coveredEnvEdgesFromThread[i].contains(edge1);
              break;
            }
          }
        }
      }
    }

    toProcess.removeAll(toDelete);

    Vector<RelyGuaranteeCFAEdgeTemplate> list1 = new Vector<RelyGuaranteeCFAEdgeTemplate>(toProcess);
    Vector<RelyGuaranteeCFAEdgeTemplate> list2 = new Vector<RelyGuaranteeCFAEdgeTemplate>();

    for (RelyGuaranteeCFAEdgeTemplate edge1 : newEdges){
      for (RelyGuaranteeCFAEdgeTemplate edge2 : toProcess){
        assert edge1 == edge2 || !isCovered(edge2,edge1)  ||  isCovered(edge2,edge1);
      }
    }
    for (RelyGuaranteeCFAEdgeTemplate edge1 : toProcess){
      for (RelyGuaranteeCFAEdgeTemplate edge2 : toProcess){
        assert edge1 == edge2 || !isCovered(edge2,edge1);
      }
    }

    while (!toProcess.isEmpty()){
      RelyGuaranteeCFAEdgeTemplate newEdge = toProcess.remove(0);
      for (RelyGuaranteeCFAEdgeTemplate oldEdge : validEnvEdgesFromThread[i]){
        assert newEdge != oldEdge;
        if (isCovered(newEdge, oldEdge)){
          System.out.println("Covered 1:\t"+newEdge+" => "+oldEdge);
          newEdge.coveredBy(oldEdge);
          coveredEnvEdgesFromThread[i].add(newEdge);
          list1.remove(newEdge);
          break;
        } else if (isCovered(oldEdge, newEdge)){
          // oldEdge => newEdge, but not equivalent
          System.out.println("Covered 2:\t"+oldEdge+" => "+newEdge);
          oldEdge.coveredBy(newEdge);
          coveredEnvEdgesFromThread[i].add(oldEdge);
          list2.add(oldEdge);
        }
      }
    }




    for (RelyGuaranteeCFAEdgeTemplate edge1  : list1){
      for (RelyGuaranteeCFAEdgeTemplate edge2  : newEdges){
        assert edge1 == edge2 || !isCovered(edge1,edge2) ||  isCovered(edge2,edge1);
      }
      for (RelyGuaranteeCFAEdgeTemplate edge2  : validEnvEdgesFromThread[i]){
        assert  !isCovered(edge1,edge2);
      }
    }
    for (RelyGuaranteeCFAEdgeTemplate edge1  : list2){
      boolean covered = false;
      assert validEnvEdgesFromThread[i].contains(edge1);
      for (RelyGuaranteeCFAEdgeTemplate edge2  : list1){
        covered = covered || isCovered(edge1, edge2);
      }
      assert covered;
    }


    return Pair.of(list1, list2);
  }

  /**
   * Returns true if env1 => env2, sound but not complete
   */
  public boolean isCovered(RelyGuaranteeCFAEdgeTemplate env1, RelyGuaranteeCFAEdgeTemplate env2) {
    if (env1.equals(env2)){
      return true;
    }
    if (!env1.getLocalEdge().equals(env2.getLocalEdge())){
      return false;
    }
    Formula f1 = env1.getPathFormula().getFormula();
    Formula f2 = env2.getPathFormula().getFormula();
    SSAMap s1 = env1.getPathFormula().getSsa();
    SSAMap s2 = env2.getPathFormula().getSsa();
    if (f1.isFalse() || f2.isTrue()) {
      return true;
    }

    Formula nImpl = fManager.makeAnd(f1, fManager.makeNot(f2));
    tProver.init();
    try {
      return tProver.isUnsat(nImpl);
    } finally {
      tProver.reset();
    }
  }

  /**
   * Returns true iff edge is an assignment to a non-global variable
   */
  private boolean isLocalAssigment(CFAEdge edge) {
    String var = getLhsVariable(edge);
    if (var != null && !globalVarsSet.contains(var)){
      return true;
    }
    return false;
  }

  /**
   * Get the variable in the lhs of an expression or return null
   */
  private String getLhsVariable(CFAEdge edge){
    IASTNode node = edge.getRawAST();
    if (node instanceof IASTExpressionAssignmentStatement) {
      IASTExpressionAssignmentStatement stmNode = (IASTExpressionAssignmentStatement) node;
      if (stmNode.getLeftHandSide() instanceof IASTIdExpression) {
        IASTIdExpression idExp = (IASTIdExpression) stmNode.getLeftHandSide();
        return new String(idExp.getName());
      }
    }
    return null;
  }

  /**
   * reachedElement elements has been merged into mergedElement, therefore adjust the source elements.
   * @param mergedElement
   * @param reachedElement
   */
  public void mergeSourceElements(ARTElement mergedElement, ARTElement reachedElement, int i) {
    assert reachedElement.isDestroyed();
    assert !mergedElement.isDestroyed();
    // valid
    for(RelyGuaranteeCFAEdgeTemplate rgEdge : validEnvEdgesFromThread[i]){
      ARTElementWrapper wrapper = rgEdge.getSourceARTElementWrapper();
      if (wrapper.getArtElement() == reachedElement){
        wrapper.setArtElement(mergedElement);
        System.out.println("! Replaced id:"+reachedElement.getElementId()+" by id:"+mergedElement.getElementId()+" in a valid edge: "+rgEdge);
      }
    }
    // covered
    for(RelyGuaranteeCFAEdgeTemplate rgEdge : coveredEnvEdgesFromThread[i]){
      ARTElementWrapper wrapper = rgEdge.getSourceARTElementWrapper();
      if (wrapper.getArtElement() == reachedElement){
        wrapper.setArtElement(mergedElement);
        System.out.println("! Replaced id:"+reachedElement.getElementId()+" by id:"+mergedElement.getElementId()+" in a covered edge: "+rgEdge);
      }
    }
    // processed before
    /* Collection<RelyGuaranteeEnvironmentalTransition> eTransitions = envTransProcessedBeforeFromThread[i].get(reachedElement);
    for (RelyGuaranteeEnvironmentalTransition et : eTransitions){
      et.setSourceARTElement(mergedElement);
      envTransProcessedBeforeFromThread[i].put(mergedElement, et);
    }*/
    // envTransProcessedBeforeFromThread[i].removeAll(reachedElement);
    // unproccessed
    Collection<RelyGuaranteeEnvironmentalTransition> eTransitions = unprocessedTransitions.get(reachedElement);
    for (RelyGuaranteeEnvironmentalTransition et : eTransitions){
      et.setSourceARTElement(mergedElement);
      unprocessedTransitions.put(mergedElement, et);
      System.out.println("! Replaced id:"+reachedElement.getElementId()+" by id:"+mergedElement.getElementId()+" in unprocesseds transition: "+et);
    }
    unprocessedTransitions.removeAll(reachedElement);

    assertion();
  }

  /**
   * Looks for env. edges generated in threads on the list and checks if their source elements have been destroyed.
   * Their  path formula is set to false and they are not
   * valid any more. Transitions covered by them will be valid again, unless they have also been  killed.
   * @param artReachedSets
   * @param tid
   */
  public void killEnvironmetalEdges(Iterable<Integer> tids, ARTReachedSet[] artReachedSets) {
    System.out.println();
    System.out.println("\t\t\t ----- Killing environemtal edges ------");
    for (Integer tid : tids){
      // remove covered transitions that belong to the subtree
      killCovered(tid);
      // kill valid and processed env. edges
      killValid(tid);
    }
    // propagate drop trees
    Set<Integer> dropped = dropApplications(artReachedSets);
    while (!dropped.isEmpty()){
      for (Integer tid : dropped){
        // remove covered transitions that belong to the subtree
        killCovered(tid);
        // kill valid and processed env. edges
        killValid(tid);
      }
      dropped = dropApplications(artReachedSets);
    }



    // kill unapplied  env. edges
    killUnapplied();
    // drop unprocess transitions that were generated in the subtree
    removeUnprocessedTransitionsFromElement();




    assertion();
  }

  /**
   * For every covered env. edge from thread i, whose source element has been destroyed:
   * - remove them for the list
   * - push one level up env. edges that they cover
   * - make them false
   * - remove from envTransProcessedBeforeFromThread so it can be generated again
   * @param pRoot
   */
  private void killCovered(int tid) {
    Vector<RelyGuaranteeCFAEdgeTemplate> toDelete = new Vector<RelyGuaranteeCFAEdgeTemplate>();
    for (RelyGuaranteeCFAEdgeTemplate rgEdge : coveredEnvEdgesFromThread[tid]){
      if (rgEdge.getSourceARTElement().isDestroyed()){
        // rgEdge belongs to a dropped subtree
        //removeFromProcessedBefore(rgEdge, tid);
        toDelete.add(rgEdge);
        rgEdge.recoverChildren();

        makeRelyGuaranteeEnvEdgeFalse(rgEdge);
      }
    }
    printEdges("Covered env. edge kill in thread "+tid+" :",toDelete);
    coveredEnvEdgesFromThread[tid].removeAll(toDelete);

    for (RelyGuaranteeCFAEdgeTemplate rgEdge : coveredEnvEdgesFromThread[tid]){
      assert !rgEdge.getSourceARTElement().isDestroyed();
    }
  }

  /**
   * For every valid env. edge from thread i, whose source element has been destroyed:
   * - remove from the list
   * - make them false
   * - revert covered transitions
   * - remove from envTransProcessedBeforeFromThread so it can be generated again
   * @param root
   * @param tid
   * @param artReachedSets
   */
  private void killValid(int tid) {
    Vector<RelyGuaranteeCFAEdgeTemplate> toDelete = new Vector<RelyGuaranteeCFAEdgeTemplate>();
    for (RelyGuaranteeCFAEdgeTemplate rgEdge : validEnvEdgesFromThread[tid]){
      if (rgEdge.getSourceARTElement().isDestroyed()){
        // rgEdge belongs to the dropped subtree
        //removeFromProcessedBefore(rgEdge, tid);
        toDelete.add(rgEdge);
        makeRelyGuaranteeEnvEdgeFalse(rgEdge);
      }
    }
    printEdges("Valid env. edge killed in thread "+tid+" :",toDelete);

    validEnvEdgesFromThread[tid].removeAll(toDelete);
    // see if some transitions that were covered by rgEdge can become valid
    // they could be covered by some other valid transition
    for (RelyGuaranteeCFAEdgeTemplate rgEdge : toDelete){
      List<RelyGuaranteeCFAEdgeTemplate> covered = new Vector<RelyGuaranteeCFAEdgeTemplate>(rgEdge.getCovers());
      rgEdge.unvalidateEdge();

      Pair<Vector<RelyGuaranteeCFAEdgeTemplate>, Vector<RelyGuaranteeCFAEdgeTemplate>> pair = semanticCoverageCheck(covered, tid);
      validEnvEdgesFromThread[tid].addAll(pair.getFirst());
      validEnvEdgesFromThread[tid].removeAll(pair.getSecond());
      coveredEnvEdgesFromThread[tid].removeAll(pair.getFirst());
      distributeAsUnapplied(pair.getFirst(), tid);
      if (!pair.getFirst().isEmpty()){
        System.out.println();
      }
      printEdges("Env edge uncovered after  "+rgEdge+":", pair.getFirst());
    }

    for (RelyGuaranteeCFAEdgeTemplate rgEdge : toDelete){
      assert !validEnvEdgesFromThread[tid].contains(toDelete);
    }
    for (RelyGuaranteeCFAEdgeTemplate rgEdge : validEnvEdgesFromThread[tid]){
      assert !rgEdge.getSourceARTElement().isDestroyed();
      assert !rgEdge.getPathFormula().toString().contains("dummy");
      assert !coveredEnvEdgesFromThread[tid].contains(rgEdge);
    }

  }

  /**
   * For every unapplied env. edge, whose source element has been destroyed:
   * - it removes it from the set
   * @param root
   * @param tid
   */
  private void killUnapplied() {
    Vector<RelyGuaranteeCFAEdgeTemplate> toDelete = new Vector<RelyGuaranteeCFAEdgeTemplate>();
    for(int j=0; j<threadNo; j++){
      for (RelyGuaranteeCFAEdgeTemplate rgEdge : unappliedEnvEdgesForThread[j]){
        if (rgEdge.getSourceARTElement().isDestroyed()){
          // rgEdge belongs to the dropped subtree
          toDelete.add(rgEdge);
        }
      }
      unappliedEnvEdgesForThread[j].removeAll(toDelete);
      printEdges("Unapplied env. edge killed in thread "+j+" :",toDelete);
      toDelete.clear();
    }
  }



  private Set<Integer> dropApplications(ARTReachedSet[] artReachedSets) {
    //List<Pair<Integer, ARTElement>> toDrop = new Vector<Pair<Integer, ARTElement>>();
    Multimap<Integer, ARTElement> toDrop = HashMultimap.create();
    for (int i=0; i<threadNo; i++){
      UnmodifiableReachedSet reached = artReachedSets[i].asReachedSet();
      for (AbstractElement element : reached){
        ARTElement artElement = (ARTElement) element;
        RelyGuaranteeAbstractElement rgElement = AbstractElements.extractElementByType(artElement, RelyGuaranteeAbstractElement.class);
        if (rgElement instanceof AbstractionElement){
          CFAEdge edge = rgElement.getParentEdge();
          if (edge != null && edge.getEdgeType() == CFAEdgeType.RelyGuaranteeCFAEdge ){
            RelyGuaranteeCFAEdge rgEdge = (RelyGuaranteeCFAEdge) edge;
            ARTElement source = rgEdge.getSourceARTElement();
            if (source.isDestroyed()){
              /// drop it
              toDrop.put(i, artElement);
            }
          }
        }
      }
    }

    System.out.println();
    System.out.println("Removing subtree because of dead env. edges:");
    for (Integer tid : toDrop.keySet()){
      for (ARTElement artElement : toDrop.get(tid)){
        System.out.println("- ART element id:"+artElement.getElementId()+" in thread "+tid);
        if (!artElement.isDestroyed()){
          artReachedSets[tid].removeSubtree(artElement);
        }
      }
    }

    return toDrop.keySet();
  }


  /**
   * Removes rgEdge generated by thread i from the list of edges that do not have to be processed.
   * @param rgEdge
   * @param tid
   */
  /*private void removeFromProcessedBefore(RelyGuaranteeCFAEdgeTemplate rgEdge , int tid) {
    RelyGuaranteeEnvironmentalTransition et = rgEdge.getSourceEnvTransition();
    ARTElement artElement = rgEdge.getSourceARTElement();
    boolean changed = envTransProcessedBeforeFromThread[tid].remove(artElement, et);
    if (!changed){
      System.out.println("DEBUG: "+et+" from element id:"+et.getSourceARTElement().getElementId());
    }
    assert changed;
  }*/





  /**
   * All env edges created from rgEdge will have a false path formula and a null source ART element.
   * @param rgEdge
   */
  private void makeRelyGuaranteeEnvEdgeFalse(RelyGuaranteeCFAEdgeTemplate rgEdge){
    //System.out.println("---> Made false "+rgEdge);
    PathFormula falsePathFormula = pfManager.makeFalsePathFormula();
    PathFormulaWrapper pfw = rgEdge.getPathFormulaWrapper();
    ARTElementWrapper aew = rgEdge.getSourceARTElementWrapper();
    assert !pfw.getPathFormula().getFormula().isFalse();
    assert aew.getArtElement() != null;
    pfw.setPathFormula(falsePathFormula);
    //aew.setARTElement(null);
  }

  /**
   * Removes all unprocessed environmental transitions that belong to subtree root at the specified element.
   * @param root
   */
  public void removeUnprocessedTransitionsFromElement() {
    Set<ARTElement> toDelete = new HashSet<ARTElement>();
    for (ARTElement element : unprocessedTransitions.keys()){
      if (element.isDestroyed()){
        toDelete.add(element);
      }
    }
    for (ARTElement element : toDelete){
      System.out.println("Killing unprocessed transitions at "+element.getElementId());
      unprocessedTransitions.removeAll(element);
    }
  }



}
