/*
 *  CPAchecker is a tool for configurable software verification.
 *  This file is part of CPAchecker.
 *
 *  Copyright (C) 2007-2011  Dirk Beyer
 *  All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *
 *  CPAchecker web page:
 *    http://cpachecker.sosy-lab.org
 */
package org.sosy_lab.cpachecker.cpa.relyguarantee.environment;

import java.io.PrintStream;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.Vector;

import org.sosy_lab.common.LogManager;
import org.sosy_lab.common.Pair;
import org.sosy_lab.common.Timer;
import org.sosy_lab.common.configuration.Configuration;
import org.sosy_lab.common.configuration.InvalidConfigurationException;
import org.sosy_lab.common.configuration.Option;
import org.sosy_lab.common.configuration.Options;
import org.sosy_lab.cpachecker.cfa.objectmodel.CFANode;
import org.sosy_lab.cpachecker.core.CPAcheckerResult.Result;
import org.sosy_lab.cpachecker.core.interfaces.Statistics;
import org.sosy_lab.cpachecker.core.interfaces.StatisticsProvider;
import org.sosy_lab.cpachecker.core.reachedset.ReachedSet;
import org.sosy_lab.cpachecker.cpa.art.ARTElement;
import org.sosy_lab.cpachecker.cpa.relyguarantee.RGAbstractElement.AbstractionElement;
import org.sosy_lab.cpachecker.cpa.relyguarantee.RGAbstractionManager;
import org.sosy_lab.cpachecker.cpa.relyguarantee.RGVariables;
import org.sosy_lab.cpachecker.cpa.relyguarantee.environment.transitions.RGEnvCandidate;
import org.sosy_lab.cpachecker.cpa.relyguarantee.environment.transitions.RGEnvTransition;
import org.sosy_lab.cpachecker.util.AbstractElements;
import org.sosy_lab.cpachecker.util.predicates.AbstractionManagerImpl;
import org.sosy_lab.cpachecker.util.predicates.AbstractionPredicate;
import org.sosy_lab.cpachecker.util.predicates.CachingPathFormulaManager;
import org.sosy_lab.cpachecker.util.predicates.PathFormulaManagerImpl;
import org.sosy_lab.cpachecker.util.predicates.SSAMapManagerImpl;
import org.sosy_lab.cpachecker.util.predicates.bdd.BDDRegionManager;
import org.sosy_lab.cpachecker.util.predicates.interfaces.PathFormulaManager;
import org.sosy_lab.cpachecker.util.predicates.interfaces.RegionManager;
import org.sosy_lab.cpachecker.util.predicates.interfaces.SSAMapManager;
import org.sosy_lab.cpachecker.util.predicates.mathsat.MathsatFormulaManager;
import org.sosy_lab.cpachecker.util.predicates.mathsat.MathsatTheoremProver;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.SetMultimap;

/**
 * Stores information about environmental edges.
 */
@Options(prefix="cpa.rg")
public class RGEnvironmentManager implements StatisticsProvider{

  @Option(description="Print debugging info?")
  private boolean debug=false;

  @Option(toUppercase=true, values={"FA", "SA", "ST"},
          description="How to abstract environmental transitions:"
          + "ST - no abstraction, SA - precondition abstracted only, FA - precondition and operation abstracted")
  private String abstractEnvTransitions = "FA";


  // Statitics about processing env. transitions
  private RelyGuaranteeEnvironmentProcessStatistics processStats;
  // general statics
  public final Stats stats;

  // number of threads
  private int threadNo;
  // unprocessed candidate for env transitions
  private final Vector<RGEnvCandidate> candidates;
  // all rely guarantee transitions  generated by thread i that do not have to be processed again
  // for thread i envTransProcessedBeforeFromThread[i] is a multimap : source ART element -> generated env transitions
  //private final Multimap<ARTElement, RelyGuaranteeEnvironmentalTransition>[] envTransProcessedBeforeFromThread;
  // valid rely env edges generated by thread i
  private final Vector<RGEnvTransition>[] validEnvEdgesFromThread;
  // rely guarantee edges valid for thread i, that haven't been applied yet on the CFA
  // these edges should belong to some  validEnvEdgesFromThread[j], where j != i
  // this data structure is used for termination check
  private final Vector<RGEnvTransition>[] unappliedEnvEdgesForThread;
  // envPrecision[i] are predicates for generating env. edges from thread i.
  private final SetMultimap<CFANode, AbstractionPredicate>[] envPrecision;
  // envGlobalPrecision[i] contains global env. predicates for thread i
  private final Set<AbstractionPredicate>[] envGlobalPrecision;
  // information about variables in threads
  private final RGVariables variables;

  // Managers
  private final PathFormulaManager pfManager;
  private final MathsatFormulaManager fManager;
  private final MathsatTheoremProver tProver;
  private final RGAbstractionManager absManager;
  private final RegionManager rManager;
  private final AbstractionManagerImpl amManager;
  private final SSAMapManager ssaManager;
  private final RGEnvTransitionManager etManager;
  private final RGEnvCandidateManager candManager;

  public RGEnvironmentManager(int threadNo, RGVariables vars, Configuration config, LogManager logger) throws InvalidConfigurationException{
    // TODO add option for caching
    config.inject(this, RGEnvironmentManager.class);

    this.threadNo = threadNo;
    this.candidates = new Vector<RGEnvCandidate>();
    this.validEnvEdgesFromThread = new Vector[threadNo];
    this.unappliedEnvEdgesForThread = new Vector[threadNo];
    this.envPrecision = new SetMultimap[threadNo];
    this.envGlobalPrecision = new HashSet[threadNo];
    this.variables = vars;
    this.stats = new Stats();

    // set up managers
    MathsatFormulaManager msatFormulaManager;
    this.rManager = BDDRegionManager.getInstance();
    msatFormulaManager = MathsatFormulaManager.getInstance(config, logger);
    this.fManager = msatFormulaManager;
    this.tProver = MathsatTheoremProver.getInstance(msatFormulaManager);
    PathFormulaManager pfMgr  = PathFormulaManagerImpl.getInstance(msatFormulaManager, config, logger);
    pfMgr = CachingPathFormulaManager.getInstance(pfMgr);
    this.pfManager = pfMgr;
    RegionManager rManager = BDDRegionManager.getInstance();
    this.absManager = RGAbstractionManager.getInstance(rManager, fManager, pfMgr, tProver, config, logger);
    this.amManager = AbstractionManagerImpl.getInstance(rManager, msatFormulaManager, pfManager, config, logger);
    this.ssaManager = SSAMapManagerImpl.getInstance(fManager, config, logger);
    this.etManager  = RGEnvTransitionManagerFactory.getInstance(abstractEnvTransitions, fManager, pfManager, absManager, ssaManager, tProver, rManager, variables, config, logger);
    this.candManager = new RGEnvCandidateManager(fManager, pfManager, absManager, ssaManager, tProver, rManager, variables, config, logger);

    for (int i=0; i< threadNo; i++){
      //envTransProcessedBeforeFromThread[i] = HashMultimap.<ARTElement, RelyGuaranteeEnvironmentalTransition>create();
      this.validEnvEdgesFromThread[i] = new Vector<RGEnvTransition>();
      this.unappliedEnvEdgesForThread[i] = new Vector<RGEnvTransition>();
      this.envPrecision[i] = HashMultimap.create();
      this.envGlobalPrecision[i] = new HashSet<AbstractionPredicate>();
    }


  }



  public int getThreadNo() {
    return threadNo;
  }

  public void setThreadNo(int pThreadNo) {
    threadNo = pThreadNo;
  }

  public RGVariables getVariables() {
    return variables;
  }

  public PathFormulaManager getPfManager() {
    return pfManager;
  }

  public MathsatFormulaManager getfManager() {
    return fManager;
  }

  public MathsatTheoremProver gettProver() {
    return tProver;
  }



  public RegionManager getrManager() {
    return rManager;
  }



  public AbstractionManagerImpl getAbsManager() {
    return amManager;
  }

  /**
   * Add new environmental transitions for processing.
   * @param pAElement
   * @param pNewEnvTransitions
   */
  public void addEnvTransitions(Collection<? extends RGEnvCandidate> newTransitions) {
    if (!newTransitions.isEmpty()){
      candidates.addAll(newTransitions);
    }
  }

  public void addEnvTransition(RGEnvCandidate newTransition) {
    candidates.add(newTransition);
  }

  public void clearCandidates(){
    candidates.clear();
  }

  public void clearUnappliedEnvEdgesForThread(int i) {
    unappliedEnvEdgesForThread[i].removeAllElements();
  }

  public Vector<RGEnvCandidate> getUnprocessedTransitions(){
    return candidates;
  }

  public void addNewEnvEgde(int j, RGEnvTransition edge) {
    unappliedEnvEdgesForThread[j].add(edge);
  }


  public  List<RGEnvTransition> getValidEnvEdgesFromThread(int i) {
    return Collections.unmodifiableList(validEnvEdgesFromThread[i]);
  }

  public  List<RGEnvTransition> getUnappliedEnvEdgesForThread(int i) {
    return Collections.unmodifiableList(unappliedEnvEdgesForThread[i]);
  }




  public void printUnprocessedTransitions() {
    printTransitions("Enviornmental transitions generated:", candidates);
  }

  /**
   * Return the stats of {@link processEnvTransitions} since the last {@link resetProcessStats}.
   * @return
   */
  public RelyGuaranteeEnvironmentProcessStatistics getProcessStats() {
    return processStats;
  }

  /**
   * Resets the stats of {@link processEnvTransitions}.
   */
  public void resetProcessStats(){
    processStats = null;
  }


  /**
   * Converts  unprocessed candidates from thread i into environmental transitions.
   * The most general transitions are remebered as valid and unapplied for other threads.
   * @param i   thread that generated the transitions
   */
  public void processCandidates(int i) {
    if (processStats == null){
      processStats = new RelyGuaranteeEnvironmentProcessStatistics();
    }
    processStats.totalTimer.start();
    stats.totalTimer.start();
    processStats.candidates = candidates.size();
    stats.allCandidates += candidates.size();;

    Vector<RGEnvCandidate> gCandidates = findMostGeneralCandidates(candidates);

    // abstract the candidates
    Vector<RGEnvTransition> newEnv   = new Vector<RGEnvTransition>(gCandidates.size());
    for (RGEnvCandidate cand : gCandidates){
      RGEnvTransition et = etManager.generateEnvTransition(cand, envGlobalPrecision[i], envPrecision[i]);
      newEnv.add(et);
    }

    newEnv = findMostGeneralTransitions(newEnv);

    // compare new and old transitions
    Pair<Vector<RGEnvTransition>, Vector<RGEnvTransition>> pair = semanticCoverageCheck(newEnv, i);

    // env. edges that are not properly covered by any valid edge or another edge in newValid
    Vector<RGEnvTransition> newValid = pair.getFirst();
    // valid env. edges that are properly covered by some edge in newValid
    Vector<RGEnvTransition> oldCovered = pair.getSecond();
    processStats.newValid = newValid.size();
    stats.allNew += newValid.size();

    if (debug){
      printEdges("New env. edges that are not covered:",newValid);
      printEdges("Old env. edges that are covered by some new ones:",oldCovered);
    }

    // remove valid edges that have been covered
    validEnvEdgesFromThread[i].removeAll(oldCovered);
    // unapplied edges may also become covered
    for (int j=0; j<threadNo; j++){
      if (j != i){
        unappliedEnvEdgesForThread[j].removeAll(oldCovered);
      }
    }

    // add the edges after filtering to the set of valid edges by thread i
    // add them to the set of unapplied edges for other threads
    validEnvEdgesFromThread[i].addAll(newValid);
    processStats.allValid = validEnvEdgesFromThread[i].size();
    stats.maxValid = Math.max(stats.maxValid, validEnvEdgesFromThread[i].size());
    distributeAsUnapplied(newValid, i);

    if (debug){
      printEdges("All valid env. edges from thread "+i+" after filtering", validEnvEdgesFromThread[i]);
    }

    stats.totalTimer.stop();
    processStats.totalTimer.stop();
  }

  /**
   * Print env. edges with a title.
   * @param string
   * @param rgEdges
   */
  private void printEdges(String string, List<RGEnvTransition> rgEdges) {
    //System.out.println();
    if (rgEdges.isEmpty()){
      System.out.println(string+"\tnone");
    } else {
      System.out.println(string);
    }
    for (RGEnvTransition edge : rgEdges){
      System.out.println("\t-"+edge);
    }
  }

  /**
   * Print env. transitinos with a title.
   * @param string
   */
  private void printTransitions(String string, Vector<RGEnvCandidate> pUnprocessedTransitions) {
    System.out.println();
    if (pUnprocessedTransitions.isEmpty()){
      System.out.println(string+"\tnone");
    } else {
      System.out.println(string);
    }
    for (RGEnvCandidate tran : pUnprocessedTransitions){
      System.out.println("\t-"+tran);
    }
  }

  /**
   * Distributes env. edges as unapplied to threads other than i.
   * @param pNewValid
   * @param i
   */
  private void distributeAsUnapplied(Vector<RGEnvTransition> pNewValid, int i) {
    for (int j=0; j<threadNo; j++){
      if (j!=i){
        unappliedEnvEdgesForThread[j].addAll(pNewValid);
      }
    }
  }

  /**
   * Find the most general elements from the set of candidates using the comparator.
   * @param candidates
   * @return
   */
  private Vector<RGEnvCandidate> findMostGeneralCandidates(List<RGEnvCandidate> candidates) {

    // candidates to be inspected
    Vector<RGEnvCandidate> cndToProcess = new Vector<RGEnvCandidate>(candidates);
    // candidate that are covered or false
    Vector<RGEnvCandidate> cndCovered = new Vector<RGEnvCandidate>();

    /* find the most general candidates by comparing them */
    for (RGEnvCandidate cnd1 : cndToProcess){
      if (!cndCovered.contains(cnd1)){
        for (RGEnvCandidate cnd2 : cndToProcess){
          if (cnd1 !=cnd2 && !cndCovered.contains(cnd2)){
            if (candManager.isLessOrEqual(cnd1, cnd2)){
              // edge1 => edge2
              if (debug){
                System.out.println("\t-covered: "+cnd1+" => "+cnd2);
              }
              cndCovered.add(cnd1);
              break;
            }
          }
        }
      }
    }

    cndToProcess.removeAll(cndCovered);

    /* if there is only one element, the check if its not bottom */
    if (cndToProcess.size() == 1){
      RGEnvCandidate cnd = cndToProcess.get(0);
      if (candManager.isBottom(cnd)){
        cndToProcess.clear();
      }
    }

    /* sanity check on request */
    if (debug){
      // for every input candidate there exist an candidate in cndToProcess that is greater or equal
      for (RGEnvCandidate cand1 : candidates){
        boolean existsGeq = false;
        for (RGEnvCandidate cand2 : cndToProcess){
          if (candManager.isLessOrEqual(cand1, cand2)){
            existsGeq = true;
            break;
          }
        }
        assert existsGeq;
      }

      // among the candidates in cndToProcess none is less or equal than other
      for (RGEnvCandidate cand1 : cndToProcess){
        for (RGEnvCandidate cand2 : cndToProcess){
          assert cand1 == cand2 || !candManager.isLessOrEqual(cand1, cand2);
        }
      }
    }

    return  cndToProcess;
  }




  /**
   * Find the most general elements from the set of candidates using the comparator.
   * @param newEnv
   * @return
   */
  private Vector<RGEnvTransition> findMostGeneralTransitions(Vector<RGEnvTransition> newEnv) {

    // candidates to be inspected
    Vector<RGEnvTransition> etToProcess = new Vector<RGEnvTransition>(newEnv);
    // candidate that are covered or false
    Vector<RGEnvTransition> etCovered = new Vector<RGEnvTransition>();

    /* find the most general candidates by comparing them */
    for (RGEnvTransition et1 : etToProcess){
      if (!etCovered.contains(et1)){
        for (RGEnvTransition et2 : etToProcess){
          if (et1 !=et2 && !etCovered.contains(et2)){
            if (etManager.isLessOrEqual(et1, et2)){
              // edge1 => edge2
              if (debug){
                System.out.println("Covered 0:\t"+et1+" => "+et2);
              }
              etCovered.add(et1);
              break;
            }
          }
        }
      }
    }

    etToProcess.removeAll(etCovered);

    /* sanity check on request */
    if (debug){
      for (RGEnvTransition edge1 : newEnv){
        for (RGEnvTransition edge2 : etToProcess){
          assert edge1 == edge2 || !etManager.isLessOrEqual(edge2,edge1)  ||  etManager.isLessOrEqual(edge2,edge1);
        }
      }
      for (RGEnvTransition edge1 : etToProcess){
        for (RGEnvTransition edge2 : etToProcess){
          assert edge1 == edge2 || !etManager.isLessOrEqual(edge2,edge1);
        }
      }
    }

    return  etToProcess;
  }



  /**
   * Return a pair of list.
   * The first list contains env. transitions from newTransitions that aren't properly covered by any transition
   * in validEnvEdgesFromThread[i]. The second list contains env. edges from validEnvEdgesFromThread[i] that are
   * properly covered by some edge in newEdges.
   * @param rgEdges   set of new env edges generated by thread i
   * @param i         source thread
   */
  private Pair<Vector<RGEnvTransition>, Vector<RGEnvTransition>> semanticCoverageCheck(Vector<RGEnvTransition> newEnv, int i) {
    Vector<RGEnvTransition> toProcess  = new Vector<RGEnvTransition>(newEnv);
    Vector<RGEnvTransition> newValid   = new Vector<RGEnvTransition>(newEnv);
    Vector<RGEnvTransition> oldCovered = new Vector<RGEnvTransition>();

    // TODO improve
    for (RGEnvTransition newEdge : toProcess){
      for (RGEnvTransition oldEdge : validEnvEdgesFromThread[i]){
        if (oldCovered.contains(oldEdge)){
          continue;
        }
        assert newEdge != oldEdge;
        if (etManager.isLessOrEqual(newEdge, oldEdge)){
          // newEdge => oldEdge
          if (debug){
            System.out.println("Covered :\t"+newEdge+" => "+oldEdge);
          }
          newValid.remove(newEdge);
          break;
        } else if (etManager.isLessOrEqual(oldEdge, newEdge)){
          // oldEdge => newEdge, but not oldEdge <= newEdge
          if (debug){
            System.out.println("Covered :\t"+oldEdge+" => "+newEdge);
          }
          oldCovered.add(oldEdge);
        }
      }
    }

    // sanity check on request
    if (debug){
      for (RGEnvTransition edge1  : newValid){
        for (RGEnvTransition edge2  : validEnvEdgesFromThread[i]){
          assert  !etManager.isLessOrEqual(edge1,edge2);
        }
      }
      for (RGEnvTransition edge1  : oldCovered){
        boolean covered = false;
        assert validEnvEdgesFromThread[i].contains(edge1);
        for (RGEnvTransition edge2  : newValid){
          covered = covered || etManager.isLessOrEqual(edge1, edge2);
        }
        assert covered;
      }
    }
    return Pair.of(newValid, oldCovered);
  }


  public void cleanEnvironment(int tid) {
    // TODO works only for two threads
    int other = tid==0 ? 1 : 0;
    unappliedEnvEdgesForThread[other].clear();
    validEnvEdgesFromThread[tid].clear();
  }

  public void resetEnvironment() {
    for (int i=0; i<threadNo; i++){
      unappliedEnvEdgesForThread[i].clear();
      validEnvEdgesFromThread[i].clear();
    }
    candidates.clear();
  }

  /**
   * Finds the next descendant in the ART that is a rely-guarantee abstraction.
   * Returns the argument if it is an abstraction.
   * @param element
   * @return
   */
  private ARTElement findNextAbstractionARTElement(ARTElement element) {

    ARTElement naARTElement = null;
    Deque<ARTElement> toProcess = new LinkedList<ARTElement>();
    Set<ARTElement> visisted = new HashSet<ARTElement>();
    toProcess.add(element);

    while (!toProcess.isEmpty()){
      ARTElement elem = toProcess.poll();
      visisted.add(elem);

      AbstractionElement aElement = AbstractElements.extractElementByType(elem, AbstractionElement.class);
      if (aElement != null){
        naARTElement = elem;
        break;
      }

      for (ARTElement parent : elem.getChildren()){
        if (!visisted.contains(parent)){
          toProcess.addLast(parent);
        }
      }
    }

    return naARTElement;
  }


  /**
   * Finds the last rely-guarantee abstraction element that is an ancestor of the argument.
   * @param target
   * @return
   */
  public static ARTElement findLastAbstractionARTElement(ARTElement target) {
    ARTElement laARTElement = null;
    Deque<ARTElement> toProcess = new LinkedList<ARTElement>();
    Set<ARTElement> visisted = new HashSet<ARTElement>();

    if (target.isDestroyed()){
      target = target.getMergedWith();
    }

    toProcess.add(target);

    while (!toProcess.isEmpty()){
      ARTElement element = toProcess.poll();
      assert !element.isDestroyed();
      visisted.add(element);

      AbstractionElement aElement = AbstractElements.extractElementByType(element, AbstractionElement.class);
      if (aElement != null){
        laARTElement = element;
        break;
      }

      for (ARTElement parent : element.getParents()){
        if (!visisted.contains(parent)){
          toProcess.addLast(parent);
        }
      }
    }

    return laARTElement;
  }



  public SetMultimap<CFANode, AbstractionPredicate>[] getEnvPrecision() {
    return envPrecision;
  }

  /**
   * Add predicates to environmental precision of some thread.
   * @param tid
   * @param loc
   * @param preds
   */
  public void addPredicatesToEnvPrecision(Integer tid, CFANode loc, Collection<AbstractionPredicate> preds){
    this.envPrecision[tid].putAll(loc, preds);
  }

  public Set<AbstractionPredicate>[] getEnvGlobalPrecision() {
    return envGlobalPrecision;
  }

  @Override
  public void collectStatistics(Collection<Statistics> pStatsCollection) {
    pStatsCollection.add(stats);
  }

  public static class Stats implements Statistics {

    private final Timer totalTimer       = new Timer();
    private int allCandidates   = 0;
    private int allNew          = 0;
    private int maxValid        = 0;

    @Override
    public void printStatistics(PrintStream out, Result pResult,
        ReachedSet pReached) {
      out.println("total candidates:                  " + this.allCandidates);
      out.println("valid env. transitions generated:  " + this.allNew);
      out.println("max. valid env. transitions:       " + this.maxValid);
      out.println("time on env. processing:           " + totalTimer);
    }

    @Override
    public String getName() {
      return "RGEnvironmentalManager";
    }

  }

  /**
   * Statistics for processing env. transitions.
   */
  public static class RelyGuaranteeEnvironmentProcessStatistics implements Statistics {

    private final Timer totalTimer    = new Timer();
    private int candidates      = 0;
    private int newValid        = 0;
    private int allValid        = 0;

    @Override
    public void printStatistics(PrintStream out, Result pResult, ReachedSet pReached) {

      out.println("time:"+totalTimer+" candidates:" +candidates + " new valid:"+newValid + " all valid:"+allValid );
    }

    @Override
    public String getName() {
      return "RGEnvironmentalManager.processEnvTransitions";
    }

  }



}



