// This file is part of CPAchecker,
// a tool for configurable software verification:
// https://cpachecker.sosy-lab.org
//
// SPDX-FileCopyrightText: 2025 Dirk Beyer <https://www.sosy-lab.org>
//
// SPDX-License-Identifier: Apache-2.0

package org.sosy_lab.cpachecker.cpa.pointer.location;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static org.sosy_lab.cpachecker.cpa.pointer.location.PointerLocationComparator.compareByType;

import com.google.common.collect.ComparisonChain;
import com.google.common.collect.Ordering;
import java.util.Objects;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Represents a symbolic abstract location on the heap, used to model memory allocated dynamically
 * (e.g., by {@code malloc}).
 *
 * <p>In static analysis, the unbounded number of concrete heap allocations that can occur at
 * runtime can be abstracted into a finite set of symbolic locations. This record provides a
 * structured identity for these symbolic locations.
 *
 * @param functionName The name of the function where the allocation occurs. This field acts as a
 *     namespace, ensuring that heap locations allocated in different functions are distinguished.
 *     This is essential for maintaining precision in an interprocedural analysis. For example, an
 *     allocation at the same line number in two different files or functions will have a different
 *     {@code functionName} and thus be a distinct abstract location.
 * @param identifier A strategy-dependent identifier that uniquely names the allocation within the
 *     scope of the {@code functionName}. This identifier is generated by the {@link
 *     org.sosy_lab.cpachecker.cpa.pointer.transfer.StatementEdgeHandler} according to the {@link
 *     org.sosy_lab.cpachecker.cpa.pointer.transfer.HeapAllocationStrategy} selected in the
 *     configuration.
 *     <ul>
 *       <li><b>SINGLE</b>: A single, constant identifier (e.g., "heap_obj") is used for all
 *           allocations within the function, modeling the heap as one summarized object per
 *           function.
 *       <li><b>PER_LINE</b>: The identifier includes the source line number (e.g., "heap_obj42"),
 *           distinguishing allocations based on their syntactic location.
 *       <li><b>PER_CALL</b>: The identifier includes a call-site-specific counter (e.g.,
 *           "heap_obj0"), distinguishing between multiple invocations of {@code malloc} on the same
 *           line (e.g., in a loop).
 *     </ul>
 *
 * @param offset The byte offset from the base address of this symbolic heap region. A {@code null}
 *     offset typically represents the base address itself or an unknown offset, while a non-null
 *     value models a pointer to a specific field within an allocated struct or an element in an
 *     array.
 */
public record HeapLocation(
    @NonNull String functionName, @NonNull String identifier, @Nullable Long offset)
    implements PointerLocation {
  private static final String HEAP_PREFIX = "heap_obj";

  public HeapLocation(String functionName, String identifier, Long offset) {
    this.functionName = checkNotNull(functionName);
    this.identifier = checkNotNull(identifier);
    this.offset = offset;
  }

  /** Single logical heap object. */
  public static HeapLocation forSingleAllocation(String functionName, @Nullable Long offset) {
    return new HeapLocation(functionName, HEAP_PREFIX, offset);
  }

  /** Per-call heap object. */
  public static HeapLocation forIndexedAllocation(
      String functionName, int index, @Nullable Long offset) {
    checkArgument(index >= 0, "index must be >= 0 for indexed allocations (was %s)", index);
    return new HeapLocation(functionName, HEAP_PREFIX + index, offset);
  }

  public static HeapLocation forLineBasedAllocation(
      String pFunctionName, int lineNumber, @Nullable Long pOffset) {
    return new HeapLocation(pFunctionName, "heap_obj" + lineNumber, pOffset);
  }

  @Override
  public int compareTo(PointerLocation pOther) {
    // Custom type check required for comparing different PointerTarget subclasses.
    // Fallback to type-based comparison for heterogeneous comparisons.
    if (!(pOther instanceof HeapLocation other)) {
      return compareByType(this, pOther);
    }

    return ComparisonChain.start()
        .compare(this.identifier, other.identifier)
        .compare(this.functionName, other.functionName)
        .compare(offset, other.offset, Ordering.natural().nullsFirst())
        .result();
  }

  @Override
  public boolean equals(Object pOther) {
    return this == pOther
        || (pOther instanceof HeapLocation other
            && identifier.equals(other.identifier)
            && functionName.equals(other.functionName)
            && Objects.equals(offset, other.offset));
  }

  @Override
  public String toString() {
    String heapName = functionName + "::" + identifier;
    if (offset == null) {
      return heapName;
    }
    return heapName + "/" + offset;
  }

  /**
   * Offset have only heap locations where we track each allocation separately.
   *
   * @return true if this heap location has an offset, false otherwise.
   */
  public boolean hasOffset() {
    return offset != null;
  }

  public long getOffset() {
    checkState(offset != null, "heap location '%s' has no offset", this);
    return offset;
  }

  public HeapLocation withAddedOffset(long pAddToOffset) {
    long oldOffset = offset == null ? 0 : offset;
    return new HeapLocation(functionName, identifier, oldOffset + pAddToOffset);
  }
}
