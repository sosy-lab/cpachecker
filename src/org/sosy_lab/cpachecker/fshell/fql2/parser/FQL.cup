/*
 *  CPAchecker is a tool for configurable software verification.
 *  This file is part of CPAchecker.
 *
 *  Copyright (C) 2007-2011  Dirk Beyer
 *  All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *
 *  CPAchecker web page:
 *    http://cpachecker.sosy-lab.org
 */

package org.sosy_lab.cpachecker.fshell.fql2.parser;

import org.sosy_lab.cpachecker.fshell.fql2.ast.Nodes;
import org.sosy_lab.cpachecker.fshell.fql2.ast.Edges;
import org.sosy_lab.cpachecker.fshell.fql2.ast.Paths;
import org.sosy_lab.cpachecker.fshell.fql2.ast.Predicate;
import org.sosy_lab.cpachecker.fshell.fql2.ast.FQLSpecification;
import org.sosy_lab.cpachecker.fshell.fql2.ast.coveragespecification.ScopePropagator;
import org.sosy_lab.cpachecker.fshell.fql2.ast.coveragespecification.CoverageSpecification;
import org.sosy_lab.cpachecker.fshell.fql2.ast.coveragespecification.Quotation;
import org.sosy_lab.cpachecker.fshell.fql2.ast.coveragespecification.Concatenation;
import org.sosy_lab.cpachecker.fshell.fql2.ast.pathpattern.PathPattern;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.Identity;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.File;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.BasicBlockEntry;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.ConditionEdge;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.DecisionEdge;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.ConditionGraph;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.Line;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.FunctionCalls;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.Column;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.Function;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.Label;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.FunctionCall;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.FunctionEntry;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.FunctionExit;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.EnclosingScopes;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.Compose;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.Expression;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.RegularExpression;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.Filter;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.SetMinus;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.Intersection;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.Union;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.Complement;
import org.sosy_lab.cpachecker.fshell.fql2.ast.filter.Predication;
import org.sosy_lab.cpachecker.util.predicates.simpleformulas.Term;
import org.sosy_lab.cpachecker.util.predicates.simpleformulas.Variable;
import org.sosy_lab.cpachecker.util.predicates.simpleformulas.Constant;

import java.io.Reader;
import java.io.InputStream;
import java.io.StringReader;

parser code
{:
	public FQLParser(String pQueryString) {
      this(new StringReader(pQueryString));
	}

	public FQLParser(Reader pReader) {
	  this(new FQLLexer(pReader));
	}

	public FQLParser(InputStream pInputStream) {
	  this(new FQLLexer(pInputStream));
	}
:}

action code
{:
:}

/* general */
terminal TOK_L_PARENTHESIS;
terminal TOK_R_PARENTHESIS;
terminal TOK_COMMA;

/* filter functions */
terminal TOK_IDENTITY;
terminal TOK_FILE;
terminal TOK_LINE;
terminal Integer TOK_LINE_ABBREV;
terminal TOK_COLUMN;
terminal TOK_FUNC;
terminal TOK_LABEL;
terminal TOK_CALL;
terminal TOK_CALLS;
terminal TOK_ENTRY;
terminal TOK_EXIT;
terminal TOK_EXPR;
terminal TOK_REGEXP;
terminal TOK_BASICBLOCKENTRY;
terminal TOK_CONDITIONEDGE;
terminal TOK_DECISIONEDGE;
terminal TOK_CONDITIONGRAPH;
terminal TOK_PREDICATION;

/* operations on target graphs */
terminal TOK_COMPLEMENT;
terminal TOK_UNION;
terminal TOK_INTERSECT;
terminal TOK_SETMINUS;
terminal TOK_ENCLOSING_SCOPES;
terminal TOK_COMPOSE;

/* abstraction/predicates */
terminal TOK_L_BRACE;
terminal TOK_R_BRACE;
terminal TOK_GREATER_OR_EQ;
terminal TOK_GREATER;
terminal TOK_EQ;
terminal TOK_LESS_OR_EQ;
terminal TOK_LESS;
terminal TOK_NEQ;

/* coverage specification */
terminal TOK_NODECOV;
terminal TOK_EDGECOV;
terminal TOK_PATHCOV;

/* path monitors */
terminal TOK_CONCAT;
terminal TOK_ALTERNATIVE;
terminal TOK_KLEENE;

terminal TOK_QUOTE;

/* query */
terminal TOK_IN;
terminal TOK_COVER;
terminal TOK_PASSING;

/* C identifier */
terminal String TOK_C_IDENT;
terminal String TOK_QUOTED_STRING;

/* a natural number */
terminal Integer TOK_NAT_NUMBER;

non terminal FQLSpecification;
non terminal CoveragePattern;
non terminal PathPattern;
non terminal PathPatternBlock;
non terminal Atom;
non terminal Cover;
non terminal Passing;
non terminal Filter;
non terminal Filter_Function;
non terminal Predicate;
non terminal Term;
non terminal Comparison;

/* precedences */
precedence left TOK_CONCAT, TOK_ALTERNATIVE;


start with FQLSpecification;

FQLSpecification 	::= Cover:coverage Passing:passing
						{:
							assert(coverage != null);
							assert(coverage instanceof CoverageSpecification);
							
							if (passing == null) {
							  RESULT = new FQLSpecification((CoverageSpecification)coverage);
							}
							else {
								assert(passing instanceof PathPattern);
							
								RESULT = new FQLSpecification((CoverageSpecification)coverage, (PathPattern)passing);
							}
						:}
					|   TOK_IN Filter:filter Cover:coverage Passing:passing
						{:
						 	assert(filter != null);
						 	assert(filter instanceof Filter);
						 	assert(coverage != null);
							assert(coverage instanceof CoverageSpecification);
							assert(passing != null);
							assert(passing instanceof PathPattern);
							
							Filter lScope = (Filter)filter;
							
							ScopePropagator lScopePropagator = new ScopePropagator(lScope);
							
							CoverageSpecification lScopedSpecification = ((CoverageSpecification)coverage).accept(lScopePropagator);
							
							RESULT = new FQLSpecification(lScopedSpecification, (PathPattern)passing);
						:}
					;

Cover				::=
						TOK_COVER CoveragePattern:pattern
						{:
							RESULT = pattern;
						:}
					;

Passing				::= 
						{:
							RESULT = null;
						:}
					| 	TOK_PASSING PathPattern:pattern
						{:
							RESULT = pattern;
						:}
					;
					
CoveragePattern 	::= Atom:atom
						{:
							RESULT = atom;
						:}
					|	TOK_L_PARENTHESIS CoveragePattern:pattern TOK_R_PARENTHESIS
						{:
							RESULT = pattern;
						:}
					|	TOK_QUOTE PathPattern:pattern TOK_QUOTE
						{:
							assert(pattern != null);
							assert(pattern instanceof PathPattern);
							
							RESULT = new Quotation((PathPattern)pattern);
						:}
					| 	CoveragePattern:leftPattern TOK_CONCAT CoveragePattern:rightPattern
						{:
							assert(leftPattern != null);
							assert(leftPattern instanceof CoverageSpecification);
							assert(rightPattern != null);
							assert(rightPattern instanceof CoverageSpecification);
							
							RESULT = new Concatenation((CoverageSpecification)leftPattern, (CoverageSpecification)rightPattern);
						:}
					|	CoveragePattern:leftPattern TOK_ALTERNATIVE CoveragePattern:rightPattern
						{:
							assert(leftPattern != null);
							assert(leftPattern instanceof CoverageSpecification);
							assert(rightPattern != null);
							assert(rightPattern instanceof CoverageSpecification);
							
							RESULT = new org.sosy_lab.cpachecker.fshell.fql2.ast.coveragespecification.Union((CoverageSpecification)leftPattern, (CoverageSpecification)rightPattern);
						:}
					;

PathPatternBlock	::= Atom:atom
						{:
							RESULT = atom;
						:}
					|	TOK_L_PARENTHESIS PathPattern:pattern TOK_R_PARENTHESIS
						{:
							RESULT = pattern;
						:}
					|   PathPatternBlock:pattern TOK_KLEENE
						{:
							assert(pattern != null);
							assert(pattern instanceof PathPattern);
							
							RESULT = new org.sosy_lab.cpachecker.fshell.fql2.ast.pathpattern.Repetition((PathPattern)pattern);
						:}
					;

PathPattern			::= PathPatternBlock:pattern
						{:
							RESULT = pattern;
						:}
					|	PathPatternBlock:leftPattern TOK_CONCAT PathPattern:rightPattern
						{:
							assert(leftPattern != null);
							assert(leftPattern instanceof PathPattern);
							assert(rightPattern != null);
							assert(rightPattern instanceof PathPattern);
							
							RESULT = new org.sosy_lab.cpachecker.fshell.fql2.ast.pathpattern.Concatenation((PathPattern)leftPattern, (PathPattern)rightPattern);
						:}
					|	PathPatternBlock:leftPattern TOK_ALTERNATIVE PathPattern:rightPattern
						{:
							assert(leftPattern != null);
							assert(leftPattern instanceof PathPattern);
							assert(rightPattern != null);
							assert(rightPattern instanceof PathPattern);
							
							RESULT = new org.sosy_lab.cpachecker.fshell.fql2.ast.pathpattern.Union((PathPattern)leftPattern, (PathPattern)rightPattern);
						:}
					;
				
Atom				::= TOK_NODECOV TOK_L_PARENTHESIS Filter:filter TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							RESULT = new Nodes((Filter)filter);
						:}
					|	TOK_EDGECOV TOK_L_PARENTHESIS Filter:filter TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
						
							RESULT = new Edges((Filter)filter);
						:}
					|  	TOK_PATHCOV TOK_L_PARENTHESIS Filter:filter TOK_COMMA TOK_NAT_NUMBER:bound TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							assert(bound != null);
							
							RESULT = new Paths((Filter)filter, bound.intValue());
						:}
					| 	Predicate:predicate
						{:
							assert(predicate != null);
							assert(predicate instanceof Predicate);
							
							RESULT = predicate;
						:}
					;


Filter				::=
						Filter_Function:filter
						{:
							RESULT = filter;
						:}
					|	TOK_COMPLEMENT TOK_L_PARENTHESIS Filter:filter TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);

							RESULT = new Complement((Filter)filter);
						:}
					| 	TOK_UNION TOK_L_PARENTHESIS Filter:filter1 TOK_COMMA Filter:filter2 TOK_R_PARENTHESIS
						{:
							assert(filter1 != null);
							assert(filter2 != null);
							assert(filter1 instanceof Filter);
							assert(filter2 instanceof Filter);

							RESULT = new Union((Filter)filter1, (Filter)filter2);
						:}
					|	TOK_INTERSECT TOK_L_PARENTHESIS Filter:filter1 TOK_COMMA Filter:filter2 TOK_R_PARENTHESIS
						{:
							assert(filter1 != null);
							assert(filter2 != null);
							assert(filter1 instanceof Filter);
							assert(filter2 instanceof Filter);

							RESULT = new Intersection((Filter)filter1, (Filter)filter2);
						:}
					| 	TOK_SETMINUS TOK_L_PARENTHESIS Filter:filter1 TOK_COMMA Filter:filter2 TOK_R_PARENTHESIS
						{:
							assert(filter1 != null);
							assert(filter2 != null);
							assert(filter1 instanceof Filter);
							assert(filter2 instanceof Filter);

							RESULT = new SetMinus((Filter)filter1, (Filter)filter2);
						:}
					| 	TOK_ENCLOSING_SCOPES TOK_L_PARENTHESIS Filter:filter TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);

							RESULT = new EnclosingScopes((Filter)filter);
						:}
					| 	TOK_COMPOSE TOK_L_PARENTHESIS Filter:filter1 TOK_COMMA Filter:filter2 TOK_R_PARENTHESIS
						{:
							assert(filter1 != null);
							assert(filter2 != null);
							assert(filter1 instanceof Filter);
							assert(filter2 instanceof Filter);

							RESULT = new Compose((Filter)filter1, (Filter)filter2);
						:}
					|	TOK_PREDICATION TOK_L_PARENTHESIS Filter:filter TOK_COMMA Predicate:predicate TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							assert(predicate != null);
							assert(predicate instanceof Predicate);
							
							RESULT = new Predication((Filter)filter, (Predicate)predicate);
						:}
					;

Filter_Function		::=
						TOK_IDENTITY
						{:
							RESULT = Identity.getInstance();
						:}
					|	TOK_FILE TOK_L_PARENTHESIS TOK_QUOTED_STRING:filename TOK_R_PARENTHESIS
						{:
							RESULT = new File(filename);
						:}
					|	TOK_LINE TOK_L_PARENTHESIS TOK_NAT_NUMBER:linenumber TOK_R_PARENTHESIS
						{:
							RESULT = new Line(linenumber);
						:}
					|	TOK_LINE_ABBREV:linenumber
						{:
							RESULT = new Line(linenumber);
						:}
					|	TOK_COLUMN TOK_L_PARENTHESIS TOK_NAT_NUMBER:columnnumber TOK_R_PARENTHESIS
						{:
							RESULT = new Column(columnnumber);
						:}
					| 	TOK_FUNC TOK_L_PARENTHESIS TOK_C_IDENT:function TOK_R_PARENTHESIS
						{:
							RESULT = new Function(function);
						:}
					|	TOK_LABEL TOK_L_PARENTHESIS TOK_C_IDENT:label TOK_R_PARENTHESIS
						{:
							RESULT = new Label(label);
						:}
					| 	TOK_CALL TOK_L_PARENTHESIS TOK_C_IDENT:function TOK_R_PARENTHESIS
						{:
							RESULT = new FunctionCall(function);
						:}
					|	TOK_CALLS
						{:
							RESULT = FunctionCalls.getInstance();
						:}
					| 	TOK_ENTRY TOK_L_PARENTHESIS TOK_C_IDENT:function TOK_R_PARENTHESIS
						{:
							RESULT = new FunctionEntry(function);
						:}
					|	TOK_EXIT TOK_L_PARENTHESIS TOK_C_IDENT:function TOK_R_PARENTHESIS
						{:
							RESULT = new FunctionExit(function);
						:}
					|	TOK_EXPR TOK_L_PARENTHESIS TOK_QUOTED_STRING:expression TOK_R_PARENTHESIS
						{:
							RESULT = new Expression(expression);
						:}
					|	TOK_REGEXP TOK_L_PARENTHESIS TOK_QUOTED_STRING:regularexpression TOK_R_PARENTHESIS
						{:
							RESULT = new RegularExpression(regularexpression);
						:}
					|	TOK_BASICBLOCKENTRY
						{:
							RESULT = BasicBlockEntry.getInstance();
						:}
					| 	TOK_CONDITIONEDGE
						{:
							RESULT = ConditionEdge.getInstance();
						:}
					|	TOK_DECISIONEDGE
						{:
							RESULT = DecisionEdge.getInstance();
						:}
					|	TOK_CONDITIONGRAPH
						{:
							RESULT = ConditionGraph.getInstance();
						:}
					;
					
Predicate			::=
						TOK_L_BRACE Term:leftterm Comparison:comparison Term:rightterm TOK_R_BRACE
						{:
							assert(leftterm != null);
							assert(comparison != null);
							assert(rightterm != null);

							assert(leftterm instanceof Term);
							assert(comparison instanceof org.sosy_lab.cpachecker.util.predicates.simpleformulas.Predicate.Comparison);
							assert(rightterm instanceof Term);

							RESULT = new Predicate(new org.sosy_lab.cpachecker.util.predicates.simpleformulas.Predicate((Term)leftterm, (org.sosy_lab.cpachecker.util.predicates.simpleformulas.Predicate.Comparison)comparison, (Term)rightterm));
						:}
					;

Term				::=
						TOK_C_IDENT:identifier
						{:
							RESULT = new Variable(identifier);
						:}
					| 	TOK_NAT_NUMBER:number
						{:
							RESULT = new Constant(number);
						:}
					;

Comparison			::=
						TOK_GREATER_OR_EQ
						{:
							RESULT = org.sosy_lab.cpachecker.util.predicates.simpleformulas.Predicate.Comparison.GREATER_OR_EQUAL;
						:}
					| 	TOK_GREATER
						{:
							RESULT = org.sosy_lab.cpachecker.util.predicates.simpleformulas.Predicate.Comparison.GREATER;
						:}
					| 	TOK_EQ
						{:
							RESULT = org.sosy_lab.cpachecker.util.predicates.simpleformulas.Predicate.Comparison.EQUAL;
						:}
					| 	TOK_LESS_OR_EQ
						{:
							RESULT = org.sosy_lab.cpachecker.util.predicates.simpleformulas.Predicate.Comparison.LESS_OR_EQUAL;
						:}
					| 	TOK_LESS
						{:
							RESULT = org.sosy_lab.cpachecker.util.predicates.simpleformulas.Predicate.Comparison.LESS;
						:}
					| 	TOK_NEQ
						{:
							RESULT = org.sosy_lab.cpachecker.util.predicates.simpleformulas.Predicate.Comparison.NOT_EQUAL;
						:}
					;
