// This file is part of CPAchecker,
// a tool for configurable software verification:
// https://cpachecker.sosy-lab.org
//
// SPDX-FileCopyrightText: 2024 Dirk Beyer <https://www.sosy-lab.org>
//
// SPDX-License-Identifier: Apache-2.0

package org.sosy_lab.cpachecker.cfa.export.json.deserialization;

import static com.google.common.base.Preconditions.checkArgument;

import com.fasterxml.jackson.annotation.ObjectIdGenerator;
import com.fasterxml.jackson.annotation.ObjectIdResolver;
import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;
import com.fasterxml.jackson.databind.util.ClassUtil;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;
import org.sosy_lab.cpachecker.cfa.export.json.CfaJsonImport;
import org.sosy_lab.cpachecker.cfa.export.json.mixins.TypeMixin;
import org.sosy_lab.cpachecker.cfa.export.json.serialization.SimpleNameIdGenerator;
import org.sosy_lab.cpachecker.cfa.types.Type;
import org.sosy_lab.cpachecker.cfa.types.c.CArrayType;
import org.sosy_lab.cpachecker.cfa.types.c.CBasicType;
import org.sosy_lab.cpachecker.cfa.types.c.CBitFieldType;
import org.sosy_lab.cpachecker.cfa.types.c.CComplexType.ComplexTypeKind;
import org.sosy_lab.cpachecker.cfa.types.c.CCompositeType;
import org.sosy_lab.cpachecker.cfa.types.c.CElaboratedType;
import org.sosy_lab.cpachecker.cfa.types.c.CEnumType;
import org.sosy_lab.cpachecker.cfa.types.c.CFunctionType;
import org.sosy_lab.cpachecker.cfa.types.c.CFunctionTypeWithNames;
import org.sosy_lab.cpachecker.cfa.types.c.CPointerType;
import org.sosy_lab.cpachecker.cfa.types.c.CProblemType;
import org.sosy_lab.cpachecker.cfa.types.c.CSimpleType;
import org.sosy_lab.cpachecker.cfa.types.c.CTypedefType;
import org.sosy_lab.cpachecker.cfa.types.c.CVoidType;

/**
 * This is a custom resolver for deserializing {@link Type} objects.
 *
 * <p>It solves "unresolved forward references" by creating placeholder objects for unknown {@link
 * Type} objects and copying field contents from the actual object to the placeholder when the
 * actual object has been deserialized. In other words, the placeholder object eventually becomes
 * (equal to) the actual object.
 *
 * <p>The "unresolved forward reference" problem occurs when an object is referenced inside of its
 * own JSON representation. For example, consider the following JSON representation of a class A:
 *
 * <pre>
 * {
 *   "id": "A_1",
 *   "field": {
 *     "reference": "A_1",
 *   }
 * }
 * </pre>
 *
 * <p>This class assumes that the identifier keys are generated by {@link SimpleNameIdGenerator} and
 * that the objects being are instances of {@link Type}. If these conditions are not met, an {@link
 * IllegalArgumentException} is thrown.
 *
 * <p>Note: While this resolver solves the "unresolved forward reference" problem and the
 * deserialization provides equality, the deserialized object may not be structured exactly as it
 * was before serialization. However, when equality is used as the identity criterion for object
 * IDs, the serialization is deterministic even if the structure is not exactly the same.
 *
 * @see CfaJsonImport
 * @see TypeMixin
 * @see SimpleNameIdGenerator
 */
public final class TypeIdResolver extends SimpleObjectIdResolver {
  private final Map<ObjectIdGenerator.IdKey, Type> placeholders = new HashMap<>();

  /**
   * Creates a new instance of {@link TypeIdResolver} for deserialization.
   *
   * @param pContext The context object for deserialization.
   * @return a new instance of {@link TypeIdResolver}.
   */
  @Override
  public ObjectIdResolver newForDeserialization(Object pContext) {
    return new TypeIdResolver();
  }

  /**
   * Binds an object to the specified ID key.
   *
   * <p>If the ID key is associated with a placeholder object, it copies the field contents from the
   * object to the placeholder so that the placeholder becomes the actual object. Otherwise, it
   * delegates the binding to the superclass implementation.
   *
   * @param pId The ID key to bind the object to.
   * @param pObject The object to be bound to the ID key.
   * @throws IllegalArgumentException if the ID key is not generated by {@link
   *     SimpleNameIdGenerator} or if the object is not an instance of {@link Type}.
   */
  @Override
  public void bindItem(ObjectIdGenerator.IdKey pId, Object pObject) {
    checkArgument(
        (pId.type == SimpleNameIdGenerator.class),
        "Wrong generator: %s is not SimpleNameIdGenerator",
        pId.type.getSimpleName());
    checkArgument(
        (pObject instanceof Type),
        "Wrong object: %s is not a Type",
        pObject.getClass().getSimpleName());

    if (placeholders.containsKey(pId)) {
      copyFieldContents((Type) pObject, placeholders.get(pId));
      placeholders.remove(pId);
    } else {
      super.bindItem(pId, pObject);
    }
  }

  /**
   * Resolves an identifier to its corresponding object.
   *
   * <p>This method checks if the identifier is already known. If not, it creates a placeholder
   * {@link Type} based on the subtype specified in the identifier key.
   *
   * @param pId The identifier key generated by {@link SimpleNameIdGenerator} including the subtype
   *     name of the {@link Type} object.
   * @return The resolved object corresponding to the identifier key.
   */
  @Override
  public Object resolveId(ObjectIdGenerator.IdKey pId) {
    if (this._items == null) {
      this._items = new HashMap<>();
    }

    /* Check if the object is already present in the map. */
    Object resolved = this._items.get(pId);

    /* If not, create placeholder. */
    if (resolved == null) {
      resolved = createPlaceholder(pId);

      /* Keep track of the placeholder so that field contents can be copied to it later. */
      placeholders.put(pId, (Type) resolved);
    }

    return resolved;
  }

  /**
   * Creates a placeholder {@link Type} object based on the subtype specified in the given
   * identifier key.
   *
   * @param pId The identifier key containing the type information.
   * @return the placeholder.
   * @throws IllegalArgumentException if the subtype specified in the identifier key is unknown or
   *     the identifier key is not generated by {@link SimpleNameIdGenerator}.
   */
  private Type createPlaceholder(ObjectIdGenerator.IdKey pId) {
    checkArgument(
        (pId.type == SimpleNameIdGenerator.class),
        "Wrong generator: %s is not SimpleNameIdGenerator",
        pId.type.getSimpleName());

    /* Types needed for construction. */
    CSimpleType simpleType =
        new CSimpleType(
            false, false, CBasicType.UNSPECIFIED, false, false, false, false, false, false, false);
    CCompositeType compositeType = new CCompositeType(false, false, ComplexTypeKind.STRUCT, "", "");
    compositeType.setMembers(new ArrayList<>());

    /* Construct placeholder based on the subtype specified in the identifier key. */
    Type placeholder;
    String subtypeName = pId.key.toString().substring(0, pId.key.toString().indexOf('_'));

    switch (subtypeName) {
      case "CArrayType":
        placeholder = new CArrayType(false, false, simpleType);
        break;
      case "CBitFieldType":
        placeholder = new CBitFieldType(simpleType, 0);
        break;
      case "CFunctionType":
        placeholder = new CFunctionType(simpleType, new ArrayList<>(), false);
        break;
      case "CFunctionTypeWithNames":
        placeholder = new CFunctionTypeWithNames(simpleType, new ArrayList<>(), false);
        break;
      case "CPointerType":
        placeholder = new CPointerType(false, false, simpleType);
        break;
      case "CProblemType":
        placeholder = new CProblemType("");
        break;
      case "CSimpleType":
        placeholder = simpleType;
        break;
      case "CTypedefType":
        placeholder = new CTypedefType(false, false, "", simpleType);
        break;
      case "CVoidType":
        placeholder = CVoidType.create(false, false);
        break;
      case "CCompositeType":
        placeholder = compositeType;
        break;
      case "CElaboratedType":
        placeholder =
            new CElaboratedType(false, false, ComplexTypeKind.STRUCT, "", "", compositeType);
        break;
      case "CEnumType":
        placeholder = new CEnumType(false, false, simpleType, new ArrayList<>(), "", "");
        break;
      default:
        throw new IllegalArgumentException("Unknown type: " + subtypeName);
    }

    return placeholder;
  }

  /**
   * Copies the contents of fields from one {@link Type} object to another of the same type.
   *
   * <p>This method ensures that all changeable fields from the source object are copied to the
   * target object. It adjusts field accessibility if necessary.
   *
   * @param pFrom The source {@link Type} object from which field values are copied.
   * @param pTo The target {@link Type} object to which field values are copied.
   * @throws IllegalArgumentException if the source and target objects are not of the same class.
   * @throws IllegalStateException if an error occurs while attempting to copy field contents.
   */
  private void copyFieldContents(Type pFrom, Type pTo) {
    checkArgument((pFrom.getClass() == pTo.getClass()), "Subtypes are not the same.");

    List<Field> fromFields = getAllFields(pFrom.getClass());
    Map<String, Field> toFieldMap =
        getAllFields(pTo.getClass()).stream()
            .filter(field -> !field.getName().equals("serialVersionUID"))
            .collect(ImmutableMap.toImmutableMap(Field::getName, field -> field));

    for (Field fromField : fromFields) {
      if (fromField.getName().equals("serialVersionUID")
          || fromField.getName().startsWith("POINTER_TO_")) {
        continue;
      }

      Field toField = toFieldMap.get(fromField.getName());

      ClassUtil.checkAndFixAccess(fromField, true);
      ClassUtil.checkAndFixAccess(toField, true);

      try {
        toField.set(pTo, fromField.get(pFrom));

      } catch (IllegalAccessException e) {
        throw new IllegalStateException(
            "Error while attempting to copy field contents of " + fromField.getName() + ".");
      }
    }
  }

  /**
   * Retrieves all fields from the specified class and its superclasses.
   *
   * @param pClass The class from which to retrieve the fields.
   * @return a list of all fields declared in the specified class and its superclasses.
   */
  private List<Field> getAllFields(Class<?> pClass) {
    return ClassUtil.findSuperClasses(pClass, Object.class, true).stream()
        .flatMap(superClass -> Stream.of(superClass.getDeclaredFields()))
        .collect(ImmutableList.toImmutableList());
  }
}
