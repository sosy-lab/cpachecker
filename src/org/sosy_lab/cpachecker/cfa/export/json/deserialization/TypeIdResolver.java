// This file is part of CPAchecker,
// a tool for configurable software verification:
// https://cpachecker.sosy-lab.org
//
// SPDX-FileCopyrightText: 2024 Dirk Beyer <https://www.sosy-lab.org>
//
// SPDX-License-Identifier: Apache-2.0

package org.sosy_lab.cpachecker.cfa.export.json.deserialization;

import static com.google.common.base.Preconditions.checkArgument;

import com.fasterxml.jackson.annotation.ObjectIdGenerator;
import com.fasterxml.jackson.annotation.ObjectIdResolver;
import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;
import com.fasterxml.jackson.databind.util.ClassUtil;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.sosy_lab.cpachecker.cfa.export.json.CfaJsonImport;
import org.sosy_lab.cpachecker.cfa.export.json.mixins.TypeMixin;
import org.sosy_lab.cpachecker.cfa.export.json.serialization.SimpleNameIdGenerator;
import org.sosy_lab.cpachecker.cfa.types.Type;
import org.sosy_lab.cpachecker.cfa.types.c.CArrayType;
import org.sosy_lab.cpachecker.cfa.types.c.CBasicType;
import org.sosy_lab.cpachecker.cfa.types.c.CBitFieldType;
import org.sosy_lab.cpachecker.cfa.types.c.CComplexType.ComplexTypeKind;
import org.sosy_lab.cpachecker.cfa.types.c.CCompositeType;
import org.sosy_lab.cpachecker.cfa.types.c.CElaboratedType;
import org.sosy_lab.cpachecker.cfa.types.c.CEnumType;
import org.sosy_lab.cpachecker.cfa.types.c.CFunctionType;
import org.sosy_lab.cpachecker.cfa.types.c.CFunctionTypeWithNames;
import org.sosy_lab.cpachecker.cfa.types.c.CPointerType;
import org.sosy_lab.cpachecker.cfa.types.c.CProblemType;
import org.sosy_lab.cpachecker.cfa.types.c.CSimpleType;
import org.sosy_lab.cpachecker.cfa.types.c.CTypedefType;
import org.sosy_lab.cpachecker.cfa.types.c.CVoidType;

/**
 * This is a custom resolver for deserializing {@link Type} objects.
 *
 * <p>It solves "unresolved forward references" by creating placeholder objects for unknown {@link
 * Type} objects and copying field contents from the actual object to the placeholder when the
 * actual object is resolved.
 *
 * <p>The "unresolved forward reference" problem occurs when an object is referenced inside of its
 * own JSON representation. For example, consider the following JSON representation of a class A:
 *
 * <pre>
 * {
 *   "id": "A_1",
 *   "field": {
 *     "reference": "A_1",
 *   }
 * }
 * </pre>
 *
 * <p>Note: This class assumes that the identifier keys are generated by {@link
 * SimpleNameIdGenerator} and that the objects being bound are instances of {@link Type}. If these
 * conditions are not met, an {@link IllegalArgumentException} is thrown.
 *
 * <p>Note: While this resolver solves the "unresolved forward reference" problem and the
 * deserialization is valid, the deserialized object may not be structured exactly as it was before
 * serialization. This is because the deserialized object is a placeholder object until the actual
 * object is resolved.
 *
 * @see CfaJsonImport
 * @see TypeMixin
 * @see SimpleNameIdGenerator
 */
public final class TypeIdResolver extends SimpleObjectIdResolver {

  /**
   * Creates a new instance of {@link TypeIdResolver} for deserialization.
   *
   * @param pContext The context object for deserialization.
   * @return a new instance of {@link TypeIdResolver}
   */
  @Override
  public ObjectIdResolver newForDeserialization(Object pContext) {
    return new TypeIdResolver();
  }

  /**
   * Binds an object to a given ID key. This method ensures that the ID key is generated by {@link
   * SimpleNameIdGenerator} and that the object is an instance of {@link Type}. If an object is
   * already bound to the ID key (forward reference placeholder), it updates the existing object
   * with the new object's field contents.
   *
   * @param pId The ID key to bind the object to, must be generated by {@link
   *     SimpleNameIdGenerator}.
   * @param pObject The object to bind, must be an instance of {@link Type}.
   * @throws IllegalArgumentException if the ID key is not generated by {@link
   *     SimpleNameIdGenerator} or if the object is not an instance of {@link Type}.
   */
  @Override
  public void bindItem(ObjectIdGenerator.IdKey pId, Object pObject) {
    checkArgument(
        (pId.type == SimpleNameIdGenerator.class),
        "Wrong generator: " + pId.type.getSimpleName() + " is not SimpleNameIdGenerator");
    checkArgument(
        (pObject instanceof Type),
        "Wrong object: " + pObject.getClass().getSimpleName() + " is not a Type");

    if (this._items == null) {
      this._items = new HashMap<>();
    } else {
      Object old = this._items.get(pId);
      if (old != null) {
        if (old == pObject) {
          return;
        }

        copyFieldContents((Type) pObject, (Type) old);
        return;
      }
    }

    this._items.put(pId, pObject);
  }

  /**
   * Resolves an object based on its identifier key.
   *
   * <p>The method performs the following steps:
   * <li>1. Checks if the provided identifier key is generated by {@link SimpleNameIdGenerator}.
   * <li>2. Initializes the internal map if it is null.
   * <li>3. Checks if the object corresponding to the identifier key is already present in the map.
   * <li>4. If the object is not present, creates a placeholder type based on the type specified in
   *     the identifier key and binds the newly created object to the identifier key in the internal
   *     map.
   * <li>5. Returns the resolved object or placeholder.
   *
   * @param pId The identifier key used to resolve the object. It must be generated by {@link
   *     SimpleNameIdGenerator}.
   * @return the resolved object corresponding to the identifier key.
   * @throws IllegalArgumentException if the generator type is not {@link SimpleNameIdGenerator} or
   *     if the type is unknown to this resolver.
   */
  @Override
  public Object resolveId(ObjectIdGenerator.IdKey pId) {
    checkArgument(
        (pId.type == SimpleNameIdGenerator.class),
        "Wrong generator: " + pId.type.getSimpleName() + " is not SimpleNameIdGenerator");

    if (this._items == null) {
      this._items = new HashMap<>();
    }

    /* Check if the object is already present in the map. */
    Object resolved = this._items.get(pId);

    /* If not, create placeholder. */
    if (resolved == null) {
      /* Types needed for construction. */
      CSimpleType simpleType =
          new CSimpleType(
              false,
              false,
              CBasicType.UNSPECIFIED,
              false,
              false,
              false,
              false,
              false,
              false,
              false);
      CCompositeType compositeType =
          new CCompositeType(false, false, ComplexTypeKind.STRUCT, "", "");
      compositeType.setMembers(new ArrayList<>());

      /* Construct placeholder type based on type specified in the identifier key. No safety checks are necessary since the key was created by SimpleNameIdGenerator. */
      String type = pId.key.toString().substring(0, pId.key.toString().indexOf('_'));

      switch (type) {
        case "CArrayType":
          resolved = new CArrayType(false, false, simpleType);
          break;
        case "CBitFieldType":
          resolved = new CBitFieldType(simpleType, 0);
          break;
        case "CFunctionType":
          resolved = new CFunctionType(simpleType, new ArrayList<>(), false);
          break;
        case "CFunctionTypeWithNames":
          resolved = new CFunctionTypeWithNames(simpleType, new ArrayList<>(), false);
          break;
        case "CPointerType":
          resolved = new CPointerType(false, false, simpleType);
          break;
        case "CProblemType":
          resolved = new CProblemType("");
          break;
        case "CSimpleType":
          resolved = simpleType;
          break;
        case "CTypedefType":
          resolved = new CTypedefType(false, false, "", simpleType);
          break;
        case "CVoidType":
          resolved = CVoidType.create(false, false);
          break;
        case "CCompositeType":
          resolved = compositeType;
          break;
        case "CElaboratedType":
          resolved =
              new CElaboratedType(false, false, ComplexTypeKind.STRUCT, "", "", compositeType);
          break;
        case "CEnumType":
          resolved = new CEnumType(false, false, simpleType, new ArrayList<>(), "", "");
          break;
        default:
          throw new IllegalArgumentException("Unknown type: " + type);
      }

      this.bindItem(pId, resolved);
    }

    return resolved;
  }

  /**
   * Copies the contents of fields from one {@link Type} object to another of the same type.
   *
   * <p>This method ensures that all fields (except for "serialVersionUID") from the source object
   * are copied to the target object. It checks that both objects are of the same class and adjusts
   * field accessibility if necessary.
   *
   * @param pFrom The source {@link Type} object from which field values are copied.
   * @param pTo The target {@link Type} object to which field values are copied.
   * @throws IllegalArgumentException if the source and target objects are not of the same class.
   * @throws IllegalStateException if an error occurs while attempting to copy field contents.
   */
  private void copyFieldContents(Type pFrom, Type pTo) {
    checkArgument((pFrom.getClass() == pTo.getClass()), "Types are not the same.");

    List<Field> fromFields = getAllFields(pFrom.getClass());
    Map<String, Field> toFieldMap =
        getAllFields(pTo.getClass()).stream()
            .collect(Collectors.toMap(Field::getName, field -> field));

    for (Field fromField : fromFields) {
      if (fromField.getName().equals("serialVersionUID")) {
        continue;
      }

      Field toField = toFieldMap.get(fromField.getName());

      ClassUtil.checkAndFixAccess(fromField, true);
      ClassUtil.checkAndFixAccess(toField, true);

      try {
        toField.set(pTo, fromField.get(pFrom));
      } catch (IllegalAccessException e) {
        throw new IllegalStateException(
            "Error while attempting to copy field contents from "
                + fromField.getName()
                + " to "
                + toField.getName()
                + ".");
      }
    }
  }

  /**
   * Retrieves all fields from the specified class and its superclasses.
   *
   * @param pClass The class from which to retrieve the fields.
   * @return a list of all fields declared in the specified class and its superclasses.
   */
  private List<Field> getAllFields(Class<?> pClass) {
    return ClassUtil.findSuperClasses(pClass, Object.class, true).stream()
        .flatMap(superClass -> Stream.of(superClass.getDeclaredFields()))
        .collect(Collectors.toList());
  }
}
