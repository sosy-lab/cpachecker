#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{amsfonts}%
\usepackage{amssymb}%
\usepackage{amsthm}
\usepackage{makeidx} % index
\usepackage{color} 
\usepackage{graphicx} 
\usepackage{booktabs} 
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{lscape}	% change to landscape on the fly
\usepackage{latexsym}
\usepackage{wasysym}
\usepackage{savesym}
\usepackage{babel}
\usepackage{parskip}
\usepackage{thmtools}
\usepackage{algorithmic}
\usepackage{stmaryrd}
\usepackage{fullpage}
\usepackage{url}
\usepackage{proof}


\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit,petri,automata}
\usepgflibrary{shapes.geometric}
\end_preamble
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 12.5cm
\paperheight 6cm
\leftmargin 0cm
\topmargin 0cm
\rightmargin 0cm
\bottommargin 0cm
\secnumdepth 4
\tocdepth 4
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Rely-Guarantee Program Verification with Large-Block Encoding 
\end_layout

\begin_layout Author
Przemys
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
l
\end_layout

\end_inset

 aw Daca
\end_layout

\begin_layout Section
Goal
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $P$
\end_inset

 - program that consists of 
\begin_inset Formula $N\geq1$
\end_inset

 threads
\begin_inset Newline newline
\end_inset

CFA for thread 
\begin_inset Formula $i$
\end_inset

 constists of 
\begin_inset Formula $L$
\end_inset

 locations and 
\begin_inset Formula $L\times Ops\times L$
\end_inset

 constrol-flow edges.
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $V$
\end_inset

 - set of all variables that appear in a program
\begin_inset Newline newline
\end_inset


\begin_inset Formula $V_{g}\subseteq V$
\end_inset

 - global variables
\begin_inset Newline newline
\end_inset


\begin_inset Formula $V_{i}\subseteq V\backslash V_{g}$
\end_inset

 - set of all variables local to thread 
\begin_inset Formula $i$
\end_inset

, including the program counter
\begin_inset Newline newline
\end_inset


\begin_inset Formula $C$
\end_inset

 - set of all valuations of variables in 
\begin_inset Formula $V$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $C_{x}$
\end_inset

 - set of all valutinos of variables in 
\begin_inset Formula $V_{x}$
\end_inset


\end_layout

\begin_layout Plain Layout
Sets of concreate states are represented by first order formula with free
 variables from 
\begin_inset Formula $V$
\end_inset

.
 Given formula 
\begin_inset Formula $\varphi$
\end_inset

: 
\begin_inset Formula $[\varphi]=\{\, c\in C\,|\, c\models\varphi\}$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\varphi_{init}$
\end_inset

- global inital state of 
\begin_inset Formula $P$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\varphi_{err}$
\end_inset

 - error states
\end_layout

\begin_layout Plain Layout
In rely-guarantee reasoning, programs counters are treated like any other
 variable and may appear in interpolants.
 To avoid cluttering of notation, we assume that programs counters are tracted
 in path formulas like other variables.
 As a result the strongest postcondition 
\begin_inset Formula $\mathrm{SP_{edge}}$
\end_inset

 is defined on CFA edges 
\begin_inset Formula $edge\in L\times Ops\times L$
\end_inset

, rather thant operation only.
 The strongest postcondition by an edge checks if the start location matches,
 applies the operation itself and then updates the program counter.
 Compared to For an assume edge 
\begin_inset Formula $assume(p)$
\end_inset

 that goes from location 
\begin_inset Formula $l$
\end_inset

 to 
\begin_inset Formula $l^{\prime}$
\end_inset

, we have 
\begin_inset Formula 
\[
SP_{l\xrightarrow{assume(p)}l^{\prime}}(\varphi)\,=\,\exists\overline{pc_{i}}\,:\,\,(pc_{i}=l\,\land\,\varphi\,\land\, p)_{[pc_{i}\mapsto\overline{pc_{i}}]}\,\land\, pc_{i}=l^{\prime}
\]

\end_inset

For an assigment operation 
\begin_inset Formula $l\xrightarrow{s:=e}l^{\prime}$
\end_inset

 in thread 
\begin_inset Formula $i$
\end_inset

 we get
\begin_inset Formula 
\[
SP_{l\xrightarrow{s:=e}l^{\prime}}(\varphi)\,=\,\exists\overline{s},\overline{pc_{i}}\,:\,(pc_{i}=l\,\land\,\varphi)_{[s\mapsto\overline{s},pc_{i}\mapsto\overline{pc_{i}}]}\,\land\, pc_{i}=l^{\prime}\,\land\, s=e_{[s\mapsto\overline{s},pc_{i}\mapsto\overline{pc_{i}}]}.
\]

\end_inset

Note that if an edge is applied on a wrong location, then the resulting
 formula is unsatisfiable.
\end_layout

\begin_layout Plain Layout
We assume that programs have interleaving semantics, i.e the set off possible
 formulas is defined inductivly be the following rules:
\begin_inset Formula 
\[
\begin{array}{cl}
1. & \varphi_{init}\in T\\
 & \,\\
2. & \infer[edge\in CFA_{i}]{\mathrm{SP}_{edge}(\varphi)\in T}{\varphi\in T}
\end{array}
\]

\end_inset

All reachable states can be obtain by aplying 
\begin_inset Formula $[\ldotp]$
\end_inset

 on all the formulas in 
\begin_inset Formula $T$
\end_inset

.
 Note that formulas is in 
\begin_inset Formula $T$
\end_inset

 that are not feasible this operation will give the empty set of concreate
 states.
 Program is 
\emph on
safe 
\emph default
iff there is no 
\begin_inset Formula $\varphi\in T$
\end_inset

 such that 
\begin_inset Formula $\varphi_{err}\land\varphi$
\end_inset

 is satisfiable.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Section*
2 Rely-Guarantee CPA with Large-Block Encoding
\end_layout

\begin_layout Plain Layout
We present in this section a CPA for rely-guarantee analysis.
 For simplicity the CPA is restricted to two threads, by can be easily extended.
\end_layout

\begin_layout Enumerate
The abstract domain is 
\begin_inset Formula $D=(C,\mathcal{E},[\cdot])$
\end_inset

.
 The concreate states were defined before.
 The lattice is 
\begin_inset Formula $\mathcal{E}=(E,\top,\sqsubseteq,\sqcup)$
\end_inset

.
 The lattice elements are 
\begin_inset Formula $E=A_{1}\times E_{1}\times A_{2}\times E_{2}$
\end_inset

, where 
\begin_inset Formula $A_{1,2}$
\end_inset

 are standard predicate elements.
 
\begin_inset Formula $E_{i}$
\end_inset

 contain environmental transitions generated by thread 
\begin_inset Formula $i$
\end_inset

, which are of the form 
\begin_inset Formula $(guard,update)$
\end_inset

.
 Here, 
\begin_inset Formula $guard$
\end_inset

 is a formula that describes 
\end_layout

\begin_layout Enumerate
Transfer relation.
 
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\begin{array}{cl}
1. & \varphi_{init}\in T_{i}\\
 & \,\\
2. & \infer[edge\in CFA_{i}]{SP_{edge}(\varphi)\in T_{i}}{\varphi\in T_{i}}\\
 & \,\\
3. & \infer[edge\in CFA_{i}]{(\psi,edge)\in E_{i}}{\varphi\in T_{i}\qquad\varphi\rightarrow\psi}\\
 & \,\\
4. & \infer[i\neq j]{SP_{edge}(\varphi\land\psi)\in T_{i}}{\varphi\in T_{i}\quad\quad(\psi,edge)\in E_{j}}
\end{array}
\]

\end_inset

Program is safe
\emph on
 with respect to rely-guarantee
\emph default
 iff there is no 
\begin_inset Formula $\varphi\in T_{i}$
\end_inset

 such that 
\begin_inset Formula $\varphi_{err}\land\varphi$
\end_inset

 is satisfiable.
\end_layout

\begin_layout Lemma
If a program is safe, then it is safe w.r.t rely-guarantee.
\end_layout

\begin_layout Proof
The proof is by counterpositive: if a program is unsafe w.r.t.
 to rely-guarantee, then it is unsafe.
 Assume that 
\end_layout

\begin_layout Lemma
If a program is safe w.r.t.
 rely-guarantee, then it is safe.
\end_layout

\begin_layout Proof
Let's us prove the counterpositive statement: if a program is unsafe, then
 it is unsafe w.r.t to rely-guarantee.
 Unsafe program means that there exists a interleaving 
\begin_inset Formula $\psi\in T$
\end_inset

 such that 
\begin_inset Formula $\psi\land\varphi_{err}$
\end_inset

 is satisfiable.
 It can be showed by induction that in this case it is possible to obtain
 
\begin_inset Formula $\psi\in T_{i}$
\end_inset

.
 The key point is to use 
\begin_inset Formula $\varphi$
\end_inset

 as 
\begin_inset Formula $\psi$
\end_inset

 in rule no.
 3.
 
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Section
Preliminaries, Semantics
\end_layout

\begin_layout Subsection
Program counters
\end_layout

\begin_layout Plain Layout
Often the program counter is a distnguished variable that it is tracted
 by a separate CPA.
 In rely-guarantee method the program counters may appear in interpolatino
 formulas, to detected cases where this information should be tracted by
 other threads.
 For simplicy, we assume that program counters appear in formulas, like
 every other variable.
 As a result the strongest postcondition 
\begin_inset Formula $\mathrm{SP_{edge}}$
\end_inset

 is defined on CFA edges 
\begin_inset Formula $edge\in L\times Ops\times L$
\end_inset

, rather thant operation only.
 Strongest postcondition by an edge 
\begin_inset Formula $(l,op,l^{\prime})$
\end_inset

 in thread 
\begin_inset Formula $i$
\end_inset

 can be though of sequence of three operations: checking if the inital program
 counter matches 
\begin_inset Formula $l$
\end_inset

, executing the operation 
\begin_inset Formula $op$
\end_inset

 itself and then, updating the program counter to 
\begin_inset Formula $l^{\prime}$
\end_inset

.
 More formally, if the 
\begin_inset Formula $SP^{old}$
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

traditional
\begin_inset Quotes erd
\end_inset

 strongerst postcondition, as described in 
\begin_inset CommandInset citation
LatexCommand cite
key "Beyer10"

\end_inset

, then our operator is 
\begin_inset Formula 
\[
SP_{(l,op,l^{\prime})}\,=\, SP_{assume(pc_{i}=l)}^{old}\circ SP_{op}^{old}\circ SP_{pc_{i}=l^{\prime}}^{old}.
\]

\end_inset


\end_layout

\begin_layout Subsection
General algorithm
\end_layout

\begin_layout Plain Layout
Let us considerer a program that consists of 
\begin_inset Formula $N$
\end_inset

 threads.
 For each thread 
\begin_inset Formula $i$
\end_inset

 we have a set 
\begin_inset Formula $\mathcal{P}_{i}$
\end_inset

 of predicates and a set 
\begin_inset Formula $R_{i}$
\end_inset

.
 Similarly, for every pair 
\begin_inset Formula $i\neq j$
\end_inset

 of threads there is a set 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

 of environemtal predicates and a set 
\begin_inset Formula $E_{i\triangleright j}$
\end_inset

 of enviromental transitions.
 If the sets of enviromental transitions are empty, then the standard LBE
 analysis is conducted on each thread with the predicates from 
\begin_inset Formula $\mathcal{P}_{i}$
\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Enviromental transitions are of the form 
\begin_inset Formula $(guard,edge)\in E_{i\triangleright j}$
\end_inset

, where 
\begin_inset Formula $guard$
\end_inset

 is a formula and 
\begin_inset Formula $edge$
\end_inset

 is an operation to be performed.
 The guard works as a preconditions --- the edge may only be applied on
 abstract states, whose valuations do not contradict the valuation of the
 guard.
 To apply an enviormental transition
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $(\phi,g)$
\end_inset

 on a some state 
\begin_inset Formula $(\psi,\varphi)$
\end_inset

, we compute 
\begin_inset Formula $(\psi,SP_{g}(\varphi\land\psi))$
\end_inset

 --- this will apply the operation 
\begin_inset Formula $g$
\end_inset

 on the states that statisfy the guard.
 For the sake of simplicity, we will often refer to enviromental transitinos
 as simply 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
transitions
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
.
\end_layout

\begin_layout Plain Layout
If a CFA edge 
\begin_inset Formula $g$
\end_inset

 is applied to an abstract state 
\begin_inset Formula $(\psi,\varphi)$
\end_inset

, then an enviromental transition may generated.
 We require that the guard overapproximates the formula 
\begin_inset Formula $\psi\land\varphi$
\end_inset

.
 In the simple case, the generated transition can be 
\begin_inset Formula $(\psi\land\varphi,g)$
\end_inset

, which I have been doing so far.
 However, the formula 
\begin_inset Formula $\psi\land\varphi$
\end_inset

 may be uncessary precise and difficult to compute.
 It may be beneficial to abstract the guard using the predicates 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
from 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

, which inform us which part of guards are important.
 The set 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

 can be enlarged by interpolation.
 In general enviromental transition are applied frequently, so it is better
 to have them as simple and as few as possible.
 
\end_layout

\begin_layout Subsection
Approximation of operations
\end_layout

\begin_layout Plain Layout
In the paper by Gupta et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Gupta11"

\end_inset

, the operations are also abstracted, just like the guards.
 We could take the same approach and intoduce a set of predicates for operation,
 but the question whether this would be beneficial.
 Operation have to be instanted to some concreate values, otherwise they
 do have a meaning, e.g.
 the edge 
\begin_inset Formula $g$
\end_inset

 applied to an abstract state 
\begin_inset Formula $(\psi,\varphi)$
\end_inset

 has a meaning only as 
\begin_inset Formula $(\psi,SP_{g}(\varphi))$
\end_inset

.
 But then, the same operation
\end_layout

\begin_layout Subsection
Most general enviromental transitions
\end_layout

\begin_layout Plain Layout
Transition 
\begin_inset Formula $(\phi_{1},g_{1})$
\end_inset

 is more general than 
\begin_inset Formula $(\phi_{2},g_{2})$
\end_inset

 if the result of applying gives a biger overapproximation:
\begin_inset Formula 
\[
(\phi_{1},g_{1})\sqsupseteq(\phi_{2},g_{2})\quad\text{iff}\quad\forall\varphi\in\mathscr{P}\,:\, SP_{g_{1}}(\varphi\land\phi_{1})\models SP_{g_{2}}(\varphi\land\phi_{2})
\]

\end_inset

where 
\begin_inset Formula $\mathscr{P}$
\end_inset

 is the set of all path formulas.
 In order to have as few transitions as possible, only the most general
 transition should be applied.
 It remains an open question how to decided whether 
\begin_inset Formula $(\phi_{1},g_{1})\sqsupseteq(\phi_{2},g_{2})$
\end_inset

 holds.
\end_layout

\begin_layout Subsection
How to apply enviromental transitions
\end_layout

\begin_layout Plain Layout
Were interested in safety properties, therefore we apply enviormental transition
 that would change the flow of the program.
 These only can be assigments to global variables, since they could affect
 the branches that are taken.
 Assume edges do not affect other threads, so they do not generate enviormental
 transitions.
 The transition with global assigments do not have to be applied at every
 abstract element of a thread, but it is enough to apply them before the
 global variable is read.
 In the terms of partial-order reduction, enviormental transitions and non-globa
l reads are 
\emph on
independent
\emph default
.
 In some cases enviromental transition can only be applied after some other
 transitions updated the abstract state.
 This implies, that before global reads it shoul be be possible to apply
 all enviromental transition, even if they assigned to local variables.
 Similarly, to get transitions with all possible guard statements, enviromental
 transitinos should also be applied before edges that generate new transitions.
\end_layout

\begin_layout Plain Layout
To sumarize:
\end_layout

\begin_layout Enumerate
enviromentaltransitions are generate by any assigments
\end_layout

\begin_layout Enumerate
all enviromental transitions can be applied before global reads and any
 assigments.
 
\end_layout

\begin_layout Plain Layout

\series bold
TODO
\series default
 write about combing
\end_layout

\begin_layout Subsection
Static Single Assigment
\end_layout

\begin_layout Plain Layout
In 
\shape smallcaps
CPAchecker
\shape default
 formulas are skolemized with SSA indexes.
 In our analysis every thread has an unique identifier, which is added to
 all variables names that appear in its formulas, e.g.
 variables in thread 
\begin_inset Formula $1$
\end_inset

 are not primed, in thread two are primed once, etc.
 This is necessary for working in formulas in SSA format, so that the old
 values do not collide.
 
\end_layout

\begin_layout Plain Layout
Suppose that we have an abstract state an abstract state 
\begin_inset Formula $(\psi,\varphi)$
\end_inset

 in thread 
\begin_inset Formula $i$
\end_inset

 and an assigment edge 
\begin_inset Formula $g$
\end_inset

.
 To generate a transition we perform cartesian or boolean abstraction on
 
\begin_inset Formula $\psi\land\varphi$
\end_inset

 with the predicates from 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

.
 The transitions consists of the abstracted formula and the edge.
 If we decide not use environmental predicates, then we take 
\begin_inset Formula $\psi\land\varphi$
\end_inset

 as the guard
\end_layout

\begin_layout Plain Layout
Now, assume that we want to apply a transition 
\begin_inset Formula $(\phi,g)$
\end_inset

 an an abstract state 
\begin_inset Formula $(\psi,\varphi)$
\end_inset

.
 By appling the guard 
\begin_inset Formula $\phi$
\end_inset

, we want to get a path formula that describes valuations that are satisfied
 by both 
\begin_inset Formula $\varphi$
\end_inset

 and 
\begin_inset Formula $\psi\land\phi$
\end_inset

.
 Since they are in SSA form, so only the last indexes should match and others
 should to be different.
 We build equalities over the last indexes of corresponding variables in
 
\begin_inset Formula $\varphi$
\end_inset

 and 
\begin_inset Formula $\psi$
\end_inset

.
 The old values of variables from different thread do not collide, because
 of priming.
 
\end_layout

\begin_layout Plain Layout
If we do not abstract enviormental transitions, then the guard might have
 colliding variables.
 This may happen when a transition is made from thread A to B and from B
 to A.
 We can avoid this situation by using environemtnal predicates or abstracting
 after each transition application.
\end_layout

\begin_layout Plain Layout
TODO write about possible benefits
\end_layout

\begin_layout Section
Interpolation
\end_layout

\begin_layout Subsection
Three ways of generating env.
 transitions
\end_layout

\begin_layout Subsection
Most general
\end_layout

\begin_layout Subsection
Avoiding blow-up
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This draft presents the design for rely-guaranratee verification with large-bloc
k encoding.
 Based on previous experiments, I have indetified three goals for the design:
\end_layout

\begin_layout Enumerate
interpolation supports non-modular environmental transitions
\end_layout

\begin_layout Enumerate
interpolation does not not interpolate the same same formula multiple times,
 which leads to huge numbers of interpolation formulas,
\end_layout

\begin_layout Enumerate
small number of abstractions, since they are costly under LBE.
\end_layout

\begin_layout Section
Interpolation
\end_layout

\begin_layout Standard
In rely-gurantee method one block formulas may generate an enviormental
 transitions, which is then applied mutliple times.
 In the current interpolation procedure, each application of the enviromental
 transition will have its own version of the block.
 In this techqniue appling enviormental transitinos is treated as calling
 a function, that does not take any formal arguments.
 The details may be found in Section 5.2 of Henziger et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Henzinger:2004"

\end_inset

.
 
\end_layout

\begin_layout Standard
This however may lead to exponental number of interpolation formulas.
 If the block are not uniquelly renamed for each application, then the interpola
nts may not be well-scoped, i.e.
 the can refer to variables outside their scope.
 As an example consider Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "itp_problem"

\end_inset

, where diamons denote abstraction points, horizontal lines are formulas
 from thread 
\begin_inset Formula $T0$
\end_inset

 and veritcal are from thread 
\begin_inset Formula $T1$
\end_inset

.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Block 
\begin_inset Formula $g=0$
\end_inset

 is used in three places, which causes interpolation problems.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "itp_problem"

\end_inset


\end_layout

\end_inset

Block 
\begin_inset Formula $g=0$
\end_inset

 appears three times: once local and twice in enviormental transitions.
 The current interpolation procedure will generate three uniquee version
 of 
\begin_inset Formula $g=0$
\end_inset

, so its applications have the correct information, but are still well-scoped.
 For example the interpolant for block 
\begin_inset Formula $x^{\prime}=g+1$
\end_inset

 is computed from 
\begin_inset Formula 
\[
(g^{1}=0\land x^{\prime}=g^{1}+1,\, g^{0}=0\land g^{2}=0\land y^{\prime}=g^{2}-1\land x^{\prime}=y^{\prime}\land g=0)
\]

\end_inset

which always gives a well-scoped predicate.
 
\end_layout

\begin_layout Standard
The method works under the assumption that variables in a formula trance
 and and enviromental transitions applied to it are renamed apart (see 
\begin_inset CommandInset citation
LatexCommand cite
key "Henzinger:2004"

\end_inset

).
 This implies that with an ordinary theorem prover the exponential blow-up
 can always occure (I'd be very happy if the reader could falsify this statement
).
 
\end_layout

\begin_layout Standard
In Gupta et all.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Gupta11"

\end_inset

 an novel interpolatino method is used for such cases.
 Block are modeled as Horn clauses and interpolants as unknown predicates.
 For Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "itp_problem"

\end_inset

 the clauses are:
\begin_inset Formula 
\[
\begin{array}{c}
g=0\rightarrow\psi_{g=0}\\
\psi_{g=0}\land x^{\prime}=g+1\rightarrow\psi_{x^{\prime}=g+1}\\
\psi_{g=0}\land y^{\prime}=g-1\rightarrow\psi_{y^{\prime}=g-1}\\
\psi_{g=0}\land\psi_{x^{\prime}=g+1}\land\psi_{y^{\prime}=g-1}\land x^{\prime}=y^{\prime}\land g=0\rightarrow false
\end{array}
\]

\end_inset

where 
\begin_inset Formula $\psi$
\end_inset

-formulas are unknown predicates over 
\begin_inset Formula $g,x^{\prime},y^{\prime}$
\end_inset

.
 
\end_layout

\begin_layout Section
Generalized Enviorment
\end_layout

\begin_layout Standard
Test have proved that the best combination for software verifications is
 single-block encoding with Cartesian abstraction or large-block encoding
 with boolean abstraction.
 In rely-guarantee method an enviromental transition can be applied any
 number of times, e.g.
 a transition which increments some variable and can be applied anywhere.
 In LBE, where operations simply extend the path formula, such transitions
 could be applied infintly many times, each time giving a distinct path
 formula.
 The cut this chain of application, at some point the formula has to be
 abstracted.
 The abstraction is at the same location, so unless covered, the transitions
 can be applied again.
 As a result, the locations where environmental transitions can be applied
 become abstraction points.
 As test have showed, boolean abstraction with many abstractions points
 decreases performance 
\begin_inset CommandInset citation
LatexCommand cite
key "Beyer10"

\end_inset

.
 
\end_layout

\begin_layout Standard
A promising solution is to create a single transitions that overapproximates
 the overall effect of the enviroment.
 It would be enough to apply the transiton only once --- subsquent application
 would not give more values.
 LBE analysis could treat the environment as yet another transition and
 would not have to abstract at these locations.
 The precision of a transition generated by thread 
\begin_inset Formula $i$
\end_inset

 to be applied to thread 
\begin_inset Formula $j$
\end_inset

 would be controlled a set 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

 of predicates.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $V$
\end_inset

 be the set of all variables that occur in a program, 
\begin_inset Formula $V_{g}$
\end_inset

 be global variables,
\begin_inset Formula $V_{i}$
\end_inset

 be variables that are local only to thread 
\begin_inset Formula $j$
\end_inset

.
 Let 
\begin_inset Formula $X^{\prime}$
\end_inset

 that set 
\begin_inset Formula $X$
\end_inset

 with its elements primed.
 is The predicates in 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

 are expressions over 
\begin_inset Formula $V\cup V_{g}^{\prime}\cup V_{i}^{\prime}$
\end_inset

.
 The unprimed variables refer to state before the transition and primed
 elements are the values after applying the transitions.
 We use 
\begin_inset Formula $id_{X}$
\end_inset

 to denote the set of equlaties 
\begin_inset Formula 
\[
id_{X}=\{v=v^{\prime}\,|\, v\in X\}
\]

\end_inset

and we require that 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}\supseteq id_{V_{g}\cup V_{i}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
We will investigate the implementation side of the problem, so let abstract
 states be formulas over 
\begin_inset Formula $V$
\end_inset

 in static single assigment format.
 We also assume that variables in each thread have an unique label.
 Let 
\begin_inset Formula $SP_{op}(\varphi)$
\end_inset

 be a successor of abstract state 
\begin_inset Formula $\varphi$
\end_inset

 by operation 
\begin_inset Formula $op$
\end_inset

.
 For each predicate in 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

 we instatiate unprimed variable to the last SSA index in 
\begin_inset Formula $\varphi$
\end_inset

 and the primed version to the last index in 
\begin_inset Formula $SP_{op}(\varphi)$
\end_inset

.
 For every instance 
\begin_inset Formula $i$
\end_inset

 a fresh propositional variable 
\begin_inset Formula $p_{i}$
\end_inset

 is introduced and the equality 
\begin_inset Formula $i\longleftrightarrow p_{i}$
\end_inset

 is appedned to the formula.
 The Boolean predicate abstraction is constructed by enumarting all models
 of the fresh variables in the extended formula.
 For a variable 
\begin_inset Formula $v$
\end_inset

 that have not been changed by 
\begin_inset Formula $op$
\end_inset

 the primed and unprimed versions will be the same, so the predicate 
\begin_inset Formula $v^{\prime}=v$
\end_inset

 will follow.
 The unprimed variables of a transitions are assosiated with SSA map of
 
\begin_inset Formula $\varphi$
\end_inset

, while primed variables are assosiated with SSA map of 
\begin_inset Formula $SP_{op}(\varphi)$
\end_inset

.
 This is needed by interpolation to relate the creation and application
 formulas.
\end_layout

\begin_layout Example
Threads 
\begin_inset Formula $T_{1}$
\end_inset

 and 
\begin_inset Formula $T_{2}$
\end_inset

 have one global variable 
\begin_inset Formula $V=\{g\}$
\end_inset

 and local variables 
\begin_inset Formula $V_{0}=\{pc_{1},x\}$
\end_inset

 and 
\begin_inset Formula $V_{1}=\{pc_{2},y\}$
\end_inset

.
 Additionally, variables in 
\begin_inset Formula $T_{1}$
\end_inset

 have an unpper index 
\begin_inset Formula $1$
\end_inset

, while in 
\begin_inset Formula $T_{2}$
\end_inset

 they have index 
\begin_inset Formula $2$
\end_inset

.
 Suppose that the environemtal predicates are
\begin_inset Formula 
\[
\mathcal{P}_{1\triangleright2}=\{g^{\prime}=g,\, pc_{1}^{\prime}=pc_{1},\, x^{\prime}=x,\, x\geq5,\, g^{\prime}=x+1\}.
\]

\end_inset

Image that we have abstract state in 
\begin_inset Formula $T_{1}$
\end_inset


\begin_inset Formula 
\[
\mbox{\varphi}_{1}:\, x^{1}@1=5\,\land\, pc_{1}^{1}@1=2\,\land\, g^{1}@1<10\,\land\, y^{1}@1\neq x^{1}@1
\]

\end_inset

and we apply operation 
\begin_inset Formula $op:\, pc_{1}=2\xrightarrow{x:=x+1}pc_{1}=3$
\end_inset

, thus obtaining the state 
\begin_inset Formula 
\begin{equation}
SP_{op}(\varphi_{1}):\, x^{1}@1=5\,\land\, pc_{1}^{1}@1=2\,\land\, g^{1}@1<10\,\land\, y^{1}@1\neq x^{1}@1\,\land\, x^{1}@2=6\,\land\, pc_{1}^{1}@2=3.\label{eq:e1_source}
\end{equation}

\end_inset

The abstraction formula for 
\begin_inset Formula $SP_{op}(\varphi_{1})$
\end_inset

 with the predicates from 
\begin_inset Formula $\mathcal{P}_{1\triangleright2}$
\end_inset

 is:
\begin_inset Formula 
\[
\begin{array}{c}
x^{1}@1=5\,\land\, pc_{1}^{1}@1=2\,\land\, g^{1}@1<10\,\land\, y^{1}@1\neq x^{1}@1\,\land\, x^{1}@2=6\,\land\, pc_{1}^{1}@2=3\,\land\,\\
p_{1}\leftrightarrow g^{1}@1=g^{1}@1\,\land\, p_{2}\leftrightarrow pc_{1}^{1}@2=pc_{1}^{1}@1\,\land\, p_{3}\leftrightarrow x^{1}@2=x^{1}@1\,\land\,\\
p_{4}\leftrightarrow x^{1}@1\geq5\,\land\, p_{5}\leftrightarrow g^{1}@2=x^{1}@1+1.
\end{array}
\]

\end_inset

After abstraction the environmental transition 
\begin_inset Formula $e_{1}$
\end_inset

 is 
\begin_inset Formula 
\[
e_{1}\,:\, g^{\prime}=g\,\land\, pc_{1}^{\prime}\neq pc_{1}\,\land\, x^{\prime}\neq x\,\land\, x\geq5.
\]

\end_inset

The assiosiated SSA map for unprimed variables is 
\begin_inset Formula 
\[
\{x^{1}\mapsto1,pc_{1}^{1}\mapsto1,g^{1}\mapsto1,y^{1}\mapsto1\}
\]

\end_inset

and for primed variables is
\begin_inset Formula 
\[
\{x^{1}\mapsto2,pc_{1}^{1}\mapsto2,g^{1}\mapsto1,y^{1}\mapsto1\}.
\]

\end_inset

The predicate 
\begin_inset Formula $g^{\prime}=x+1$
\end_inset

 does not appear in 
\begin_inset Formula $e_{1}$
\end_inset

 since it may or may not hold.
\end_layout

\begin_layout Example
Suppose we have a transition 
\begin_inset Formula $e$
\end_inset

 from thread 
\begin_inset Formula $i$
\end_inset

 we want to apply it on a abstract formula 
\begin_inset Formula $\psi$
\end_inset

 in thread 
\begin_inset Formula $j$
\end_inset

.
 The procedure is:
\end_layout

\begin_layout Enumerate
For every variable 
\begin_inset Formula $v\in V$
\end_inset

 we appeand an equality 
\begin_inset Formula $v^{i}=v^{j}$
\end_inset

 to 
\begin_inset Formula $\psi$
\end_inset

, where 
\begin_inset Formula $v^{j}$
\end_inset

 is the latest version of 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $\psi$
\end_inset

 and 
\begin_inset Formula $v^{i}$
\end_inset

 is the latest version of 
\begin_inset Formula $v$
\end_inset

 in the unprimed SSA map of 
\begin_inset Formula $e$
\end_inset

.
 By 
\begin_inset Quotes eld
\end_inset

latest version of 
\begin_inset Formula $v$
\end_inset


\begin_inset Quotes erd
\end_inset

 we mean the one with the highest index modulo the unqiee thread labels.
 The equalities will relate valuations of 
\begin_inset Formula $\psi$
\end_inset

 with the unprimed variables in 
\begin_inset Formula $e$
\end_inset

.
\end_layout

\begin_layout Enumerate
Transition 
\begin_inset Formula $e$
\end_inset

 is instantiated with the two assosiated SSA maps: unprimed variables with
 the first map and primed with the other.
 This gives an abstract formula that is weaker then the foruma that generated
 the transition.
 Since threads have unique labels,the instatited formula does not overlapp
 with 
\begin_inset Formula $\psi$
\end_inset

.
 The instance is appeanded to 
\begin_inset Formula $\psi$
\end_inset

.
\end_layout

\begin_layout Enumerate
For every variable 
\begin_inset Formula $v$
\end_inset

 that can be changed by thread 
\begin_inset Formula $i$
\end_inset

, that is by 
\begin_inset Formula $v\in V_{g}\cup V_{i}$
\end_inset

, an equality 
\begin_inset Formula $w^{i}=w^{j}$
\end_inset

 is appeaned to 
\begin_inset Formula $\varphi$
\end_inset

, where 
\begin_inset Formula $w^{i}$
\end_inset

 is the latest version of 
\begin_inset Formula $v$
\end_inset

 in the primed SSA map of 
\begin_inset Formula $e$
\end_inset

 and 
\begin_inset Formula $w^{j}$
\end_inset

 is a new version of 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $\psi$
\end_inset

.
 These related the primed variables of 
\begin_inset Formula $e$
\end_inset

 with new values of variables.
\end_layout

\begin_layout Example
Let us apply transition 
\begin_inset Formula $e_{1}$
\end_inset

 from the previous example on a state 
\begin_inset Formula $\psi$
\end_inset

 in thread 
\begin_inset Formula $T_{2}$
\end_inset

 
\begin_inset Formula 
\begin{equation}
\psi:\, g^{2}@5=3\,\land\, pc_{2}^{2}@5=4\,\land\, y^{2}@5>0.\label{eq:applicationI}
\end{equation}

\end_inset

In step 1.
 the following equalities are added to 
\begin_inset Formula $\psi$
\end_inset

:
\begin_inset Formula 
\begin{equation}
g^{2}@5=g^{1}@1\,\land\, pc_{1}^{2}@1=pc_{1}^{1}@1\,\land\, x^{2}@1=x^{1}@1\,\land\, pc_{2}^{2}@5=pc_{2}^{1}@1\,\land\, y^{2}@5=y^{1}@1.\label{applicationII}
\end{equation}

\end_inset

Here, we assumed that variables that do not appear in SSA map, like 
\begin_inset Formula $x^{2}$
\end_inset

 in 
\begin_inset Formula $\psi$
\end_inset

, have a default index 
\begin_inset Formula $1$
\end_inset

.
 In step 2.
 
\begin_inset Formula $e_{1}$
\end_inset

 is instantiated to a formula 
\begin_inset Formula $\dot{e_{1}}$
\end_inset

 
\begin_inset Formula 
\begin{equation}
\dot{e_{1}}\,:\, g^{1}@1=g^{1}@1\,\land\, pc_{1}^{1}@2\neq pc_{1}^{1}@1\,\land\, x^{1}@2\neq x^{1}@1\,\land\, x^{1}@1\geq5.\label{applicationIII}
\end{equation}

\end_inset

Note that it holds that 
\begin_inset Formula $SP_{op}(\varphi)\rightarrow\dot{e_{1}}$
\end_inset

.
 The equalities added in step 1.
 relate the last valuations of 
\begin_inset Formula $\psi$
\end_inset

 of to the lowest indexes of 
\begin_inset Formula $\dot{e_{1}}$
\end_inset

.
 In step 3.
 the following equalites link the the lastest values of 
\begin_inset Formula $\dot{e_{1}}$
\end_inset

 with new valuations of 
\begin_inset Formula $\psi$
\end_inset

: 
\begin_inset Formula 
\begin{equation}
g^{2}@6=g^{1}@1\,\land\, pc_{1}^{2}@2=pc_{1}^{1}@2\,\land\, x^{2}@2=x^{1}@2.\label{applicationIV}
\end{equation}

\end_inset

The new formula 
\begin_inset Formula $\psi^{\prime}$
\end_inset

is conjuction of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:applicationI"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "applicationII"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "applicationIII"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "applicationIV"

\end_inset

.
 Variables 
\begin_inset Formula $pc_{2}$
\end_inset

, 
\begin_inset Formula $y$
\end_inset

, which are local to 
\begin_inset Formula $T_{2}$
\end_inset

, remain unchanged by the application.
 On the other hand, variables 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $pc_{1}$
\end_inset

, 
\begin_inset Formula $x$
\end_inset

 get new values specified by the constraint of 
\begin_inset Formula $e$
\end_inset

.
 For instance, 
\begin_inset Formula $pc_{1}^{2}@2$
\end_inset

 can have any value, as long it different from 
\begin_inset Formula $pc_{1}^{2}@1$
\end_inset

.
 The instated formula 
\begin_inset Formula $\dot{e_{1}}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "applicationIII"

\end_inset

 related the application to formula 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:e1_source"

\end_inset

 that generated 
\begin_inset Formula $e_{1}$
\end_inset

, which is necessary for interpolation.
 Image that after the application of 
\begin_inset Formula $e_{1}$
\end_inset

 to 
\begin_inset Formula $\psi$
\end_inset

 there is an assertion that 
\begin_inset Formula $x^{2}\neq5$
\end_inset

 (let us skip over the detail that 
\begin_inset Formula $x$
\end_inset

 is local to 
\begin_inset Formula $T_{0}$
\end_inset

).
 The new abstract state 
\begin_inset Formula $\psi^{\prime}$
\end_inset

 might violate the assertion, so interpolation is perfomed to check if the
 formula trace is feasible.
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $SP_{op}(\varphi)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x^{1}@1=5\,\land\, pc_{1}^{1}@1=2\,\land\, g^{1}@1<10\,\land\, y^{1}@1\neq x^{1}@1\,\land\, x^{1}@2=6\,\land\, pc_{1}^{1}@2=3$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\psi^{\prime}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
g^{2}@5=3\,\land\, pc_{2}^{2}@5=4\,\land\, y^{2}@5>0\,\land\\
g^{2}@5=g^{1}@1\,\land\, pc_{1}^{2}@1=pc_{1}^{1}@1\,\land\, x^{2}@1=x^{1}@1\,\land\, pc_{2}^{2}@5=pc_{2}^{1}@1\,\land\, y^{2}@5=y^{1}@1\land\\
g^{1}@1=g^{1}@1\,\land\, pc_{1}^{1}@2\neq pc_{1}^{1}@1\,\land\, x^{1}@2\neq x^{1}@1\,\land\, x^{1}@1\geq5\,\land\\
g^{2}@6=g^{1}@1\,\land\, pc_{1}^{2}@2=pc_{1}^{1}@2\,\land\, x^{2}@2=x^{1}@2\,\land
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assert
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x^{2}@2\neq5$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "ref"
options "ieeetr"

\end_inset


\end_layout

\end_body
\end_document
