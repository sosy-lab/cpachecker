#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{amsfonts}%
\usepackage{amssymb}%
\usepackage{amsthm}
\usepackage{makeidx} % index
\usepackage{color} 
\usepackage{graphicx} 
\usepackage{booktabs} 
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{lscape}	% change to landscape on the fly
\usepackage{latexsym}
\usepackage{wasysym}
\usepackage{savesym}
\usepackage{babel}
\usepackage{parskip}
\usepackage{thmtools}
\usepackage{algorithmic}
\usepackage{stmaryrd}
\usepackage{fullpage}
\usepackage{url}
\usepackage{proof}


\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit,petri,automata}
\usepgflibrary{shapes.geometric}
\end_preamble
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 12.5cm
\paperheight 6cm
\leftmargin 0cm
\topmargin 0cm
\rightmargin 0cm
\bottommargin 0cm
\secnumdepth 4
\tocdepth 4
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Generalized Environment: A Draft
\end_layout

\begin_layout Author
Przemys
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
l
\end_layout

\end_inset

 aw Daca
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $P$
\end_inset

 - program that consists of 
\begin_inset Formula $N\geq1$
\end_inset

 threads
\begin_inset Newline newline
\end_inset

CFA for thread 
\begin_inset Formula $i$
\end_inset

 constists of 
\begin_inset Formula $L$
\end_inset

 locations and 
\begin_inset Formula $L\times Ops\times L$
\end_inset

 constrol-flow edges.
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $V$
\end_inset

 - set of all variables that appear in a program
\begin_inset Newline newline
\end_inset


\begin_inset Formula $V_{g}\subseteq V$
\end_inset

 - global variables
\begin_inset Newline newline
\end_inset


\begin_inset Formula $V_{i}\subseteq V\backslash V_{g}$
\end_inset

 - set of all variables local to thread 
\begin_inset Formula $i$
\end_inset

, including the program counter
\begin_inset Newline newline
\end_inset


\begin_inset Formula $C$
\end_inset

 - set of all valuations of variables in 
\begin_inset Formula $V$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $C_{x}$
\end_inset

 - set of all valutinos of variables in 
\begin_inset Formula $V_{x}$
\end_inset


\end_layout

\begin_layout Plain Layout
Sets of concreate states are represented by first order formula with free
 variables from 
\begin_inset Formula $V$
\end_inset

.
 Given formula 
\begin_inset Formula $\varphi$
\end_inset

: 
\begin_inset Formula $[\varphi]=\{\, c\in C\,|\, c\models\varphi\}$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\varphi_{init}$
\end_inset

- global inital state of 
\begin_inset Formula $P$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\varphi_{err}$
\end_inset

 - error states
\end_layout

\begin_layout Plain Layout
In rely-guarantee reasoning, programs counters are treated like any other
 variable and may appear in interpolants.
 To avoid cluttering of notation, we assume that programs counters are tracted
 in path formulas like other variables.
 As a result the strongest postcondition 
\begin_inset Formula $\mathrm{SP_{edge}}$
\end_inset

 is defined on CFA edges 
\begin_inset Formula $edge\in L\times Ops\times L$
\end_inset

, rather thant operation only.
 The strongest postcondition by an edge checks if the start location matches,
 applies the operation itself and then updates the program counter.
 Compared to For an assume edge 
\begin_inset Formula $assume(p)$
\end_inset

 that goes from location 
\begin_inset Formula $l$
\end_inset

 to 
\begin_inset Formula $l^{\prime}$
\end_inset

, we have 
\begin_inset Formula 
\[
SP_{l\xrightarrow{assume(p)}l^{\prime}}(\varphi)\,=\,\exists\overline{pc_{i}}\,:\,\,(pc_{i}=l\,\land\,\varphi\,\land\, p)_{[pc_{i}\mapsto\overline{pc_{i}}]}\,\land\, pc_{i}=l^{\prime}
\]

\end_inset

For an assigment operation 
\begin_inset Formula $l\xrightarrow{s:=e}l^{\prime}$
\end_inset

 in thread 
\begin_inset Formula $i$
\end_inset

 we get
\begin_inset Formula 
\[
SP_{l\xrightarrow{s:=e}l^{\prime}}(\varphi)\,=\,\exists\overline{s},\overline{pc_{i}}\,:\,(pc_{i}=l\,\land\,\varphi)_{[s\mapsto\overline{s},pc_{i}\mapsto\overline{pc_{i}}]}\,\land\, pc_{i}=l^{\prime}\,\land\, s=e_{[s\mapsto\overline{s},pc_{i}\mapsto\overline{pc_{i}}]}.
\]

\end_inset

Note that if an edge is applied on a wrong location, then the resulting
 formula is unsatisfiable.
\end_layout

\begin_layout Plain Layout
We assume that programs have interleaving semantics, i.e the set off possible
 formulas is defined inductivly be the following rules:
\begin_inset Formula 
\[
\begin{array}{cl}
1. & \varphi_{init}\in T\\
 & \,\\
2. & \infer[edge\in CFA_{i}]{\mathrm{SP}_{edge}(\varphi)\in T}{\varphi\in T}
\end{array}
\]

\end_inset

All reachable states can be obtain by aplying 
\begin_inset Formula $[\ldotp]$
\end_inset

 on all the formulas in 
\begin_inset Formula $T$
\end_inset

.
 Note that formulas is in 
\begin_inset Formula $T$
\end_inset

 that are not feasible this operation will give the empty set of concreate
 states.
 Program is 
\emph on
safe 
\emph default
iff there is no 
\begin_inset Formula $\varphi\in T$
\end_inset

 such that 
\begin_inset Formula $\varphi_{err}\land\varphi$
\end_inset

 is satisfiable.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Section*
2 Rely-Guarantee CPA with Large-Block Encoding
\end_layout

\begin_layout Plain Layout
We present in this section a CPA for rely-guarantee analysis.
 For simplicity the CPA is restricted to two threads, by can be easily extended.
\end_layout

\begin_layout Enumerate
The abstract domain is 
\begin_inset Formula $D=(C,\mathcal{E},[\cdot])$
\end_inset

.
 The concreate states were defined before.
 The lattice is 
\begin_inset Formula $\mathcal{E}=(E,\top,\sqsubseteq,\sqcup)$
\end_inset

.
 The lattice elements are 
\begin_inset Formula $E=A_{1}\times E_{1}\times A_{2}\times E_{2}$
\end_inset

, where 
\begin_inset Formula $A_{1,2}$
\end_inset

 are standard predicate elements.
 
\begin_inset Formula $E_{i}$
\end_inset

 contain environmental transitions generated by thread 
\begin_inset Formula $i$
\end_inset

, which are of the form 
\begin_inset Formula $(guard,update)$
\end_inset

.
 Here, 
\begin_inset Formula $guard$
\end_inset

 is a formula that describes 
\end_layout

\begin_layout Enumerate
Transfer relation.
 
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\begin{array}{cl}
1. & \varphi_{init}\in T_{i}\\
 & \,\\
2. & \infer[edge\in CFA_{i}]{SP_{edge}(\varphi)\in T_{i}}{\varphi\in T_{i}}\\
 & \,\\
3. & \infer[edge\in CFA_{i}]{(\psi,edge)\in E_{i}}{\varphi\in T_{i}\qquad\varphi\rightarrow\psi}\\
 & \,\\
4. & \infer[i\neq j]{SP_{edge}(\varphi\land\psi)\in T_{i}}{\varphi\in T_{i}\quad\quad(\psi,edge)\in E_{j}}
\end{array}
\]

\end_inset

Program is safe
\emph on
 with respect to rely-guarantee
\emph default
 iff there is no 
\begin_inset Formula $\varphi\in T_{i}$
\end_inset

 such that 
\begin_inset Formula $\varphi_{err}\land\varphi$
\end_inset

 is satisfiable.
\end_layout

\begin_layout Lemma
If a program is safe, then it is safe w.r.t rely-guarantee.
\end_layout

\begin_layout Proof
The proof is by counterpositive: if a program is unsafe w.r.t.
 to rely-guarantee, then it is unsafe.
 Assume that 
\end_layout

\begin_layout Lemma
If a program is safe w.r.t.
 rely-guarantee, then it is safe.
\end_layout

\begin_layout Proof
Let's us prove the counterpositive statement: if a program is unsafe, then
 it is unsafe w.r.t to rely-guarantee.
 Unsafe program means that there exists a interleaving 
\begin_inset Formula $\psi\in T$
\end_inset

 such that 
\begin_inset Formula $\psi\land\varphi_{err}$
\end_inset

 is satisfiable.
 It can be showed by induction that in this case it is possible to obtain
 
\begin_inset Formula $\psi\in T_{i}$
\end_inset

.
 The key point is to use 
\begin_inset Formula $\varphi$
\end_inset

 as 
\begin_inset Formula $\psi$
\end_inset

 in rule no.
 3.
 
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Section
Preliminaries, Semantics
\end_layout

\begin_layout Subsection
Program counters
\end_layout

\begin_layout Plain Layout
Often the program counter is a distnguished variable that it is tracted
 by a separate CPA.
 In rely-guarantee method the program counters may appear in interpolatino
 formulas, to detected cases where this information should be tracted by
 other threads.
 For simplicy, we assume that program counters appear in formulas, like
 every other variable.
 As a result the strongest postcondition 
\begin_inset Formula $\mathrm{SP_{edge}}$
\end_inset

 is defined on CFA edges 
\begin_inset Formula $edge\in L\times Ops\times L$
\end_inset

, rather thant operation only.
 Strongest postcondition by an edge 
\begin_inset Formula $(l,op,l^{\prime})$
\end_inset

 in thread 
\begin_inset Formula $i$
\end_inset

 can be though of sequence of three operations: checking if the inital program
 counter matches 
\begin_inset Formula $l$
\end_inset

, executing the operation 
\begin_inset Formula $op$
\end_inset

 itself and then, updating the program counter to 
\begin_inset Formula $l^{\prime}$
\end_inset

.
 More formally, if the 
\begin_inset Formula $SP^{old}$
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

traditional
\begin_inset Quotes erd
\end_inset

 strongerst postcondition, as described in 
\begin_inset CommandInset citation
LatexCommand cite
key "Beyer10"

\end_inset

, then our operator is 
\begin_inset Formula 
\[
SP_{(l,op,l^{\prime})}\,=\, SP_{assume(pc_{i}=l)}^{old}\circ SP_{op}^{old}\circ SP_{pc_{i}=l^{\prime}}^{old}.
\]

\end_inset


\end_layout

\begin_layout Subsection
General algorithm
\end_layout

\begin_layout Plain Layout
Let us considerer a program that consists of 
\begin_inset Formula $N$
\end_inset

 threads.
 For each thread 
\begin_inset Formula $i$
\end_inset

 we have a set 
\begin_inset Formula $\mathcal{P}_{i}$
\end_inset

 of predicates and a set 
\begin_inset Formula $R_{i}$
\end_inset

.
 Similarly, for every pair 
\begin_inset Formula $i\neq j$
\end_inset

 of threads there is a set 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

 of environemtal predicates and a set 
\begin_inset Formula $E_{i\triangleright j}$
\end_inset

 of enviromental transitions.
 If the sets of enviromental transitions are empty, then the standard LBE
 analysis is conducted on each thread with the predicates from 
\begin_inset Formula $\mathcal{P}_{i}$
\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Enviromental transitions are of the form 
\begin_inset Formula $(guard,edge)\in E_{i\triangleright j}$
\end_inset

, where 
\begin_inset Formula $guard$
\end_inset

 is a formula and 
\begin_inset Formula $edge$
\end_inset

 is an operation to be performed.
 The guard works as a preconditions --- the edge may only be applied on
 abstract states, whose valuations do not contradict the valuation of the
 guard.
 To apply an enviormental transition
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $(\phi,g)$
\end_inset

 on a some state 
\begin_inset Formula $(\psi,\varphi)$
\end_inset

, we compute 
\begin_inset Formula $(\psi,SP_{g}(\varphi\land\psi))$
\end_inset

 --- this will apply the operation 
\begin_inset Formula $g$
\end_inset

 on the states that statisfy the guard.
 For the sake of simplicity, we will often refer to enviromental transitinos
 as simply 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
transitions
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
.
\end_layout

\begin_layout Plain Layout
If a CFA edge 
\begin_inset Formula $g$
\end_inset

 is applied to an abstract state 
\begin_inset Formula $(\psi,\varphi)$
\end_inset

, then an enviromental transition may generated.
 We require that the guard overapproximates the formula 
\begin_inset Formula $\psi\land\varphi$
\end_inset

.
 In the simple case, the generated transition can be 
\begin_inset Formula $(\psi\land\varphi,g)$
\end_inset

, which I have been doing so far.
 However, the formula 
\begin_inset Formula $\psi\land\varphi$
\end_inset

 may be uncessary precise and difficult to compute.
 It may be beneficial to abstract the guard using the predicates 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
from 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

, which inform us which part of guards are important.
 The set 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

 can be enlarged by interpolation.
 In general enviromental transition are applied frequently, so it is better
 to have them as simple and as few as possible.
 
\end_layout

\begin_layout Subsection
Approximation of operations
\end_layout

\begin_layout Plain Layout
In the paper by Gupta et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Gupta11"

\end_inset

, the operations are also abstracted, just like the guards.
 We could take the same approach and introduce a set of predicates for operation
, but the question whether this would be beneficial.
 Operation have to be instantiated to some concrete values, otherwise they
 do have a meaning, e.g.
 the edge 
\begin_inset Formula $g$
\end_inset

 applied to an abstract state 
\begin_inset Formula $(\psi,\varphi)$
\end_inset

 has a meaning only as 
\begin_inset Formula $(\psi,SP_{g}(\varphi))$
\end_inset

.
 But then, the same operation
\end_layout

\begin_layout Subsection
Most general environmental transitions
\end_layout

\begin_layout Plain Layout
Transition 
\begin_inset Formula $(\phi_{1},g_{1})$
\end_inset

 is more general than 
\begin_inset Formula $(\phi_{2},g_{2})$
\end_inset

 if the result of applying gives a bigger over-approximation:
\begin_inset Formula 
\[
(\phi_{1},g_{1})\sqsupseteq(\phi_{2},g_{2})\quad\text{iff}\quad\forall\varphi\in\mathscr{P}\,:\, SP_{g_{1}}(\varphi\land\phi_{1})\models SP_{g_{2}}(\varphi\land\phi_{2})
\]

\end_inset

where 
\begin_inset Formula $\mathscr{P}$
\end_inset

 is the set of all path formulas.
 In order to have as few transitions as possible, only the most general
 transition should be applied.
 It remains an open question how to decided whether 
\begin_inset Formula $(\phi_{1},g_{1})\sqsupseteq(\phi_{2},g_{2})$
\end_inset

 holds.
\end_layout

\begin_layout Subsection
How to apply environmental transitions
\end_layout

\begin_layout Plain Layout
Were interested in safety properties, therefore we apply environmental transitio
n that would change the flow of the program.
 These only can be assignments to global variables, since they could affect
 the branches that are taken.
 Assume edges do not affect other threads, so they do not generate environmental
 transitions.
 The transition with global assignments do not have to be applied at every
 abstract element of a thread, but it is enough to apply them before the
 global variable is read.
 In the terms of partial-order reduction, environmental transitions and
 non-globall reads are 
\emph on
independent
\emph default
.
 In some cases environmental transition can only be applied after some other
 transitions updated the abstract state.
 This implies, that before global reads it should be be possible to apply
 all environmental transition, even if they assigned to local variables.
 Similarly, to get transitions with all possible guard statements, environmental
 transitions should also be applied before edges that generate new transitions.
\end_layout

\begin_layout Plain Layout
To summarize:
\end_layout

\begin_layout Enumerate
environmental transitions are generate by any assignments
\end_layout

\begin_layout Enumerate
all environmental transitions can be applied before global reads and any
 assignments.
 
\end_layout

\begin_layout Plain Layout

\series bold
TO DO
\series default
 write about combing
\end_layout

\begin_layout Subsection
Static Single Assigment
\end_layout

\begin_layout Plain Layout
In 
\shape smallcaps
CPAchecker
\shape default
 formulas are skolemized with SSA indexes.
 In our analysis every thread has an unique identifier, which is added to
 all variables names that appear in its formulas, e.g.
 variables in thread 
\begin_inset Formula $1$
\end_inset

 are not primed, in thread two are primed once, etc.
 This is necessary for working in formulas in SSA format, so that the old
 values do not collide.
 
\end_layout

\begin_layout Plain Layout
Suppose that we have an abstract state an abstract state 
\begin_inset Formula $(\psi,\varphi)$
\end_inset

 in thread 
\begin_inset Formula $i$
\end_inset

 and an assignment edge 
\begin_inset Formula $g$
\end_inset

.
 To generate a transition we perform Cartesian or Boolean abstraction on
 
\begin_inset Formula $\psi\land\varphi$
\end_inset

 with the predicates from 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

.
 The transitions consists of the abstracted formula and the edge.
 If we decide not use environmental predicates, then we take 
\begin_inset Formula $\psi\land\varphi$
\end_inset

 as the guard
\end_layout

\begin_layout Plain Layout
Now, assume that we want to apply a transition 
\begin_inset Formula $(\phi,g)$
\end_inset

 an an abstract state 
\begin_inset Formula $(\psi,\varphi)$
\end_inset

.
 By applying the guard 
\begin_inset Formula $\phi$
\end_inset

, we want to get a path formula that describes valuations that are satisfied
 by both 
\begin_inset Formula $\varphi$
\end_inset

 and 
\begin_inset Formula $\psi\land\phi$
\end_inset

.
 Since they are in SSA form, so only the last indexes should match and others
 should to be different.
 We build equalities over the last indexes of corresponding variables in
 
\begin_inset Formula $\varphi$
\end_inset

 and 
\begin_inset Formula $\psi$
\end_inset

.
 The old values of variables from different thread do not collide, because
 of priming.
 
\end_layout

\begin_layout Plain Layout
If we do not abstract environmental transitions, then the guard might have
 colliding variables.
 This may happen when a transition is made from thread A to B and from B
 to A.
 We can avoid this situation by using environmental predicates or abstracting
 after each transition application.
\end_layout

\begin_layout Plain Layout
TODO write about possible benefits
\end_layout

\begin_layout Section
Interpolation
\end_layout

\begin_layout Subsection
Three ways of generating env.
 transitions
\end_layout

\begin_layout Subsection
Most general
\end_layout

\begin_layout Subsection
Avoiding blow-up
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Section
Interpolation
\end_layout

\begin_layout Plain Layout
In rely-guarantee method one block formulas may generate an environmental
 transitions, which is then applied multiple times.
 In the current interpolation procedure, each application of the environmental
 transition will have its own version of the block.
 In this technique applying environmental transitions is treated as calling
 a function, that does not take any formal arguments.
 The details may be found in Section 5.2 of Henziger et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Henzinger:2004"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
This however may lead to exponential number of interpolation formulas.
 If the block are not uniquely renamed for each application, then the interpolan
ts may not be well-scoped, i.e.
 the can refer to variables outside their scope.
 As an example consider Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "itp_problem"

\end_inset

, where diamons denote abstraction points, horizontal lines are formulas
 from thread 
\begin_inset Formula $T0$
\end_inset

 and veritcal are from thread 
\begin_inset Formula $T1$
\end_inset

.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Block 
\begin_inset Formula $g=0$
\end_inset

 is used in three places, which causes interpolation problems.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "itp_problem"

\end_inset


\end_layout

\end_inset

Block 
\begin_inset Formula $g=0$
\end_inset

 appears three times: once local and twice in environmental transitions.
 The current interpolation procedure will generate three unique version
 of 
\begin_inset Formula $g=0$
\end_inset

, so its applications have the correct information, but are still well-scoped.
 For example the interpolants for block 
\begin_inset Formula $x^{\prime}=g+1$
\end_inset

 is computed from 
\begin_inset Formula 
\[
(g^{1}=0\land x^{\prime}=g^{1}+1,\, g^{0}=0\land g^{2}=0\land y^{\prime}=g^{2}-1\land x^{\prime}=y^{\prime}\land g=0)
\]

\end_inset

which always gives a well-scoped predicate.
 
\end_layout

\begin_layout Plain Layout
The method works under the assumption that variables in a formula trance
 and and environmental transitions applied to it are renamed apart (see
 
\begin_inset CommandInset citation
LatexCommand cite
key "Henzinger:2004"

\end_inset

).
 This implies that with an ordinary theorem prover the exponential blow-up
 can always occur (I'd be very happy if the reader could falsify this statement).
 
\end_layout

\begin_layout Plain Layout
In Gupta et all.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Gupta11"

\end_inset

 an novel interpolatino method is used for such cases.
 Block are modeled as Horn clauses and interpolants as unknown predicates.
 For Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "itp_problem"

\end_inset

 the clauses are:
\begin_inset Formula 
\[
\begin{array}{c}
g=0\rightarrow\psi_{g=0}\\
\psi_{g=0}\land x^{\prime}=g+1\rightarrow\psi_{x^{\prime}=g+1}\\
\psi_{g=0}\land y^{\prime}=g-1\rightarrow\psi_{y^{\prime}=g-1}\\
\psi_{g=0}\land\psi_{x^{\prime}=g+1}\land\psi_{y^{\prime}=g-1}\land x^{\prime}=y^{\prime}\land g=0\rightarrow false
\end{array}
\]

\end_inset

where 
\begin_inset Formula $\psi$
\end_inset

-formulas are unknown predicates over 
\begin_inset Formula $g,x^{\prime},y^{\prime}$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Generalized Environment
\end_layout

\begin_layout Standard
In rely-guarantee method an environmental transition can be applied any
 number of times, e.g.
 a transition that increments some variable.
 In LBE, where operations simply extend the path formula, such transitions
 could be applied infinitely many times, each time giving a distinct path
 formula.
 To cut this chain of applications the formula has to be abstracted at some
 point.
 The abstraction is at the same location as applications, so unless covered,
 the transitions can be applied again.
 As a result, the locations where environmental transitions can be applied
 become abstraction points.
 As test have showed, Boolean abstraction with many abstractions points
 exhibits low performance 
\begin_inset CommandInset citation
LatexCommand cite
key "Beyer10"

\end_inset

.
 
\end_layout

\begin_layout Standard
A promising solution is to create a single transition that over-approximates
 the overall effect of the environment.
 It would be enough to apply the transition only once provided that subsequent
 application would not give more valuations.
 LBE analysis could treat the environment as yet another transition, so
 there would be less abstraction locations.
 The precision of the environment applied to thread 
\begin_inset Formula $j$
\end_inset

 and generated by thread 
\begin_inset Formula $i$
\end_inset

 would be controlled by a set 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

 of predicates.
\end_layout

\begin_layout Subsection
Generating transitions
\begin_inset CommandInset label
LatexCommand label
name "sub:Generating-transitions"

\end_inset


\end_layout

\begin_layout Standard
In this section, we show how transitions can be generated from abstract
 states.
 Let 
\begin_inset Formula $V$
\end_inset

 be the set of all variables that occur in a program, 
\begin_inset Formula $V_{g}$
\end_inset

 be global variables and let 
\begin_inset Formula $V_{i}$
\end_inset

 be variables that are local only to thread 
\begin_inset Formula $j$
\end_inset

.
 Let 
\begin_inset Formula $X^{\prime}$
\end_inset

 be the set 
\begin_inset Formula $X$
\end_inset

 with all its elements primed.
 The predicates in 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

 are expressions over 
\begin_inset Formula $V\cup V_{g}^{\prime}\cup V_{i}^{\prime}$
\end_inset

.
 The unprimed variables refer to the state before the environmental transition
 and primed elements are the values after applying the transitions.
 We use 
\begin_inset Formula $id_{X}$
\end_inset

 to denote the set of equalities 
\begin_inset Formula 
\[
id_{X}=\{v=v^{\prime}\,|\, v\in X\}.
\]

\end_inset

and we require that 
\begin_inset Formula 
\[
\mathcal{P}_{i\triangleright j}\supseteq id_{V_{g}\cup V_{i}}.
\]

\end_inset


\end_layout

\begin_layout Standard
We will investigate the implementation side of the problem, so let abstract
 states be formulas over 
\begin_inset Formula $V$
\end_inset

 in static single assignment form.
 We also assume that variables in each thread have unique labels.
 Let 
\begin_inset Formula $SP_{op}(\varphi)$
\end_inset

 be the successor of abstract state 
\begin_inset Formula $\varphi$
\end_inset

 by operation 
\begin_inset Formula $op$
\end_inset

.
 For each predicate in 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

 we instantiate the unprimed variables in the predicate to the last SSA
 indexes in 
\begin_inset Formula $\varphi$
\end_inset

 and the primed variables to the last indexes in 
\begin_inset Formula $SP_{op}(\varphi)$
\end_inset

.
 For every predicate instance 
\begin_inset Formula $i$
\end_inset

, a fresh propositional variable 
\begin_inset Formula $p_{i}$
\end_inset

 is introduced and the equality 
\begin_inset Formula $i\longleftrightarrow p_{i}$
\end_inset

 is appended to the formula.
 The Boolean predicate abstraction is constructed by enumerating all models
 of the fresh variables in the extended formula.
 For a variable 
\begin_inset Formula $v$
\end_inset

 that has not been changed by 
\begin_inset Formula $op$
\end_inset

, the primed and unprimed versions will be the same, so the predicate 
\begin_inset Formula $v^{\prime}=v$
\end_inset

 will follow.
 In a transition, we implicitly asociate the unprimed variables with the
 SSA map of 
\begin_inset Formula $\varphi$
\end_inset

 and primed variables with the SSA map of 
\begin_inset Formula $SP_{op}(\varphi)$
\end_inset

.
 This is needed by interpolation to relate the source and application formulas.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
bigskip
\end_layout

\end_inset


\end_layout

\begin_layout Example
Threads 
\begin_inset Formula $T_{1}$
\end_inset

 and 
\begin_inset Formula $T_{2}$
\end_inset

 have one global variable 
\begin_inset Formula $V=\{g\}$
\end_inset

 and local variables 
\begin_inset Formula $V_{0}=\{pc_{1},x\}$
\end_inset

 and 
\begin_inset Formula $V_{1}=\{pc_{2},y\}$
\end_inset

.
 Variables in 
\begin_inset Formula $T_{1}$
\end_inset

 have an upper index 
\begin_inset Formula $^{1}$
\end_inset

, while in 
\begin_inset Formula $T_{2}$
\end_inset

 they have an index 
\begin_inset Formula $^{2}$
\end_inset

.
 Suppose that the environmental predicates are
\begin_inset Formula 
\[
\mathcal{P}_{1\triangleright2}=\{g^{\prime}=g,\, pc_{1}^{\prime}=pc_{1},\, x^{\prime}=x,\, x\geq5,\, g^{\prime}=x+1\}.
\]

\end_inset

Imagine that we have an abstract state in 
\begin_inset Formula $T_{1}$
\end_inset


\begin_inset Formula 
\[
\mbox{\varphi}_{1}:\, x^{1}@1=5\,\land\, pc_{1}^{1}@1=2\,\land\, g^{1}@1<10\,\land\, y^{1}@1\neq x^{1}@1
\]

\end_inset

and we apply operation 
\begin_inset Formula $op:\, pc_{1}=2\xrightarrow{x:=x+1}pc_{1}=3$
\end_inset

, thus obtaining the state 
\begin_inset Formula 
\begin{equation}
SP_{op}(\varphi_{1}):\, x^{1}@1=5\,\land\, pc_{1}^{1}@1=2\,\land\, g^{1}@1<10\,\land\, y^{1}@1\neq x^{1}@1\,\land\, x^{1}@2=6\,\land\, pc_{1}^{1}@2=3.\label{eq:e1_source}
\end{equation}

\end_inset

The abstraction formula for 
\begin_inset Formula $SP_{op}(\varphi_{1})$
\end_inset

 with the predicates from 
\begin_inset Formula $\mathcal{P}_{1\triangleright2}$
\end_inset

 is:
\begin_inset Formula 
\[
\begin{array}{c}
x^{1}@1=5\,\land\, pc_{1}^{1}@1=2\,\land\, g^{1}@1<10\,\land\, y^{1}@1\neq x^{1}@1\,\land\, x^{1}@2=6\,\land\, pc_{1}^{1}@2=3\\
\,\land\, p_{1}\leftrightarrow g^{1}@1=g^{1}@1\,\land\, p_{2}\leftrightarrow pc_{1}^{1}@2=pc_{1}^{1}@1\,\land\, p_{3}\leftrightarrow x^{1}@2=x^{1}@1\,\land\,\\
p_{4}\leftrightarrow x^{1}@1\geq5\,\land\, p_{5}\leftrightarrow g^{1}@2=x^{1}@1+1
\end{array}
\]

\end_inset

where 
\begin_inset Formula $p_{1\ldots5}$
\end_inset

 are related to the predicates in 
\begin_inset Formula $\mathcal{P}_{1\triangleright j}$
\end_inset

.
 After abstraction the environmental transition 
\begin_inset Formula $e_{1}$
\end_inset

 is 
\begin_inset Formula 
\[
e_{1}\,:\, g^{\prime}=g\,\land\, pc_{1}^{\prime}\neq pc_{1}\,\land\, x^{\prime}\neq x\,\land\, x\geq5.
\]

\end_inset

The associated SSA map for unprimed variables is 
\begin_inset Formula 
\[
\{x^{1}\mapsto1,pc_{1}^{1}\mapsto1,g^{1}\mapsto1,y^{1}\mapsto1\}
\]

\end_inset

and for primed variables is
\begin_inset Formula 
\[
\{x^{1}\mapsto2,pc_{1}^{1}\mapsto2,g^{1}\mapsto1,y^{1}\mapsto1\}.
\]

\end_inset

The predicate 
\begin_inset Formula $g^{\prime}=x+1$
\end_inset

 does not appear in 
\begin_inset Formula $e_{1}$
\end_inset

 since it may or may not hold.
\end_layout

\begin_layout Subsection
Application and interpolation
\end_layout

\begin_layout Standard
Suppose we have a transition 
\begin_inset Formula $e$
\end_inset

 from thread 
\begin_inset Formula $i$
\end_inset

 and we want to apply it to an abstract formula 
\begin_inset Formula $\psi$
\end_inset

 in thread 
\begin_inset Formula $j$
\end_inset

.
 The procedure is:
\end_layout

\begin_layout Enumerate
For every variable 
\begin_inset Formula $v\in V$
\end_inset

 we append an equality 
\begin_inset Formula $v^{i}=v^{j}$
\end_inset

 to 
\begin_inset Formula $\psi$
\end_inset

, where 
\begin_inset Formula $v^{j}$
\end_inset

 is the latest version of 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $\psi$
\end_inset

 and 
\begin_inset Formula $v^{i}$
\end_inset

 is the latest version of 
\begin_inset Formula $v$
\end_inset

 in the unprimed SSA map of 
\begin_inset Formula $e$
\end_inset

.
 By 
\begin_inset Quotes eld
\end_inset

latest version of 
\begin_inset Formula $v$
\end_inset


\begin_inset Quotes erd
\end_inset

 we mean the one with the highest index modulo unique thread labels.
 These equalities will relate valuations of 
\begin_inset Formula $\psi$
\end_inset

 to the unprimed variables in 
\begin_inset Formula $e$
\end_inset

.
\end_layout

\begin_layout Enumerate
Transition 
\begin_inset Formula $e$
\end_inset

 is instantiated using the two associated SSA maps: unprimed variables with
 the first map and primed with the other.
 This gives an abstract formula that is weaker than the formula that generated
 the transition.
 Since threads have unique labels, the instantiated formula does not overlap
 with 
\begin_inset Formula $\psi$
\end_inset

.
 The instance is appended to 
\begin_inset Formula $\psi$
\end_inset

.
\end_layout

\begin_layout Enumerate
For every variable 
\begin_inset Formula $v$
\end_inset

 that can be changed by thread 
\begin_inset Formula $i$
\end_inset

, that is for 
\begin_inset Formula $v\in V_{g}\cup V_{i}$
\end_inset

, an equality 
\begin_inset Formula $w^{i}=w^{j}$
\end_inset

 is append to 
\begin_inset Formula $\varphi$
\end_inset

, where 
\begin_inset Formula $w^{i}$
\end_inset

 is the latest version of 
\begin_inset Formula $v$
\end_inset

 in the primed SSA map of 
\begin_inset Formula $e$
\end_inset

 and 
\begin_inset Formula $w^{j}$
\end_inset

 is a new version of 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $\psi$
\end_inset

.
 These relate the primed variables of 
\begin_inset Formula $e$
\end_inset

 with the new values of variables.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
bigskip
\end_layout

\end_inset


\end_layout

\begin_layout Example
Let us apply transition 
\begin_inset Formula $e_{1}$
\end_inset

 from the previous example to a state 
\begin_inset Formula $\psi$
\end_inset

 in thread 
\begin_inset Formula $T_{2}$
\end_inset

 
\begin_inset Formula 
\begin{equation}
\psi:\, g^{2}@5=3\,\land\, pc_{2}^{2}@5=4\,\land\, y^{2}@5>0.\label{eq:applicationI}
\end{equation}

\end_inset

In step 1.
 the following equalities are added to 
\begin_inset Formula $\psi$
\end_inset

:
\begin_inset Formula 
\begin{equation}
g^{2}@5=g^{1}@1\,\land\, pc_{1}^{2}@1=pc_{1}^{1}@1\,\land\, x^{2}@1=x^{1}@1\,\land\, pc_{2}^{2}@5=pc_{2}^{1}@1\,\land\, y^{2}@5=y^{1}@1.\label{applicationII}
\end{equation}

\end_inset

Here, we assumed that variables that do not appear in SSA map, like 
\begin_inset Formula $x^{2}$
\end_inset

 in 
\begin_inset Formula $\psi$
\end_inset

, have a default index 
\begin_inset Formula $1$
\end_inset

.
 In step 2.
 
\begin_inset Formula $e_{1}$
\end_inset

 is instantiated to a formula 
\begin_inset Formula $\dot{e_{1}}$
\end_inset

 
\begin_inset Formula 
\begin{equation}
\dot{e_{1}}\,:\, g^{1}@1=g^{1}@1\,\land\, pc_{1}^{1}@2\neq pc_{1}^{1}@1\,\land\, x^{1}@2\neq x^{1}@1\,\land\, x^{1}@1\geq5.\label{applicationIII}
\end{equation}

\end_inset

Note that it holds that 
\begin_inset Formula $SP_{op}(\varphi)\rightarrow\dot{e_{1}}$
\end_inset

.
 The equalities added in step 1.
 relate the last valuations of 
\begin_inset Formula $\psi$
\end_inset

 of to the lowest indexes of 
\begin_inset Formula $\dot{e_{1}}$
\end_inset

.
 In step 3.
 the following equalities link the latest versions of 
\begin_inset Formula $\dot{e_{1}}$
\end_inset

 with the new valuations of 
\begin_inset Formula $\psi$
\end_inset

: 
\begin_inset Formula 
\begin{equation}
g^{2}@6=g^{1}@1\,\land\, pc_{1}^{2}@2=pc_{1}^{1}@2\,\land\, x^{2}@2=x^{1}@2.\label{applicationIV}
\end{equation}

\end_inset

The new formula 
\begin_inset Formula $\psi^{\prime}$
\end_inset

 is a conjunction of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:applicationI"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "applicationII"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "applicationIII"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "applicationIV"

\end_inset

.
 Variables 
\begin_inset Formula $pc_{2}$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 which are local to 
\begin_inset Formula $T_{2}$
\end_inset

, remain unchanged by the application.
 Variables 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $pc_{1}$
\end_inset

 and 
\begin_inset Formula $x$
\end_inset

 receive new values specified by the constraint of 
\begin_inset Formula $e$
\end_inset

.
 For instance, 
\begin_inset Formula $pc_{1}^{2}@2$
\end_inset

 can have any value, as long it different from 
\begin_inset Formula $pc_{1}^{2}@1$
\end_inset

.
 
\end_layout

\begin_layout Example
The instantiated formula 
\begin_inset Formula $\dot{e_{1}}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "applicationIII"

\end_inset

 relates the application 
\begin_inset Formula $\psi^{\prime}$
\end_inset

 to formula 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:e1_source"

\end_inset

 that generated 
\begin_inset Formula $e_{1}$
\end_inset

 --- this is necessary for interpolation.
 Image that after the application of 
\begin_inset Formula $e_{1}$
\end_inset

 to 
\begin_inset Formula $\psi$
\end_inset

 there is an assertion that 
\begin_inset Formula $x\neq5$
\end_inset

 (let us skip over the detail that 
\begin_inset Formula $x$
\end_inset

 is local to 
\begin_inset Formula $T_{0}$
\end_inset

).
 The new abstract state 
\begin_inset Formula $\psi^{\prime}$
\end_inset

 might violate the assertion, so interpolation is performed to check if
 the formula trace is feasible.
 For the sake of simplicity let us assume that there are no other formulas
 involved besides 
\begin_inset Formula $SP_{op}(\varphi)$
\end_inset

, 
\begin_inset Formula $\psi^{\prime}$
\end_inset

 and the assertion.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "itp_e1topsi"

\end_inset

 shows the interpolation formulas for the error trace.
 
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $SP_{op}(\varphi)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x^{1}@1=5\,\land\, pc_{1}^{1}@1=2\,\land\, g^{1}@1<10\,\land\, y^{1}@1\neq x^{1}@1\,\land\, x^{1}@2=6\,\land\, pc_{1}^{1}@2=3$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\psi^{\prime}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
g^{2}@5=3\,\land\, pc_{2}^{2}@5=4\,\land\, y^{2}@5>0\,\land\\
g^{2}@5=g^{1}@1\,\land\, pc_{1}^{2}@1=pc_{1}^{1}@1\,\land\, x^{2}@1=x^{1}@1\,\land\, pc_{2}^{2}@5=pc_{2}^{1}@1\,\land\, y^{2}@5=y^{1}@1\\
g^{1}@1=g^{1}@1\,\land\, pc_{1}^{1}@2\neq pc_{1}^{1}@1\,\land\, x^{1}@2\neq x^{1}@1\,\land\, x^{1}@1\geq5\,\land\\
g^{2}@6=g^{1}@1\,\land\, pc_{1}^{2}@2=pc_{1}^{1}@2\,\land\, x^{2}@2=x^{1}@2\,\land
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assert
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x^{2}@2\neq5$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Interpolation formulas for 
\begin_inset Formula $e_{1}$
\end_inset

 applied to 
\begin_inset Formula $\psi$
\end_inset

 and an assertion.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "itp_e1topsi"

\end_inset


\end_layout

\end_inset

 The interpolant after 
\begin_inset Formula $SP_{op}(\varphi)$
\end_inset

 could be 
\begin_inset Formula $x^{1}@2>x^{1}@1$
\end_inset

.
 Translating the SSA indexes of 
\begin_inset Formula $\varphi$
\end_inset

 to unprimed variables and indexes of 
\begin_inset Formula $SP_{op}(\varphi)$
\end_inset

 to primed variables, this interpolants can be expressed as 
\begin_inset Formula $x^{\prime}>x$
\end_inset

.
 Adding this predicate to 
\begin_inset Formula $\mathcal{P}_{1\triangleright2}$
\end_inset

 and restarting the analysis will make this error trace infeasible.
 Details of refinement depend on the interpolation procedure.
 
\end_layout

\begin_layout Subsection
Generalizing transitions
\end_layout

\begin_layout Standard
Transitions generated in the presented way may still be applied infinitely
 many times.
 Now, we present how the generalize several environmental transition into
 one that may be applied only once.
 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\mathcal{B}(\mathcal{P}_{i\triangleright j})$
\end_inset

 be the set all Boolean combinations of predicates from 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

 that have different valuations, so combinations like 
\begin_inset Formula $p\vee r$
\end_inset

, 
\begin_inset Formula $r\vee p$
\end_inset

 and 
\begin_inset Formula $p\vee p\vee r$
\end_inset

 are considered to be equal.
 We define 
\begin_inset Formula $L_{i\triangleright j}$
\end_inset

 as the complete lattice over the set 
\begin_inset Formula $\mathcal{B}(\mathcal{P}_{i\triangleright j})$
\end_inset

, partially ordered by 
\begin_inset Formula $\rightarrow$
\end_inset

, the least upper bound being 
\begin_inset Formula $\vee$
\end_inset

 and formula 
\begin_inset Formula $false$
\end_inset

 as the bottom element.
 Lattice 
\begin_inset Formula $L_{i\triangleright j}$
\end_inset

 orders transitions by how much their application can change, for example
 the transition 
\begin_inset Formula $x^{\prime}=x\,\land\, x^{\prime}>0$
\end_inset

 can change less than 
\begin_inset Formula $x^{\prime}=x$
\end_inset

.
 The least upper bound of transitions gives a transitions that can change
 more than any of them.
 We distinguish the element 
\begin_inset Formula $e_{id}$
\end_inset

 which is a Boolean abstraction of 
\begin_inset Formula $\bigwedge id_{V_{g}\cup V_{i}}$
\end_inset

 with the predicates 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

.
 Transition 
\begin_inset Formula $e_{id}$
\end_inset

 expresses that environment does not change anything.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
bigskip
\end_layout

\end_inset


\end_layout

\begin_layout Example
Let 
\begin_inset Formula $g$
\end_inset

 be the only variable.
 Lattice 
\begin_inset Formula $L_{1\triangleright2}$
\end_inset

 is based on the following predicate set 
\begin_inset Formula 
\[
\mathcal{P}_{1\triangleright2}=\{g^{\prime}=g,\, g>0,\, g^{\prime}=g+1\}.
\]

\end_inset

The identity transition is
\begin_inset Formula 
\[
e_{id}:\, g^{\prime}=g\,\land\, g^{\prime}\neq g+1.
\]

\end_inset

Now, consider transitions 
\begin_inset Formula $e_{2}$
\end_inset

 and 
\begin_inset Formula $e_{3}$
\end_inset

 
\begin_inset Formula 
\[
e_{2}:\, g>0\,\land\, g^{\prime}\neq g\,\land\, g^{\prime}=g+1
\]

\end_inset


\begin_inset Formula 
\[
e_{3}:\, g\leq0\,\land\, g^{\prime}\neq g.
\]

\end_inset

Transition 
\begin_inset Formula $e_{2}$
\end_inset

 increments 
\begin_inset Formula $g$
\end_inset

 when it is positive, while 
\begin_inset Formula $e_{3}$
\end_inset

 gives some new value to 
\begin_inset Formula $g$
\end_inset

 if it is non-positive.
 Transition 
\begin_inset Formula $e_{2}\vee e_{3}\vee e_{id}$
\end_inset

 has the same effect as applying 
\begin_inset Formula $e_{2}$
\end_inset

 or 
\begin_inset Formula $e_{3}$
\end_inset

 or not applying any transition.
\end_layout

\begin_layout Standard
Transitions can be applied one after another.
 Let 
\begin_inset Formula $\varphi[X\rightarrow\overline{X}]$
\end_inset

 denote an abstract state, where every occurrence of 
\begin_inset Formula $v\in X$
\end_inset

 has been replaced by a fresh variable 
\begin_inset Formula $\overline{v}$
\end_inset

.
 Moreover, let 
\begin_inset Formula $\alpha_{X}(\varphi)$
\end_inset

 be the Boolean abstraction of 
\begin_inset Formula $\varphi$
\end_inset

 with the predicates from 
\begin_inset Formula $X$
\end_inset

.

\emph on
 Composition of transitions
\emph default
 
\begin_inset Formula $e^{\prime}$
\end_inset

 
\emph on
and
\emph default
 
\begin_inset Formula $e$
\end_inset

, denoted by 
\begin_inset Formula $e^{\prime}\circ e$
\end_inset

, is defined in the following way 
\begin_inset Formula 
\[
e^{\prime}\circ e\,=\,\alpha_{\mathcal{P}_{i\triangleright j}}(e[V^{\prime}\rightarrow\overline{V}]\,\land\, e^{\prime}[V\rightarrow\overline{V}])
\]

\end_inset

where the set of predicates 
\begin_inset Formula $\mathcal{P}_{i\triangleright j}$
\end_inset

 should be clear from the context.
 The composition 
\begin_inset Formula $e^{\prime}\circ e$
\end_inset

 extracts the relation between the unprimed variables of 
\begin_inset Formula $e$
\end_inset

 and primed variables of 
\begin_inset Formula $e^{\prime}$
\end_inset

 linked by an intermediate variables in 
\begin_inset Formula $\overline{V}$
\end_inset

.
 Composition of two transitions from 
\begin_inset Formula $L_{i\triangleright j}$
\end_inset

 also belongs to the lattice.
 
\end_layout

\begin_layout Standard
Suppose that we have generated a set of transitions 
\begin_inset Formula $E$
\end_inset

 and we want to create a single transition that over-approximates them.
 This generalized transition should describe the effect of applying the
 transitions in an arbitrary sequence or lack of any application.
 We define a function 
\begin_inset Formula $f_{E}\,:\, L_{i\triangleright j}\rightarrow L_{i\triangleright j}$
\end_inset

 on transitions
\begin_inset Formula 
\[
f_{E}(e)\,=\,(\bigvee E)\circ e\,\vee\, e_{id}.
\]

\end_inset

Given some transition 
\begin_inset Formula $e$
\end_inset

, 
\begin_inset Formula $f_{E}$
\end_inset

 will return the composition of 
\begin_inset Formula $\bigvee E$
\end_inset

 with 
\begin_inset Formula $e$
\end_inset

, but not smaller then the identity transition 
\begin_inset Formula $e_{id}$
\end_inset

.
 For a fixed 
\begin_inset Formula $E$
\end_inset

 the function is monotone.
 The 
\emph on
generalized transition
\emph default
 
\begin_inset Formula $e_{g}$
\end_inset

 is the least fixed point of 
\begin_inset Formula $f_{E}$
\end_inset

.
 Since the lattice 
\begin_inset Formula $L_{i\triangleright j}$
\end_inset

 has a finite size, therefore 
\begin_inset Formula $e_{g}$
\end_inset

 can be obtained be iterating over 
\begin_inset Formula $f_{E}^{n}(false)$
\end_inset

 until it inevitably stabilizes.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
bigskip
\end_layout

\end_inset


\end_layout

\begin_layout Example
Let us continue with the previous example, but assume that 
\begin_inset Formula $e_{2}$
\end_inset

 is the only transition, i.e.
 
\begin_inset Formula $E=\{e_{1}\}$
\end_inset

.
 Function 
\begin_inset Formula $f_{E}(e)$
\end_inset

 becomes 
\begin_inset Formula 
\[
f_{E}(e)\,=\, e_{2}\circ e\,\vee\, e_{id}.
\]

\end_inset

Let us iterate over 
\begin_inset Formula $f_{E}$
\end_inset

 until the least fixed point is reached.
 The first iteration gives the identity transition: 
\begin_inset Formula 
\[
f_{E}^{1}(false)\,=\, e_{2}\circ false\,\vee\, e_{id}=e_{id}.
\]

\end_inset

The second iteration is
\begin_inset Formula 
\[
f_{E}^{2}(false)\,=\, f_{E}(e_{id})\,=\, e_{2}\circ e_{id}\,\vee\, e_{id}=
\]

\end_inset


\begin_inset Formula 
\[
\text{\alpha}_{\mathcal{P}_{i\triangleright j}}(\overline{g}=g\,\land\,\overline{g}\neq g+1\land\overline{g}>0\,\land\, g^{\prime}\neq\overline{g}\,\land\, g^{\prime}=\overline{g}+1)\,\vee\, e_{id}=
\]

\end_inset


\begin_inset Formula 
\[
(g>0\,\land g^{\prime}\neq g\,\land\, g^{\prime}=g+1)\,\vee\, e_{id}.
\]

\end_inset

The result is weaker than 
\begin_inset Formula $e_{id}$
\end_inset

, so we continue with 
\begin_inset Formula $f_{E}^{3}(false)$
\end_inset

:
\begin_inset Formula 
\[
f_{E}^{3}(false)\,=\, f_{E}(f_{E}^{2}(false))\,=\, e_{2}\circ f_{E}^{2}(false)\,\vee\, e_{id}=
\]

\end_inset


\begin_inset Formula 
\[
\text{\alpha}_{\mathcal{P}_{i\triangleright j}}(((g>0\,\land\overline{g}\neq g\,\land\,\overline{g}=g+1)\vee(\overline{g}=g\,\land\,\overline{g}\neq g+1))\land\,\overline{g}>0\,\land\, g^{\prime}\neq\overline{g}\,\land\, g^{\prime}=\overline{g}+1)\,\vee\, e_{id}=
\]

\end_inset


\begin_inset Formula 
\[
(g>0\,\land\, g^{\prime}\neq g)\,\vee\, e_{id}.
\]

\end_inset

The fourth iteration is:
\begin_inset Formula 
\[
f_{E}^{4}(false)\,=\, f_{E}(f_{E}^{3}(false))\,=
\]

\end_inset


\begin_inset Formula 
\[
\text{\alpha}_{\mathcal{P}_{i\triangleright j}}(((g>0\,\land\,\overline{g}\neq g)\vee(\overline{g}=g\,\land\,\overline{g}\neq g+1))\land\,\overline{g}>0\,\land\, g^{\prime}\neq\overline{g}\,\land\, g^{\prime}=\overline{g}+1)\,\vee\, e_{id}=
\]

\end_inset


\begin_inset Formula 
\[
g>0\,\vee\, e_{id}.
\]

\end_inset

The last iteration gives 
\begin_inset Formula 
\[
f_{E}^{5}(false)\,=\, f_{E}(f_{E}^{4}(false))\,=
\]

\end_inset


\begin_inset Formula 
\[
\text{\alpha}_{\mathcal{P}_{i\triangleright j}}((g>0\,\vee\,(\overline{g}=g\,\land\,\overline{g}\neq g+1))\land\,\overline{g}>0\,\land\, g^{\prime}\neq\overline{g}\,\land\, g^{\prime}=\overline{g}+1)\,\vee\, e_{id}=
\]

\end_inset


\begin_inset Formula 
\[
g>0\,\vee\, e_{id}.
\]

\end_inset

The result has stabilized, therefore the generalized transition 
\begin_inset Formula $e_{g}$
\end_inset

 is 
\begin_inset Formula 
\[
g>0\,\vee\,(g\,\land\, g^{\prime}\neq g+1).
\]

\end_inset

Notice that 
\begin_inset Formula $f_{E}^{n}(false)$
\end_inset

 over-approximates the effect of applying transitions from 
\begin_inset Formula $E$
\end_inset

 less than 
\begin_inset Formula $n$
\end_inset

 times.
 The intuitive meaning is that 
\begin_inset Formula $e_{g}$
\end_inset

 changes nothing or, if 
\begin_inset Formula $g$
\end_inset

 is non-negative, it may set 
\begin_inset Formula $g$
\end_inset

 to any value.
 In LBE analysis, it is enough to apply 
\begin_inset Formula $e_{g}$
\end_inset

 once, since subsequent application will give the same result.
  
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "ref"
options "ieeetr"

\end_inset


\end_layout

\end_body
\end_document
